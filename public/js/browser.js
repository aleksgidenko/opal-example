(function(undefined) {
  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var global_object = this, console;

  // Detect the global object
  if (typeof(global) !== 'undefined') { global_object = global; }
  if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(this.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return this.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal object that is exposed globally
  var Opal = this.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported fearures
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $hasOwn       = Object.hasOwnProperty;
  var $bind         = Function.prototype.bind;
  var $setPrototype = Object.setPrototypeOf;
  var $slice        = Array.prototype.slice;
  var $splice       = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $defineProperty(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    Opal.gvars["!"] = Opal.exceptions.pop() || nil;
  };

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function(obj) {
    if (obj === undefined) {
      return "undefined";
    }
    else if (obj === null) {
      return "null";
    }
    else if (!obj.$$class) {
      return obj.toString();
    }
    else {
      return obj.$inspect();
    }
  };

  function $defineProperty(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and nil do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.defineProperty = $defineProperty;

  Opal.slice = $slice;


  // Truth
  // -----

  Opal.truthy = function(val) {
    return (val !== nil && val != null && (!val.$$is_boolean || val == true));
  };

  Opal.falsy = function(val) {
    return (val === nil || val == null || (val.$$is_boolean && val == false))
  };


  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) return cref.$$const[name];
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, result, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) return constant;
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, result, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $hasOwn.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $defineProperty(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $defineProperty(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $defineProperty(cref, name, value);

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], module_constants, i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Don not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload != null && cref.$$autoload[name] != null) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };


  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $setPrototype(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name) {
      $defineProperty(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $defineProperty(klass, '$$name', name);
    $defineProperty(klass, '$$constructor', constructor);
    $defineProperty(klass, '$$prototype', constructor.prototype);
    $defineProperty(klass, '$$const', {});
    $defineProperty(klass, '$$is_class', true);
    $defineProperty(klass, '$$is_a_module', true);
    $defineProperty(klass, '$$super', superclass);
    $defineProperty(klass, '$$cvars', {});
    $defineProperty(klass, '$$own_included_modules', []);
    $defineProperty(klass, '$$own_prepended_modules', []);
    $defineProperty(klass, '$$ancestors', []);
    $defineProperty(klass, '$$ancestors_cache_version', null);

    $defineProperty(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $setPrototype(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $setPrototype(klass.$$prototype, superclass.$$prototype);

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null) {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (superclass != null && !superclass.hasOwnProperty('$$is_class')) {
      bridged = superclass;
      superclass = _Object;
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    Opal.const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $defineProperty(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $defineProperty(constructor, 'displayName', name+'.constructor');

    $defineProperty(module, '$$name', name);
    $defineProperty(module, '$$prototype', constructor.prototype);
    $defineProperty(module, '$$const', {});
    $defineProperty(module, '$$is_module', true);
    $defineProperty(module, '$$is_a_module', true);
    $defineProperty(module, '$$cvars', {});
    $defineProperty(module, '$$iclasses', []);
    $defineProperty(module, '$$own_included_modules', []);
    $defineProperty(module, '$$own_prepended_modules', []);
    $defineProperty(module, '$$ancestors', [module]);
    $defineProperty(module, '$$ancestors_cache_version', null);

    $setPrototype(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null) {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {
      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    Opal.const_set(scope, name, module);

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singletin_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', klass);
    $defineProperty(klass, '$$meta', meta);
    $setPrototype(klass, meta.$$prototype);
    // Restoring ClassName.class
    $defineProperty(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singletin_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', mod);
    $defineProperty(mod, '$$meta', meta);
    $setPrototype(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $defineProperty(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, function(){});

    $defineProperty(klass, '$$is_singleton', true);
    $defineProperty(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $defineProperty(object, '$$meta', klass);

    $setPrototype(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.own_methods = function(obj) {
    return Opal.own_instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($hasOwn.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var proto = includer.$$prototype, parent = proto, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (isRoot(module_iclass) && module_iclass.$$module === module) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      var next_ancestor = Object.getPrototypeOf(module_iclass);

      // skip non-root iclasses (that were recursively included)
      while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
        next_ancestor = Object.getPrototypeOf(next_ancestor);
      }

      start_chain_after = parent;
      end_chain_on = next_ancestor;
    }

    $setPrototype(start_chain_after, chain.first);
    $setPrototype(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $defineProperty(dummy_prepender, '$$dummy', true);
      $defineProperty(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $setPrototype(dummy_prepender, prepender_iclass);
      $setPrototype(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $setPrototype(start_chain_after, chain.first);
    $setPrototype(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $defineProperty(iclass, prop, proto[prop]);
    }

    $defineProperty(iclass, '$$iclass', true);
    $defineProperty(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $defineProperty(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $setPrototype(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    var klass_to_inject, klass_reference;

    klass_to_inject = klass.$$super || Opal.Object;
    klass_reference = klass;
    var original_prototype = klass.$$prototype;

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $defineProperty(native_klass, '$$bridge', klass);
    $setPrototype(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $defineProperty(klass, '$$prototype', native_klass.prototype);

    $defineProperty(klass.$$prototype, '$$class', klass);
    $defineProperty(klass, '$$constructor', native_klass);
    $defineProperty(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;

    for (var i = 0, length = stubs.length; i < length; i++) {
      var stub = stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    var method_missing_stub = Opal.stub_for(stub);
    $defineProperty(prototype, stub, method_missing_stub);
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {
    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, defs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        var method = proto[jsid];

        if (!method.$$stub) {
          super_method = method;
        }
        break;
      }
    }

    if (!defcheck && super_method == null && Opal.Kernel.$method_missing === obj.$method_missing) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && kwargs['$respond_to?']('to_hash', true)) {
      $splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block) {
    var body = (typeof(method) === 'string') ? recv['$'+method] : method;

    if (body != null) {
      if (typeof block === 'function') {
        body.$$p = block;
      }
      return body.apply(recv, args);
    }

    return recv.$method_missing.apply(recv, [method].concat(args));
  };

  Opal.lambda = function(block) {
    block.$$is_lambda = true;
    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function(obj, jsid, body) {
    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      Opal.defn(Opal.Object, jsid, body)
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      Opal.defn(obj, jsid, body);
    }
    else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $defineProperty(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $defineProperty(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(jsid.substr(1));
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body) {
    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    Opal.defn(Opal.get_singleton_class(obj), jsid, body)
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$hasOwn.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body   = obj.$$prototype['$' + old],
        alias;

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be ovrewritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) { alias.$$p = null }

      return Opal.send(this, body, args, block);
    };

    // Try to make the browser pick the right name
    alias.displayName       = name;
    alias.length            = body.length;
    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$hasOwn.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$hasOwn.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($hasOwn.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($hasOwn.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value;

    if (key.$$is_string) {
      if (!$hasOwn.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        if (keys[i] === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$hasOwn.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$hasOwn.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($hasOwn.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Initialization
  // --------------
  function $BasicObject() {}
  function $Object() {}
  function $Module() {}
  function $Class() {}

  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null, $BasicObject);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject, $Object);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object, $Module);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module, $Class);

  $setPrototype(Opal.BasicObject, Opal.Class.$$prototype);
  $setPrototype(Opal.Object, Opal.Class.$$prototype);
  $setPrototype(Opal.Module, Opal.Class.$$prototype);
  $setPrototype(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject",  BasicObject);
  Opal.const_set(_Object, "Object",       _Object);
  Opal.const_set(_Object, "Module",       Module);
  Opal.const_set(_Object, "Class",        Class);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;

  // Forward .toString() to #to_s
  $defineProperty(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $defineProperty(_Object.$$prototype, '$require', Opal.require);

  // Add a short helper to navigate constants manually.
  // @example
  //   Opal.$$.Regexp.$$.IGNORECASE
  Opal.$$ = _Object.$$;

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };


  // Nil
  function $NilClass() {}
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object, $NilClass);
  Opal.const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
/* Generated by Opal 1.0.3 */
Opal.modules["corelib/helpers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$class', '$===', '$respond_to?', '$raise', '$type_error', '$__send__', '$coerce_to', '$nil?', '$<=>', '$coerce_to!', '$!=', '$[]', '$upcase']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $Opal_bridge$1, $Opal_type_error$2, $Opal_coerce_to$3, $Opal_coerce_to$excl$4, $Opal_coerce_to$ques$5, $Opal_try_convert$6, $Opal_compare$7, $Opal_destructure$8, $Opal_respond_to$ques$9, $Opal_inspect_obj$10, $Opal_instance_variable_name$excl$11, $Opal_class_variable_name$excl$12, $Opal_const_name$excl$13, $Opal_pristine$14;

    
    Opal.defs(self, '$bridge', $Opal_bridge$1 = function $$bridge(constructor, klass) {
      var self = this;

      return Opal.bridge(constructor, klass);
    }, $Opal_bridge$1.$$arity = 2);
    Opal.defs(self, '$type_error', $Opal_type_error$2 = function $$type_error(object, type, method, coerced) {
      var $a, self = this;

      
      
      if (method == null) {
        method = nil;
      };
      
      if (coerced == null) {
        coerced = nil;
      };
      if ($truthy(($truthy($a = method) ? coerced : $a))) {
        return $$($nesting, 'TypeError').$new("" + "can't convert " + (object.$class()) + " into " + (type) + " (" + (object.$class()) + "#" + (method) + " gives " + (coerced.$class()) + ")")
      } else {
        return $$($nesting, 'TypeError').$new("" + "no implicit conversion of " + (object.$class()) + " into " + (type))
      };
    }, $Opal_type_error$2.$$arity = -3);
    Opal.defs(self, '$coerce_to', $Opal_coerce_to$3 = function $$coerce_to(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        self.$raise(self.$type_error(object, type))
      };
      return object.$__send__(method);
    }, $Opal_coerce_to$3.$$arity = 3);
    Opal.defs(self, '$coerce_to!', $Opal_coerce_to$excl$4 = function(object, type, method) {
      var self = this, coerced = nil;

      
      coerced = self.$coerce_to(object, type, method);
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise(self.$type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$excl$4.$$arity = 3);
    Opal.defs(self, '$coerce_to?', $Opal_coerce_to$ques$5 = function(object, type, method) {
      var self = this, coerced = nil;

      
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        return nil
      };
      coerced = self.$coerce_to(object, type, method);
      if ($truthy(coerced['$nil?']())) {
        return nil};
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise(self.$type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$ques$5.$$arity = 3);
    Opal.defs(self, '$try_convert', $Opal_try_convert$6 = function $$try_convert(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, $Opal_try_convert$6.$$arity = 3);
    Opal.defs(self, '$compare', $Opal_compare$7 = function $$compare(a, b) {
      var self = this, compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")};
      return compare;
    }, $Opal_compare$7.$$arity = 2);
    Opal.defs(self, '$destructure', $Opal_destructure$8 = function $$destructure(args) {
      var self = this;

      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, $Opal_destructure$8.$$arity = 1);
    Opal.defs(self, '$respond_to?', $Opal_respond_to$ques$9 = function(obj, method, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, $Opal_respond_to$ques$9.$$arity = -3);
    Opal.defs(self, '$inspect_obj', $Opal_inspect_obj$10 = function $$inspect_obj(obj) {
      var self = this;

      return Opal.inspect(obj);
    }, $Opal_inspect_obj$10.$$arity = 1);
    Opal.defs(self, '$instance_variable_name!', $Opal_instance_variable_name$excl$11 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, $Opal_instance_variable_name$excl$11.$$arity = 1);
    Opal.defs(self, '$class_variable_name!', $Opal_class_variable_name$excl$12 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        self.$raise($$($nesting, 'NameError').$new("" + "`" + (name) + "' is not allowed as a class variable name", name))};
      return name;
    }, $Opal_class_variable_name$excl$12.$$arity = 1);
    Opal.defs(self, '$const_name!', $Opal_const_name$excl$13 = function(const_name) {
      var self = this;

      
      const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), "to_str");
      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
        self.$raise($$($nesting, 'NameError'), "" + "wrong constant name " + (const_name))};
      return const_name;
    }, $Opal_const_name$excl$13.$$arity = 1);
    Opal.defs(self, '$pristine', $Opal_pristine$14 = function $$pristine(owner_class, $a) {
      var $post_args, method_names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, $Opal_pristine$14.$$arity = -2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/module"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $lambda = Opal.lambda, $range = Opal.range, $hash2 = Opal.hash2;

  Opal.add_stubs(['$module_eval', '$to_proc', '$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$class_variable_name!', '$new', '$const_name!', '$=~', '$inject', '$split', '$const_get', '$==', '$!~', '$start_with?', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$any?', '$prepend_features', '$prepended', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_allocate$1, $Module_initialize$2, $Module_$eq_eq_eq$3, $Module_$lt$4, $Module_$lt_eq$5, $Module_$gt$6, $Module_$gt_eq$7, $Module_$lt_eq_gt$8, $Module_alias_method$9, $Module_alias_native$10, $Module_ancestors$11, $Module_append_features$12, $Module_attr_accessor$13, $Module_attr_reader$14, $Module_attr_writer$15, $Module_autoload$16, $Module_class_variables$17, $Module_class_variable_get$18, $Module_class_variable_set$19, $Module_class_variable_defined$ques$20, $Module_remove_class_variable$21, $Module_constants$22, $Module_constants$23, $Module_nesting$24, $Module_const_defined$ques$25, $Module_const_get$26, $Module_const_missing$28, $Module_const_set$29, $Module_public_constant$30, $Module_define_method$31, $Module_remove_method$33, $Module_singleton_class$ques$34, $Module_include$35, $Module_included_modules$36, $Module_include$ques$37, $Module_instance_method$38, $Module_instance_methods$39, $Module_included$40, $Module_extended$41, $Module_extend_object$42, $Module_method_added$43, $Module_method_removed$44, $Module_method_undefined$45, $Module_module_eval$46, $Module_module_exec$48, $Module_method_defined$ques$49, $Module_module_function$50, $Module_name$51, $Module_prepend$52, $Module_prepend_features$53, $Module_prepended$54, $Module_remove_const$55, $Module_to_s$56, $Module_undef_method$57, $Module_instance_variables$58, $Module_dup$59, $Module_copy_class_variables$60, $Module_copy_constants$61;

    
    Opal.defs(self, '$allocate', $Module_allocate$1 = function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, $Module_allocate$1.$$arity = 0);
    
    Opal.def(self, '$initialize', $Module_initialize$2 = function $$initialize() {
      var $iter = $Module_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Module_initialize$2.$$p = null;
      
      
      if ($iter) $Module_initialize$2.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, $Module_initialize$2.$$arity = 0);
    
    Opal.def(self, '$===', $Module_$eq_eq_eq$3 = function(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false};
      return Opal.is_a(object, self);;
    }, $Module_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Module_$lt$4 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, $Module_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Module_$lt_eq$5 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_lt(self, other))
    }, $Module_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$>', $Module_$gt$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, $Module_$gt$6.$$arity = 1);
    
    Opal.def(self, '$>=', $Module_$gt_eq$7 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_gt(self, other))
    }, $Module_$gt_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Module_$lt_eq_gt$8 = function(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil};
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, $Module_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$alias_method', $Module_alias_method$9 = function $$alias_method(newname, oldname) {
      var self = this;

      
      Opal.alias(self, newname, oldname);
      return self;
    }, $Module_alias_method$9.$$arity = 2);
    
    Opal.def(self, '$alias_native', $Module_alias_native$10 = function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) {
        jsid = mid;
      };
      Opal.alias_native(self, mid, jsid);
      return self;
    }, $Module_alias_native$10.$$arity = -2);
    
    Opal.def(self, '$ancestors', $Module_ancestors$11 = function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, $Module_ancestors$11.$$arity = 0);
    
    Opal.def(self, '$append_features', $Module_append_features$12 = function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, $Module_append_features$12.$$arity = 1);
    
    Opal.def(self, '$attr_accessor', $Module_attr_accessor$13 = function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      $send(self, 'attr_reader', Opal.to_a(names));
      return $send(self, 'attr_writer', Opal.to_a(names));
    }, $Module_attr_accessor$13.$$arity = -1);
    Opal.alias(self, "attr", "attr_accessor");
    
    Opal.def(self, '$attr_reader', $Module_attr_reader$14 = function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_reader$14.$$arity = -1);
    
    Opal.def(self, '$attr_writer', $Module_attr_writer$15 = function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_writer$15.$$arity = -1);
    
    Opal.def(self, '$autoload', $Module_autoload$16 = function $$autoload(const$, path) {
      var self = this;

      
      if (self.$$autoload == null) self.$$autoload = {};
      Opal.const_cache_version++;
      self.$$autoload[const$] = path;
      return nil;
    
    }, $Module_autoload$16.$$arity = 2);
    
    Opal.def(self, '$class_variables', $Module_class_variables$17 = function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, $Module_class_variables$17.$$arity = 0);
    
    Opal.def(self, '$class_variable_get', $Module_class_variable_get$18 = function $$class_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      var value = Opal.class_variables(self)[name];
      if (value == null) {
        self.$raise($$($nesting, 'NameError').$new("" + "uninitialized class variable " + (name) + " in " + (self), name))
      }
      return value;
    ;
    }, $Module_class_variable_get$18.$$arity = 1);
    
    Opal.def(self, '$class_variable_set', $Module_class_variable_set$19 = function $$class_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, $Module_class_variable_set$19.$$arity = 2);
    
    Opal.def(self, '$class_variable_defined?', $Module_class_variable_defined$ques$20 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, $Module_class_variable_defined$ques$20.$$arity = 1);
    
    Opal.def(self, '$remove_class_variable', $Module_remove_class_variable$21 = function $$remove_class_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        self.$raise($$($nesting, 'NameError'), "" + "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, $Module_remove_class_variable$21.$$arity = 1);
    
    Opal.def(self, '$constants', $Module_constants$22 = function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      return Opal.constants(self, inherit);;
    }, $Module_constants$22.$$arity = -1);
    Opal.defs(self, '$constants', $Module_constants$23 = function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, $Module_constants$23.$$arity = -1);
    Opal.defs(self, '$nesting', $Module_nesting$24 = function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, $Module_nesting$24.$$arity = 0);
    
    Opal.def(self, '$const_defined?', $Module_const_defined$ques$25 = function(name, inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) {
          return true;
        }
      }

      return false;
    ;
    }, $Module_const_defined$ques$25.$$arity = -2);
    
    Opal.def(self, '$const_get', $Module_const_get$26 = function $$const_get(name, inherit) {
      var $$27, self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], ($$27 = function(o, c){var self = $$27.$$s || this;

        
          
          if (o == null) {
            o = nil;
          };
          
          if (c == null) {
            c = nil;
          };
          return o.$const_get(c);}, $$27.$$s = self, $$27.$$arity = 2, $$27))};
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return $$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, $Module_const_get$26.$$arity = -2);
    
    Opal.def(self, '$const_missing', $Module_const_missing$28 = function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return self.$const_get(name);
        }
      }
    ;
      full_const_name = (function() {if (self['$==']($$($nesting, 'Object'))) {
        return name
      } else {
        return "" + (self) + "::" + (name)
      }; return nil; })();
      return self.$raise($$($nesting, 'NameError').$new("" + "uninitialized constant " + (full_const_name), name));
    }, $Module_const_missing$28.$$arity = 1);
    
    Opal.def(self, '$const_set', $Module_const_set$29 = function $$const_set(name, value) {
      var $a, self = this;

      
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(($truthy($a = name['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP'))) ? $a : name['$start_with?']("::")))) {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))};
      Opal.const_set(self, name, value);
      return value;
    }, $Module_const_set$29.$$arity = 2);
    
    Opal.def(self, '$public_constant', $Module_public_constant$30 = function $$public_constant(const_name) {
      var self = this;

      return nil
    }, $Module_public_constant$30.$$arity = 1);
    
    Opal.def(self, '$define_method', $Module_define_method$31 = function $$define_method(name, method) {
      var $iter = $Module_define_method$31.$$p, block = $iter || nil, $a, $$32, self = this, $case = nil;

      if ($iter) $Module_define_method$31.$$p = null;
      
      
      if ($iter) $Module_define_method$31.$$p = null;;
      ;
      if ($truthy(method === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")};
      block = ($truthy($a = block) ? $a : (function() {$case = method;
      if ($$($nesting, 'Proc')['$===']($case)) {return method}
      else if ($$($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}
      else if ($$($nesting, 'UnboundMethod')['$===']($case)) {return $lambda(($$32 = function($b){var self = $$32.$$s || this, $post_args, args, bound = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        bound = method.$bind(self);
        return $send(bound, 'call', Opal.to_a(args));}, $$32.$$s = self, $$32.$$arity = -1, $$32))}
      else {return self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (block.$class()) + " (expected Proc/Method)")}})());
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      Opal.defn(self, id, block);

      return name;
    ;
    }, $Module_define_method$31.$$arity = -2);
    
    Opal.def(self, '$remove_method', $Module_remove_method$33 = function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_remove_method$33.$$arity = -1);
    
    Opal.def(self, '$singleton_class?', $Module_singleton_class$ques$34 = function() {
      var self = this;

      return !!self.$$is_singleton;
    }, $Module_singleton_class$ques$34.$$arity = 0);
    
    Opal.def(self, '$include', $Module_include$35 = function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, $Module_include$35.$$arity = -1);
    
    Opal.def(self, '$included_modules', $Module_included_modules$36 = function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, $Module_included_modules$36.$$arity = 0);
    
    Opal.def(self, '$include?', $Module_include$ques$37 = function(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, $Module_include$ques$37.$$arity = 1);
    
    Opal.def(self, '$instance_method', $Module_instance_method$38 = function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, $Module_instance_method$38.$$arity = 1);
    
    Opal.def(self, '$instance_methods', $Module_instance_methods$39 = function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) {
        include_super = true;
      };
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, $Module_instance_methods$39.$$arity = -1);
    
    Opal.def(self, '$included', $Module_included$40 = function $$included(mod) {
      var self = this;

      return nil
    }, $Module_included$40.$$arity = 1);
    
    Opal.def(self, '$extended', $Module_extended$41 = function $$extended(mod) {
      var self = this;

      return nil
    }, $Module_extended$41.$$arity = 1);
    
    Opal.def(self, '$extend_object', $Module_extend_object$42 = function $$extend_object(object) {
      var self = this;

      return nil
    }, $Module_extend_object$42.$$arity = 1);
    
    Opal.def(self, '$method_added', $Module_method_added$43 = function $$method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_added$43.$$arity = -1);
    
    Opal.def(self, '$method_removed', $Module_method_removed$44 = function $$method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_removed$44.$$arity = -1);
    
    Opal.def(self, '$method_undefined', $Module_method_undefined$45 = function $$method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_undefined$45.$$arity = -1);
    
    Opal.def(self, '$module_eval', $Module_module_eval$46 = function $$module_eval($a) {
      var $iter = $Module_module_eval$46.$$p, block = $iter || nil, $post_args, args, $b, $$47, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;

      if ($iter) $Module_module_eval$46.$$p = null;
      
      
      if ($iter) $Module_module_eval$46.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy($b = file) ? $b : "(eval)"), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$($nesting, 'Opal').$compile(string, compiling_options);
        block = $send($$($nesting, 'Kernel'), 'proc', [], ($$47 = function(){var self = $$47.$$s || this;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$47.$$s = self, $$47.$$arity = 0, $$47));
      } else if ($truthy(args['$any?']())) {
        $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + ("" + "wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")};
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, $Module_module_eval$46.$$arity = -1);
    Opal.alias(self, "class_eval", "module_eval");
    
    Opal.def(self, '$module_exec', $Module_module_exec$48 = function $$module_exec($a) {
      var $iter = $Module_module_exec$48.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Module_module_exec$48.$$p = null;
      
      
      if ($iter) $Module_module_exec$48.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block === nil) {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, $Module_module_exec$48.$$arity = -1);
    Opal.alias(self, "class_exec", "module_exec");
    
    Opal.def(self, '$method_defined?', $Module_method_defined$ques$49 = function(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, $Module_method_defined$ques$49.$$arity = 1);
    
    Opal.def(self, '$module_function', $Module_module_function$50 = function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
      }

      return self;
    ;
    }, $Module_module_function$50.$$arity = -1);
    
    Opal.def(self, '$name', $Module_name$51 = function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, $Module_name$51.$$arity = 0);
    
    Opal.def(self, '$prepend', $Module_prepend$52 = function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, $Module_prepend$52.$$arity = -1);
    
    Opal.def(self, '$prepend_features', $Module_prepend_features$53 = function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, $Module_prepend_features$53.$$arity = 1);
    
    Opal.def(self, '$prepended', $Module_prepended$54 = function $$prepended(mod) {
      var self = this;

      return nil
    }, $Module_prepended$54.$$arity = 1);
    
    Opal.def(self, '$remove_const', $Module_remove_const$55 = function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, $Module_remove_const$55.$$arity = 1);
    
    Opal.def(self, '$to_s', $Module_to_s$56 = function $$to_s() {
      var $a, self = this;

      return ($truthy($a = Opal.Module.$name.call(self)) ? $a : "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">")
    }, $Module_to_s$56.$$arity = 0);
    
    Opal.def(self, '$undef_method', $Module_undef_method$57 = function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_undef_method$57.$$arity = -1);
    
    Opal.def(self, '$instance_variables', $Module_instance_variables$58 = function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, $Module_instance_variables$58.$$arity = 0);
    
    Opal.def(self, '$dup', $Module_dup$59 = function $$dup() {
      var $iter = $Module_dup$59.$$p, $yield = $iter || nil, self = this, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Module_dup$59.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      copy = $send(self, Opal.find_super_dispatcher(self, 'dup', $Module_dup$59, false), $zuper, $iter);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, $Module_dup$59.$$arity = 0);
    
    Opal.def(self, '$copy_class_variables', $Module_copy_class_variables$60 = function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, $Module_copy_class_variables$60.$$arity = 1);
    return (Opal.def(self, '$copy_constants', $Module_copy_constants$61 = function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        Opal.const_set(self, name, other_constants[name]);
      }
    
    }, $Module_copy_constants$61.$$arity = 1), nil) && 'copy_constants';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/class"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$require', '$class_eval', '$to_proc', '$initialize_copy', '$allocate', '$name', '$to_s']);
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_new$1, $Class_allocate$2, $Class_inherited$3, $Class_initialize_dup$4, $Class_new$5, $Class_superclass$6, $Class_to_s$7;

    
    Opal.defs(self, '$new', $Class_new$1 = function(superclass) {
      var $iter = $Class_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Class_new$1.$$p = null;
      
      
      if ($iter) $Class_new$1.$$p = null;;
      
      if (superclass == null) {
        superclass = $$($nesting, 'Object');
      };
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      (function() {if ((block !== nil)) {
        return $send((klass), 'class_eval', [], block.$to_proc())
      } else {
        return nil
      }; return nil; })()
      return klass;
    ;
    }, $Class_new$1.$$arity = -1);
    
    Opal.def(self, '$allocate', $Class_allocate$2 = function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, $Class_allocate$2.$$arity = 0);
    
    Opal.def(self, '$inherited', $Class_inherited$3 = function $$inherited(cls) {
      var self = this;

      return nil
    }, $Class_inherited$3.$$arity = 1);
    
    Opal.def(self, '$initialize_dup', $Class_initialize_dup$4 = function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, $Class_initialize_dup$4.$$arity = 1);
    
    Opal.def(self, '$new', $Class_new$5 = function($a) {
      var $iter = $Class_new$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Class_new$5.$$p = null;
      
      
      if ($iter) $Class_new$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, $Class_new$5.$$arity = -1);
    
    Opal.def(self, '$superclass', $Class_superclass$6 = function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, $Class_superclass$6.$$arity = 0);
    return (Opal.def(self, '$to_s', $Class_to_s$7 = function $$to_s() {
      var $iter = $Class_to_s$7.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Class_to_s$7.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && (singleton_of.$$is_a_module)) {
        return "" + "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "" + "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }
      return $send(self, Opal.find_super_dispatcher(self, 'to_s', $Class_to_s$7, false), [], null);
    
    }, $Class_to_s$7.$$arity = 0), nil) && 'to_s';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/basic_object"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$any?', '$inspect', '$new']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'BasicObject');

    var $nesting = [self].concat($parent_nesting), $BasicObject_initialize$1, $BasicObject_$eq_eq$2, $BasicObject_eql$ques$3, $BasicObject___id__$4, $BasicObject___send__$5, $BasicObject_$excl$6, $BasicObject_$not_eq$7, $BasicObject_instance_eval$8, $BasicObject_instance_exec$10, $BasicObject_singleton_method_added$11, $BasicObject_singleton_method_removed$12, $BasicObject_singleton_method_undefined$13, $BasicObject_class$14, $BasicObject_method_missing$15;

    
    
    Opal.def(self, '$initialize', $BasicObject_initialize$1 = function $$initialize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_initialize$1.$$arity = -1);
    
    Opal.def(self, '$==', $BasicObject_$eq_eq$2 = function(other) {
      var self = this;

      return self === other;
    }, $BasicObject_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$eql?', $BasicObject_eql$ques$3 = function(other) {
      var self = this;

      return self['$=='](other)
    }, $BasicObject_eql$ques$3.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    
    Opal.def(self, '$__id__', $BasicObject___id__$4 = function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.defineProperty(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, $BasicObject___id__$4.$$arity = 0);
    
    Opal.def(self, '$__send__', $BasicObject___send__$5 = function $$__send__(symbol, $a) {
      var $iter = $BasicObject___send__$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject___send__$5.$$p = null;
      
      
      if ($iter) $BasicObject___send__$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      var func = self['$' + symbol]

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, $BasicObject___send__$5.$$arity = -2);
    
    Opal.def(self, '$!', $BasicObject_$excl$6 = function() {
      var self = this;

      return false
    }, $BasicObject_$excl$6.$$arity = 0);
    
    Opal.def(self, '$!=', $BasicObject_$not_eq$7 = function(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, $BasicObject_$not_eq$7.$$arity = 1);
    
    Opal.def(self, '$instance_eval', $BasicObject_instance_eval$8 = function $$instance_eval($a) {
      var $iter = $BasicObject_instance_eval$8.$$p, block = $iter || nil, $post_args, args, $b, $$9, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;

      if ($iter) $BasicObject_instance_eval$8.$$p = null;
      
      
      if ($iter) $BasicObject_instance_eval$8.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy($b = file) ? $b : "(eval)"), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$$('::', 'Opal').$compile(string, compiling_options);
        block = $send($$$('::', 'Kernel'), 'proc', [], ($$9 = function(){var self = $$9.$$s || this;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$9.$$s = self, $$9.$$arity = 0, $$9));
      } else if ($truthy(args['$any?']())) {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (" + (args.$size()) + " for 0)")};
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, $BasicObject_instance_eval$8.$$arity = -1);
    
    Opal.def(self, '$instance_exec', $BasicObject_instance_exec$10 = function $$instance_exec($a) {
      var $iter = $BasicObject_instance_exec$10.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject_instance_exec$10.$$p = null;
      
      
      if ($iter) $BasicObject_instance_exec$10.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
      } else {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, $BasicObject_instance_exec$10.$$arity = -1);
    
    Opal.def(self, '$singleton_method_added', $BasicObject_singleton_method_added$11 = function $$singleton_method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_added$11.$$arity = -1);
    
    Opal.def(self, '$singleton_method_removed', $BasicObject_singleton_method_removed$12 = function $$singleton_method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_removed$12.$$arity = -1);
    
    Opal.def(self, '$singleton_method_undefined', $BasicObject_singleton_method_undefined$13 = function $$singleton_method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_undefined$13.$$arity = -1);
    
    Opal.def(self, '$class', $BasicObject_class$14 = function() {
      var self = this;

      return self.$$class;
    }, $BasicObject_class$14.$$arity = 0);
    return (Opal.def(self, '$method_missing', $BasicObject_method_missing$15 = function $$method_missing(symbol, $a) {
      var $iter = $BasicObject_method_missing$15.$$p, block = $iter || nil, $post_args, args, self = this, message = nil;

      if ($iter) $BasicObject_method_missing$15.$$p = null;
      
      
      if ($iter) $BasicObject_method_missing$15.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      message = (function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$inspect()) + ":" + (self.$$class)
      } else {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$$class)
      }; return nil; })();
      return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));
    }, $BasicObject_method_missing$15.$$arity = -2), nil) && 'method_missing';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/kernel"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;

  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$empty?', '$pop', '$call', '$coerce_to', '$append_features', '$extend_object', '$extended', '$__id__', '$to_s', '$instance_variable_name!', '$respond_to?', '$to_int', '$coerce_to!', '$Integer', '$nil?', '$===', '$enum_for', '$result', '$any?', '$print', '$format', '$puts', '$each', '$<=', '$length', '$[]', '$exception', '$is_a?', '$rand', '$respond_to_missing?', '$try_convert!', '$expand_path', '$join', '$start_with?', '$new_seed', '$srand', '$sym', '$arg', '$open', '$include']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_method_missing$1, $Kernel_$eq_tilde$2, $Kernel_$excl_tilde$3, $Kernel_$eq_eq_eq$4, $Kernel_$lt_eq_gt$5, $Kernel_method$6, $Kernel_methods$7, $Kernel_public_methods$8, $Kernel_Array$9, $Kernel_at_exit$10, $Kernel_caller$11, $Kernel_class$12, $Kernel_copy_instance_variables$13, $Kernel_copy_singleton_methods$14, $Kernel_clone$15, $Kernel_initialize_clone$16, $Kernel_define_singleton_method$17, $Kernel_dup$18, $Kernel_initialize_dup$19, $Kernel_enum_for$20, $Kernel_equal$ques$21, $Kernel_exit$22, $Kernel_extend$23, $Kernel_hash$24, $Kernel_initialize_copy$25, $Kernel_inspect$26, $Kernel_instance_of$ques$27, $Kernel_instance_variable_defined$ques$28, $Kernel_instance_variable_get$29, $Kernel_instance_variable_set$30, $Kernel_remove_instance_variable$31, $Kernel_instance_variables$32, $Kernel_Integer$33, $Kernel_Float$34, $Kernel_Hash$35, $Kernel_is_a$ques$36, $Kernel_itself$37, $Kernel_lambda$38, $Kernel_load$39, $Kernel_loop$40, $Kernel_nil$ques$42, $Kernel_printf$43, $Kernel_proc$44, $Kernel_puts$45, $Kernel_p$46, $Kernel_print$48, $Kernel_warn$49, $Kernel_raise$50, $Kernel_rand$51, $Kernel_respond_to$ques$52, $Kernel_respond_to_missing$ques$53, $Kernel_require$54, $Kernel_require_relative$55, $Kernel_require_tree$56, $Kernel_singleton_class$57, $Kernel_sleep$58, $Kernel_srand$59, $Kernel_String$60, $Kernel_tap$61, $Kernel_to_proc$62, $Kernel_to_s$63, $Kernel_catch$64, $Kernel_throw$65, $Kernel_open$66, $Kernel_yield_self$67;

    
    
    Opal.def(self, '$method_missing', $Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
      var $iter = $Kernel_method_missing$1.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_method_missing$1.$$p = null;
      
      
      if ($iter) $Kernel_method_missing$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (symbol) + "' for " + (self.$inspect()), symbol, args));
    }, $Kernel_method_missing$1.$$arity = -2);
    
    Opal.def(self, '$=~', $Kernel_$eq_tilde$2 = function(obj) {
      var self = this;

      return false
    }, $Kernel_$eq_tilde$2.$$arity = 1);
    
    Opal.def(self, '$!~', $Kernel_$excl_tilde$3 = function(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, $Kernel_$excl_tilde$3.$$arity = 1);
    
    Opal.def(self, '$===', $Kernel_$eq_eq_eq$4 = function(other) {
      var $a, self = this;

      return ($truthy($a = self.$object_id()['$=='](other.$object_id())) ? $a : self['$=='](other))
    }, $Kernel_$eq_eq_eq$4.$$arity = 1);
    
    Opal.def(self, '$<=>', $Kernel_$lt_eq_gt$5 = function(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, $Kernel_$lt_eq_gt$5.$$arity = 1);
    
    Opal.def(self, '$method', $Kernel_method$6 = function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, $Kernel_method$6.$$arity = 1);
    
    Opal.def(self, '$methods', $Kernel_methods$7 = function $$methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, $Kernel_methods$7.$$arity = -1);
    
    Opal.def(self, '$public_methods', $Kernel_public_methods$8 = function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, $Kernel_public_methods$8.$$arity = -1);
    
    Opal.def(self, '$Array', $Kernel_Array$9 = function $$Array(object) {
      var self = this;

      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, $Kernel_Array$9.$$arity = 1);
    
    Opal.def(self, '$at_exit', $Kernel_at_exit$10 = function $$at_exit() {
      var $iter = $Kernel_at_exit$10.$$p, block = $iter || nil, $a, self = this;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if ($iter) $Kernel_at_exit$10.$$p = null;
      
      
      if ($iter) $Kernel_at_exit$10.$$p = null;;
      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);
      return $gvars.__at_exit__['$<<'](block);
    }, $Kernel_at_exit$10.$$arity = 0);
    
    Opal.def(self, '$caller', $Kernel_caller$11 = function $$caller($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return [];
    }, $Kernel_caller$11.$$arity = -1);
    
    Opal.def(self, '$class', $Kernel_class$12 = function() {
      var self = this;

      return self.$$class;
    }, $Kernel_class$12.$$arity = 0);
    
    Opal.def(self, '$copy_instance_variables', $Kernel_copy_instance_variables$13 = function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_instance_variables$13.$$arity = 1);
    
    Opal.def(self, '$copy_singleton_methods', $Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_singleton_methods$14.$$arity = 1);
    
    Opal.def(self, '$clone', $Kernel_clone$15 = function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $Kernel_clone$15.$$arity = -1);
    
    Opal.def(self, '$initialize_clone', $Kernel_initialize_clone$16 = function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_clone$16.$$arity = 1);
    
    Opal.def(self, '$define_singleton_method', $Kernel_define_singleton_method$17 = function $$define_singleton_method(name, method) {
      var $iter = $Kernel_define_singleton_method$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_define_singleton_method$17.$$p = null;
      
      
      if ($iter) $Kernel_define_singleton_method$17.$$p = null;;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, $Kernel_define_singleton_method$17.$$arity = -2);
    
    Opal.def(self, '$dup', $Kernel_dup$18 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Kernel_dup$18.$$arity = 0);
    
    Opal.def(self, '$initialize_dup', $Kernel_initialize_dup$19 = function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_dup$19.$$arity = 1);
    
    Opal.def(self, '$enum_for', $Kernel_enum_for$20 = function $$enum_for($a, $b) {
      var $iter = $Kernel_enum_for$20.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Kernel_enum_for$20.$$p = null;
      
      
      if ($iter) $Kernel_enum_for$20.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      return $send($$($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Kernel_enum_for$20.$$arity = -1);
    Opal.alias(self, "to_enum", "enum_for");
    
    Opal.def(self, '$equal?', $Kernel_equal$ques$21 = function(other) {
      var self = this;

      return self === other;
    }, $Kernel_equal$ques$21.$$arity = 1);
    
    Opal.def(self, '$exit', $Kernel_exit$22 = function $$exit(status) {
      var $a, self = this, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) {
        status = true;
      };
      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $$($nesting, 'Opal').$coerce_to(status, $$($nesting, 'Integer'), "to_int")
      }

      Opal.exit(status);
    ;
      return nil;
    }, $Kernel_exit$22.$$arity = -1);
    
    Opal.def(self, '$extend', $Kernel_extend$23 = function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, $Kernel_extend$23.$$arity = -1);
    
    Opal.def(self, '$hash', $Kernel_hash$24 = function $$hash() {
      var self = this;

      return self.$__id__()
    }, $Kernel_hash$24.$$arity = 0);
    
    Opal.def(self, '$initialize_copy', $Kernel_initialize_copy$25 = function $$initialize_copy(other) {
      var self = this;

      return nil
    }, $Kernel_initialize_copy$25.$$arity = 1);
    
    Opal.def(self, '$inspect', $Kernel_inspect$26 = function $$inspect() {
      var self = this;

      return self.$to_s()
    }, $Kernel_inspect$26.$$arity = 0);
    
    Opal.def(self, '$instance_of?', $Kernel_instance_of$ques$27 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, $Kernel_instance_of$ques$27.$$arity = 1);
    
    Opal.def(self, '$instance_variable_defined?', $Kernel_instance_variable_defined$ques$28 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, $Kernel_instance_variable_defined$ques$28.$$arity = 1);
    
    Opal.def(self, '$instance_variable_get', $Kernel_instance_variable_get$29 = function $$instance_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, $Kernel_instance_variable_get$29.$$arity = 1);
    
    Opal.def(self, '$instance_variable_set', $Kernel_instance_variable_set$30 = function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, $Kernel_instance_variable_set$30.$$arity = 2);
    
    Opal.def(self, '$remove_instance_variable', $Kernel_remove_instance_variable$31 = function $$remove_instance_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return self.$raise($$($nesting, 'NameError'), "" + "instance variable " + (name) + " not defined");
    }, $Kernel_remove_instance_variable$31.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Kernel_instance_variables$32 = function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, $Kernel_instance_variables$32.$$arity = 0);
    
    Opal.def(self, '$Integer', $Kernel_Integer$33 = function $$Integer(value, base) {
      var self = this;

      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          self.$raise($$($nesting, 'TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            self.$raise($$($nesting, 'FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $$($nesting, 'Opal').$coerce_to(base, $$($nesting, 'Integer'), "to_int");
        if (base === 1 || base < 0 || base > 36) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
        }
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, $Kernel_Integer$33.$$arity = -2);
    
    Opal.def(self, '$Float', $Kernel_Float$34 = function $$Float(value) {
      var self = this;

      
      var str;

      if (value === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return self.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), "to_f");
    
    }, $Kernel_Float$34.$$arity = 1);
    
    Opal.def(self, '$Hash', $Kernel_Hash$35 = function $$Hash(arg) {
      var $a, self = this;

      
      if ($truthy(($truthy($a = arg['$nil?']()) ? $a : arg['$==']([])))) {
        return $hash2([], {})};
      if ($truthy($$($nesting, 'Hash')['$==='](arg))) {
        return arg};
      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), "to_hash");
    }, $Kernel_Hash$35.$$arity = 1);
    
    Opal.def(self, '$is_a?', $Kernel_is_a$ques$36 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, $Kernel_is_a$ques$36.$$arity = 1);
    
    Opal.def(self, '$itself', $Kernel_itself$37 = function $$itself() {
      var self = this;

      return self
    }, $Kernel_itself$37.$$arity = 0);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$lambda', $Kernel_lambda$38 = function $$lambda() {
      var $iter = $Kernel_lambda$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_lambda$38.$$p = null;
      
      
      if ($iter) $Kernel_lambda$38.$$p = null;;
      return Opal.lambda(block);;
    }, $Kernel_lambda$38.$$arity = 0);
    
    Opal.def(self, '$load', $Kernel_load$39 = function $$load(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.load(file);
    }, $Kernel_load$39.$$arity = 1);
    
    Opal.def(self, '$loop', $Kernel_loop$40 = function $$loop() {
      var $$41, $a, $iter = $Kernel_loop$40.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_loop$40.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["loop"], ($$41 = function(){var self = $$41.$$s || this;

        return $$$($$($nesting, 'Float'), 'INFINITY')}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StopIteration')])) {e = $err;
            try {
              return e.$result()
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      };
      return self;
    }, $Kernel_loop$40.$$arity = 0);
    
    Opal.def(self, '$nil?', $Kernel_nil$ques$42 = function() {
      var self = this;

      return false
    }, $Kernel_nil$ques$42.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$printf', $Kernel_printf$43 = function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', Opal.to_a(args)))};
      return nil;
    }, $Kernel_printf$43.$$arity = -1);
    
    Opal.def(self, '$proc', $Kernel_proc$44 = function $$proc() {
      var $iter = $Kernel_proc$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_proc$44.$$p = null;
      
      
      if ($iter) $Kernel_proc$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, $Kernel_proc$44.$$arity = 0);
    
    Opal.def(self, '$puts', $Kernel_puts$45 = function $$puts($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', Opal.to_a(strs));
    }, $Kernel_puts$45.$$arity = -1);
    
    Opal.def(self, '$p', $Kernel_p$46 = function $$p($a) {
      var $post_args, args, $$47, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      $send(args, 'each', [], ($$47 = function(obj){var self = $$47.$$s || this;
        if ($gvars.stdout == null) $gvars.stdout = nil;

      
        
        if (obj == null) {
          obj = nil;
        };
        return $gvars.stdout.$puts(obj.$inspect());}, $$47.$$s = self, $$47.$$arity = 1, $$47));
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, $Kernel_p$46.$$arity = -1);
    
    Opal.def(self, '$print', $Kernel_print$48 = function $$print($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', Opal.to_a(strs));
    }, $Kernel_print$48.$$arity = -1);
    
    Opal.def(self, '$warn', $Kernel_warn$49 = function $$warn($a) {
      var $post_args, strs, $b, self = this;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      if ($truthy(($truthy($b = $gvars.VERBOSE['$nil?']()) ? $b : strs['$empty?']()))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', Opal.to_a(strs))
      };
    }, $Kernel_warn$49.$$arity = -1);
    
    Opal.def(self, '$raise', $Kernel_raise$50 = function $$raise(exception, string, _backtrace) {
      var self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      ;
      
      if (string == null) {
        string = nil;
      };
      
      if (_backtrace == null) {
        _backtrace = nil;
      };
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$($nesting, 'RuntimeError').$new();
      }
      else if (exception.$$is_string) {
        exception = $$($nesting, 'RuntimeError').$new(exception);
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && exception['$respond_to?']("exception")) {
        exception = exception.$exception(string);
      }
      else if (exception['$is_a?']($$($nesting, 'Exception'))) {
        // exception is fine
      }
      else {
        exception = $$($nesting, 'TypeError').$new("exception class/object expected");
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    ;
    }, $Kernel_raise$50.$$arity = -1);
    Opal.alias(self, "fail", "raise");
    
    Opal.def(self, '$rand', $Kernel_rand$51 = function $$rand(max) {
      var self = this;

      
      ;
      
      if (max === undefined) {
        return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);
    }, $Kernel_rand$51.$$arity = -1);
    
    Opal.def(self, '$respond_to?', $Kernel_respond_to$ques$52 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      if ($truthy(self['$respond_to_missing?'](name, include_all))) {
        return true};
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
    ;
      return false;
    }, $Kernel_respond_to$ques$52.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Kernel_respond_to_missing$ques$53 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $Kernel_respond_to_missing$ques$53.$$arity = -2);
    
    Opal.def(self, '$require', $Kernel_require$54 = function $$require(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.require(file);
    }, $Kernel_require$54.$$arity = 1);
    
    Opal.def(self, '$require_relative', $Kernel_require_relative$55 = function $$require_relative(file) {
      var self = this;

      
      $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), "to_str");
      file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, $Kernel_require_relative$55.$$arity = 1);
    
    Opal.def(self, '$require_tree', $Kernel_require_tree$56 = function $$require_tree(path) {
      var self = this;

      
      var result = [];

      path = $$($nesting, 'File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          result.push([name, Opal.require(name)]);
        }
      }

      return result;
    
    }, $Kernel_require_tree$56.$$arity = 1);
    Opal.alias(self, "send", "__send__");
    Opal.alias(self, "public_send", "__send__");
    
    Opal.def(self, '$singleton_class', $Kernel_singleton_class$57 = function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, $Kernel_singleton_class$57.$$arity = 0);
    
    Opal.def(self, '$sleep', $Kernel_sleep$58 = function $$sleep(seconds) {
      var self = this;

      
      
      if (seconds == null) {
        seconds = nil;
      };
      
      if (seconds === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return seconds;
    ;
    }, $Kernel_sleep$58.$$arity = -1);
    
    Opal.def(self, '$srand', $Kernel_srand$59 = function $$srand(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      return $$($nesting, 'Random').$srand(seed);
    }, $Kernel_srand$59.$$arity = -1);
    
    Opal.def(self, '$String', $Kernel_String$60 = function $$String(str) {
      var $a, self = this;

      return ($truthy($a = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), "to_str")) ? $a : $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), "to_s"))
    }, $Kernel_String$60.$$arity = 1);
    
    Opal.def(self, '$tap', $Kernel_tap$61 = function $$tap() {
      var $iter = $Kernel_tap$61.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_tap$61.$$p = null;
      
      
      if ($iter) $Kernel_tap$61.$$p = null;;
      Opal.yield1(block, self);
      return self;
    }, $Kernel_tap$61.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Kernel_to_proc$62 = function $$to_proc() {
      var self = this;

      return self
    }, $Kernel_to_proc$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $Kernel_to_s$63 = function $$to_s() {
      var self = this;

      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, $Kernel_to_s$63.$$arity = 0);
    
    Opal.def(self, '$catch', $Kernel_catch$64 = function(sym) {
      var $iter = $Kernel_catch$64.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_catch$64.$$p = null;
      try {
        return Opal.yieldX($yield, []);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'UncaughtThrowError')])) {e = $err;
          try {
            
            if (e.$sym()['$=='](sym)) {
              return e.$arg()};
            return self.$raise();
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Kernel_catch$64.$$arity = 1);
    
    Opal.def(self, '$throw', $Kernel_throw$65 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'UncaughtThrowError'), args);
    }, $Kernel_throw$65.$$arity = -1);
    
    Opal.def(self, '$open', $Kernel_open$66 = function $$open($a) {
      var $iter = $Kernel_open$66.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_open$66.$$p = null;
      
      
      if ($iter) $Kernel_open$66.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($$($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc());
    }, $Kernel_open$66.$$arity = -1);
    
    Opal.def(self, '$yield_self', $Kernel_yield_self$67 = function $$yield_self() {
      var $$68, $iter = $Kernel_yield_self$67.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_yield_self$67.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["yield_self"], ($$68 = function(){var self = $$68.$$s || this;

        return 1}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      return Opal.yield1($yield, self);;
    }, $Kernel_yield_self$67.$$arity = 0);
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, 'Kernel'))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/error"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$raise', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $Exception_new$1, $Exception_exception$2, $Exception_initialize$3, $Exception_backtrace$4, $Exception_exception$5, $Exception_message$6, $Exception_inspect$7, $Exception_set_backtrace$8, $Exception_to_s$9;

    self.$$prototype.message = nil;
    
    var stack_trace_limit;
    Opal.defs(self, '$new', $Exception_new$1 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, $Exception_new$1.$$arity = -1);
    stack_trace_limit = self.$new;
    Opal.defs(self, '$exception', $Exception_exception$2 = function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $Exception_exception$2.$$arity = -1);
    
    Opal.def(self, '$initialize', $Exception_initialize$3 = function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, $Exception_initialize$3.$$arity = -1);
    
    Opal.def(self, '$backtrace', $Exception_backtrace$4 = function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) === 'string') {
        return backtrace.split("\n").slice(0, 15);
      }
      else if (backtrace) {
        return backtrace.slice(0, 15);
      }

      return [];
    
    }, $Exception_backtrace$4.$$arity = 0);
    
    Opal.def(self, '$exception', $Exception_exception$5 = function $$exception(str) {
      var self = this;

      
      
      if (str == null) {
        str = nil;
      };
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      cloned.stack = self.stack;
      return cloned;
    ;
    }, $Exception_exception$5.$$arity = -1);
    
    Opal.def(self, '$message', $Exception_message$6 = function $$message() {
      var self = this;

      return self.$to_s()
    }, $Exception_message$6.$$arity = 0);
    
    Opal.def(self, '$inspect', $Exception_inspect$7 = function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "" + "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, $Exception_inspect$7.$$arity = 0);
    
    Opal.def(self, '$set_backtrace', $Exception_set_backtrace$8 = function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          self.$raise($$($nesting, 'TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = backtrace.join('\n');
      }

      return backtrace;
    
    }, $Exception_set_backtrace$8.$$arity = 1);
    return (Opal.def(self, '$to_s', $Exception_to_s$9 = function $$to_s() {
      var $a, $b, self = this;

      return ($truthy($a = ($truthy($b = self.message) ? self.message.$to_s() : $b)) ? $a : self.$class().$to_s())
    }, $Exception_to_s$9.$$arity = 0), nil) && 'to_s';
  })($nesting[0], Error, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ScriptError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SyntaxError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LoadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NotImplementedError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemExit');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMemoryError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SignalException');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Interrupt');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SecurityError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StandardError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'EncodingError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ZeroDivisionError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'NameError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RuntimeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FrozenError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RuntimeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LocalJumpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TypeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ArgumentError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IndexError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FloatDomainError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RangeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IOError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EINVAL');

      var $nesting = [self].concat($parent_nesting), $EINVAL_new$10;

      return (Opal.defs(self, '$new', $EINVAL_new$10 = function(name) {
        var $iter = $EINVAL_new$10.$$p, $yield = $iter || nil, self = this, message = nil;

        if ($iter) $EINVAL_new$10.$$p = null;
        
        
        if (name == null) {
          name = nil;
        };
        message = "Invalid argument";
        if ($truthy(name)) {
          message = $rb_plus(message, "" + " - " + (name))};
        return $send(self, Opal.find_super_dispatcher(self, 'new', $EINVAL_new$10, false, self.$$class.$$prototype), [message], null);
      }, $EINVAL_new$10.$$arity = -1), nil) && 'new'
    })($nesting[0], $$($nesting, 'SystemCallError'), $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $nesting = [self].concat($parent_nesting), $UncaughtThrowError_initialize$11;

    self.$$prototype.sym = nil;
    
    self.$attr_reader("sym", "arg");
    return (Opal.def(self, '$initialize', $UncaughtThrowError_initialize$11 = function $$initialize(args) {
      var $iter = $UncaughtThrowError_initialize$11.$$p, $yield = $iter || nil, self = this;

      if ($iter) $UncaughtThrowError_initialize$11.$$p = null;
      
      self.sym = args['$[]'](0);
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.arg = args['$[]'](1)};
      return $send(self, Opal.find_super_dispatcher(self, 'initialize', $UncaughtThrowError_initialize$11, false), ["" + "uncaught throw " + (self.sym.$inspect())], null);
    }, $UncaughtThrowError_initialize$11.$$arity = 1), nil) && 'initialize';
  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting), $NameError_initialize$12;

    
    self.$attr_reader("name");
    return (Opal.def(self, '$initialize', $NameError_initialize$12 = function $$initialize(message, name) {
      var $iter = $NameError_initialize$12.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NameError_initialize$12.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $NameError_initialize$12, false), [message], null);
      return (self.name = name);
    }, $NameError_initialize$12.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting), $NoMethodError_initialize$13;

    
    self.$attr_reader("args");
    return (Opal.def(self, '$initialize', $NoMethodError_initialize$13 = function $$initialize(message, name, args) {
      var $iter = $NoMethodError_initialize$13.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NoMethodError_initialize$13.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      
      if (args == null) {
        args = [];
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $NoMethodError_initialize$13, false), [message, name], null);
      return (self.args = args);
    }, $NoMethodError_initialize$13.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting), $KeyError_initialize$14, $KeyError_receiver$15, $KeyError_key$16;

    self.$$prototype.receiver = self.$$prototype.key = nil;
    
    
    Opal.def(self, '$initialize', $KeyError_initialize$14 = function $$initialize(message, $kwargs) {
      var receiver, key, $iter = $KeyError_initialize$14.$$p, $yield = $iter || nil, self = this;

      if ($iter) $KeyError_initialize$14.$$p = null;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) {
        receiver = nil
      };
      
      key = $kwargs.$$smap["key"];
      if (key == null) {
        key = nil
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $KeyError_initialize$14, false), [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, $KeyError_initialize$14.$$arity = -2);
    
    Opal.def(self, '$receiver', $KeyError_receiver$15 = function $$receiver() {
      var $a, self = this;

      return ($truthy($a = self.receiver) ? $a : self.$raise($$($nesting, 'ArgumentError'), "no receiver is available"))
    }, $KeyError_receiver$15.$$arity = 0);
    return (Opal.def(self, '$key', $KeyError_key$16 = function $$key() {
      var $a, self = this;

      return ($truthy($a = self.key) ? $a : self.$raise($$($nesting, 'ArgumentError'), "no key is available"))
    }, $KeyError_key$16.$$arity = 0), nil) && 'key';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Error');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/constants"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  
  Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
  Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
  Opal.const_set($nesting[0], 'RUBY_VERSION', "2.5.7");
  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "1.0.3");
  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2020-02-01");
  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
  Opal.const_set($nesting[0], 'RUBY_REVISION', 0);
  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2020 Adam Beynon and the Opal contributors");
  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + ($$($nesting, 'RUBY_ENGINE_VERSION')) + " (" + ($$($nesting, 'RUBY_RELEASE_DATE')) + " revision " + ($$($nesting, 'RUBY_REVISION')) + ")");
};

/* Generated by Opal 1.0.3 */
Opal.modules["opal/base"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/nil"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_$excl$2, $NilClass_$$3, $NilClass_$$4, $NilClass_$$5, $NilClass_$eq_eq$6, $NilClass_dup$7, $NilClass_clone$8, $NilClass_inspect$9, $NilClass_nil$ques$10, $NilClass_singleton_class$11, $NilClass_to_a$12, $NilClass_to_h$13, $NilClass_to_i$14, $NilClass_to_s$15, $NilClass_to_c$16, $NilClass_rationalize$17, $NilClass_to_r$18, $NilClass_instance_variables$19;

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$!', $NilClass_$excl$2 = function() {
      var self = this;

      return true
    }, $NilClass_$excl$2.$$arity = 0);
    
    Opal.def(self, '$&', $NilClass_$$3 = function(other) {
      var self = this;

      return false
    }, $NilClass_$$3.$$arity = 1);
    
    Opal.def(self, '$|', $NilClass_$$4 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$4.$$arity = 1);
    
    Opal.def(self, '$^', $NilClass_$$5 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$5.$$arity = 1);
    
    Opal.def(self, '$==', $NilClass_$eq_eq$6 = function(other) {
      var self = this;

      return other === nil;
    }, $NilClass_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$dup', $NilClass_dup$7 = function $$dup() {
      var self = this;

      return nil
    }, $NilClass_dup$7.$$arity = 0);
    
    Opal.def(self, '$clone', $NilClass_clone$8 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return nil;
    }, $NilClass_clone$8.$$arity = -1);
    
    Opal.def(self, '$inspect', $NilClass_inspect$9 = function $$inspect() {
      var self = this;

      return "nil"
    }, $NilClass_inspect$9.$$arity = 0);
    
    Opal.def(self, '$nil?', $NilClass_nil$ques$10 = function() {
      var self = this;

      return true
    }, $NilClass_nil$ques$10.$$arity = 0);
    
    Opal.def(self, '$singleton_class', $NilClass_singleton_class$11 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'NilClass')
    }, $NilClass_singleton_class$11.$$arity = 0);
    
    Opal.def(self, '$to_a', $NilClass_to_a$12 = function $$to_a() {
      var self = this;

      return []
    }, $NilClass_to_a$12.$$arity = 0);
    
    Opal.def(self, '$to_h', $NilClass_to_h$13 = function $$to_h() {
      var self = this;

      return Opal.hash();
    }, $NilClass_to_h$13.$$arity = 0);
    
    Opal.def(self, '$to_i', $NilClass_to_i$14 = function $$to_i() {
      var self = this;

      return 0
    }, $NilClass_to_i$14.$$arity = 0);
    Opal.alias(self, "to_f", "to_i");
    
    Opal.def(self, '$to_s', $NilClass_to_s$15 = function $$to_s() {
      var self = this;

      return ""
    }, $NilClass_to_s$15.$$arity = 0);
    
    Opal.def(self, '$to_c', $NilClass_to_c$16 = function $$to_c() {
      var self = this;

      return $$($nesting, 'Complex').$new(0, 0)
    }, $NilClass_to_c$16.$$arity = 0);
    
    Opal.def(self, '$rationalize', $NilClass_rationalize$17 = function $$rationalize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.$raise($$($nesting, 'ArgumentError'))};
      return self.$Rational(0, 1);
    }, $NilClass_rationalize$17.$$arity = -1);
    
    Opal.def(self, '$to_r', $NilClass_to_r$18 = function $$to_r() {
      var self = this;

      return self.$Rational(0, 1)
    }, $NilClass_to_r$18.$$arity = 0);
    return (Opal.def(self, '$instance_variables', $NilClass_instance_variables$19 = function $$instance_variables() {
      var self = this;

      return []
    }, $NilClass_instance_variables$19.$$arity = 0), nil) && 'instance_variables';
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'NIL', nil);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/boolean"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$name']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean___id__$2, $Boolean_$excl$3, $Boolean_$$4, $Boolean_$$5, $Boolean_$$6, $Boolean_$eq_eq$7, $Boolean_singleton_class$8, $Boolean_to_s$9, $Boolean_dup$10, $Boolean_clone$11;

    
    Opal.defineProperty(self.$$prototype, '$$is_boolean', true);
    Opal.defineProperty(self.$$prototype, '$$meta', self);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$__id__', $Boolean___id__$2 = function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, $Boolean___id__$2.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$!', $Boolean_$excl$3 = function() {
      var self = this;

      return self != true;
    }, $Boolean_$excl$3.$$arity = 0);
    
    Opal.def(self, '$&', $Boolean_$$4 = function(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, $Boolean_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Boolean_$$5 = function(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, $Boolean_$$5.$$arity = 1);
    
    Opal.def(self, '$^', $Boolean_$$6 = function(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, $Boolean_$$6.$$arity = 1);
    
    Opal.def(self, '$==', $Boolean_$eq_eq$7 = function(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, $Boolean_$eq_eq$7.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$singleton_class', $Boolean_singleton_class$8 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'Boolean')
    }, $Boolean_singleton_class$8.$$arity = 0);
    
    Opal.def(self, '$to_s', $Boolean_to_s$9 = function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_s$9.$$arity = 0);
    
    Opal.def(self, '$dup', $Boolean_dup$10 = function $$dup() {
      var self = this;

      return self
    }, $Boolean_dup$10.$$arity = 0);
    return (Opal.def(self, '$clone', $Boolean_clone$11 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Boolean_clone$11.$$arity = -1), nil) && 'clone';
  })($nesting[0], Boolean, $nesting);
  Opal.const_set($nesting[0], 'TrueClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'FalseClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'TRUE', true);
  return Opal.const_set($nesting[0], 'FALSE', false);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$>', '$<', '$===', '$raise', '$class', '$equal?', '$<=>']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_$eq_eq$1, $Comparable_$gt$2, $Comparable_$gt_eq$3, $Comparable_$lt$4, $Comparable_$lt_eq$5, $Comparable_between$ques$6, $Comparable_clamp$7, $case = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (function() {$case = rhs;
    if (nil['$===']($case) || true['$===']($case) || false['$===']($case) || $$($nesting, 'Integer')['$===']($case) || $$($nesting, 'Float')['$===']($case)) {return class_name = rhs.$inspect();}
    else {return class_name = rhs.$$class;}})()
      self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }
  ;
    
    Opal.def(self, '$==', $Comparable_$eq_eq$1 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true};
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        return false
      };
      return normalize(cmp) == 0;;
    }, $Comparable_$eq_eq$1.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$2 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        fail_comparison(self, other)
      };
      return normalize(cmp) > 0;;
    }, $Comparable_$gt$2.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$3 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        fail_comparison(self, other)
      };
      return normalize(cmp) >= 0;;
    }, $Comparable_$gt_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$4 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        fail_comparison(self, other)
      };
      return normalize(cmp) < 0;;
    }, $Comparable_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$5 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        fail_comparison(self, other)
      };
      return normalize(cmp) <= 0;;
    }, $Comparable_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$6 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$6.$$arity = 2);
    
    Opal.def(self, '$clamp', $Comparable_clamp$7 = function $$clamp(min, max) {
      var self = this, cmp = nil;

      
      cmp = min['$<=>'](max);
      if ($truthy(cmp)) {
      } else {
        fail_comparison(min, max)
      };
      if ($truthy(normalize(cmp) > 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")};
      if ($truthy(normalize(self['$<=>'](min)) < 0)) {
        return min};
      if ($truthy(normalize(self['$<=>'](max)) > 0)) {
        return max};
      return self;
    }, $Comparable_clamp$7.$$arity = 2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/regexp"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$coerce_to', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RegexpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_$eq_eq$6, $Regexp_$eq_eq_eq$7, $Regexp_$eq_tilde$8, $Regexp_inspect$9, $Regexp_match$10, $Regexp_match$ques$11, $Regexp_$$12, $Regexp_source$13, $Regexp_options$14, $Regexp_casefold$ques$15;

    
    Opal.const_set($nesting[0], 'IGNORECASE', 1);
    Opal.const_set($nesting[0], 'EXTENDED', 2);
    Opal.const_set($nesting[0], 'MULTILINE', 4);
    Opal.defineProperty(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1, $escape$2, $last_match$3, $union$4, $new$5;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var $iter = $allocate$1.$$p, $yield = $iter || nil, self = this, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $allocate$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        allocated = $send(self, Opal.find_super_dispatcher(self, 'allocate', $allocate$1, false), $zuper, $iter);
        allocated.uninitialized = true;
        return allocated;
      }, $allocate$1.$$arity = 0);
      
      Opal.def(self, '$escape', $escape$2 = function $$escape(string) {
        var self = this;

        return Opal.escape_regexp(string);
      }, $escape$2.$$arity = 1);
      
      Opal.def(self, '$last_match', $last_match$3 = function $$last_match(n) {
        var self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) {
          n = nil;
        };
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else {
          return $gvars["~"]['$[]'](n)
        };
      }, $last_match$3.$$arity = -1);
      Opal.alias(self, "quote", "escape");
      
      Opal.def(self, '$union', $union$4 = function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              self.$raise($$($nesting, 'TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, $union$4.$$arity = -1);
      return (Opal.def(self, '$new', $new$5 = function(regexp, options) {
        var self = this;

        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          self.$raise($$($nesting, 'RegexpError'), "" + "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$($nesting, 'IGNORECASE') & options) { temp += 'i'; }
          if ($$($nesting, 'MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, $new$5.$$arity = -2), nil) && 'new';
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$==', $Regexp_$eq_eq$6 = function(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, $Regexp_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$===', $Regexp_$eq_eq_eq$7 = function(string) {
      var self = this;

      return self.$match($$($nesting, 'Opal')['$coerce_to?'](string, $$($nesting, 'String'), "to_str")) !== nil
    }, $Regexp_$eq_eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$=~', $Regexp_$eq_tilde$8 = function(string) {
      var $a, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      return ($truthy($a = self.$match(string)) ? $gvars["~"].$begin(0) : $a)
    }, $Regexp_$eq_tilde$8.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$inspect', $Regexp_inspect$9 = function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, $Regexp_inspect$9.$$arity = 0);
    
    Opal.def(self, '$match', $Regexp_match$10 = function $$match(string, pos) {
      var $iter = $Regexp_match$10.$$p, block = $iter || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($iter) $Regexp_match$10.$$p = null;
      
      
      if ($iter) $Regexp_match$10.$$p = null;;
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str"));
        if (m) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $$($nesting, 'Opal').$coerce_to(pos, $$($nesting, 'Integer'), "to_int");

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str");

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, $Regexp_match$10.$$arity = -2);
    
    Opal.def(self, '$match?', $Regexp_match$ques$11 = function(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str"));
      }

      pos = $$($nesting, 'Opal').$coerce_to(pos, $$($nesting, 'Integer'), "to_int");

      if (string === nil) {
        return false;
      }

      string = $$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str");

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, $Regexp_match$ques$11.$$arity = -2);
    
    Opal.def(self, '$~', $Regexp_$$12 = function() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, $Regexp_$$12.$$arity = 0);
    
    Opal.def(self, '$source', $Regexp_source$13 = function $$source() {
      var self = this;

      return self.source;
    }, $Regexp_source$13.$$arity = 0);
    
    Opal.def(self, '$options', $Regexp_options$14 = function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$($nesting, 'MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$($nesting, 'IGNORECASE');
      }
      return result;
    
    }, $Regexp_options$14.$$arity = 0);
    
    Opal.def(self, '$casefold?', $Regexp_casefold$ques$15 = function() {
      var self = this;

      return self.ignoreCase;
    }, $Regexp_casefold$ques$15.$$arity = 0);
    return Opal.alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_initialize$16, $MatchData_$$$17, $MatchData_offset$18, $MatchData_$eq_eq$19, $MatchData_begin$20, $MatchData_end$21, $MatchData_captures$22, $MatchData_inspect$23, $MatchData_length$24, $MatchData_to_a$25, $MatchData_to_s$26, $MatchData_values_at$27;

    self.$$prototype.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    Opal.def(self, '$initialize', $MatchData_initialize$16 = function $$initialize(regexp, match_groups) {
      var self = this;

      
      $gvars["~"] = self;
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, $MatchData_initialize$16.$$arity = 2);
    
    Opal.def(self, '$[]', $MatchData_$$$17 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self.matches, '[]', Opal.to_a(args));
    }, $MatchData_$$$17.$$arity = -1);
    
    Opal.def(self, '$offset', $MatchData_offset$18 = function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, $MatchData_offset$18.$$arity = 1);
    
    Opal.def(self, '$==', $MatchData_$eq_eq$19 = function(other) {
      var $a, $b, $c, $d, self = this;

      
      if ($truthy($$($nesting, 'MatchData')['$==='](other))) {
      } else {
        return false
      };
      return ($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = self.string == other.string) ? self.regexp.toString() == other.regexp.toString() : $d)) ? self.pre_match == other.pre_match : $c)) ? self.post_match == other.post_match : $b)) ? self.begin == other.begin : $a);
    }, $MatchData_$eq_eq$19.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$begin', $MatchData_begin$20 = function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, $MatchData_begin$20.$$arity = 1);
    
    Opal.def(self, '$end', $MatchData_end$21 = function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, $MatchData_end$21.$$arity = 1);
    
    Opal.def(self, '$captures', $MatchData_captures$22 = function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, $MatchData_captures$22.$$arity = 0);
    
    Opal.def(self, '$inspect', $MatchData_inspect$23 = function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      for (var i = 1, length = self.matches.length; i < length; i++) {
        str += " " + i + ":" + (self.matches[i]).$inspect();
      }

      return str + ">";
    
    }, $MatchData_inspect$23.$$arity = 0);
    
    Opal.def(self, '$length', $MatchData_length$24 = function $$length() {
      var self = this;

      return self.matches.length
    }, $MatchData_length$24.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $MatchData_to_a$25 = function $$to_a() {
      var self = this;

      return self.matches
    }, $MatchData_to_a$25.$$arity = 0);
    
    Opal.def(self, '$to_s', $MatchData_to_s$26 = function $$to_s() {
      var self = this;

      return self.matches[0]
    }, $MatchData_to_s$26.$$arity = 0);
    return (Opal.def(self, '$values_at', $MatchData_values_at$27 = function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $$($nesting, 'Opal')['$coerce_to!'](args[i], $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, $MatchData_values_at$27.$$arity = -1), nil) && 'values_at';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/string"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$coerce_to', '$raise', '$===', '$format', '$to_s', '$respond_to?', '$to_str', '$<=>', '$==', '$=~', '$new', '$force_encoding', '$casecmp', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$to_a', '$each_char', '$to_proc', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$size', '$chomp', '$[]', '$to_i', '$each_line', '$encoding', '$class', '$match', '$match?', '$captures', '$proc', '$succ', '$escape']);
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String___id__$1, $String_try_convert$2, $String_new$3, $String_initialize$4, $String_$percent$5, $String_$$6, $String_$plus$7, $String_$lt_eq_gt$8, $String_$eq_eq$9, $String_$eq_tilde$10, $String_$$$11, $String_b$12, $String_capitalize$13, $String_casecmp$14, $String_casecmp$ques$15, $String_center$16, $String_chars$17, $String_chomp$18, $String_chop$19, $String_chr$20, $String_clone$21, $String_dup$22, $String_count$23, $String_delete$24, $String_delete_prefix$25, $String_delete_suffix$26, $String_downcase$27, $String_each_char$28, $String_each_line$30, $String_empty$ques$31, $String_end_with$ques$32, $String_gsub$33, $String_hash$34, $String_hex$35, $String_include$ques$36, $String_index$37, $String_inspect$38, $String_intern$39, $String_lines$40, $String_length$41, $String_ljust$42, $String_lstrip$43, $String_ascii_only$ques$44, $String_match$45, $String_match$ques$46, $String_next$47, $String_oct$48, $String_ord$49, $String_partition$50, $String_reverse$51, $String_rindex$52, $String_rjust$53, $String_rpartition$54, $String_rstrip$55, $String_scan$56, $String_split$57, $String_squeeze$58, $String_start_with$ques$59, $String_strip$60, $String_sub$61, $String_sum$62, $String_swapcase$63, $String_to_f$64, $String_to_i$65, $String_to_proc$66, $String_to_s$68, $String_tr$69, $String_tr_s$70, $String_upcase$71, $String_upto$72, $String_instance_variables$73, $String__load$74, $String_unicode_normalize$75, $String_unicode_normalized$ques$76, $String_unpack$77, $String_unpack1$78;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.defineProperty(self.$$prototype, '$$is_string', true);

    Opal.defineProperty(self.$$prototype, '$$cast', function(string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
  ;
    
    Opal.def(self, '$__id__', $String___id__$1 = function $$__id__() {
      var self = this;

      return self.toString();
    }, $String___id__$1.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    Opal.defs(self, '$try_convert', $String_try_convert$2 = function $$try_convert(what) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), "to_str")
    }, $String_try_convert$2.$$arity = 1);
    Opal.defs(self, '$new', $String_new$3 = function(str) {
      var self = this;

      
      
      if (str == null) {
        str = "";
      };
      str = $$($nesting, 'Opal').$coerce_to(str, $$($nesting, 'String'), "to_str");
      return new self.$$constructor(str);;
    }, $String_new$3.$$arity = -1);
    
    Opal.def(self, '$initialize', $String_initialize$4 = function $$initialize(str) {
      var self = this;

      
      ;
      
      if (str === undefined) {
        return self;
      }
    ;
      return self.$raise($$($nesting, 'NotImplementedError'), "Mutable strings are not supported in Opal.");
    }, $String_initialize$4.$$arity = -1);
    
    Opal.def(self, '$%', $String_$percent$5 = function(data) {
      var self = this;

      if ($truthy($$($nesting, 'Array')['$==='](data))) {
        return $send(self, 'format', [self].concat(Opal.to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, $String_$percent$5.$$arity = 1);
    
    Opal.def(self, '$*', $String_$$6 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return self.$$cast('');
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        self.$raise($$($nesting, 'RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return self.$$cast(result);
    
    }, $String_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $String_$plus$7 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str");
      return self + other.$to_s();
    }, $String_$plus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $String_$lt_eq_gt$8 = function(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, $String_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $String_$eq_eq$9 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($$($nesting, 'Opal')['$respond_to?'](other, "to_str")) {
        return other['$=='](self);
      }
      return false;
    
    }, $String_$eq_eq$9.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    
    Opal.def(self, '$=~', $String_$eq_tilde$10 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        self.$raise($$($nesting, 'TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, $String_$eq_tilde$10.$$arity = 1);
    
    Opal.def(self, '$[]', $String_$$$11 = function(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude;

      if (index.$$is_range) {
        exclude = index.excl;
        length  = $$($nesting, 'Opal').$coerce_to(index.end, $$($nesting, 'Integer'), "to_int");
        index   = $$($nesting, 'Opal').$coerce_to(index.begin, $$($nesting, 'Integer'), "to_int");

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.$$cast(self.substr(index, length));
      }


      if (index.$$is_string) {
        if (length != null) {
          self.$raise($$($nesting, 'TypeError'))
        }
        return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$($nesting, 'MatchData').$new(index, match))

        if (length == null) {
          return self.$$cast(match[0]);
        }

        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

        if (length < 0 && -length < match.length) {
          return self.$$cast(match[length += match.length]);
        }

        if (length >= 0 && length < match.length) {
          return self.$$cast(match[length]);
        }

        return nil;
      }


      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.$$cast(self.substr(index, 1));
      }

      length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.$$cast(self.substr(index, length));
    ;
    }, $String_$$$11.$$arity = -2);
    Opal.alias(self, "byteslice", "[]");
    
    Opal.def(self, '$b', $String_b$12 = function $$b() {
      var self = this;

      return self.$force_encoding("binary")
    }, $String_b$12.$$arity = 0);
    
    Opal.def(self, '$capitalize', $String_capitalize$13 = function $$capitalize() {
      var self = this;

      return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
    }, $String_capitalize$13.$$arity = 0);
    
    Opal.def(self, '$casecmp', $String_casecmp$14 = function $$casecmp(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
      } else {
        return nil
      };
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str").$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, $String_casecmp$14.$$arity = 1);
    
    Opal.def(self, '$casecmp?', $String_casecmp$ques$15 = function(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, $String_casecmp$ques$15.$$arity = 1);
    
    Opal.def(self, '$center', $String_center$16 = function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return self.$$cast(rjustified + ljustified.slice(self.length));
    ;
    }, $String_center$16.$$arity = -2);
    
    Opal.def(self, '$chars', $String_chars$17 = function $$chars() {
      var $iter = $String_chars$17.$$p, block = $iter || nil, self = this;

      if ($iter) $String_chars$17.$$p = null;
      
      
      if ($iter) $String_chars$17.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, $String_chars$17.$$arity = 0);
    
    Opal.def(self, '$chomp', $String_chomp$18 = function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(separator === nil || self.length === 0)) {
        return self};
      separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return self.$$cast(result);
      }
    ;
      return self;
    }, $String_chomp$18.$$arity = -1);
    
    Opal.def(self, '$chop', $String_chop$19 = function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return self.$$cast(result);
    
    }, $String_chop$19.$$arity = 0);
    
    Opal.def(self, '$chr', $String_chr$20 = function $$chr() {
      var self = this;

      return self.charAt(0);
    }, $String_chr$20.$$arity = 0);
    
    Opal.def(self, '$clone', $String_clone$21 = function $$clone() {
      var self = this, copy = nil;

      
      copy = self.slice();
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $String_clone$21.$$arity = 0);
    
    Opal.def(self, '$dup', $String_dup$22 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.slice();
      copy.$initialize_dup(self);
      return copy;
    }, $String_dup$22.$$arity = 0);
    
    Opal.def(self, '$count', $String_count$23 = function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, $String_count$23.$$arity = -1);
    
    Opal.def(self, '$delete', $String_delete$24 = function($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
    ;
    }, $String_delete$24.$$arity = -1);
    
    Opal.def(self, '$delete_prefix', $String_delete_prefix$25 = function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        (prefix = $$($nesting, 'Opal').$coerce_to(prefix, $$($nesting, 'String'), "to_str"))
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.$$cast(self.slice(prefix.length));
      } else {
        return self;
      }
    
    }, $String_delete_prefix$25.$$arity = 1);
    
    Opal.def(self, '$delete_suffix', $String_delete_suffix$26 = function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        (suffix = $$($nesting, 'Opal').$coerce_to(suffix, $$($nesting, 'String'), "to_str"))
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.$$cast(self.slice(0, self.length - suffix.length));
      } else {
        return self;
      }
    
    }, $String_delete_suffix$26.$$arity = 1);
    
    Opal.def(self, '$downcase', $String_downcase$27 = function $$downcase() {
      var self = this;

      return self.$$cast(self.toLowerCase());
    }, $String_downcase$27.$$arity = 0);
    
    Opal.def(self, '$each_char', $String_each_char$28 = function $$each_char() {
      var $iter = $String_each_char$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $String_each_char$28.$$p = null;
      
      
      if ($iter) $String_each_char$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_char"], ($$29 = function(){var self = $$29.$$s || this;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.charAt(i));
      }
    ;
      return self;
    }, $String_each_char$28.$$arity = 0);
    
    Opal.def(self, '$each_line', $String_each_line$30 = function $$each_line(separator) {
      var $iter = $String_each_line$30.$$p, block = $iter || nil, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_each_line$30.$$p = null;
      
      
      if ($iter) $String_each_line$30.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_line", separator)
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $$($nesting, 'Opal').$coerce_to(separator, $$($nesting, 'String'), "to_str")

      var a, i, n, length, chomped, trailing, splitted;

      if (separator.length === 0) {
        for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            var value = (a[i] || "") + (a[i + 1] || "");
            Opal.yield1(block, self.$$cast(value));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        if (i < length - 1 || trailing) {
          Opal.yield1(block, self.$$cast(splitted[i] + separator));
        }
        else {
          Opal.yield1(block, self.$$cast(splitted[i]));
        }
      }
    ;
      return self;
    }, $String_each_line$30.$$arity = -1);
    
    Opal.def(self, '$empty?', $String_empty$ques$31 = function() {
      var self = this;

      return self.length === 0;
    }, $String_empty$ques$31.$$arity = 0);
    
    Opal.def(self, '$end_with?', $String_end_with$ques$32 = function($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $$($nesting, 'Opal').$coerce_to(suffixes[i], $$($nesting, 'String'), "to_str").$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, $String_end_with$ques$32.$$arity = -1);
    Opal.alias(self, "equal?", "===");
    
    Opal.def(self, '$gsub', $String_gsub$33 = function $$gsub(pattern, replacement) {
      var $iter = $String_gsub$33.$$p, block = $iter || nil, self = this;

      if ($iter) $String_gsub$33.$$p = null;
      
      
      if ($iter) $String_gsub$33.$$p = null;;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$($nesting, 'MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $$($nesting, 'Opal').$coerce_to(replacement, $$($nesting, 'String'), "to_str");
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (_replacement + self.slice(index, match.index + 1))
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return self.$$cast(result);
    ;
    }, $String_gsub$33.$$arity = -2);
    
    Opal.def(self, '$hash', $String_hash$34 = function $$hash() {
      var self = this;

      return self.toString();
    }, $String_hash$34.$$arity = 0);
    
    Opal.def(self, '$hex', $String_hex$35 = function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, $String_hex$35.$$arity = 0);
    
    Opal.def(self, '$include?', $String_include$ques$36 = function(other) {
      var self = this;

      
      if (!other.$$is_string) {
        (other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str"))
      }
      return self.indexOf(other) !== -1;
    
    }, $String_include$ques$36.$$arity = 1);
    
    Opal.def(self, '$index', $String_index$37 = function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int");
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = Opal.global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $$($nesting, 'Opal').$coerce_to(search, $$($nesting, 'String'), "to_str");
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, $String_index$37.$$arity = -2);
    
    Opal.def(self, '$inspect', $String_inspect$38 = function $$inspect() {
      var self = this;

      
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            return meta[chr] || '\\u' + ('0000' + chr.charCodeAt(0).toString(16).toUpperCase()).slice(-4);
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
    
    }, $String_inspect$38.$$arity = 0);
    
    Opal.def(self, '$intern', $String_intern$39 = function $$intern() {
      var self = this;

      return self.toString();
    }, $String_intern$39.$$arity = 0);
    
    Opal.def(self, '$lines', $String_lines$40 = function $$lines(separator) {
      var $iter = $String_lines$40.$$p, block = $iter || nil, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_lines$40.$$p = null;
      
      
      if ($iter) $String_lines$40.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, $String_lines$40.$$arity = -1);
    
    Opal.def(self, '$length', $String_length$41 = function $$length() {
      var self = this;

      return self.length;
    }, $String_length$41.$$arity = 0);
    
    Opal.def(self, '$ljust', $String_ljust$42 = function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self.$$cast(self + result.slice(0, width));
    ;
    }, $String_ljust$42.$$arity = -2);
    
    Opal.def(self, '$lstrip', $String_lstrip$43 = function $$lstrip() {
      var self = this;

      return self.replace(/^\s*/, '');
    }, $String_lstrip$43.$$arity = 0);
    
    Opal.def(self, '$ascii_only?', $String_ascii_only$ques$44 = function() {
      var self = this;

      
      if (self.$encoding()['$==']($$$($$($nesting, 'Encoding'), 'UTF_16BE'))) {
        return false};
      return /^[\x00-\x7F]*$/.test(self);;
    }, $String_ascii_only$ques$44.$$arity = 0);
    
    Opal.def(self, '$match', $String_match$45 = function $$match(pattern, pos) {
      var $iter = $String_match$45.$$p, block = $iter || nil, $a, self = this;

      if ($iter) $String_match$45.$$p = null;
      
      
      if ($iter) $String_match$45.$$p = null;;
      ;
      if ($truthy(($truthy($a = $$($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?']("to_str")))) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, $String_match$45.$$arity = -2);
    
    Opal.def(self, '$match?', $String_match$ques$46 = function(pattern, pos) {
      var $a, self = this;

      
      ;
      if ($truthy(($truthy($a = $$($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?']("to_str")))) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, $String_match$ques$46.$$arity = -2);
    
    Opal.def(self, '$next', $String_next$47 = function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return self.$$cast('');
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return self.$$cast(result);
    
    }, $String_next$47.$$arity = 0);
    
    Opal.def(self, '$oct', $String_oct$48 = function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, $String_oct$48.$$arity = 0);
    
    Opal.def(self, '$ord', $String_ord$49 = function $$ord() {
      var self = this;

      return self.charCodeAt(0);
    }, $String_ord$49.$$arity = 0);
    
    Opal.def(self, '$partition', $String_partition$50 = function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $$($nesting, 'Opal').$coerce_to(sep, $$($nesting, 'String'), "to_str");
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_partition$50.$$arity = 1);
    
    Opal.def(self, '$reverse', $String_reverse$51 = function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, $String_reverse$51.$$arity = 0);
    
    Opal.def(self, '$rindex', $String_rindex$52 = function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int");
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $$($nesting, 'Opal').$coerce_to(search, $$($nesting, 'String'), "to_str");
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, $String_rindex$52.$$arity = -2);
    
    Opal.def(self, '$rjust', $String_rjust$53 = function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return self.$$cast(result + padstr.slice(0, remaining) + self);
    ;
    }, $String_rjust$53.$$arity = -2);
    
    Opal.def(self, '$rpartition', $String_rpartition$54 = function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $$($nesting, 'Opal').$coerce_to(sep, $$($nesting, 'String'), "to_str");
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_rpartition$54.$$arity = 1);
    
    Opal.def(self, '$rstrip', $String_rstrip$55 = function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, $String_rstrip$55.$$arity = 0);
    
    Opal.def(self, '$scan', $String_scan$56 = function $$scan(pattern) {
      var $iter = $String_scan$56.$$p, block = $iter || nil, self = this;

      if ($iter) $String_scan$56.$$p = null;
      
      
      if ($iter) $String_scan$56.$$p = null;;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$($nesting, 'MatchData').$new(pattern, match);
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      ($gvars["~"] = match_data)

      return (block !== nil ? self : result);
    ;
    }, $String_scan$56.$$arity = 1);
    Opal.alias(self, "size", "length");
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$split', $String_split$57 = function $$split(pattern, limit) {
      var $a, self = this;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy($a = $gvars[";"]) ? $a : " ");
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str").$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [self.$$cast(result[0])];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      function castResult() {
        for (i = 0; i < result.length; i++) {
          result[i] = self.$$cast(result[i]);
        }
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        castResult();
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        castResult();
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        castResult();
        return result;
      }

      if (limit >= result.length) {
        castResult();
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      castResult();
      return result;
    ;
    }, $String_split$57.$$arity = -1);
    
    Opal.def(self, '$squeeze', $String_squeeze$58 = function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.$$cast(self.replace(/(.)\1+/g, '$1'));
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
    ;
    }, $String_squeeze$58.$$arity = -1);
    
    Opal.def(self, '$start_with?', $String_start_with$ques$59 = function($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        var prefix = $$($nesting, 'Opal').$coerce_to(prefixes[i], $$($nesting, 'String'), "to_str").$to_s();

        if (self.indexOf(prefix) === 0) {
          return true;
        }
      }

      return false;
    ;
    }, $String_start_with$ques$59.$$arity = -1);
    
    Opal.def(self, '$strip', $String_strip$60 = function $$strip() {
      var self = this;

      return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '');
    }, $String_strip$60.$$arity = 0);
    
    Opal.def(self, '$sub', $String_sub$61 = function $$sub(pattern, replacement) {
      var $iter = $String_sub$61.$$p, block = $iter || nil, self = this;

      if ($iter) $String_sub$61.$$p = null;
      
      
      if ($iter) $String_sub$61.$$p = null;;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$($nesting, 'MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $$($nesting, 'Opal').$coerce_to(replacement, $$($nesting, 'String'), "to_str");

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return self.$$cast(result);
    ;
    }, $String_sub$61.$$arity = -2);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$sum', $String_sum$62 = function $$sum(n) {
      var self = this;

      
      
      if (n == null) {
        n = 16;
      };
      
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, $String_sum$62.$$arity = -1);
    
    Opal.def(self, '$swapcase', $String_swapcase$63 = function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, $String_swapcase$63.$$arity = 0);
    
    Opal.def(self, '$to_f', $String_to_f$64 = function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, $String_to_f$64.$$arity = 0);
    
    Opal.def(self, '$to_i', $String_to_i$65 = function $$to_i(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      
      var result,
          string = self.toLowerCase(),
          radix = $$($nesting, 'Opal').$coerce_to(base, $$($nesting, 'Integer'), "to_int");

      if (radix === 1 || radix < 0 || radix > 36) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, $String_to_i$65.$$arity = -1);
    
    Opal.def(self, '$to_proc', $String_to_proc$66 = function $$to_proc() {
      var $$67, $iter = $String_to_proc$66.$$p, $yield = $iter || nil, self = this, method_name = nil;

      if ($iter) $String_to_proc$66.$$p = null;
      
      method_name = $rb_plus("$", self.valueOf());
      return $send(self, 'proc', [], ($$67 = function($a){var self = $$67.$$s || this, $iter = $$67.$$p, block = $iter || nil, $post_args, args;

      
        
        if ($iter) $$67.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        if (args.length === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[method_name];

        if (!body) {
          return recv.$method_missing.apply(recv, args);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 1) {
          return body.call(recv);
        } else {
          return body.apply(recv, args.slice(1));
        }
      ;}, $$67.$$s = self, $$67.$$arity = -1, $$67));
    }, $String_to_proc$66.$$arity = 0);
    
    Opal.def(self, '$to_s', $String_to_s$68 = function $$to_s() {
      var self = this;

      return self.toString();
    }, $String_to_s$68.$$arity = 0);
    Opal.alias(self, "to_str", "to_s");
    Opal.alias(self, "to_sym", "intern");
    
    Opal.def(self, '$tr', $String_tr$69 = function $$tr(from, to) {
      var self = this;

      
      from = $$($nesting, 'Opal').$coerce_to(from, $$($nesting, 'String'), "to_str").$to_s();
      to = $$($nesting, 'Opal').$coerce_to(to, $$($nesting, 'String'), "to_str").$to_s();
      
      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return self.$$cast(new_str);
    ;
    }, $String_tr$69.$$arity = 2);
    
    Opal.def(self, '$tr_s', $String_tr_s$70 = function $$tr_s(from, to) {
      var self = this;

      
      from = $$($nesting, 'Opal').$coerce_to(from, $$($nesting, 'String'), "to_str").$to_s();
      to = $$($nesting, 'Opal').$coerce_to(to, $$($nesting, 'String'), "to_str").$to_s();
      
      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return self.$$cast(new_str);
    ;
    }, $String_tr_s$70.$$arity = 2);
    
    Opal.def(self, '$upcase', $String_upcase$71 = function $$upcase() {
      var self = this;

      return self.$$cast(self.toUpperCase());
    }, $String_upcase$71.$$arity = 0);
    
    Opal.def(self, '$upto', $String_upto$72 = function $$upto(stop, excl) {
      var $iter = $String_upto$72.$$p, block = $iter || nil, self = this;

      if ($iter) $String_upto$72.$$p = null;
      
      
      if ($iter) $String_upto$72.$$p = null;;
      
      if (excl == null) {
        excl = false;
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("upto", stop, excl)
      };
      stop = $$($nesting, 'Opal').$coerce_to(stop, $$($nesting, 'String'), "to_str");
      
      var a, b, s = self.toString();

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, $String_upto$72.$$arity = -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $$($nesting, 'Opal').$coerce_to(sets[i], $$($nesting, 'String'), "to_str");
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    Opal.def(self, '$instance_variables', $String_instance_variables$73 = function $$instance_variables() {
      var self = this;

      return []
    }, $String_instance_variables$73.$$arity = 0);
    Opal.defs(self, '$_load', $String__load$74 = function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $String__load$74.$$arity = -1);
    
    Opal.def(self, '$unicode_normalize', $String_unicode_normalize$75 = function $$unicode_normalize(form) {
      var self = this;

      
      ;
      return self.toString();;
    }, $String_unicode_normalize$75.$$arity = -1);
    
    Opal.def(self, '$unicode_normalized?', $String_unicode_normalized$ques$76 = function(form) {
      var self = this;

      
      ;
      return true;
    }, $String_unicode_normalized$ques$76.$$arity = -1);
    
    Opal.def(self, '$unpack', $String_unpack$77 = function $$unpack(format) {
      var self = this;

      return self.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, $String_unpack$77.$$arity = 1);
    return (Opal.def(self, '$unpack1', $String_unpack1$78 = function $$unpack1(format) {
      var self = this;

      return self.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, $String_unpack1$78.$$arity = 1), nil) && 'unpack1';
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], 'Symbol', $$($nesting, 'String'));
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/enumerable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy, $hash2 = Opal.hash2, $lambda = Opal.lambda;

  Opal.add_stubs(['$each', '$public_send', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$coerce_to', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$__send__', '$length', '$<=', '$[]', '$push', '$<<', '$[]=', '$===', '$inspect', '$<=>', '$first', '$reverse', '$sort', '$to_proc', '$compare', '$call', '$dup', '$to_a', '$sort!', '$map!', '$key?', '$values', '$zip']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_all$ques$1, $Enumerable_any$ques$5, $Enumerable_chunk$9, $Enumerable_chunk_while$12, $Enumerable_collect$14, $Enumerable_collect_concat$16, $Enumerable_count$19, $Enumerable_cycle$23, $Enumerable_detect$25, $Enumerable_drop$27, $Enumerable_drop_while$28, $Enumerable_each_cons$29, $Enumerable_each_entry$31, $Enumerable_each_slice$33, $Enumerable_each_with_index$35, $Enumerable_each_with_object$37, $Enumerable_entries$39, $Enumerable_find_all$40, $Enumerable_find_index$42, $Enumerable_first$45, $Enumerable_grep$48, $Enumerable_grep_v$50, $Enumerable_group_by$52, $Enumerable_include$ques$54, $Enumerable_inject$56, $Enumerable_lazy$57, $Enumerable_enumerator_size$59, $Enumerable_max$60, $Enumerable_max_by$61, $Enumerable_min$63, $Enumerable_min_by$64, $Enumerable_minmax$66, $Enumerable_minmax_by$68, $Enumerable_none$ques$69, $Enumerable_one$ques$73, $Enumerable_partition$77, $Enumerable_reject$79, $Enumerable_reverse_each$81, $Enumerable_slice_before$83, $Enumerable_slice_after$85, $Enumerable_slice_when$88, $Enumerable_sort$90, $Enumerable_sort_by$92, $Enumerable_sum$97, $Enumerable_take$99, $Enumerable_take_while$100, $Enumerable_uniq$102, $Enumerable_zip$104;

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    Opal.def(self, '$all?', $Enumerable_all$ques$1 = function(pattern) {try {

      var $iter = $Enumerable_all$ques$1.$$p, block = $iter || nil, $$2, $$3, $$4, self = this;

      if ($iter) $Enumerable_all$ques$1.$$p = null;
      
      
      if ($iter) $Enumerable_all$ques$1.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$2 = function($a){var self = $$2.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$2.$$s = self, $$2.$$arity = -1, $$2))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$3 = function($a){var self = $$3.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$3.$$s = self, $$3.$$arity = -1, $$3))
      } else {
        $send(self, 'each', [], ($$4 = function($a){var self = $$4.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$4.$$s = self, $$4.$$arity = -1, $$4))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_all$ques$1.$$arity = -1);
    
    Opal.def(self, '$any?', $Enumerable_any$ques$5 = function(pattern) {try {

      var $iter = $Enumerable_any$ques$5.$$p, block = $iter || nil, $$6, $$7, $$8, self = this;

      if ($iter) $Enumerable_any$ques$5.$$p = null;
      
      
      if ($iter) $Enumerable_any$ques$5.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$6 = function($a){var self = $$6.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$arity = -1, $$6))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$7 = function($a){var self = $$7.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = -1, $$7))
      } else {
        $send(self, 'each', [], ($$8 = function($a){var self = $$8.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$8.$$s = self, $$8.$$arity = -1, $$8))
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_any$ques$5.$$arity = -1);
    
    Opal.def(self, '$chunk', $Enumerable_chunk$9 = function $$chunk() {
      var $iter = $Enumerable_chunk$9.$$p, block = $iter || nil, $$10, $$11, self = this;

      if ($iter) $Enumerable_chunk$9.$$p = null;
      
      
      if ($iter) $Enumerable_chunk$9.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["chunk"], ($$10 = function(){var self = $$10.$$s || this;

        return self.$enumerator_size()}, $$10.$$s = self, $$10.$$arity = 0, $$10))
      };
      return $send($$$('::', 'Enumerator'), 'new', [], ($$11 = function(yielder){var self = $$11.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = Opal.yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, $$11.$$s = self, $$11.$$arity = 1, $$11));
    }, $Enumerable_chunk$9.$$arity = 0);
    
    Opal.def(self, '$chunk_while', $Enumerable_chunk_while$12 = function $$chunk_while() {
      var $iter = $Enumerable_chunk_while$12.$$p, block = $iter || nil, $$13, self = this;

      if ($iter) $Enumerable_chunk_while$12.$$p = null;
      
      
      if ($iter) $Enumerable_chunk_while$12.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], ($$13 = function(before, after){var self = $$13.$$s || this;

      
        
        if (before == null) {
          before = nil;
        };
        
        if (after == null) {
          after = nil;
        };
        return Opal.yieldX(block, [before, after])['$!']();}, $$13.$$s = self, $$13.$$arity = 2, $$13));
    }, $Enumerable_chunk_while$12.$$arity = 0);
    
    Opal.def(self, '$collect', $Enumerable_collect$14 = function $$collect() {
      var $iter = $Enumerable_collect$14.$$p, block = $iter || nil, $$15, self = this;

      if ($iter) $Enumerable_collect$14.$$p = null;
      
      
      if ($iter) $Enumerable_collect$14.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$15 = function(){var self = $$15.$$s || this;

        return self.$enumerator_size()}, $$15.$$s = self, $$15.$$arity = 0, $$15))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = Opal.yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_collect$14.$$arity = 0);
    
    Opal.def(self, '$collect_concat', $Enumerable_collect_concat$16 = function $$collect_concat() {
      var $iter = $Enumerable_collect_concat$16.$$p, block = $iter || nil, $$17, $$18, self = this;

      if ($iter) $Enumerable_collect_concat$16.$$p = null;
      
      
      if ($iter) $Enumerable_collect_concat$16.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect_concat"], ($$17 = function(){var self = $$17.$$s || this;

        return self.$enumerator_size()}, $$17.$$s = self, $$17.$$arity = 0, $$17))
      };
      return $send(self, 'map', [], ($$18 = function(item){var self = $$18.$$s || this;

      
        
        if (item == null) {
          item = nil;
        };
        return Opal.yield1(block, item);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)).$flatten(1);
    }, $Enumerable_collect_concat$16.$$arity = 0);
    
    Opal.def(self, '$count', $Enumerable_count$19 = function $$count(object) {
      var $iter = $Enumerable_count$19.$$p, block = $iter || nil, $$20, $$21, $$22, self = this, result = nil;

      if ($iter) $Enumerable_count$19.$$p = null;
      
      
      if ($iter) $Enumerable_count$19.$$p = null;;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send(self, 'proc', [], ($$20 = function($a){var self = $$20.$$s || this, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $$($nesting, 'Opal').$destructure(args)['$=='](object);}, $$20.$$s = self, $$20.$$arity = -1, $$20))
      } else if ($truthy(block['$nil?']())) {
        block = $send(self, 'proc', [], ($$21 = function(){var self = $$21.$$s || this;

        return true}, $$21.$$s = self, $$21.$$arity = 0, $$21))};
      $send(self, 'each', [], ($$22 = function($a){var self = $$22.$$s || this, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($truthy(Opal.yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, $$22.$$s = self, $$22.$$arity = -1, $$22));
      return result;
    }, $Enumerable_count$19.$$arity = -1);
    
    Opal.def(self, '$cycle', $Enumerable_cycle$23 = function $$cycle(n) {
      var $iter = $Enumerable_cycle$23.$$p, block = $iter || nil, $$24, self = this;

      if ($iter) $Enumerable_cycle$23.$$p = null;
      
      
      if ($iter) $Enumerable_cycle$23.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$24 = function(){var self = $$24.$$s || this;

        if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$($nesting, 'Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$24.$$s = self, $$24.$$arity = 0, $$24))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil};
      };
      
      var result,
          all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, $Enumerable_cycle$23.$$arity = -1);
    
    Opal.def(self, '$detect', $Enumerable_detect$25 = function $$detect(ifnone) {try {

      var $iter = $Enumerable_detect$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Enumerable_detect$25.$$p = null;
      
      
      if ($iter) $Enumerable_detect$25.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], ($$26 = function($a){var self = $$26.$$s || this, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, $$26.$$s = self, $$26.$$arity = -1, $$26));
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_detect$25.$$arity = -1);
    
    Opal.def(self, '$drop', $Enumerable_drop$27 = function $$drop(number) {
      var self = this;

      
      number = $$($nesting, 'Opal').$coerce_to(number, $$($nesting, 'Integer'), "to_int");
      if ($truthy(number < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($$($nesting, 'Opal').$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, $Enumerable_drop$27.$$arity = 1);
    
    Opal.def(self, '$drop_while', $Enumerable_drop_while$28 = function $$drop_while() {
      var $iter = $Enumerable_drop_while$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_drop_while$28.$$p = null;
      
      
      if ($iter) $Enumerable_drop_while$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        if (dropping) {
          var value = Opal.yield1(block, param);

          if ($falsy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_drop_while$28.$$arity = 0);
    
    Opal.def(self, '$each_cons', $Enumerable_each_cons$29 = function $$each_cons(n) {
      var $iter = $Enumerable_each_cons$29.$$p, block = $iter || nil, $$30, self = this;

      if ($iter) $Enumerable_each_cons$29.$$p = null;
      
      
      if ($iter) $Enumerable_each_cons$29.$$p = null;;
      if ($truthy(arguments.length != 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 1)")};
      n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_cons", n], ($$30 = function(){var self = $$30.$$s || this, $a, enum_size = nil;

        
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if ($truthy(($truthy($a = enum_size['$=='](0)) ? $a : $rb_lt(enum_size, n)))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, $$30.$$s = self, $$30.$$arity = 0, $$30))
      };
      
      var buffer = [], result = nil;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          Opal.yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return result;
    ;
    }, $Enumerable_each_cons$29.$$arity = 1);
    
    Opal.def(self, '$each_entry', $Enumerable_each_entry$31 = function $$each_entry($a) {
      var $iter = $Enumerable_each_entry$31.$$p, block = $iter || nil, $post_args, data, $$32, self = this;

      if ($iter) $Enumerable_each_entry$31.$$p = null;
      
      
      if ($iter) $Enumerable_each_entry$31.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      data = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["each_entry"].concat(Opal.to_a(data)), ($$32 = function(){var self = $$32.$$s || this;

        return self.$enumerator_size()}, $$32.$$s = self, $$32.$$arity = 0, $$32))
      };
      
      self.$each.$$p = function() {
        var item = $$($nesting, 'Opal').$destructure(arguments);

        Opal.yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, $Enumerable_each_entry$31.$$arity = -1);
    
    Opal.def(self, '$each_slice', $Enumerable_each_slice$33 = function $$each_slice(n) {
      var $iter = $Enumerable_each_slice$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Enumerable_each_slice$33.$$p = null;
      
      
      if ($iter) $Enumerable_each_slice$33.$$p = null;;
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid slice size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_slice", n], ($$34 = function(){var self = $$34.$$s || this;

        if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, $$34.$$s = self, $$34.$$arity = 0, $$34))
      };
      
      var result,
          slice = []

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          Opal.yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      if (result !== undefined) {
        return result;
      }

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        Opal.yield1(block, slice);
      }
    ;
      return nil;
    }, $Enumerable_each_slice$33.$$arity = 1);
    
    Opal.def(self, '$each_with_index', $Enumerable_each_with_index$35 = function $$each_with_index($a) {
      var $iter = $Enumerable_each_with_index$35.$$p, block = $iter || nil, $post_args, args, $$36, self = this;

      if ($iter) $Enumerable_each_with_index$35.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_index$35.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"].concat(Opal.to_a(args)), ($$36 = function(){var self = $$36.$$s || this;

        return self.$enumerator_size()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      var result,
          index = 0;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);

      if (result !== undefined) {
        return result;
      }
    ;
      return self;
    }, $Enumerable_each_with_index$35.$$arity = -1);
    
    Opal.def(self, '$each_with_object', $Enumerable_each_with_object$37 = function $$each_with_object(object) {
      var $iter = $Enumerable_each_with_object$37.$$p, block = $iter || nil, $$38, self = this;

      if ($iter) $Enumerable_each_with_object$37.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_object$37.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_object", object], ($$38 = function(){var self = $$38.$$s || this;

        return self.$enumerator_size()}, $$38.$$s = self, $$38.$$arity = 0, $$38))
      };
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, object);
      };

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return object;
    }, $Enumerable_each_with_object$37.$$arity = 1);
    
    Opal.def(self, '$entries', $Enumerable_entries$39 = function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($$($nesting, 'Opal').$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, $Enumerable_entries$39.$$arity = -1);
    Opal.alias(self, "find", "detect");
    
    Opal.def(self, '$find_all', $Enumerable_find_all$40 = function $$find_all() {
      var $iter = $Enumerable_find_all$40.$$p, block = $iter || nil, $$41, self = this;

      if ($iter) $Enumerable_find_all$40.$$p = null;
      
      
      if ($iter) $Enumerable_find_all$40.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["find_all"], ($$41 = function(){var self = $$41.$$s || this;

        return self.$enumerator_size()}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_find_all$40.$$arity = 0);
    
    Opal.def(self, '$find_index', $Enumerable_find_index$42 = function $$find_index(object) {try {

      var $iter = $Enumerable_find_index$42.$$p, block = $iter || nil, $$43, $$44, self = this, index = nil;

      if ($iter) $Enumerable_find_index$42.$$p = null;
      
      
      if ($iter) $Enumerable_find_index$42.$$p = null;;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")};
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], ($$43 = function($a){var self = $$43.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {
            Opal.ret(index)};
          return index += 1;;}, $$43.$$s = self, $$43.$$arity = -1, $$43))
      } else {
        $send(self, 'each', [], ($$44 = function($a){var self = $$44.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(index)};
          return index += 1;;}, $$44.$$s = self, $$44.$$arity = -1, $$44))
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_find_index$42.$$arity = -1);
    
    Opal.def(self, '$first', $Enumerable_first$45 = function $$first(number) {try {

      var $$46, $$47, self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], ($$46 = function(value){var self = $$46.$$s || this;

        
          
          if (value == null) {
            value = nil;
          };
          Opal.ret(value);}, $$46.$$s = self, $$46.$$arity = 1, $$46))
      } else {
        
        result = [];
        number = $$($nesting, 'Opal').$coerce_to(number, $$($nesting, 'Integer'), "to_int");
        if ($truthy(number < 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        if ($truthy(number == 0)) {
          return []};
        current = 0;
        $send(self, 'each', [], ($$47 = function($a){var self = $$47.$$s || this, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          result.push($$($nesting, 'Opal').$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, $$47.$$s = self, $$47.$$arity = -1, $$47));
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_first$45.$$arity = -1);
    Opal.alias(self, "flat_map", "collect_concat");
    
    Opal.def(self, '$grep', $Enumerable_grep$48 = function $$grep(pattern) {
      var $iter = $Enumerable_grep$48.$$p, block = $iter || nil, $$49, self = this, result = nil;

      if ($iter) $Enumerable_grep$48.$$p = null;
      
      
      if ($iter) $Enumerable_grep$48.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$49 = function($a){var self = $$49.$$s || this, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
        } else {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$49.$$s = self, $$49.$$arity = -1, $$49));
      return result;
    }, $Enumerable_grep$48.$$arity = 1);
    
    Opal.def(self, '$grep_v', $Enumerable_grep_v$50 = function $$grep_v(pattern) {
      var $iter = $Enumerable_grep_v$50.$$p, block = $iter || nil, $$51, self = this, result = nil;

      if ($iter) $Enumerable_grep_v$50.$$p = null;
      
      
      if ($iter) $Enumerable_grep_v$50.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$51 = function($a){var self = $$51.$$s || this, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
          return nil;};
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$51.$$s = self, $$51.$$arity = -1, $$51));
      return result;
    }, $Enumerable_grep_v$50.$$arity = 1);
    
    Opal.def(self, '$group_by', $Enumerable_group_by$52 = function $$group_by() {
      var $iter = $Enumerable_group_by$52.$$p, block = $iter || nil, $$53, $a, self = this, hash = nil, $writer = nil;

      if ($iter) $Enumerable_group_by$52.$$p = null;
      
      
      if ($iter) $Enumerable_group_by$52.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["group_by"], ($$53 = function(){var self = $$53.$$s || this;

        return self.$enumerator_size()}, $$53.$$s = self, $$53.$$arity = 0, $$53))
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        ($truthy($a = hash['$[]'](value)) ? $a : (($writer = [value, []]), $send(hash, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, $Enumerable_group_by$52.$$arity = 0);
    
    Opal.def(self, '$include?', $Enumerable_include$ques$54 = function(obj) {try {

      var $$55, self = this;

      
      $send(self, 'each', [], ($$55 = function($a){var self = $$55.$$s || this, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($$($nesting, 'Opal').$destructure(args)['$=='](obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, $$55.$$s = self, $$55.$$arity = -1, $$55));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_include$ques$54.$$arity = 1);
    
    Opal.def(self, '$inject', $Enumerable_inject$56 = function $$inject(object, sym) {
      var $iter = $Enumerable_inject$56.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_inject$56.$$p = null;
      
      
      if ($iter) $Enumerable_inject$56.$$p = null;;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = Opal.yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$($nesting, 'Symbol')['$==='](object)) {
            self.$raise($$($nesting, 'TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, $Enumerable_inject$56.$$arity = -1);
    
    Opal.def(self, '$lazy', $Enumerable_lazy$57 = function $$lazy() {
      var $$58, self = this;

      return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], ($$58 = function(enum$, $a){var self = $$58.$$s || this, $post_args, args;

      
        
        if (enum$ == null) {
          enum$ = nil;
        };
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $send(enum$, 'yield', Opal.to_a(args));}, $$58.$$s = self, $$58.$$arity = -2, $$58))
    }, $Enumerable_lazy$57.$$arity = 0);
    
    Opal.def(self, '$enumerator_size', $Enumerable_enumerator_size$59 = function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, $Enumerable_enumerator_size$59.$$arity = 0);
    Opal.alias(self, "map", "collect");
    
    Opal.def(self, '$max', $Enumerable_max$60 = function $$max(n) {
      var $iter = $Enumerable_max$60.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_max$60.$$p = null;
      
      
      if ($iter) $Enumerable_max$60.$$p = null;;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = Opal.yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }
    ;
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, $Enumerable_max$60.$$arity = -1);
    
    Opal.def(self, '$max_by', $Enumerable_max_by$61 = function $$max_by() {
      var $iter = $Enumerable_max_by$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Enumerable_max_by$61.$$p = null;
      
      
      if ($iter) $Enumerable_max_by$61.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["max_by"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$enumerator_size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_max_by$61.$$arity = 0);
    Opal.alias(self, "member?", "include?");
    
    Opal.def(self, '$min', $Enumerable_min$63 = function $$min() {
      var $iter = $Enumerable_min$63.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_min$63.$$p = null;
      
      
      if ($iter) $Enumerable_min$63.$$p = null;;
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($$($nesting, 'Opal').$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min$63.$$arity = 0);
    
    Opal.def(self, '$min_by', $Enumerable_min_by$64 = function $$min_by() {
      var $iter = $Enumerable_min_by$64.$$p, block = $iter || nil, $$65, self = this;

      if ($iter) $Enumerable_min_by$64.$$p = null;
      
      
      if ($iter) $Enumerable_min_by$64.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["min_by"], ($$65 = function(){var self = $$65.$$s || this;

        return self.$enumerator_size()}, $$65.$$s = self, $$65.$$arity = 0, $$65))
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min_by$64.$$arity = 0);
    
    Opal.def(self, '$minmax', $Enumerable_minmax$66 = function $$minmax() {
      var $iter = $Enumerable_minmax$66.$$p, block = $iter || nil, $a, $$67, self = this;

      if ($iter) $Enumerable_minmax$66.$$p = null;
      
      
      if ($iter) $Enumerable_minmax$66.$$p = null;;
      block = ($truthy($a = block) ? $a : $send(self, 'proc', [], ($$67 = function(a, b){var self = $$67.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$<=>'](b);}, $$67.$$s = self, $$67.$$arity = 2, $$67)));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, $Enumerable_minmax$66.$$arity = 0);
    
    Opal.def(self, '$minmax_by', $Enumerable_minmax_by$68 = function $$minmax_by() {
      var $iter = $Enumerable_minmax_by$68.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_minmax_by$68.$$p = null;
      
      
      if ($iter) $Enumerable_minmax_by$68.$$p = null;;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Enumerable_minmax_by$68.$$arity = 0);
    
    Opal.def(self, '$none?', $Enumerable_none$ques$69 = function(pattern) {try {

      var $iter = $Enumerable_none$ques$69.$$p, block = $iter || nil, $$70, $$71, $$72, self = this;

      if ($iter) $Enumerable_none$ques$69.$$p = null;
      
      
      if ($iter) $Enumerable_none$ques$69.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$70 = function($a){var self = $$70.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$70.$$s = self, $$70.$$arity = -1, $$70))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$71 = function($a){var self = $$71.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$71.$$s = self, $$71.$$arity = -1, $$71))
      } else {
        $send(self, 'each', [], ($$72 = function($a){var self = $$72.$$s || this, $post_args, value, item = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          item = $$($nesting, 'Opal').$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$72.$$s = self, $$72.$$arity = -1, $$72))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_none$ques$69.$$arity = -1);
    
    Opal.def(self, '$one?', $Enumerable_one$ques$73 = function(pattern) {try {

      var $iter = $Enumerable_one$ques$73.$$p, block = $iter || nil, $$74, $$75, $$76, self = this, count = nil;

      if ($iter) $Enumerable_one$ques$73.$$p = null;
      
      
      if ($iter) $Enumerable_one$ques$73.$$p = null;;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$74 = function($a){var self = $$74.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, $$74.$$s = self, $$74.$$arity = -1, $$74))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$75 = function($a){var self = $$75.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$75.$$s = self, $$75.$$arity = -1, $$75))
      } else {
        $send(self, 'each', [], ($$76 = function($a){var self = $$76.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$76.$$s = self, $$76.$$arity = -1, $$76))
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_one$ques$73.$$arity = -1);
    
    Opal.def(self, '$partition', $Enumerable_partition$77 = function $$partition() {
      var $iter = $Enumerable_partition$77.$$p, block = $iter || nil, $$78, self = this;

      if ($iter) $Enumerable_partition$77.$$p = null;
      
      
      if ($iter) $Enumerable_partition$77.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["partition"], ($$78 = function(){var self = $$78.$$s || this;

        return self.$enumerator_size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, $Enumerable_partition$77.$$arity = 0);
    Opal.alias(self, "reduce", "inject");
    
    Opal.def(self, '$reject', $Enumerable_reject$79 = function $$reject() {
      var $iter = $Enumerable_reject$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Enumerable_reject$79.$$p = null;
      
      
      if ($iter) $Enumerable_reject$79.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$80 = function(){var self = $$80.$$s || this;

        return self.$enumerator_size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($falsy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_reject$79.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Enumerable_reverse_each$81 = function $$reverse_each() {
      var $iter = $Enumerable_reverse_each$81.$$p, block = $iter || nil, $$82, self = this;

      if ($iter) $Enumerable_reverse_each$81.$$p = null;
      
      
      if ($iter) $Enumerable_reverse_each$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$82 = function(){var self = $$82.$$s || this;

        return self.$enumerator_size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        Opal.yieldX(block, result[i]);
      }

      return result;
    ;
    }, $Enumerable_reverse_each$81.$$arity = 0);
    Opal.alias(self, "select", "find_all");
    
    Opal.def(self, '$slice_before', $Enumerable_slice_before$83 = function $$slice_before(pattern) {
      var $iter = $Enumerable_slice_before$83.$$p, block = $iter || nil, $$84, self = this;

      if ($iter) $Enumerable_slice_before$83.$$p = null;
      
      
      if ($iter) $Enumerable_slice_before$83.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$84 = function(e){var self = $$84.$$s || this;

      
        
        if (e == null) {
          e = nil;
        };
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = Opal.yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $$($nesting, 'Opal').$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, $$84.$$s = self, $$84.$$arity = 1, $$84));
    }, $Enumerable_slice_before$83.$$arity = -1);
    
    Opal.def(self, '$slice_after', $Enumerable_slice_after$85 = function $$slice_after(pattern) {
      var $iter = $Enumerable_slice_after$85.$$p, block = $iter || nil, $$86, $$87, self = this;

      if ($iter) $Enumerable_slice_after$85.$$p = null;
      
      
      if ($iter) $Enumerable_slice_after$85.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      if ($truthy(pattern !== undefined)) {
        block = $send(self, 'proc', [], ($$86 = function(e){var self = $$86.$$s || this;

        
          
          if (e == null) {
            e = nil;
          };
          return pattern['$==='](e);}, $$86.$$s = self, $$86.$$arity = 1, $$86))};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$87 = function(yielder){var self = $$87.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $$($nesting, 'Opal').$destructure(arguments),
              end_chunk = Opal.yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, $$87.$$s = self, $$87.$$arity = 1, $$87));
    }, $Enumerable_slice_after$85.$$arity = -1);
    
    Opal.def(self, '$slice_when', $Enumerable_slice_when$88 = function $$slice_when() {
      var $iter = $Enumerable_slice_when$88.$$p, block = $iter || nil, $$89, self = this;

      if ($iter) $Enumerable_slice_when$88.$$p = null;
      
      
      if ($iter) $Enumerable_slice_when$88.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$89 = function(yielder){var self = $$89.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $$($nesting, 'Opal').$destructure(arguments),
              before = params[0],
              after = params[1],
              match = Opal.yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, $$89.$$s = self, $$89.$$arity = 1, $$89));
    }, $Enumerable_slice_when$88.$$arity = 0);
    
    Opal.def(self, '$sort', $Enumerable_sort$90 = function $$sort() {
      var $iter = $Enumerable_sort$90.$$p, block = $iter || nil, $$91, self = this, ary = nil;

      if ($iter) $Enumerable_sort$90.$$p = null;
      
      
      if ($iter) $Enumerable_sort$90.$$p = null;;
      ary = self.$to_a();
      if ((block !== nil)) {
      } else {
        block = $lambda(($$91 = function(a, b){var self = $$91.$$s || this;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$91.$$s = self, $$91.$$arity = 2, $$91))
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, $Enumerable_sort$90.$$arity = 0);
    
    Opal.def(self, '$sort_by', $Enumerable_sort_by$92 = function $$sort_by() {
      var $iter = $Enumerable_sort_by$92.$$p, block = $iter || nil, $$93, $$94, $$95, $$96, self = this, dup = nil;

      if ($iter) $Enumerable_sort_by$92.$$p = null;
      
      
      if ($iter) $Enumerable_sort_by$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by"], ($$93 = function(){var self = $$93.$$s || this;

        return self.$enumerator_size()}, $$93.$$s = self, $$93.$$arity = 0, $$93))
      };
      dup = $send(self, 'map', [], ($$94 = function(){var self = $$94.$$s || this, arg = nil;

      
        arg = $$($nesting, 'Opal').$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, $$94.$$s = self, $$94.$$arity = 0, $$94));
      $send(dup, 'sort!', [], ($$95 = function(a, b){var self = $$95.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return (a[0])['$<=>'](b[0]);}, $$95.$$s = self, $$95.$$arity = 2, $$95));
      return $send(dup, 'map!', [], ($$96 = function(i){var self = $$96.$$s || this;

      
        
        if (i == null) {
          i = nil;
        };
        return i[1];;}, $$96.$$s = self, $$96.$$arity = 1, $$96));
    }, $Enumerable_sort_by$92.$$arity = 0);
    
    Opal.def(self, '$sum', $Enumerable_sum$97 = function $$sum(initial) {
      var $$98, $iter = $Enumerable_sum$97.$$p, $yield = $iter || nil, self = this, result = nil;

      if ($iter) $Enumerable_sum$97.$$p = null;
      
      
      if (initial == null) {
        initial = 0;
      };
      result = initial;
      $send(self, 'each', [], ($$98 = function($a){var self = $$98.$$s || this, $post_args, args, item = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        item = (function() {if (($yield !== nil)) {
          return Opal.yieldX($yield, Opal.to_a(args));
        } else {
          return $$($nesting, 'Opal').$destructure(args)
        }; return nil; })();
        return (result = $rb_plus(result, item));}, $$98.$$s = self, $$98.$$arity = -1, $$98));
      return result;
    }, $Enumerable_sum$97.$$arity = -1);
    
    Opal.def(self, '$take', $Enumerable_take$99 = function $$take(num) {
      var self = this;

      return self.$first(num)
    }, $Enumerable_take$99.$$arity = 1);
    
    Opal.def(self, '$take_while', $Enumerable_take_while$100 = function $$take_while() {try {

      var $iter = $Enumerable_take_while$100.$$p, block = $iter || nil, $$101, self = this, result = nil;

      if ($iter) $Enumerable_take_while$100.$$p = null;
      
      
      if ($iter) $Enumerable_take_while$100.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], ($$101 = function($a){var self = $$101.$$s || this, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
        } else {
          Opal.ret(result)
        };
        return result.push(value);;}, $$101.$$s = self, $$101.$$arity = -1, $$101));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_take_while$100.$$arity = 0);
    
    Opal.def(self, '$uniq', $Enumerable_uniq$102 = function $$uniq() {
      var $iter = $Enumerable_uniq$102.$$p, block = $iter || nil, $$103, self = this, hash = nil;

      if ($iter) $Enumerable_uniq$102.$$p = null;
      
      
      if ($iter) $Enumerable_uniq$102.$$p = null;;
      hash = $hash2([], {});
      $send(self, 'each', [], ($$103 = function($a){var self = $$103.$$s || this, $post_args, args, value = nil, produced = nil, $writer = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        produced = (function() {if ((block !== nil)) {
          return Opal.yield1(block, value);
        } else {
          return value
        }; return nil; })();
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, $$103.$$s = self, $$103.$$arity = -1, $$103));
      return hash.$values();
    }, $Enumerable_uniq$102.$$arity = 0);
    Opal.alias(self, "to_a", "entries");
    
    Opal.def(self, '$zip', $Enumerable_zip$104 = function $$zip($a) {
      var $iter = $Enumerable_zip$104.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Enumerable_zip$104.$$p = null;
      
      
      if ($iter) $Enumerable_zip$104.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', Opal.to_a(others));
    }, $Enumerable_zip$104.$$arity = -1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/enumerator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$coerce_to', '$nil?', '$empty?', '$+', '$class', '$__send__', '$===', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$respond_to?', '$try_convert', '$<', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_inspect$7;

    self.$$prototype.size = self.$$prototype.args = self.$$prototype.object = self.$$prototype.method = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(self, '$for', $Enumerator_for$1 = function(object, $a, $b) {
      var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Enumerator_for$1.$$p = null;
      
      
      if ($iter) $Enumerator_for$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    ;
    }, $Enumerator_for$1.$$arity = -2);
    
    Opal.def(self, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
      var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this;

      if ($iter) $Enumerator_initialize$2.$$p = null;
      
      
      if ($iter) $Enumerator_initialize$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      if ($truthy(block)) {
        
        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy(self.size)) {
          return (self.size = $$($nesting, 'Opal').$coerce_to(self.size, $$($nesting, 'Integer'), "to_int"))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, $Enumerator_initialize$2.$$arity = -1);
    
    Opal.def(self, '$each', $Enumerator_each$3 = function $$each($a) {
      var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args, $b, self = this;

      if ($iter) $Enumerator_each$3.$$p = null;
      
      
      if ($iter) $Enumerator_each$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? args['$empty?']() : $b))) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerator_each$3.$$arity = -1);
    
    Opal.def(self, '$size', $Enumerator_size$4 = function $$size() {
      var self = this;

      if ($truthy($$($nesting, 'Proc')['$==='](self.size))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
      } else {
        return self.size
      }
    }, $Enumerator_size$4.$$arity = 0);
    
    Opal.def(self, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
      var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Enumerator_with_index$5.$$p = null;
      
      
      if ($iter) $Enumerator_with_index$5.$$p = null;;
      
      if (offset == null) {
        offset = 0;
      };
      offset = (function() {if ($truthy(offset)) {
        return $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int")
      } else {
        return 0
      }; return nil; })();
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["with_index", offset], ($$6 = function(){var self = $$6.$$s || this;

        return self.$size()}, $$6.$$s = self, $$6.$$arity = 0, $$6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, $Enumerator_with_index$5.$$arity = -1);
    Opal.alias(self, "with_object", "each_with_object");
    
    Opal.def(self, '$inspect', $Enumerator_inspect$7 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + ")")};
      return $rb_plus(result, ">");
    }, $Enumerator_inspect$7.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $Generator_initialize$8, $Generator_each$9;

      self.$$prototype.block = nil;
      
      self.$include($$($nesting, 'Enumerable'));
      
      Opal.def(self, '$initialize', $Generator_initialize$8 = function $$initialize() {
        var $iter = $Generator_initialize$8.$$p, block = $iter || nil, self = this;

        if ($iter) $Generator_initialize$8.$$p = null;
        
        
        if ($iter) $Generator_initialize$8.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, $Generator_initialize$8.$$arity = 0);
      return (Opal.def(self, '$each', $Generator_each$9 = function $$each($a) {
        var $iter = $Generator_each$9.$$p, block = $iter || nil, $post_args, args, self = this, yielder = nil;

        if ($iter) $Generator_each$9.$$p = null;
        
        
        if ($iter) $Generator_each$9.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, $Generator_each$9.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Yielder');

      var $nesting = [self].concat($parent_nesting), $Yielder_initialize$10, $Yielder_yield$11, $Yielder_$lt$lt$12;

      self.$$prototype.block = nil;
      
      
      Opal.def(self, '$initialize', $Yielder_initialize$10 = function $$initialize() {
        var $iter = $Yielder_initialize$10.$$p, block = $iter || nil, self = this;

        if ($iter) $Yielder_initialize$10.$$p = null;
        
        
        if ($iter) $Yielder_initialize$10.$$p = null;;
        return (self.block = block);
      }, $Yielder_initialize$10.$$arity = 0);
      
      Opal.def(self, '$yield', $Yielder_yield$11 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, $Yielder_yield$11.$$arity = -1);
      return (Opal.def(self, '$<<', $Yielder_$lt$lt$12 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, $Yielder_$lt$lt$12.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $Lazy_initialize$13, $Lazy_lazy$16, $Lazy_collect$17, $Lazy_collect_concat$19, $Lazy_drop$23, $Lazy_drop_while$25, $Lazy_enum_for$27, $Lazy_find_all$28, $Lazy_grep$30, $Lazy_reject$33, $Lazy_take$35, $Lazy_take_while$37, $Lazy_inspect$39;

      self.$$prototype.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopLazyError');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Exception'), $nesting);
      
      Opal.def(self, '$initialize', $Lazy_initialize$13 = function $$initialize(object, size) {
        var $iter = $Lazy_initialize$13.$$p, block = $iter || nil, $$14, self = this;

        if ($iter) $Lazy_initialize$13.$$p = null;
        
        
        if ($iter) $Lazy_initialize$13.$$p = null;;
        
        if (size == null) {
          size = nil;
        };
        if ((block !== nil)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send(self, Opal.find_super_dispatcher(self, 'initialize', $Lazy_initialize$13, false), [size], ($$14 = function(yielder, $a){var self = $$14.$$s || this, $post_args, each_args, $$15;

        
          
          if (yielder == null) {
            yielder = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', Opal.to_a(each_args), ($$15 = function($b){var self = $$15.$$s || this, $post_args, args;

            
              
              $post_args = Opal.slice.call(arguments, 0, arguments.length);
              
              args = $post_args;;
              
            args.unshift(yielder);

            Opal.yieldX(block, args);
          ;}, $$15.$$s = self, $$15.$$arity = -1, $$15))
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, $$14.$$s = self, $$14.$$arity = -2, $$14));
      }, $Lazy_initialize$13.$$arity = -2);
      Opal.alias(self, "force", "to_a");
      
      Opal.def(self, '$lazy', $Lazy_lazy$16 = function $$lazy() {
        var self = this;

        return self
      }, $Lazy_lazy$16.$$arity = 0);
      
      Opal.def(self, '$collect', $Lazy_collect$17 = function $$collect() {
        var $iter = $Lazy_collect$17.$$p, block = $iter || nil, $$18, self = this;

        if ($iter) $Lazy_collect$17.$$p = null;
        
        
        if ($iter) $Lazy_collect$17.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], ($$18 = function(enum$, $a){var self = $$18.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        ;}, $$18.$$s = self, $$18.$$arity = -2, $$18));
      }, $Lazy_collect$17.$$arity = 0);
      
      Opal.def(self, '$collect_concat', $Lazy_collect_concat$19 = function $$collect_concat() {
        var $iter = $Lazy_collect_concat$19.$$p, block = $iter || nil, $$20, self = this;

        if ($iter) $Lazy_collect_concat$19.$$p = null;
        
        
        if ($iter) $Lazy_collect_concat$19.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$20 = function(enum$, $a){var self = $$20.$$s || this, $post_args, args, $$21, $$22;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], ($$21 = function(v){var self = $$21.$$s || this;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$21.$$s = self, $$21.$$arity = 1, $$21))
          }
          else {
            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], ($$22 = function(v){var self = $$22.$$s || this;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$22.$$s = self, $$22.$$arity = 1, $$22));
            }
          }
        ;}, $$20.$$s = self, $$20.$$arity = -2, $$20));
      }, $Lazy_collect_concat$19.$$arity = 0);
      
      Opal.def(self, '$drop', $Lazy_drop$23 = function $$drop(n) {
        var $$24, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$24 = function(enum$, $a){var self = $$24.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$24.$$s = self, $$24.$$arity = -2, $$24));
      }, $Lazy_drop$23.$$arity = 1);
      
      Opal.def(self, '$drop_while', $Lazy_drop_while$25 = function $$drop_while() {
        var $iter = $Lazy_drop_while$25.$$p, block = $iter || nil, $$26, self = this, succeeding = nil;

        if ($iter) $Lazy_drop_while$25.$$p = null;
        
        
        if ($iter) $Lazy_drop_while$25.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$26 = function(enum$, $a){var self = $$26.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$26.$$s = self, $$26.$$arity = -2, $$26));
      }, $Lazy_drop_while$25.$$arity = 0);
      
      Opal.def(self, '$enum_for', $Lazy_enum_for$27 = function $$enum_for($a, $b) {
        var $iter = $Lazy_enum_for$27.$$p, block = $iter || nil, $post_args, method, args, self = this;

        if ($iter) $Lazy_enum_for$27.$$p = null;
        
        
        if ($iter) $Lazy_enum_for$27.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        };
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
      }, $Lazy_enum_for$27.$$arity = -1);
      
      Opal.def(self, '$find_all', $Lazy_find_all$28 = function $$find_all() {
        var $iter = $Lazy_find_all$28.$$p, block = $iter || nil, $$29, self = this;

        if ($iter) $Lazy_find_all$28.$$p = null;
        
        
        if ($iter) $Lazy_find_all$28.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$29 = function(enum$, $a){var self = $$29.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$29.$$s = self, $$29.$$arity = -2, $$29));
      }, $Lazy_find_all$28.$$arity = 0);
      Opal.alias(self, "flat_map", "collect_concat");
      
      Opal.def(self, '$grep', $Lazy_grep$30 = function $$grep(pattern) {
        var $iter = $Lazy_grep$30.$$p, block = $iter || nil, $$31, $$32, self = this;

        if ($iter) $Lazy_grep$30.$$p = null;
        
        
        if ($iter) $Lazy_grep$30.$$p = null;;
        if ($truthy(block)) {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$31 = function(enum$, $a){var self = $$31.$$s || this, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          ;}, $$31.$$s = self, $$31.$$arity = -2, $$31))
        } else {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$32 = function(enum$, $a){var self = $$32.$$s || this, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, $$32.$$s = self, $$32.$$arity = -2, $$32))
        };
      }, $Lazy_grep$30.$$arity = 1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "select", "find_all");
      
      Opal.def(self, '$reject', $Lazy_reject$33 = function $$reject() {
        var $iter = $Lazy_reject$33.$$p, block = $iter || nil, $$34, self = this;

        if ($iter) $Lazy_reject$33.$$p = null;
        
        
        if ($iter) $Lazy_reject$33.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$34 = function(enum$, $a){var self = $$34.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$34.$$s = self, $$34.$$arity = -2, $$34));
      }, $Lazy_reject$33.$$arity = 0);
      
      Opal.def(self, '$take', $Lazy_take$35 = function $$take(n) {
        var $$36, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$36 = function(enum$, $a){var self = $$36.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return self.$raise($$($nesting, 'StopLazyError'))
          };}, $$36.$$s = self, $$36.$$arity = -2, $$36));
      }, $Lazy_take$35.$$arity = 1);
      
      Opal.def(self, '$take_while', $Lazy_take_while$37 = function $$take_while() {
        var $iter = $Lazy_take_while$37.$$p, block = $iter || nil, $$38, self = this;

        if ($iter) $Lazy_take_while$37.$$p = null;
        
        
        if ($iter) $Lazy_take_while$37.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$38 = function(enum$, $a){var self = $$38.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise($$($nesting, 'StopLazyError'));
          }
        ;}, $$38.$$s = self, $$38.$$arity = -2, $$38));
      }, $Lazy_take_while$37.$$arity = 0);
      Opal.alias(self, "to_enum", "enum_for");
      return (Opal.def(self, '$inspect', $Lazy_inspect$39 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, $Lazy_inspect$39.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/numeric"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$respond_to?', '$coerce', '$__send__', '$===', '$raise', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$to_i', '$truncate', '$>']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_coerce$1, $Numeric___coerced__$2, $Numeric_$lt_eq_gt$3, $Numeric_$plus$$4, $Numeric_$minus$$5, $Numeric_$percent$6, $Numeric_abs$7, $Numeric_abs2$8, $Numeric_angle$9, $Numeric_ceil$10, $Numeric_conj$11, $Numeric_denominator$12, $Numeric_div$13, $Numeric_divmod$14, $Numeric_fdiv$15, $Numeric_floor$16, $Numeric_i$17, $Numeric_imag$18, $Numeric_integer$ques$19, $Numeric_nonzero$ques$20, $Numeric_numerator$21, $Numeric_polar$22, $Numeric_quo$23, $Numeric_real$24, $Numeric_real$ques$25, $Numeric_rect$26, $Numeric_round$27, $Numeric_to_c$28, $Numeric_to_int$29, $Numeric_truncate$30, $Numeric_zero$ques$31, $Numeric_positive$ques$32, $Numeric_negative$ques$33, $Numeric_dup$34, $Numeric_clone$35, $Numeric_finite$ques$36, $Numeric_infinite$ques$37;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.def(self, '$coerce', $Numeric_coerce$1 = function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]};
      return [self.$Float(other), self.$Float(self)];
    }, $Numeric_coerce$1.$$arity = 1);
    
    Opal.def(self, '$__coerced__', $Numeric___coerced__$2 = function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $case = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else {
        return (function() {$case = method;
        if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")}
        else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {return self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")}
        else { return nil }})()
      }
    }, $Numeric___coerced__$2.$$arity = 2);
    
    Opal.def(self, '$<=>', $Numeric_$lt_eq_gt$3 = function(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0};
      return nil;
    }, $Numeric_$lt_eq_gt$3.$$arity = 1);
    
    Opal.def(self, '$+@', $Numeric_$plus$$4 = function() {
      var self = this;

      return self
    }, $Numeric_$plus$$4.$$arity = 0);
    
    Opal.def(self, '$-@', $Numeric_$minus$$5 = function() {
      var self = this;

      return $rb_minus(0, self)
    }, $Numeric_$minus$$5.$$arity = 0);
    
    Opal.def(self, '$%', $Numeric_$percent$6 = function(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, $Numeric_$percent$6.$$arity = 1);
    
    Opal.def(self, '$abs', $Numeric_abs$7 = function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, $Numeric_abs$7.$$arity = 0);
    
    Opal.def(self, '$abs2', $Numeric_abs2$8 = function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, $Numeric_abs2$8.$$arity = 0);
    
    Opal.def(self, '$angle', $Numeric_angle$9 = function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$($nesting, 'Math'), 'PI')
      } else {
        return 0
      }
    }, $Numeric_angle$9.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$ceil', $Numeric_ceil$10 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$ceil(ndigits);
    }, $Numeric_ceil$10.$$arity = -1);
    
    Opal.def(self, '$conj', $Numeric_conj$11 = function $$conj() {
      var self = this;

      return self
    }, $Numeric_conj$11.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Numeric_denominator$12 = function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, $Numeric_denominator$12.$$arity = 0);
    
    Opal.def(self, '$div', $Numeric_div$13 = function $$div(other) {
      var self = this;

      
      if (other['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by o")};
      return $rb_divide(self, other).$floor();
    }, $Numeric_div$13.$$arity = 1);
    
    Opal.def(self, '$divmod', $Numeric_divmod$14 = function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, $Numeric_divmod$14.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Numeric_fdiv$15 = function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, $Numeric_fdiv$15.$$arity = 1);
    
    Opal.def(self, '$floor', $Numeric_floor$16 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$floor(ndigits);
    }, $Numeric_floor$16.$$arity = -1);
    
    Opal.def(self, '$i', $Numeric_i$17 = function $$i() {
      var self = this;

      return self.$Complex(0, self)
    }, $Numeric_i$17.$$arity = 0);
    
    Opal.def(self, '$imag', $Numeric_imag$18 = function $$imag() {
      var self = this;

      return 0
    }, $Numeric_imag$18.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$integer?', $Numeric_integer$ques$19 = function() {
      var self = this;

      return false
    }, $Numeric_integer$ques$19.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$nonzero?', $Numeric_nonzero$ques$20 = function() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, $Numeric_nonzero$ques$20.$$arity = 0);
    
    Opal.def(self, '$numerator', $Numeric_numerator$21 = function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, $Numeric_numerator$21.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Numeric_polar$22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Numeric_polar$22.$$arity = 0);
    
    Opal.def(self, '$quo', $Numeric_quo$23 = function $$quo(other) {
      var self = this;

      return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), "to_r"), other)
    }, $Numeric_quo$23.$$arity = 1);
    
    Opal.def(self, '$real', $Numeric_real$24 = function $$real() {
      var self = this;

      return self
    }, $Numeric_real$24.$$arity = 0);
    
    Opal.def(self, '$real?', $Numeric_real$ques$25 = function() {
      var self = this;

      return true
    }, $Numeric_real$ques$25.$$arity = 0);
    
    Opal.def(self, '$rect', $Numeric_rect$26 = function $$rect() {
      var self = this;

      return [self, 0]
    }, $Numeric_rect$26.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$round', $Numeric_round$27 = function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, $Numeric_round$27.$$arity = -1);
    
    Opal.def(self, '$to_c', $Numeric_to_c$28 = function $$to_c() {
      var self = this;

      return self.$Complex(self, 0)
    }, $Numeric_to_c$28.$$arity = 0);
    
    Opal.def(self, '$to_int', $Numeric_to_int$29 = function $$to_int() {
      var self = this;

      return self.$to_i()
    }, $Numeric_to_int$29.$$arity = 0);
    
    Opal.def(self, '$truncate', $Numeric_truncate$30 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$truncate(ndigits);
    }, $Numeric_truncate$30.$$arity = -1);
    
    Opal.def(self, '$zero?', $Numeric_zero$ques$31 = function() {
      var self = this;

      return self['$=='](0)
    }, $Numeric_zero$ques$31.$$arity = 0);
    
    Opal.def(self, '$positive?', $Numeric_positive$ques$32 = function() {
      var self = this;

      return $rb_gt(self, 0)
    }, $Numeric_positive$ques$32.$$arity = 0);
    
    Opal.def(self, '$negative?', $Numeric_negative$ques$33 = function() {
      var self = this;

      return $rb_lt(self, 0)
    }, $Numeric_negative$ques$33.$$arity = 0);
    
    Opal.def(self, '$dup', $Numeric_dup$34 = function $$dup() {
      var self = this;

      return self
    }, $Numeric_dup$34.$$arity = 0);
    
    Opal.def(self, '$clone', $Numeric_clone$35 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Numeric_clone$35.$$arity = -1);
    
    Opal.def(self, '$finite?', $Numeric_finite$ques$36 = function() {
      var self = this;

      return true
    }, $Numeric_finite$ques$36.$$arity = 0);
    return (Opal.def(self, '$infinite?', $Numeric_infinite$ques$37 = function() {
      var self = this;

      return nil
    }, $Numeric_infinite$ques$37.$$arity = 0), nil) && 'infinite?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/array"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to', '$coerce_to?', '$===', '$join', '$to_str', '$class', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$bsearch_index', '$to_proc', '$nil?', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$[]', '$dig', '$eql?', '$length', '$begin', '$end', '$exclude_end?', '$flatten', '$__id__', '$to_s', '$new', '$max', '$min', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$-', '$<<', '$values', '$is_a?', '$last', '$first', '$upto', '$reject', '$pristine', '$singleton_class']);
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_$$$1, $Array_initialize$2, $Array_try_convert$3, $Array_$$4, $Array_$$5, $Array_$$6, $Array_$plus$7, $Array_$minus$8, $Array_$lt$lt$9, $Array_$lt_eq_gt$10, $Array_$eq_eq$11, $Array_$$$12, $Array_$$$eq$13, $Array_any$ques$14, $Array_assoc$15, $Array_at$16, $Array_bsearch_index$17, $Array_bsearch$18, $Array_cycle$19, $Array_clear$21, $Array_count$22, $Array_initialize_copy$23, $Array_collect$24, $Array_collect$excl$26, $Array_combination$28, $Array_repeated_combination$30, $Array_compact$32, $Array_compact$excl$33, $Array_concat$34, $Array_delete$37, $Array_delete_at$38, $Array_delete_if$39, $Array_dig$41, $Array_drop$42, $Array_dup$43, $Array_each$44, $Array_each_index$46, $Array_empty$ques$48, $Array_eql$ques$49, $Array_fetch$50, $Array_fill$51, $Array_first$52, $Array_flatten$53, $Array_flatten$excl$54, $Array_hash$55, $Array_include$ques$56, $Array_index$57, $Array_insert$58, $Array_inspect$59, $Array_join$60, $Array_keep_if$61, $Array_last$63, $Array_length$64, $Array_max$65, $Array_min$66, $Array_permutation$67, $Array_repeated_permutation$69, $Array_pop$71, $Array_product$72, $Array_push$73, $Array_rassoc$74, $Array_reject$75, $Array_reject$excl$77, $Array_replace$79, $Array_reverse$80, $Array_reverse$excl$81, $Array_reverse_each$82, $Array_rindex$84, $Array_rotate$85, $Array_rotate$excl$86, $Array_sample$89, $Array_select$90, $Array_select$excl$92, $Array_shift$94, $Array_shuffle$95, $Array_shuffle$excl$96, $Array_slice$excl$97, $Array_sort$98, $Array_sort$excl$99, $Array_sort_by$excl$100, $Array_take$102, $Array_take_while$103, $Array_to_a$104, $Array_to_h$105, $Array_transpose$106, $Array_uniq$109, $Array_uniq$excl$110, $Array_unshift$111, $Array_values_at$112, $Array_zip$115, $Array_inherited$116, $Array_instance_variables$117, $Array_pack$119;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defineProperty(self.$$prototype, '$$is_array', true);
    
    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }
  ;
    Opal.defs(self, '$[]', $Array_$$$1 = function($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, $Array_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Array_initialize$2 = function $$initialize(size, obj) {
      var $iter = $Array_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_initialize$2.$$p = null;
      
      
      if ($iter) $Array_initialize$2.$$p = null;;
      
      if (size == null) {
        size = nil;
      };
      
      if (obj == null) {
        obj = nil;
      };
      
      if (obj !== nil && block !== nil) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$($nesting, 'Integer'), 'MAX')) {
        self.$raise($$($nesting, 'ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $$($nesting, 'Opal').$coerce_to(size, $$($nesting, 'Integer'), "to_int")

      if (size < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, $Array_initialize$2.$$arity = -1);
    Opal.defs(self, '$try_convert', $Array_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Array'), "to_ary")
    }, $Array_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$&', $Array_$$4 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if (Opal.hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Array_$$5 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        Opal.hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, $Array_$$5.$$arity = 1);
    
    Opal.def(self, '$*', $Array_$$6 = function(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())};
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Integer'), "to_int");
      if ($truthy(other < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")};
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return toArraySubclass(result, self.$class());
    ;
    }, $Array_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $Array_$plus$7 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      return self.concat(other);;
    }, $Array_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Array_$minus$8 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(other.length === 0)) {
        return self.slice()};
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if (Opal.hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$minus$8.$$arity = 1);
    
    Opal.def(self, '$<<', $Array_$lt$lt$9 = function(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, $Array_$lt$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=>', $Array_$lt_eq_gt$10 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, $Array_$lt_eq_gt$10.$$arity = 1);
    
    Opal.def(self, '$==', $Array_$eq_eq$11 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($$($nesting, 'Opal')['$respond_to?'](other, "to_ary")) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, $Array_$eq_eq$11.$$arity = 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = Opal.Opal.$coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = Opal.Opal.$coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return toArraySubclass(result, self.$class());
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = Opal.Opal.$coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = Opal.Opal.$coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return toArraySubclass(result, self.$class());
    }
  ;
    
    Opal.def(self, '$[]', $Array_$$$12 = function(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, $Array_$$$12.$$arity = -2);
    
    Opal.def(self, '$[]=', $Array_$$$eq$13 = function(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
            var i, size = self.length;;
      if ($truthy($$($nesting, 'Range')['$==='](index))) {
        
        data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
          return value.$to_a()
        } else if ($truthy(value['$respond_to?']("to_ary"))) {
          return value.$to_ary().$to_a()
        } else {
          return [value]
        }; return nil; })();
        
        var exclude = index.excl,
            from    = $$($nesting, 'Opal').$coerce_to(index.begin, $$($nesting, 'Integer'), "to_int"),
            to      = $$($nesting, 'Opal').$coerce_to(index.end, $$($nesting, 'Integer'), "to_int");

        if (from < 0) {
          from += size;

          if (from < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
      } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
        } else {
          
          length = value;
          value = extra;
          data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
            return value.$to_a()
          } else if ($truthy(value['$respond_to?']("to_ary"))) {
            return value.$to_ary().$to_a()
          } else {
            return [value]
          }; return nil; })();
        };
        
        var old;

        index  = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          self.$raise($$($nesting, 'IndexError'), "" + "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, $Array_$$$eq$13.$$arity = -3);
    
    Opal.def(self, '$any?', $Array_any$ques$14 = function(pattern) {
      var $iter = $Array_any$ques$14.$$p, block = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_any$ques$14.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_any$ques$14.$$p = null;;
      ;
      if (self.length === 0) return false;
      return $send(self, Opal.find_super_dispatcher(self, 'any?', $Array_any$ques$14, false), $zuper, $iter);
    }, $Array_any$ques$14.$$arity = -1);
    
    Opal.def(self, '$assoc', $Array_assoc$15 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, $Array_assoc$15.$$arity = 1);
    
    Opal.def(self, '$at', $Array_at$16 = function $$at(index) {
      var self = this;

      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
      
      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    ;
    }, $Array_at$16.$$arity = 1);
    
    Opal.def(self, '$bsearch_index', $Array_bsearch_index$17 = function $$bsearch_index() {
      var $iter = $Array_bsearch_index$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_bsearch_index$17.$$p = null;
      
      
      if ($iter) $Array_bsearch_index$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = Opal.yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, $Array_bsearch_index$17.$$arity = 0);
    
    Opal.def(self, '$bsearch', $Array_bsearch$18 = function $$bsearch() {
      var $iter = $Array_bsearch$18.$$p, block = $iter || nil, self = this, index = nil;

      if ($iter) $Array_bsearch$18.$$p = null;
      
      
      if ($iter) $Array_bsearch$18.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, $Array_bsearch$18.$$arity = 0);
    
    Opal.def(self, '$cycle', $Array_cycle$19 = function $$cycle(n) {
      var $iter = $Array_cycle$19.$$p, block = $iter || nil, $$20, $a, self = this;

      if ($iter) $Array_cycle$19.$$p = null;
      
      
      if ($iter) $Array_cycle$19.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$20 = function(){var self = $$20.$$s || this;

        if ($truthy(n['$nil?']())) {
            return $$$($$($nesting, 'Float'), 'INFINITY')
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$20.$$s = self, $$20.$$arity = 0, $$20))
      };
      if ($truthy(($truthy($a = self['$empty?']()) ? $a : n['$=='](0)))) {
        return nil};
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = Opal.yield1(block, self[i]);
          }
        }
      }
      else {
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = Opal.yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, $Array_cycle$19.$$arity = -1);
    
    Opal.def(self, '$clear', $Array_clear$21 = function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, $Array_clear$21.$$arity = 0);
    
    Opal.def(self, '$count', $Array_count$22 = function $$count(object) {
      var $iter = $Array_count$22.$$p, block = $iter || nil, $a, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_count$22.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_count$22.$$p = null;;
      
      if (object == null) {
        object = nil;
      };
      if ($truthy(($truthy($a = object) ? $a : block))) {
        return $send(self, Opal.find_super_dispatcher(self, 'count', $Array_count$22, false), $zuper, $iter)
      } else {
        return self.$size()
      };
    }, $Array_count$22.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Array_initialize_copy$23 = function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, $Array_initialize_copy$23.$$arity = 1);
    
    Opal.def(self, '$collect', $Array_collect$24 = function $$collect() {
      var $iter = $Array_collect$24.$$p, block = $iter || nil, $$25, self = this;

      if ($iter) $Array_collect$24.$$p = null;
      
      
      if ($iter) $Array_collect$24.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$25 = function(){var self = $$25.$$s || this;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, $Array_collect$24.$$arity = 0);
    
    Opal.def(self, '$collect!', $Array_collect$excl$26 = function() {
      var $iter = $Array_collect$excl$26.$$p, block = $iter || nil, $$27, self = this;

      if ($iter) $Array_collect$excl$26.$$p = null;
      
      
      if ($iter) $Array_collect$excl$26.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect!"], ($$27 = function(){var self = $$27.$$s || this;

        return self.$size()}, $$27.$$s = self, $$27.$$arity = 0, $$27))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, $Array_collect$excl$26.$$arity = 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    Opal.def(self, '$combination', $Array_combination$28 = function $$combination(n) {
      var $$29, $iter = $Array_combination$28.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_combination$28.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["combination", num], ($$29 = function(){var self = $$29.$$s || this;

        return binomial_coefficient(self.length, num)}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, $Array_combination$28.$$arity = 1);
    
    Opal.def(self, '$repeated_combination', $Array_repeated_combination$30 = function $$repeated_combination(n) {
      var $$31, $iter = $Array_repeated_combination$30.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_combination$30.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_combination", num], ($$31 = function(){var self = $$31.$$s || this;

        return binomial_coefficient(self.length + num - 1, num);}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, $Array_repeated_combination$30.$$arity = 1);
    
    Opal.def(self, '$compact', $Array_compact$32 = function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, $Array_compact$32.$$arity = 0);
    
    Opal.def(self, '$compact!', $Array_compact$excl$33 = function() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, $Array_compact$excl$33.$$arity = 0);
    
    Opal.def(self, '$concat', $Array_concat$34 = function $$concat($a) {
      var $post_args, others, $$35, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      others = $send(others, 'map', [], ($$35 = function(other){var self = $$35.$$s || this;

      
        
        if (other == null) {
          other = nil;
        };
        other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
          return other.$to_a()
        } else {
          return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
        }; return nil; })();
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()};
        return other;}, $$35.$$s = self, $$35.$$arity = 1, $$35));
      $send(others, 'each', [], ($$36 = function(other){var self = $$36.$$s || this;

      
        
        if (other == null) {
          other = nil;
        };
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      return self;
    }, $Array_concat$34.$$arity = -1);
    
    Opal.def(self, '$delete', $Array_delete$37 = function(object) {
      var $iter = $Array_delete$37.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Array_delete$37.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, $Array_delete$37.$$arity = 1);
    
    Opal.def(self, '$delete_at', $Array_delete_at$38 = function $$delete_at(index) {
      var self = this;

      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, $Array_delete_at$38.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Array_delete_if$39 = function $$delete_if() {
      var $iter = $Array_delete_if$39.$$p, block = $iter || nil, $$40, self = this;

      if ($iter) $Array_delete_if$39.$$p = null;
      
      
      if ($iter) $Array_delete_if$39.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$40 = function(){var self = $$40.$$s || this;

        return self.$size()}, $$40.$$s = self, $$40.$$arity = 0, $$40))
      };
      
      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value !== false && value !== nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }
    ;
      return self;
    }, $Array_delete_if$39.$$arity = 0);
    
    Opal.def(self, '$dig', $Array_dig$41 = function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(idxs));
    }, $Array_dig$41.$$arity = -2);
    
    Opal.def(self, '$drop', $Array_drop$42 = function $$drop(number) {
      var self = this;

      
      if (number < 0) {
        self.$raise($$($nesting, 'ArgumentError'))
      }

      return self.slice(number);
    
    }, $Array_drop$42.$$arity = 1);
    
    Opal.def(self, '$dup', $Array_dup$43 = function $$dup() {
      var $iter = $Array_dup$43.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_dup$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send(self, Opal.find_super_dispatcher(self, 'dup', $Array_dup$43, false), $zuper, $iter);
    }, $Array_dup$43.$$arity = 0);
    
    Opal.def(self, '$each', $Array_each$44 = function $$each() {
      var $iter = $Array_each$44.$$p, block = $iter || nil, $$45, self = this;

      if ($iter) $Array_each$44.$$p = null;
      
      
      if ($iter) $Array_each$44.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$45 = function(){var self = $$45.$$s || this;

        return self.$size()}, $$45.$$s = self, $$45.$$arity = 0, $$45))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
      }
    ;
      return self;
    }, $Array_each$44.$$arity = 0);
    
    Opal.def(self, '$each_index', $Array_each_index$46 = function $$each_index() {
      var $iter = $Array_each_index$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Array_each_index$46.$$p = null;
      
      
      if ($iter) $Array_each_index$46.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_index"], ($$47 = function(){var self = $$47.$$s || this;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, i);
      }
    ;
      return self;
    }, $Array_each_index$46.$$arity = 0);
    
    Opal.def(self, '$empty?', $Array_empty$ques$48 = function() {
      var self = this;

      return self.length === 0;
    }, $Array_empty$ques$48.$$arity = 0);
    
    Opal.def(self, '$eql?', $Array_eql$ques$49 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, $Array_eql$ques$49.$$arity = 1);
    
    Opal.def(self, '$fetch', $Array_fetch$50 = function $$fetch(index, defaults) {
      var $iter = $Array_fetch$50.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_fetch$50.$$p = null;
      
      
      if ($iter) $Array_fetch$50.$$p = null;;
      ;
      
      var original = index;

      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, $Array_fetch$50.$$arity = -2);
    
    Opal.def(self, '$fill', $Array_fill$51 = function $$fill($a) {
      var $iter = $Array_fill$51.$$p, block = $iter || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      if ($iter) $Array_fill$51.$$p = null;
      
      
      if ($iter) $Array_fill$51.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 0..2)")};
        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 1..3)")};
        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($truthy($$($nesting, 'Range')['$==='](one))) {
        
        if ($truthy(two)) {
          self.$raise($$($nesting, 'TypeError'), "length invalid with range")};
        left = $$($nesting, 'Opal').$coerce_to(one.$begin(), $$($nesting, 'Integer'), "to_int");
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          self.$raise($$($nesting, 'RangeError'), "" + (one.$inspect()) + " out of range")};
        right = $$($nesting, 'Opal').$coerce_to(one.$end(), $$($nesting, 'Integer'), "to_int");
        if ($truthy(right < 0)) {
          right += this.length};
        if ($truthy(one['$exclude_end?']())) {
        } else {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self};
      } else if ($truthy(one)) {
        
        left = $$($nesting, 'Opal').$coerce_to(one, $$($nesting, 'Integer'), "to_int");
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          left = 0};
        if ($truthy(two)) {
          
          right = $$($nesting, 'Opal').$coerce_to(two, $$($nesting, 'Integer'), "to_int");
          if ($truthy(right == 0)) {
            return self};
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      };
      if ($truthy(right > this.length)) {
        this.length = right};
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, $Array_fill$51.$$arity = -1);
    
    Opal.def(self, '$first', $Array_first$52 = function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, $Array_first$52.$$arity = -1);
    
    Opal.def(self, '$flatten', $Array_flatten$53 = function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$$($nesting, 'Opal')['$respond_to?'](item, "to_ary", true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            self.$raise($$($nesting, 'TypeError'));
          }

          if (ary === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $$($nesting, 'Opal').$coerce_to(level, $$($nesting, 'Integer'), "to_int");
      }

      return toArraySubclass(_flatten(self, level), self.$class());
    ;
    }, $Array_flatten$53.$$arity = -1);
    
    Opal.def(self, '$flatten!', $Array_flatten$excl$54 = function(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, $Array_flatten$excl$54.$$arity = -1);
    
    Opal.def(self, '$hash', $Array_hash$55 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if (Opal.hash_ids[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Array_hash$55.$$arity = 0);
    
    Opal.def(self, '$include?', $Array_include$ques$56 = function(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, $Array_include$ques$56.$$arity = 1);
    
    Opal.def(self, '$index', $Array_index$57 = function $$index(object) {
      var $iter = $Array_index$57.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_index$57.$$p = null;
      
      
      if ($iter) $Array_index$57.$$p = null;;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, $Array_index$57.$$arity = -1);
    
    Opal.def(self, '$insert', $Array_insert$58 = function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      objects = $post_args;;
      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, $Array_insert$58.$$arity = -2);
    
    Opal.def(self, '$inspect', $Array_inspect$59 = function $$inspect() {
      var self = this;

      
      var result = [],
          id     = self.$__id__();

      for (var i = 0, length = self.length; i < length; i++) {
        var item = self['$[]'](i);

        if ((item).$__id__() === id) {
          result.push('[...]');
        }
        else {
          result.push((item).$inspect());
        }
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_inspect$59.$$arity = 0);
    
    Opal.def(self, '$join', $Array_join$60 = function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) {
        sep = nil;
      };
      if ($truthy(self.length === 0)) {
        return ""};
      if ($truthy(sep === nil)) {
        sep = $gvars[","]};
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_str")) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_ary")) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_s")) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        self.$raise($$($nesting, 'NoMethodError').$new("" + (Opal.inspect(item)) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($$($nesting, 'Opal')['$coerce_to!'](sep, $$($nesting, 'String'), "to_str").$to_s());
      }
    ;
    }, $Array_join$60.$$arity = -1);
    
    Opal.def(self, '$keep_if', $Array_keep_if$61 = function $$keep_if() {
      var $iter = $Array_keep_if$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Array_keep_if$61.$$p = null;
      
      
      if ($iter) $Array_keep_if$61.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }
    ;
      return self;
    }, $Array_keep_if$61.$$arity = 0);
    
    Opal.def(self, '$last', $Array_last$63 = function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, $Array_last$63.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$64 = function $$length() {
      var self = this;

      return self.length;
    }, $Array_length$64.$$arity = 0);
    Opal.alias(self, "map", "collect");
    Opal.alias(self, "map!", "collect!");
    
    Opal.def(self, '$max', $Array_max$65 = function $$max(n) {
      var $iter = $Array_max$65.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_max$65.$$p = null;
      
      
      if ($iter) $Array_max$65.$$p = null;;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, $Array_max$65.$$arity = -1);
    
    Opal.def(self, '$min', $Array_min$66 = function $$min() {
      var $iter = $Array_min$66.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_min$66.$$p = null;
      
      
      if ($iter) $Array_min$66.$$p = null;;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, $Array_min$66.$$arity = 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    Opal.def(self, '$permutation', $Array_permutation$67 = function $$permutation(num) {
      var $iter = $Array_permutation$67.$$p, block = $iter || nil, $$68, self = this, perm = nil, used = nil;

      if ($iter) $Array_permutation$67.$$p = null;
      
      
      if ($iter) $Array_permutation$67.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["permutation", num], ($$68 = function(){var self = $$68.$$s || this;

        return descending_factorial(self.length, num === undefined ? self.length : num);}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $$($nesting, 'Opal').$coerce_to(num, $$($nesting, 'Integer'), "to_int")
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$($nesting, 'Array').$new(num));
        (used = $$($nesting, 'Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                Opal.yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, $Array_permutation$67.$$arity = -1);
    
    Opal.def(self, '$repeated_permutation', $Array_repeated_permutation$69 = function $$repeated_permutation(n) {
      var $$70, $iter = $Array_repeated_permutation$69.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_permutation$69.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_permutation", num], ($$70 = function(){var self = $$70.$$s || this;

        if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, $$70.$$s = self, $$70.$$arity = 0, $$70))
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, $Array_repeated_permutation$69.$$arity = 1);
    
    Opal.def(self, '$pop', $Array_pop$71 = function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.pop();};
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, $Array_pop$71.$$arity = -1);
    
    Opal.def(self, '$product', $Array_product$72 = function $$product($a) {
      var $iter = $Array_product$72.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Array_product$72.$$p = null;
      
      
      if ($iter) $Array_product$72.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $$($nesting, 'Opal').$coerce_to(args[i - 1], $$($nesting, 'Array'), "to_ary");
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          self.$raise($$($nesting, 'RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, $Array_product$72.$$arity = -1);
    
    Opal.def(self, '$push', $Array_push$73 = function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, $Array_push$73.$$arity = -1);
    Opal.alias(self, "append", "push");
    
    Opal.def(self, '$rassoc', $Array_rassoc$74 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, $Array_rassoc$74.$$arity = 1);
    
    Opal.def(self, '$reject', $Array_reject$75 = function $$reject() {
      var $iter = $Array_reject$75.$$p, block = $iter || nil, $$76, self = this;

      if ($iter) $Array_reject$75.$$p = null;
      
      
      if ($iter) $Array_reject$75.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$76 = function(){var self = $$76.$$s || this;

        return self.$size()}, $$76.$$s = self, $$76.$$arity = 0, $$76))
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, $Array_reject$75.$$arity = 0);
    
    Opal.def(self, '$reject!', $Array_reject$excl$77 = function() {
      var $iter = $Array_reject$excl$77.$$p, block = $iter || nil, $$78, self = this, original = nil;

      if ($iter) $Array_reject$excl$77.$$p = null;
      
      
      if ($iter) $Array_reject$excl$77.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$78 = function(){var self = $$78.$$s || this;

        return self.$size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$length()['$=='](original)) {
        return nil
      } else {
        return self
      };
    }, $Array_reject$excl$77.$$arity = 0);
    
    Opal.def(self, '$replace', $Array_replace$79 = function $$replace(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, $Array_replace$79.$$arity = 1);
    
    Opal.def(self, '$reverse', $Array_reverse$80 = function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, $Array_reverse$80.$$arity = 0);
    
    Opal.def(self, '$reverse!', $Array_reverse$excl$81 = function() {
      var self = this;

      return self.reverse();
    }, $Array_reverse$excl$81.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Array_reverse_each$82 = function $$reverse_each() {
      var $iter = $Array_reverse_each$82.$$p, block = $iter || nil, $$83, self = this;

      if ($iter) $Array_reverse_each$82.$$p = null;
      
      
      if ($iter) $Array_reverse_each$82.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$83 = function(){var self = $$83.$$s || this;

        return self.$size()}, $$83.$$s = self, $$83.$$arity = 0, $$83))
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, $Array_reverse_each$82.$$arity = 0);
    
    Opal.def(self, '$rindex', $Array_rindex$84 = function $$rindex(object) {
      var $iter = $Array_rindex$84.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_rindex$84.$$p = null;
      
      
      if ($iter) $Array_rindex$84.$$p = null;;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, $Array_rindex$84.$$arity = -1);
    
    Opal.def(self, '$rotate', $Array_rotate$85 = function $$rotate(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      
      var ary, idx, firstPart, lastPart;

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, $Array_rotate$85.$$arity = -1);
    
    Opal.def(self, '$rotate!', $Array_rotate$excl$86 = function(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) {
        cnt = 1;
      };
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
    ;
      cnt = $$($nesting, 'Opal').$coerce_to(cnt, $$($nesting, 'Integer'), "to_int");
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, $Array_rotate$excl$86.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SampleRandom');

      var $nesting = [self].concat($parent_nesting), $SampleRandom_initialize$87, $SampleRandom_rand$88;

      self.$$prototype.rng = nil;
      
      
      Opal.def(self, '$initialize', $SampleRandom_initialize$87 = function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, $SampleRandom_initialize$87.$$arity = 1);
      return (Opal.def(self, '$rand', $SampleRandom_rand$88 = function $$rand(size) {
        var self = this, random = nil;

        
        random = $$($nesting, 'Opal').$coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), "to_int");
        if ($truthy(random < 0)) {
          self.$raise($$($nesting, 'RangeError'), "random value must be >= 0")};
        if ($truthy(random < size)) {
        } else {
          self.$raise($$($nesting, 'RangeError'), "random value must be less than Array size")
        };
        return random;
      }, $SampleRandom_rand$88.$$arity = 1), nil) && 'rand';
    })($nesting[0], null, $nesting);
    
    Opal.def(self, '$sample', $Array_sample$89 = function $$sample(count, options) {
      var $a, self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($$($nesting, 'Kernel').$rand(self.length))};
      if ($truthy(options === undefined)) {
        if ($truthy((o = $$($nesting, 'Opal')['$coerce_to?'](count, $$($nesting, 'Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
        }
      } else {
        
        count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
        options = $$($nesting, 'Opal').$coerce_to(options, $$($nesting, 'Hash'), "to_hash");
      };
      if ($truthy(($truthy($a = count) ? count < 0 : $a))) {
        self.$raise($$($nesting, 'ArgumentError'), "count must be greater than 0")};
      if ($truthy(options)) {
        rng = options['$[]']("random")};
      rng = (function() {if ($truthy(($truthy($a = rng) ? rng['$respond_to?']("rand") : $a))) {
        return $$($nesting, 'SampleRandom').$new(rng)
      } else {
        return $$($nesting, 'Kernel')
      }; return nil; })();
      if ($truthy(count)) {
      } else {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$($nesting, 'Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, $Array_sample$89.$$arity = -1);
    
    Opal.def(self, '$select', $Array_select$90 = function $$select() {
      var $iter = $Array_select$90.$$p, block = $iter || nil, $$91, self = this;

      if ($iter) $Array_select$90.$$p = null;
      
      
      if ($iter) $Array_select$90.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$91 = function(){var self = $$91.$$s || this;

        return self.$size()}, $$91.$$s = self, $$91.$$arity = 0, $$91))
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = Opal.yield1(block, item);

        if (Opal.truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_select$90.$$arity = 0);
    
    Opal.def(self, '$select!', $Array_select$excl$92 = function() {
      var $iter = $Array_select$excl$92.$$p, block = $iter || nil, $$93, self = this;

      if ($iter) $Array_select$excl$92.$$p = null;
      
      
      if ($iter) $Array_select$excl$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$93 = function(){var self = $$93.$$s || this;

        return self.$size()}, $$93.$$s = self, $$93.$$arity = 0, $$93))
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, $Array_select$excl$92.$$arity = 0);
    
    Opal.def(self, '$shift', $Array_shift$94 = function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.shift();};
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      return self.splice(0, count);;
    }, $Array_shift$94.$$arity = -1);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$shuffle', $Array_shuffle$95 = function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, $Array_shuffle$95.$$arity = -1);
    
    Opal.def(self, '$shuffle!', $Array_shuffle$excl$96 = function(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $$($nesting, 'Opal')['$coerce_to?'](rng, $$($nesting, 'Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too small " + (j))
          }

          if (j >= i) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, $Array_shuffle$excl$96.$$arity = -1);
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$slice!', $Array_slice$excl$97 = function(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($truthy($$($nesting, 'Range')['$==='](index))) {
          
          range = index;
          result = self['$[]'](range);
          range_start = $$($nesting, 'Opal').$coerce_to(range.$begin(), $$($nesting, 'Integer'), "to_int");
          range_end = $$($nesting, 'Opal').$coerce_to(range.$end(), $$($nesting, 'Integer'), "to_int");
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, $Array_slice$excl$97.$$arity = -2);
    
    Opal.def(self, '$sort', $Array_sort$98 = function $$sort() {
      var $iter = $Array_sort$98.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$98.$$p = null;
      
      
      if ($iter) $Array_sort$98.$$p = null;;
      if ($truthy(self.length > 1)) {
      } else {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, $Array_sort$98.$$arity = 0);
    
    Opal.def(self, '$sort!', $Array_sort$excl$99 = function() {
      var $iter = $Array_sort$excl$99.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$excl$99.$$p = null;
      
      
      if ($iter) $Array_sort$excl$99.$$p = null;;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, $Array_sort$excl$99.$$arity = 0);
    
    Opal.def(self, '$sort_by!', $Array_sort_by$excl$100 = function() {
      var $iter = $Array_sort_by$excl$100.$$p, block = $iter || nil, $$101, self = this;

      if ($iter) $Array_sort_by$excl$100.$$p = null;
      
      
      if ($iter) $Array_sort_by$excl$100.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by!"], ($$101 = function(){var self = $$101.$$s || this;

        return self.$size()}, $$101.$$s = self, $$101.$$arity = 0, $$101))
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, $Array_sort_by$excl$100.$$arity = 0);
    
    Opal.def(self, '$take', $Array_take$102 = function $$take(count) {
      var self = this;

      
      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'));
      }

      return self.slice(0, count);
    
    }, $Array_take$102.$$arity = 1);
    
    Opal.def(self, '$take_while', $Array_take_while$103 = function $$take_while() {
      var $iter = $Array_take_while$103.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_take_while$103.$$p = null;
      
      
      if ($iter) $Array_take_while$103.$$p = null;;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, $Array_take_while$103.$$arity = 0);
    
    Opal.def(self, '$to_a', $Array_to_a$104 = function $$to_a() {
      var self = this;

      return self
    }, $Array_to_a$104.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    
    Opal.def(self, '$to_h', $Array_to_h$105 = function $$to_h() {
      var self = this;

      
      var i, len = self.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $$($nesting, 'Opal')['$coerce_to?'](self[i], $$($nesting, 'Array'), "to_ary");
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        Opal.hash_put(hash, key, val);
      }

      return hash;
    
    }, $Array_to_h$105.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transpose', $Array_transpose$106 = function $$transpose() {
      var $$107, self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []};
      result = [];
      max = nil;
      $send(self, 'each', [], ($$107 = function(row){var self = $$107.$$s || this, $a, $$108;

      
        
        if (row == null) {
          row = nil;
        };
        row = (function() {if ($truthy($$($nesting, 'Array')['$==='](row))) {
          return row.$to_a()
        } else {
          return $$($nesting, 'Opal').$coerce_to(row, $$($nesting, 'Array'), "to_ary").$to_a()
        }; return nil; })();
        max = ($truthy($a = max) ? $a : row.length);
        if ($truthy((row.length)['$!='](max))) {
          self.$raise($$($nesting, 'IndexError'), "" + "element size differs (" + (row.length) + " should be " + (max) + ")")};
        return $send((row.length), 'times', [], ($$108 = function(i){var self = $$108.$$s || this, $b, entry = nil, $writer = nil;

        
          
          if (i == null) {
            i = nil;
          };
          entry = ($truthy($b = result['$[]'](i)) ? $b : (($writer = [i, []]), $send(result, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          return entry['$<<'](row.$at(i));}, $$108.$$s = self, $$108.$$arity = 1, $$108));}, $$107.$$s = self, $$107.$$arity = 1, $$107));
      return result;
    }, $Array_transpose$106.$$arity = 0);
    
    Opal.def(self, '$uniq', $Array_uniq$109 = function $$uniq() {
      var $iter = $Array_uniq$109.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$109.$$p = null;
      
      
      if ($iter) $Array_uniq$109.$$p = null;;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if (Opal.hash_get(hash, item) === undefined) {
            Opal.hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = Opal.yield1(block, item);
          if (Opal.hash_get(hash, key) === undefined) {
            Opal.hash_put(hash, key, item);
          }
        }
      }

      return toArraySubclass((hash).$values(), self.$class());
    ;
    }, $Array_uniq$109.$$arity = 0);
    
    Opal.def(self, '$uniq!', $Array_uniq$excl$110 = function() {
      var $iter = $Array_uniq$excl$110.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$excl$110.$$p = null;
      
      
      if ($iter) $Array_uniq$excl$110.$$p = null;;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : Opal.yield1(block, item));

        if (Opal.hash_get(hash, key) === undefined) {
          Opal.hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, $Array_uniq$excl$110.$$arity = 0);
    
    Opal.def(self, '$unshift', $Array_unshift$111 = function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = objects.length - 1; i >= 0; i--) {
        self.unshift(objects[i]);
      }
    ;
      return self;
    }, $Array_unshift$111.$$arity = -1);
    Opal.alias(self, "prepend", "unshift");
    
    Opal.def(self, '$values_at', $Array_values_at$112 = function $$values_at($a) {
      var $post_args, args, $$113, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], ($$113 = function(elem){var self = $$113.$$s || this, $$114, finish = nil, start = nil, i = nil;

      
        
        if (elem == null) {
          elem = nil;
        };
        if ($truthy(elem['$is_a?']($$($nesting, 'Range')))) {
          
          finish = $$($nesting, 'Opal').$coerce_to(elem.$last(), $$($nesting, 'Integer'), "to_int");
          start = $$($nesting, 'Opal').$coerce_to(elem.$first(), $$($nesting, 'Integer'), "to_int");
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']()) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], ($$114 = function(i){var self = $$114.$$s || this;

          
            
            if (i == null) {
              i = nil;
            };
            return out['$<<'](self.$at(i));}, $$114.$$s = self, $$114.$$arity = 1, $$114));
        } else {
          
          i = $$($nesting, 'Opal').$coerce_to(elem, $$($nesting, 'Integer'), "to_int");
          return out['$<<'](self.$at(i));
        };}, $$113.$$s = self, $$113.$$arity = 1, $$113));
      return out;
    }, $Array_values_at$112.$$arity = -1);
    
    Opal.def(self, '$zip', $Array_zip$115 = function $$zip($a) {
      var $iter = $Array_zip$115.$$p, block = $iter || nil, $post_args, others, $b, self = this;

      if ($iter) $Array_zip$115.$$p = null;
      
      
      if ($iter) $Array_zip$115.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_enumerator) {
          if (o.$size() === Infinity) {
            others[j] = o.$take(size);
          } else {
            others[j] = o.$to_a();
          }
          continue;
        }
        others[j] = ($truthy($b = $$($nesting, 'Opal')['$coerce_to?'](o, $$($nesting, 'Array'), "to_ary")) ? $b : $$($nesting, 'Opal')['$coerce_to!'](o, $$($nesting, 'Enumerator'), "each")).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          block(result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, $Array_zip$115.$$arity = -1);
    Opal.defs(self, '$inherited', $Array_inherited$116 = function $$inherited(klass) {
      var self = this;

      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, $Array_inherited$116.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Array_instance_variables$117 = function $$instance_variables() {
      var $$118, $iter = $Array_instance_variables$117.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_instance_variables$117.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $send($send(self, Opal.find_super_dispatcher(self, 'instance_variables', $Array_instance_variables$117, false), $zuper, $iter), 'reject', [], ($$118 = function(ivar){var self = $$118.$$s || this, $a;

      
        
        if (ivar == null) {
          ivar = nil;
        };
        return ($truthy($a = /^@\d+$/.test(ivar)) ? $a : ivar['$==']("@length"));}, $$118.$$s = self, $$118.$$arity = 1, $$118))
    }, $Array_instance_variables$117.$$arity = 0);
    $$($nesting, 'Opal').$pristine(self.$singleton_class(), "allocate");
    $$($nesting, 'Opal').$pristine(self, "copy_instance_variables", "initialize_dup");
    return (Opal.def(self, '$pack', $Array_pack$119 = function $$pack($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, $Array_pack$119.$$arity = -1), nil) && 'pack';
  })($nesting[0], Array, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/hash"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$new', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$dup', '$default_proc', '$default_proc=', '$-', '$default=', '$proc']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_$$$1, $Hash_allocate$2, $Hash_try_convert$3, $Hash_initialize$4, $Hash_$eq_eq$5, $Hash_$gt_eq$6, $Hash_$gt$8, $Hash_$lt$9, $Hash_$lt_eq$10, $Hash_$$$11, $Hash_$$$eq$12, $Hash_assoc$13, $Hash_clear$14, $Hash_clone$15, $Hash_compact$16, $Hash_compact$excl$17, $Hash_compare_by_identity$18, $Hash_compare_by_identity$ques$19, $Hash_default$20, $Hash_default$eq$21, $Hash_default_proc$22, $Hash_default_proc$eq$23, $Hash_delete$24, $Hash_delete_if$25, $Hash_dig$27, $Hash_each$28, $Hash_each_key$30, $Hash_each_value$32, $Hash_empty$ques$34, $Hash_fetch$35, $Hash_fetch_values$36, $Hash_flatten$38, $Hash_has_key$ques$39, $Hash_has_value$ques$40, $Hash_hash$41, $Hash_index$42, $Hash_indexes$43, $Hash_inspect$44, $Hash_invert$45, $Hash_keep_if$46, $Hash_keys$48, $Hash_length$49, $Hash_merge$50, $Hash_merge$excl$51, $Hash_rassoc$52, $Hash_rehash$53, $Hash_reject$54, $Hash_reject$excl$56, $Hash_replace$58, $Hash_select$59, $Hash_select$excl$61, $Hash_shift$63, $Hash_slice$64, $Hash_to_a$65, $Hash_to_h$66, $Hash_to_hash$67, $Hash_to_proc$68, $Hash_transform_keys$70, $Hash_transform_keys$excl$72, $Hash_transform_values$74, $Hash_transform_values$excl$76, $Hash_values$78;

    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_hash = true;
    Opal.defs(self, '$[]', $Hash_$$$1 = function($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if (argv === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, $Hash_$$$1.$$arity = -1);
    Opal.defs(self, '$allocate', $Hash_allocate$2 = function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      Opal.hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, $Hash_allocate$2.$$arity = 0);
    Opal.defs(self, '$try_convert', $Hash_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), "to_hash")
    }, $Hash_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$initialize', $Hash_initialize$4 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$4.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$4.$$p = null;
      
      
      if ($iter) $Hash_initialize$4.$$p = null;;
      ;
      
      if (defaults !== undefined && block !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, $Hash_initialize$4.$$arity = -1);
    
    Opal.def(self, '$==', $Hash_$eq_eq$5 = function(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = Opal.hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, $Hash_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$>=', $Hash_$gt_eq$6 = function(other) {
      var $$7, self = this, result = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], ($$7 = function(other_key, other_val){var self = $$7.$$s || this, val = nil;

      
        
        if (other_key == null) {
          other_key = nil;
        };
        
        if (other_val == null) {
          other_val = nil;
        };
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, $$7.$$s = self, $$7.$$arity = 2, $$7));
      return result;
    }, $Hash_$gt_eq$6.$$arity = 1);
    
    Opal.def(self, '$>', $Hash_$gt$8 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, $Hash_$gt$8.$$arity = 1);
    
    Opal.def(self, '$<', $Hash_$lt$9 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_gt(other, self);
    }, $Hash_$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=', $Hash_$lt_eq$10 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_ge(other, self);
    }, $Hash_$lt_eq$10.$$arity = 1);
    
    Opal.def(self, '$[]', $Hash_$$$11 = function(key) {
      var self = this;

      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, $Hash_$$$11.$$arity = 1);
    
    Opal.def(self, '$[]=', $Hash_$$$eq$12 = function(key, value) {
      var self = this;

      
      Opal.hash_put(self, key, value);
      return value;
    
    }, $Hash_$$$eq$12.$$arity = 2);
    
    Opal.def(self, '$assoc', $Hash_assoc$13 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, $Hash_assoc$13.$$arity = 1);
    
    Opal.def(self, '$clear', $Hash_clear$14 = function $$clear() {
      var self = this;

      
      Opal.hash_init(self);
      return self;
    
    }, $Hash_clear$14.$$arity = 0);
    
    Opal.def(self, '$clone', $Hash_clone$15 = function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_clone$15.$$arity = 0);
    
    Opal.def(self, '$compact', $Hash_compact$16 = function $$compact() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, $Hash_compact$16.$$arity = 0);
    
    Opal.def(self, '$compact!', $Hash_compact$excl$17 = function() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, $Hash_compact$excl$17.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity', $Hash_compare_by_identity$18 = function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, $Hash_compare_by_identity$18.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity?', $Hash_compare_by_identity$ques$19 = function() {
      var self = this;

      return self.$$by_identity === true;
    }, $Hash_compare_by_identity$ques$19.$$arity = 0);
    
    Opal.def(self, '$default', $Hash_default$20 = function(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, $Hash_default$20.$$arity = -1);
    
    Opal.def(self, '$default=', $Hash_default$eq$21 = function(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, $Hash_default$eq$21.$$arity = 1);
    
    Opal.def(self, '$default_proc', $Hash_default_proc$22 = function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, $Hash_default_proc$22.$$arity = 0);
    
    Opal.def(self, '$default_proc=', $Hash_default_proc$eq$23 = function(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          self.$raise($$($nesting, 'TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, $Hash_default_proc$eq$23.$$arity = 1);
    
    Opal.def(self, '$delete', $Hash_delete$24 = function(key) {
      var $iter = $Hash_delete$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_delete$24.$$p = null;
      
      
      if ($iter) $Hash_delete$24.$$p = null;;
      
      var value = Opal.hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, $Hash_delete$24.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Hash_delete_if$25 = function $$delete_if() {
      var $iter = $Hash_delete_if$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Hash_delete_if$25.$$p = null;
      
      
      if ($iter) $Hash_delete_if$25.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$26 = function(){var self = $$26.$$s || this;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_delete_if$25.$$arity = 0);
    Opal.alias(self, "dup", "clone");
    
    Opal.def(self, '$dig', $Hash_dig$27 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Hash_dig$27.$$arity = -2);
    
    Opal.def(self, '$each', $Hash_each$28 = function $$each() {
      var $iter = $Hash_each$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $Hash_each$28.$$p = null;
      
      
      if ($iter) $Hash_each$28.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$29 = function(){var self = $$29.$$s || this;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.yield1(block, [key, value]);
      }

      return self;
    ;
    }, $Hash_each$28.$$arity = 0);
    
    Opal.def(self, '$each_key', $Hash_each_key$30 = function $$each_key() {
      var $iter = $Hash_each_key$30.$$p, block = $iter || nil, $$31, self = this;

      if ($iter) $Hash_each_key$30.$$p = null;
      
      
      if ($iter) $Hash_each_key$30.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_key"], ($$31 = function(){var self = $$31.$$s || this;

        return self.$size()}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, $Hash_each_key$30.$$arity = 0);
    Opal.alias(self, "each_pair", "each");
    
    Opal.def(self, '$each_value', $Hash_each_value$32 = function $$each_value() {
      var $iter = $Hash_each_value$32.$$p, block = $iter || nil, $$33, self = this;

      if ($iter) $Hash_each_value$32.$$p = null;
      
      
      if ($iter) $Hash_each_value$32.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_value"], ($$33 = function(){var self = $$33.$$s || this;

        return self.$size()}, $$33.$$s = self, $$33.$$arity = 0, $$33))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, $Hash_each_value$32.$$arity = 0);
    
    Opal.def(self, '$empty?', $Hash_empty$ques$34 = function() {
      var self = this;

      return self.$$keys.length === 0;
    }, $Hash_empty$ques$34.$$arity = 0);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$fetch', $Hash_fetch$35 = function $$fetch(key, defaults) {
      var $iter = $Hash_fetch$35.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_fetch$35.$$p = null;
      
      
      if ($iter) $Hash_fetch$35.$$p = null;;
      ;
      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return self.$raise($$($nesting, 'KeyError').$new("" + "key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, $Hash_fetch$35.$$arity = -2);
    
    Opal.def(self, '$fetch_values', $Hash_fetch_values$36 = function $$fetch_values($a) {
      var $iter = $Hash_fetch_values$36.$$p, block = $iter || nil, $post_args, keys, $$37, self = this;

      if ($iter) $Hash_fetch_values$36.$$p = null;
      
      
      if ($iter) $Hash_fetch_values$36.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(keys, 'map', [], ($$37 = function(key){var self = $$37.$$s || this;

      
        
        if (key == null) {
          key = nil;
        };
        return $send(self, 'fetch', [key], block.$to_proc());}, $$37.$$s = self, $$37.$$arity = 1, $$37));
    }, $Hash_fetch_values$36.$$arity = -1);
    
    Opal.def(self, '$flatten', $Hash_flatten$38 = function $$flatten(level) {
      var self = this;

      
      
      if (level == null) {
        level = 1;
      };
      level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_flatten$38.$$arity = -1);
    
    Opal.def(self, '$has_key?', $Hash_has_key$ques$39 = function(key) {
      var self = this;

      return Opal.hash_get(self, key) !== undefined;
    }, $Hash_has_key$ques$39.$$arity = 1);
    
    Opal.def(self, '$has_value?', $Hash_has_value$ques$40 = function(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, $Hash_has_value$ques$40.$$arity = 1);
    
    Opal.def(self, '$hash', $Hash_hash$41 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Hash_hash$41.$$arity = 0);
    Opal.alias(self, "include?", "has_key?");
    
    Opal.def(self, '$index', $Hash_index$42 = function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, $Hash_index$42.$$arity = 1);
    
    Opal.def(self, '$indexes', $Hash_indexes$43 = function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = Opal.hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_indexes$43.$$arity = -1);
    Opal.alias(self, "indices", "indexes");
    var inspect_ids;
    
    Opal.def(self, '$inspect', $Hash_inspect$44 = function $$inspect() {
      var self = this;

      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];

      try {
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key.$inspect() + '=>' + value.$inspect());
        }

        return '{' + result.join(', ') + '}';

      } finally {
        if (top) {
          inspect_ids = undefined;
        }
      }
    
    }, $Hash_inspect$44.$$arity = 0);
    
    Opal.def(self, '$invert', $Hash_invert$45 = function $$invert() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.hash_put(hash, value, key);
      }

      return hash;
    
    }, $Hash_invert$45.$$arity = 0);
    
    Opal.def(self, '$keep_if', $Hash_keep_if$46 = function $$keep_if() {
      var $iter = $Hash_keep_if$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Hash_keep_if$46.$$p = null;
      
      
      if ($iter) $Hash_keep_if$46.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$47 = function(){var self = $$47.$$s || this;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_keep_if$46.$$arity = 0);
    Opal.alias(self, "key", "index");
    Opal.alias(self, "key?", "has_key?");
    
    Opal.def(self, '$keys', $Hash_keys$48 = function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, $Hash_keys$48.$$arity = 0);
    
    Opal.def(self, '$length', $Hash_length$49 = function $$length() {
      var self = this;

      return self.$$keys.length;
    }, $Hash_length$49.$$arity = 0);
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$merge', $Hash_merge$50 = function $$merge(other) {
      var $iter = $Hash_merge$50.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_merge$50.$$p = null;
      
      
      if ($iter) $Hash_merge$50.$$p = null;;
      return $send(self.$dup(), 'merge!', [other], block.$to_proc());
    }, $Hash_merge$50.$$arity = 1);
    
    Opal.def(self, '$merge!', $Hash_merge$excl$51 = function(other) {
      var $iter = $Hash_merge$excl$51.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_merge$excl$51.$$p = null;
      
      
      if ($iter) $Hash_merge$excl$51.$$p = null;;
      
      if (!other.$$is_hash) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      }

      var i, other_keys = other.$$keys, length = other_keys.length, key, value, other_value;

      if (block === nil) {
        for (i = 0; i < length; i++) {
          key = other_keys[i];

          if (key.$$is_string) {
            other_value = other.$$smap[key];
          } else {
            other_value = key.value;
            key = key.key;
          }

          Opal.hash_put(self, key, other_value);
        }

        return self;
      }

      for (i = 0; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        value = Opal.hash_get(self, key);

        if (value === undefined) {
          Opal.hash_put(self, key, other_value);
          continue;
        }

        Opal.hash_put(self, key, block(key, value, other_value));
      }

      return self;
    ;
    }, $Hash_merge$excl$51.$$arity = 1);
    
    Opal.def(self, '$rassoc', $Hash_rassoc$52 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, $Hash_rassoc$52.$$arity = 1);
    
    Opal.def(self, '$rehash', $Hash_rehash$53 = function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, $Hash_rehash$53.$$arity = 0);
    
    Opal.def(self, '$reject', $Hash_reject$54 = function $$reject() {
      var $iter = $Hash_reject$54.$$p, block = $iter || nil, $$55, self = this;

      if ($iter) $Hash_reject$54.$$p = null;
      
      
      if ($iter) $Hash_reject$54.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$55 = function(){var self = $$55.$$s || this;

        return self.$size()}, $$55.$$s = self, $$55.$$arity = 0, $$55))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_reject$54.$$arity = 0);
    
    Opal.def(self, '$reject!', $Hash_reject$excl$56 = function() {
      var $iter = $Hash_reject$excl$56.$$p, block = $iter || nil, $$57, self = this;

      if ($iter) $Hash_reject$excl$56.$$p = null;
      
      
      if ($iter) $Hash_reject$excl$56.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$57 = function(){var self = $$57.$$s || this;

        return self.$size()}, $$57.$$s = self, $$57.$$arity = 0, $$57))
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, $Hash_reject$excl$56.$$arity = 0);
    
    Opal.def(self, '$replace', $Hash_replace$58 = function $$replace(other) {
      var self = this, $writer = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      Opal.hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        Opal.hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, $Hash_replace$58.$$arity = 1);
    
    Opal.def(self, '$select', $Hash_select$59 = function $$select() {
      var $iter = $Hash_select$59.$$p, block = $iter || nil, $$60, self = this;

      if ($iter) $Hash_select$59.$$p = null;
      
      
      if ($iter) $Hash_select$59.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$60 = function(){var self = $$60.$$s || this;

        return self.$size()}, $$60.$$s = self, $$60.$$arity = 0, $$60))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_select$59.$$arity = 0);
    
    Opal.def(self, '$select!', $Hash_select$excl$61 = function() {
      var $iter = $Hash_select$excl$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Hash_select$excl$61.$$p = null;
      
      
      if ($iter) $Hash_select$excl$61.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, $Hash_select$excl$61.$$arity = 0);
    
    Opal.def(self, '$shift', $Hash_shift$63 = function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, Opal.hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, $Hash_shift$63.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$slice', $Hash_slice$64 = function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      
      var result = Opal.hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = Opal.hash_get(self, key);

        if (value !== undefined) {
          Opal.hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, $Hash_slice$64.$$arity = -1);
    Opal.alias(self, "store", "[]=");
    
    Opal.def(self, '$to_a', $Hash_to_a$65 = function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, $Hash_to_a$65.$$arity = 0);
    
    Opal.def(self, '$to_h', $Hash_to_h$66 = function $$to_h() {
      var self = this;

      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_to_h$66.$$arity = 0);
    
    Opal.def(self, '$to_hash', $Hash_to_hash$67 = function $$to_hash() {
      var self = this;

      return self
    }, $Hash_to_hash$67.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Hash_to_proc$68 = function $$to_proc() {
      var $$69, self = this;

      return $send(self, 'proc', [], ($$69 = function(key){var self = $$69.$$s || this;

      
        ;
        
        if (key == null) {
          self.$raise($$($nesting, 'ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, $$69.$$s = self, $$69.$$arity = -1, $$69))
    }, $Hash_to_proc$68.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transform_keys', $Hash_transform_keys$70 = function $$transform_keys() {
      var $iter = $Hash_transform_keys$70.$$p, block = $iter || nil, $$71, self = this;

      if ($iter) $Hash_transform_keys$70.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$70.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys"], ($$71 = function(){var self = $$71.$$s || this;

        return self.$size()}, $$71.$$s = self, $$71.$$arity = 0, $$71))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = Opal.yield1(block, key);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_keys$70.$$arity = 0);
    
    Opal.def(self, '$transform_keys!', $Hash_transform_keys$excl$72 = function() {
      var $iter = $Hash_transform_keys$excl$72.$$p, block = $iter || nil, $$73, self = this;

      if ($iter) $Hash_transform_keys$excl$72.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$excl$72.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys!"], ($$73 = function(){var self = $$73.$$s || this;

        return self.$size()}, $$73.$$s = self, $$73.$$arity = 0, $$73))
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = Opal.yield1(block, key);

        Opal.hash_delete(self, key);
        Opal.hash_put(self, new_key, value);
      }

      return self;
    ;
    }, $Hash_transform_keys$excl$72.$$arity = 0);
    
    Opal.def(self, '$transform_values', $Hash_transform_values$74 = function $$transform_values() {
      var $iter = $Hash_transform_values$74.$$p, block = $iter || nil, $$75, self = this;

      if ($iter) $Hash_transform_values$74.$$p = null;
      
      
      if ($iter) $Hash_transform_values$74.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values"], ($$75 = function(){var self = $$75.$$s || this;

        return self.$size()}, $$75.$$s = self, $$75.$$arity = 0, $$75))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_values$74.$$arity = 0);
    
    Opal.def(self, '$transform_values!', $Hash_transform_values$excl$76 = function() {
      var $iter = $Hash_transform_values$excl$76.$$p, block = $iter || nil, $$77, self = this;

      if ($iter) $Hash_transform_values$excl$76.$$p = null;
      
      
      if ($iter) $Hash_transform_values$excl$76.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values!"], ($$77 = function(){var self = $$77.$$s || this;

        return self.$size()}, $$77.$$s = self, $$77.$$arity = 0, $$77))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(self, key, value);
      }

      return self;
    ;
    }, $Hash_transform_values$excl$76.$$arity = 0);
    Opal.alias(self, "update", "merge!");
    Opal.alias(self, "value?", "has_value?");
    Opal.alias(self, "values_at", "indexes");
    return (Opal.def(self, '$values', $Hash_values$78 = function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, $Hash_values$78.$$arity = 0), nil) && 'values';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$%', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$truncate', '$-@', '$size', '$<=', '$>=', '$<=>', '$compare', '$any?']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $Number_coerce$2, $Number___id__$3, $Number_$plus$4, $Number_$minus$5, $Number_$$6, $Number_$slash$7, $Number_$percent$8, $Number_$$9, $Number_$$10, $Number_$$11, $Number_$lt$12, $Number_$lt_eq$13, $Number_$gt$14, $Number_$gt_eq$15, $Number_$lt_eq_gt$16, $Number_$lt$lt$17, $Number_$gt$gt$18, $Number_$$$19, $Number_$plus$$20, $Number_$minus$$21, $Number_$$22, $Number_$$$23, $Number_$eq_eq_eq$24, $Number_$eq_eq$25, $Number_abs$26, $Number_abs2$27, $Number_allbits$ques$28, $Number_anybits$ques$29, $Number_angle$30, $Number_bit_length$31, $Number_ceil$32, $Number_chr$33, $Number_denominator$34, $Number_downto$35, $Number_equal$ques$37, $Number_even$ques$38, $Number_floor$39, $Number_gcd$40, $Number_gcdlcm$41, $Number_integer$ques$42, $Number_is_a$ques$43, $Number_instance_of$ques$44, $Number_lcm$45, $Number_next$46, $Number_nobits$ques$47, $Number_nonzero$ques$48, $Number_numerator$49, $Number_odd$ques$50, $Number_ord$51, $Number_pow$52, $Number_pred$53, $Number_quo$54, $Number_rationalize$55, $Number_remainder$56, $Number_round$57, $Number_step$58, $Number_times$60, $Number_to_f$62, $Number_to_i$63, $Number_to_r$64, $Number_to_s$65, $Number_truncate$66, $Number_digits$67, $Number_divmod$68, $Number_upto$69, $Number_zero$ques$71, $Number_size$72, $Number_nan$ques$73, $Number_finite$ques$74, $Number_infinite$ques$75, $Number_positive$ques$76, $Number_negative$ques$77;

    
    $$($nesting, 'Opal').$bridge(Number, self);
    Opal.defineProperty(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$coerce', $Number_coerce$2 = function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [self.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
    
    }, $Number_coerce$2.$$arity = 1);
    
    Opal.def(self, '$__id__', $Number___id__$3 = function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, $Number___id__$3.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$+', $Number_$plus$4 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, $Number_$plus$4.$$arity = 1);
    
    Opal.def(self, '$-', $Number_$minus$5 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, $Number_$minus$5.$$arity = 1);
    
    Opal.def(self, '$*', $Number_$$6 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, $Number_$$6.$$arity = 1);
    
    Opal.def(self, '$/', $Number_$slash$7 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, $Number_$slash$7.$$arity = 1);
    Opal.alias(self, "fdiv", "/");
    
    Opal.def(self, '$%', $Number_$percent$8 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, $Number_$percent$8.$$arity = 1);
    
    Opal.def(self, '$&', $Number_$$9 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, $Number_$$9.$$arity = 1);
    
    Opal.def(self, '$|', $Number_$$10 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, $Number_$$10.$$arity = 1);
    
    Opal.def(self, '$^', $Number_$$11 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, $Number_$$11.$$arity = 1);
    
    Opal.def(self, '$<', $Number_$lt$12 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, $Number_$lt$12.$$arity = 1);
    
    Opal.def(self, '$<=', $Number_$lt_eq$13 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, $Number_$lt_eq$13.$$arity = 1);
    
    Opal.def(self, '$>', $Number_$gt$14 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, $Number_$gt$14.$$arity = 1);
    
    Opal.def(self, '$>=', $Number_$gt_eq$15 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, $Number_$gt_eq$15.$$arity = 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    Opal.def(self, '$<=>', $Number_$lt_eq_gt$16 = function(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Number_$lt_eq_gt$16.$$arity = 1);
    
    Opal.def(self, '$<<', $Number_$lt$lt$17 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, $Number_$lt$lt$17.$$arity = 1);
    
    Opal.def(self, '$>>', $Number_$gt$gt$18 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, $Number_$gt$gt$18.$$arity = 1);
    
    Opal.def(self, '$[]', $Number_$$$19 = function(bit) {
      var self = this;

      
      bit = $$($nesting, 'Opal')['$coerce_to!'](bit, $$($nesting, 'Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, $Number_$$$19.$$arity = 1);
    
    Opal.def(self, '$+@', $Number_$plus$$20 = function() {
      var self = this;

      return +self;
    }, $Number_$plus$$20.$$arity = 0);
    
    Opal.def(self, '$-@', $Number_$minus$$21 = function() {
      var self = this;

      return -self;
    }, $Number_$minus$$21.$$arity = 0);
    
    Opal.def(self, '$~', $Number_$$22 = function() {
      var self = this;

      return ~self;
    }, $Number_$$22.$$arity = 0);
    
    Opal.def(self, '$**', $Number_$$$23 = function(other) {
      var $a, $b, self = this;

      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy(($truthy($a = $$($nesting, 'Integer')['$==='](self)['$!']()) ? $a : $rb_gt(other, 0)))) {
          return Math.pow(self, other);
        } else {
          return $$($nesting, 'Rational').$new(self, 1)['$**'](other)
        }
      } else if ($truthy((($a = $rb_lt(self, 0)) ? ($truthy($b = $$($nesting, 'Float')['$==='](other)) ? $b : $$($nesting, 'Rational')['$==='](other)) : $rb_lt(self, 0)))) {
        return $$($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, $Number_$$$23.$$arity = 1);
    
    Opal.def(self, '$===', $Number_$eq_eq_eq$24 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq_eq$24.$$arity = 1);
    
    Opal.def(self, '$==', $Number_$eq_eq$25 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq$25.$$arity = 1);
    
    Opal.def(self, '$abs', $Number_abs$26 = function $$abs() {
      var self = this;

      return Math.abs(self);
    }, $Number_abs$26.$$arity = 0);
    
    Opal.def(self, '$abs2', $Number_abs2$27 = function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, $Number_abs2$27.$$arity = 0);
    
    Opal.def(self, '$allbits?', $Number_allbits$ques$28 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == mask;;
    }, $Number_allbits$ques$28.$$arity = 1);
    
    Opal.def(self, '$anybits?', $Number_anybits$ques$29 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) !== 0;;
    }, $Number_anybits$ques$29.$$arity = 1);
    
    Opal.def(self, '$angle', $Number_angle$30 = function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self};
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, $Number_angle$30.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    Opal.alias(self, "phase", "angle");
    
    Opal.def(self, '$bit_length', $Number_bit_length$31 = function $$bit_length() {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
      } else {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, $Number_bit_length$31.$$arity = 0);
    
    Opal.def(self, '$ceil', $Number_ceil$32 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_ceil$32.$$arity = -1);
    
    Opal.def(self, '$chr', $Number_chr$33 = function $$chr(encoding) {
      var self = this;

      
      ;
      return String.fromCharCode(self);;
    }, $Number_chr$33.$$arity = -1);
    
    Opal.def(self, '$denominator', $Number_denominator$34 = function $$denominator() {
      var $a, $iter = $Number_denominator$34.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_denominator$34.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
        return 1
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'denominator', $Number_denominator$34, false), $zuper, $iter)
      }
    }, $Number_denominator$34.$$arity = 0);
    
    Opal.def(self, '$downto', $Number_downto$35 = function $$downto(stop) {
      var $iter = $Number_downto$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $Number_downto$35.$$p = null;
      
      
      if ($iter) $Number_downto$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["downto", stop], ($$36 = function(){var self = $$36.$$s || this;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, $Number_downto$35.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$equal?', $Number_equal$ques$37 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$=='](other)) ? $a : isNaN(self) && isNaN(other))
    }, $Number_equal$ques$37.$$arity = 1);
    
    Opal.def(self, '$even?', $Number_even$ques$38 = function() {
      var self = this;

      return self % 2 === 0;
    }, $Number_even$ques$38.$$arity = 0);
    
    Opal.def(self, '$floor', $Number_floor$39 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_floor$39.$$arity = -1);
    
    Opal.def(self, '$gcd', $Number_gcd$40 = function $$gcd(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, $Number_gcd$40.$$arity = 1);
    
    Opal.def(self, '$gcdlcm', $Number_gcdlcm$41 = function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(), self.$lcm()]
    }, $Number_gcdlcm$41.$$arity = 1);
    
    Opal.def(self, '$integer?', $Number_integer$ques$42 = function() {
      var self = this;

      return self % 1 === 0;
    }, $Number_integer$ques$42.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Number_is_a$ques$43 = function(klass) {
      var $a, $iter = $Number_is_a$ques$43.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_is_a$ques$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Float'))) ? $$($nesting, 'Float')['$==='](self) : klass['$==']($$($nesting, 'Float'))))) {
        return true};
      return $send(self, Opal.find_super_dispatcher(self, 'is_a?', $Number_is_a$ques$43, false), $zuper, $iter);
    }, $Number_is_a$ques$43.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Number_instance_of$ques$44 = function(klass) {
      var $a, $iter = $Number_instance_of$ques$44.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_instance_of$ques$44.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Float'))) ? $$($nesting, 'Float')['$==='](self) : klass['$==']($$($nesting, 'Float'))))) {
        return true};
      return $send(self, Opal.find_super_dispatcher(self, 'instance_of?', $Number_instance_of$ques$44, false), $zuper, $iter);
    }, $Number_instance_of$ques$44.$$arity = 1);
    
    Opal.def(self, '$lcm', $Number_lcm$45 = function $$lcm(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, $Number_lcm$45.$$arity = 1);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$next', $Number_next$46 = function $$next() {
      var self = this;

      return self + 1;
    }, $Number_next$46.$$arity = 0);
    
    Opal.def(self, '$nobits?', $Number_nobits$ques$47 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == 0;;
    }, $Number_nobits$ques$47.$$arity = 1);
    
    Opal.def(self, '$nonzero?', $Number_nonzero$ques$48 = function() {
      var self = this;

      return self == 0 ? nil : self;
    }, $Number_nonzero$ques$48.$$arity = 0);
    
    Opal.def(self, '$numerator', $Number_numerator$49 = function $$numerator() {
      var $a, $iter = $Number_numerator$49.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_numerator$49.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
        return self
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'numerator', $Number_numerator$49, false), $zuper, $iter)
      }
    }, $Number_numerator$49.$$arity = 0);
    
    Opal.def(self, '$odd?', $Number_odd$ques$50 = function() {
      var self = this;

      return self % 2 !== 0;
    }, $Number_odd$ques$50.$$arity = 0);
    
    Opal.def(self, '$ord', $Number_ord$51 = function $$ord() {
      var self = this;

      return self
    }, $Number_ord$51.$$arity = 0);
    
    Opal.def(self, '$pow', $Number_pow$52 = function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$($nesting, 'Integer')['$==='](b))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$($nesting, 'Integer')['$==='](m))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, $Number_pow$52.$$arity = -2);
    
    Opal.def(self, '$pred', $Number_pred$53 = function $$pred() {
      var self = this;

      return self - 1;
    }, $Number_pred$53.$$arity = 0);
    
    Opal.def(self, '$quo', $Number_quo$54 = function $$quo(other) {
      var $iter = $Number_quo$54.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_quo$54.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $send(self, Opal.find_super_dispatcher(self, 'quo', $Number_quo$54, false), $zuper, $iter)
      } else {
        return $rb_divide(self, other)
      }
    }, $Number_quo$54.$$arity = 1);
    
    Opal.def(self, '$rationalize', $Number_rationalize$55 = function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $$($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, $Number_rationalize$55.$$arity = -1);
    
    Opal.def(self, '$remainder', $Number_remainder$56 = function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, $Number_remainder$56.$$arity = 1);
    
    Opal.def(self, '$round', $Number_round$57 = function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        
        if ($truthy(ndigits == null)) {
          return self};
        if ($truthy(($truthy($a = $$($nesting, 'Float')['$==='](ndigits)) ? ndigits['$infinite?']() : $a))) {
          self.$raise($$($nesting, 'RangeError'), "Infinity")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$($nesting, 'Integer'), 'MIN')))) {
          self.$raise($$($nesting, 'RangeError'), "out of bounds")};
        if ($truthy(ndigits >= 0)) {
          return self};
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(x) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if ($truthy(($truthy($a = self['$nan?']()) ? ndigits == null : $a))) {
          self.$raise($$($nesting, 'FloatDomainError'), "NaN")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            self.$raise($$($nesting, 'RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            self.$raise($$($nesting, 'FloatDomainError'), "Infinity")}
        } else if (ndigits['$=='](0)) {
          return Math.round(self)
        } else if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
          return self};
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_divide(exp, 4)
        } else {
          return $rb_minus($rb_divide(exp, 3), 1)
        }; return nil; })())))) {
          return self};
        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_plus($rb_divide(exp, 3), 1)
        } else {
          return $rb_divide(exp, 4)
        }; return nil; })()['$-@']()))) {
          return 0};
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, $Number_round$57.$$arity = -1);
    
    Opal.def(self, '$step', $Number_step$58 = function $$step($a, $b, $c) {
      var $iter = $Number_step$58.$$p, block = $iter || nil, $post_args, $kwargs, limit, step, to, by, $$59, self = this, positional_args = nil, keyword_args = nil;

      if ($iter) $Number_step$58.$$p = null;
      
      
      if ($iter) $Number_step$58.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        limit = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      if ($post_args.length > 0) {
        step = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "step is given twice")
      }

      function validateParameters() {
        if (to !== undefined) {
          limit = to;
        }

        if (limit === undefined) {
          limit = nil;
        }

        if (step === nil) {
          self.$raise($$($nesting, 'TypeError'), "step must be numeric")
        }

        if (step === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }

        if (by !== undefined) {
          step = by;
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
        }

        $$($nesting, 'Opal').$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }
    ;
      if ((block !== nil)) {
      } else {
        
        positional_args = [];
        keyword_args = $hash2([], {});
        
        if (limit !== undefined) {
          positional_args.push(limit);
        }

        if (step !== undefined) {
          positional_args.push(step);
        }

        if (to !== undefined) {
          Opal.hash_put(keyword_args, "to", to);
        }

        if (by !== undefined) {
          Opal.hash_put(keyword_args, "by", by);
        }

        if (keyword_args['$any?']()) {
          positional_args.push(keyword_args);
        }
      ;
        return $send(self, 'enum_for', ["step"].concat(Opal.to_a(positional_args)), ($$59 = function(){var self = $$59.$$s || this;

        return stepSize();}, $$59.$$s = self, $$59.$$arity = 0, $$59));
      };
      
      validateParameters();

      if (step === 0) {
        while (true) {
          block(self);
        }
      }

      if (self % 1 !== 0 || limit % 1 !== 0 || step % 1 !== 0) {
        var n = stepFloatSize();

        if (n > 0) {
          if (step === Infinity || step === -Infinity) {
            block(self);
          } else {
            var i = 0, d;

            if (step > 0) {
              while (i < n) {
                d = i * step + self;
                if (limit < d) {
                  d = limit;
                }
                block(d);
                i += 1;
              }
            } else {
              while (i < n) {
                d = i * step + self;
                if (limit > d) {
                  d = limit;
                }
                block(d);
                i += 1
              }
            }
          }
        }
      } else {
        var value = self;

        if (step > 0) {
          while (value <= limit) {
            block(value);
            value += step;
          }
        } else {
          while (value >= limit) {
            block(value);
            value += step
          }
        }
      }

      return self;
    ;
    }, $Number_step$58.$$arity = -1);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$times', $Number_times$60 = function $$times() {
      var $iter = $Number_times$60.$$p, block = $iter || nil, $$61, self = this;

      if ($iter) $Number_times$60.$$p = null;
      
      
      if ($iter) $Number_times$60.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["times"], ($$61 = function(){var self = $$61.$$s || this;

        return self}, $$61.$$s = self, $$61.$$arity = 0, $$61))
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_times$60.$$arity = 0);
    
    Opal.def(self, '$to_f', $Number_to_f$62 = function $$to_f() {
      var self = this;

      return self
    }, $Number_to_f$62.$$arity = 0);
    
    Opal.def(self, '$to_i', $Number_to_i$63 = function $$to_i() {
      var self = this;

      return parseInt(self, 10);
    }, $Number_to_i$63.$$arity = 0);
    Opal.alias(self, "to_int", "to_i");
    
    Opal.def(self, '$to_r', $Number_to_r$64 = function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, $Number_to_r$64.$$arity = 0);
    
    Opal.def(self, '$to_s', $Number_to_s$65 = function $$to_s(base) {
      var $a, self = this;

      
      
      if (base == null) {
        base = 10;
      };
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy(($truthy($a = $rb_lt(base, 2)) ? $a : $rb_gt(base, 36)))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      return self.toString(base);;
    }, $Number_to_s$65.$$arity = -1);
    
    Opal.def(self, '$truncate', $Number_truncate$66 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_truncate$66.$$arity = -1);
    Opal.alias(self, "inspect", "to_s");
    
    Opal.def(self, '$digits', $Number_digits$67 = function $$digits(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      if ($rb_lt(self, 0)) {
        self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "out of domain")};
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      
      var value = self, result = [];

      while (value !== 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, $Number_digits$67.$$arity = -1);
    
    Opal.def(self, '$divmod', $Number_divmod$68 = function $$divmod(other) {
      var $a, $iter = $Number_divmod$68.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_divmod$68.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : other['$nan?']()))) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'divmod', $Number_divmod$68, false), $zuper, $iter)
      }
    }, $Number_divmod$68.$$arity = 1);
    
    Opal.def(self, '$upto', $Number_upto$69 = function $$upto(stop) {
      var $iter = $Number_upto$69.$$p, block = $iter || nil, $$70, self = this;

      if ($iter) $Number_upto$69.$$p = null;
      
      
      if ($iter) $Number_upto$69.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["upto", stop], ($$70 = function(){var self = $$70.$$s || this;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, $$70.$$s = self, $$70.$$arity = 0, $$70))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_upto$69.$$arity = 1);
    
    Opal.def(self, '$zero?', $Number_zero$ques$71 = function() {
      var self = this;

      return self == 0;
    }, $Number_zero$ques$71.$$arity = 0);
    
    Opal.def(self, '$size', $Number_size$72 = function $$size() {
      var self = this;

      return 4
    }, $Number_size$72.$$arity = 0);
    
    Opal.def(self, '$nan?', $Number_nan$ques$73 = function() {
      var self = this;

      return isNaN(self);
    }, $Number_nan$ques$73.$$arity = 0);
    
    Opal.def(self, '$finite?', $Number_finite$ques$74 = function() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, $Number_finite$ques$74.$$arity = 0);
    
    Opal.def(self, '$infinite?', $Number_infinite$ques$75 = function() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, $Number_infinite$ques$75.$$arity = 0);
    
    Opal.def(self, '$positive?', $Number_positive$ques$76 = function() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, $Number_positive$ques$76.$$arity = 0);
    return (Opal.def(self, '$negative?', $Number_negative$ques$77 = function() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, $Number_negative$ques$77.$$arity = 0), nil) && 'negative?';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  Opal.const_set($nesting[0], 'Fixnum', $$($nesting, 'Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$78, $eq_eq_eq$79, $sqrt$80;

      
      
      Opal.def(self, '$allocate', $allocate$78 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$78.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      
      Opal.def(self, '$===', $eq_eq_eq$79 = function(other) {
        var self = this;

        
        if (!other.$$is_number) {
          return false;
        }

        return (other % 1) === 0;
      
      }, $eq_eq_eq$79.$$arity = 1);
      return (Opal.def(self, '$sqrt', $sqrt$80 = function $$sqrt(n) {
        var self = this;

        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        
        if (n < 0) {
          self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, $sqrt$80.$$arity = 1), nil) && 'sqrt';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$81, $eq_eq_eq$82;

      
      
      Opal.def(self, '$allocate', $allocate$81 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$81.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$===', $eq_eq_eq$82 = function(other) {
        var self = this;

        return !!other.$$is_number;
      }, $eq_eq_eq$82.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'INFINITY', Infinity);
    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);
    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);
    Opal.const_set($nesting[0], 'NAN', NaN);
    Opal.const_set($nesting[0], 'DIG', 15);
    Opal.const_set($nesting[0], 'MANT_DIG', 53);
    Opal.const_set($nesting[0], 'RADIX', 2);
    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/range"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$include?', '$<=', '$<', '$enum_for', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$!', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-', '$abs', '$to_i', '$coerce_to!', '$ceil', '$/', '$size', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $Range_initialize$1, $Range_$eq_eq$2, $Range_$eq_eq_eq$3, $Range_cover$ques$4, $Range_each$5, $Range_eql$ques$6, $Range_exclude_end$ques$7, $Range_first$8, $Range_last$9, $Range_max$10, $Range_min$11, $Range_size$12, $Range_step$13, $Range_bsearch$17, $Range_to_s$18, $Range_inspect$19, $Range_marshal_load$20, $Range_hash$21;

    self.$$prototype.begin = self.$$prototype.end = self.$$prototype.excl = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    Opal.def(self, '$initialize', $Range_initialize$1 = function $$initialize(first, last, exclude) {
      var self = this;

      
      
      if (exclude == null) {
        exclude = false;
      };
      if ($truthy(self.begin)) {
        self.$raise($$($nesting, 'NameError'), "'initialize' called twice")};
      if ($truthy(first['$<=>'](last))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, $Range_initialize$1.$$arity = -3);
    
    Opal.def(self, '$==', $Range_$eq_eq$2 = function(other) {
      var self = this;

      
      if (!other.$$is_range) {
        return false;
      }

      return self.excl  === other.excl &&
             self.begin ==  other.begin &&
             self.end   ==  other.end;
    
    }, $Range_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$===', $Range_$eq_eq_eq$3 = function(value) {
      var self = this;

      return self['$include?'](value)
    }, $Range_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$cover?', $Range_cover$ques$4 = function(value) {
      var $a, self = this, beg_cmp = nil, end_cmp = nil;

      
      beg_cmp = self.begin['$<=>'](value);
      if ($truthy(($truthy($a = beg_cmp) ? $rb_le(beg_cmp, 0) : $a))) {
      } else {
        return false
      };
      end_cmp = value['$<=>'](self.end);
      if ($truthy(self.excl)) {
        return ($truthy($a = end_cmp) ? $rb_lt(end_cmp, 0) : $a)
      } else {
        return ($truthy($a = end_cmp) ? $rb_le(end_cmp, 0) : $a)
      };
    }, $Range_cover$ques$4.$$arity = 1);
    
    Opal.def(self, '$each', $Range_each$5 = function $$each() {
      var $iter = $Range_each$5.$$p, block = $iter || nil, $a, self = this, current = nil, last = nil;

      if ($iter) $Range_each$5.$$p = null;
      
      
      if ($iter) $Range_each$5.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each")
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {
        return 0
      } else {
        return 1
      }; return nil; })(); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if ($truthy(current['$respond_to?']("succ"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't iterate from " + (current.$class()))
      };
      while ($truthy($rb_lt(current['$<=>'](last), 0))) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if ($truthy(($truthy($a = self.excl['$!']()) ? current['$=='](last) : $a))) {
        Opal.yield1(block, current)};
      return self;
    }, $Range_each$5.$$arity = 0);
    
    Opal.def(self, '$eql?', $Range_eql$ques$6 = function(other) {
      var $a, $b, self = this;

      
      if ($truthy($$($nesting, 'Range')['$==='](other))) {
      } else {
        return false
      };
      return ($truthy($a = ($truthy($b = self.excl['$==='](other['$exclude_end?']())) ? self.begin['$eql?'](other.$begin()) : $b)) ? self.end['$eql?'](other.$end()) : $a);
    }, $Range_eql$ques$6.$$arity = 1);
    
    Opal.def(self, '$exclude_end?', $Range_exclude_end$ques$7 = function() {
      var self = this;

      return self.excl
    }, $Range_exclude_end$ques$7.$$arity = 0);
    
    Opal.def(self, '$first', $Range_first$8 = function $$first(n) {
      var $iter = $Range_first$8.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_first$8.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      ;
      if ($truthy(n == null)) {
        return self.begin};
      return $send(self, Opal.find_super_dispatcher(self, 'first', $Range_first$8, false), $zuper, $iter);
    }, $Range_first$8.$$arity = -1);
    Opal.alias(self, "include?", "cover?");
    
    Opal.def(self, '$last', $Range_last$9 = function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(n == null)) {
        return self.end};
      return self.$to_a().$last(n);
    }, $Range_last$9.$$arity = -1);
    
    Opal.def(self, '$max', $Range_max$10 = function $$max() {
      var $a, $iter = $Range_max$10.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_max$10.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send(self, Opal.find_super_dispatcher(self, 'max', $Range_max$10, false), $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, $Range_max$10.$$arity = 0);
    Opal.alias(self, "member?", "cover?");
    
    Opal.def(self, '$min', $Range_min$11 = function $$min() {
      var $a, $iter = $Range_min$11.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_min$11.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send(self, Opal.find_super_dispatcher(self, 'min', $Range_min$11, false), $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {
        return nil
      } else {
        return self.begin
      }
    }, $Range_min$11.$$arity = 0);
    
    Opal.def(self, '$size', $Range_size$12 = function $$size() {
      var $a, self = this, range_begin = nil, range_end = nil, infinity = nil;

      
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)};
      if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](range_begin)) ? $$($nesting, 'Numeric')['$==='](range_end) : $a))) {
      } else {
        return nil
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0};
      infinity = $$$($$($nesting, 'Float'), 'INFINITY');
      if ($truthy([range_begin.$abs(), range_end.$abs()]['$include?'](infinity))) {
        return infinity};
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, $Range_size$12.$$arity = 0);
    
    Opal.def(self, '$step', $Range_step$13 = function $$step(n) {
      var $$14, $$15, $$16, $iter = $Range_step$13.$$p, $yield = $iter || nil, self = this, i = nil;

      if ($iter) $Range_step$13.$$p = null;
      
      
      if (n == null) {
        n = 1;
      };
      
      function coerceStepSize() {
        if (!n.$$is_number) {
          n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int")
        }

        if (n < 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", n], ($$14 = function(){var self = $$14.$$s || this;

        
          coerceStepSize();
          return enumeratorSize();
        }, $$14.$$s = self, $$14.$$arity = 0, $$14))
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$15 = function(){var self = $$15.$$s || this, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

        
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)}
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)};
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, $$15.$$s = self, $$15.$$brk = $brk, $$15.$$arity = 0, $$15))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], ($$16 = function(value, idx){var self = $$16.$$s || this;

        
          
          if (value == null) {
            value = nil;
          };
          
          if (idx == null) {
            idx = nil;
          };
          if (idx['$%'](n)['$=='](0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, $$16.$$s = self, $$16.$$arity = 2, $$16));
      };
      return self;
    }, $Range_step$13.$$arity = -1);
    
    Opal.def(self, '$bsearch', $Range_bsearch$17 = function $$bsearch() {
      var $iter = $Range_bsearch$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Range_bsearch$17.$$p = null;
      
      
      if ($iter) $Range_bsearch$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, $Range_bsearch$17.$$arity = 0);
    
    Opal.def(self, '$to_s', $Range_to_s$18 = function $$to_s() {
      var self = this;

      return "" + (self.begin) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + (self.end)
    }, $Range_to_s$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Range_inspect$19 = function $$inspect() {
      var self = this;

      return "" + (self.begin.$inspect()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + (self.end.$inspect())
    }, $Range_inspect$19.$$arity = 0);
    
    Opal.def(self, '$marshal_load', $Range_marshal_load$20 = function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, $Range_marshal_load$20.$$arity = 1);
    return (Opal.def(self, '$hash', $Range_hash$21 = function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, $Range_hash$21.$$arity = 0), nil) && 'hash';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/proc"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_to_proc$3, $Proc_lambda$ques$4, $Proc_arity$5, $Proc_source_location$6, $Proc_binding$7, $Proc_parameters$8, $Proc_curry$9, $Proc_dup$10;

    
    Opal.defineProperty(self.$$prototype, '$$is_proc', true);
    Opal.defineProperty(self.$$prototype, '$$is_lambda', false);
    Opal.defs(self, '$new', $Proc_new$1 = function() {
      var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Proc_new$1.$$p = null;
      
      
      if ($iter) $Proc_new$1.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, $Proc_new$1.$$arity = 0);
    
    Opal.def(self, '$call', $Proc_call$2 = function $$call($a) {
      var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Proc_call$2.$$p = null;
      
      
      if ($iter) $Proc_call$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, $Proc_call$2.$$arity = -1);
    Opal.alias(self, "[]", "call");
    Opal.alias(self, "===", "call");
    Opal.alias(self, "yield", "call");
    
    Opal.def(self, '$to_proc', $Proc_to_proc$3 = function $$to_proc() {
      var self = this;

      return self
    }, $Proc_to_proc$3.$$arity = 0);
    
    Opal.def(self, '$lambda?', $Proc_lambda$ques$4 = function() {
      var self = this;

      return !!self.$$is_lambda;
    }, $Proc_lambda$ques$4.$$arity = 0);
    
    Opal.def(self, '$arity', $Proc_arity$5 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, $Proc_arity$5.$$arity = 0);
    
    Opal.def(self, '$source_location', $Proc_source_location$6 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, $Proc_source_location$6.$$arity = 0);
    
    Opal.def(self, '$binding', $Proc_binding$7 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, $Proc_binding$7.$$arity = 0);
    
    Opal.def(self, '$parameters', $Proc_parameters$8 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, $Proc_parameters$8.$$arity = 0);
    
    Opal.def(self, '$curry', $Proc_curry$9 = function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, $Proc_curry$9.$$arity = -1);
    
    Opal.def(self, '$dup', $Proc_dup$10 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, $Proc_dup$10.$$arity = 0);
    return Opal.alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/method"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$arity', '$new', '$class', '$join', '$source_location', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Method');

    var $nesting = [self].concat($parent_nesting), $Method_initialize$1, $Method_arity$2, $Method_parameters$3, $Method_source_location$4, $Method_comments$5, $Method_call$6, $Method_unbind$7, $Method_to_proc$8, $Method_inspect$9;

    self.$$prototype.method = self.$$prototype.receiver = self.$$prototype.owner = self.$$prototype.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    Opal.def(self, '$initialize', $Method_initialize$1 = function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, $Method_initialize$1.$$arity = 4);
    
    Opal.def(self, '$arity', $Method_arity$2 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $Method_arity$2.$$arity = 0);
    
    Opal.def(self, '$parameters', $Method_parameters$3 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $Method_parameters$3.$$arity = 0);
    
    Opal.def(self, '$source_location', $Method_source_location$4 = function $$source_location() {
      var $a, self = this;

      return ($truthy($a = self.method.$$source_location) ? $a : ["(eval)", 0])
    }, $Method_source_location$4.$$arity = 0);
    
    Opal.def(self, '$comments', $Method_comments$5 = function $$comments() {
      var $a, self = this;

      return ($truthy($a = self.method.$$comments) ? $a : [])
    }, $Method_comments$5.$$arity = 0);
    
    Opal.def(self, '$call', $Method_call$6 = function $$call($a) {
      var $iter = $Method_call$6.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Method_call$6.$$p = null;
      
      
      if ($iter) $Method_call$6.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, $Method_call$6.$$arity = -1);
    Opal.alias(self, "[]", "call");
    
    Opal.def(self, '$unbind', $Method_unbind$7 = function $$unbind() {
      var self = this;

      return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, $Method_unbind$7.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Method_to_proc$8 = function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, $Method_to_proc$8.$$arity = 0);
    return (Opal.def(self, '$inspect', $Method_inspect$9 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $Method_inspect$9.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $nesting = [self].concat($parent_nesting), $UnboundMethod_initialize$10, $UnboundMethod_arity$11, $UnboundMethod_parameters$12, $UnboundMethod_source_location$13, $UnboundMethod_comments$14, $UnboundMethod_bind$15, $UnboundMethod_inspect$16;

    self.$$prototype.method = self.$$prototype.owner = self.$$prototype.name = self.$$prototype.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    Opal.def(self, '$initialize', $UnboundMethod_initialize$10 = function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, $UnboundMethod_initialize$10.$$arity = 4);
    
    Opal.def(self, '$arity', $UnboundMethod_arity$11 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $UnboundMethod_arity$11.$$arity = 0);
    
    Opal.def(self, '$parameters', $UnboundMethod_parameters$12 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $UnboundMethod_parameters$12.$$arity = 0);
    
    Opal.def(self, '$source_location', $UnboundMethod_source_location$13 = function $$source_location() {
      var $a, self = this;

      return ($truthy($a = self.method.$$source_location) ? $a : ["(eval)", 0])
    }, $UnboundMethod_source_location$13.$$arity = 0);
    
    Opal.def(self, '$comments', $UnboundMethod_comments$14 = function $$comments() {
      var $a, self = this;

      return ($truthy($a = self.method.$$comments) ? $a : [])
    }, $UnboundMethod_comments$14.$$arity = 0);
    
    Opal.def(self, '$bind', $UnboundMethod_bind$15 = function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, $UnboundMethod_bind$15.$$arity = 1);
    return (Opal.def(self, '$inspect', $UnboundMethod_inspect$16 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $UnboundMethod_inspect$16.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/variables"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new']);
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], 'ARGV', []);
  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

/* Generated by Opal 1.0.3 */
Opal.modules["opal/regexp_anchors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$==', '$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'REGEXP_START', (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "^"
    } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'REGEXP_END', (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "$"
    } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new("" + "[^" + ($$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new("" + ($$($nesting, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$($nesting, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["opal/mini"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  return self.$require("opal/regexp_anchors");
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/kernel/format"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$==', '$length', '$respond_to?', '$[]', '$coerce_to?', '$nil?', '$to_a', '$raise', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$coerce_to', '$inspect', '$to_s']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_format$1;

    
    
    Opal.def(self, '$format', $Kernel_format$1 = function $$format(format_string, $a) {
      var $post_args, args, $b, self = this, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy((($b = args.$length()['$=='](1)) ? args['$[]'](0)['$respond_to?']("to_ary") : args.$length()['$=='](1)))) {
        
        ary = $$($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if ($truthy(ary['$nil?']())) {
        } else {
          args = ary.$to_a()
        };};
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "flag after width") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "width given twice") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { self.$raise($$($nesting, 'ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with numbered")
        case -2: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with named")
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              self.$raise($$($nesting, 'ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                self.$raise($$($nesting, 'ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  self.$raise($$($nesting, 'ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              self.$raise($$($nesting, 'ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = self.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            self.$raise($$($nesting, 'NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($$($nesting, 'Opal').$coerce_to(arg, $$($nesting, 'Integer'), "to_int"));
            }
            if (str.length !== 1) {
              self.$raise($$($nesting, 'ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        self.$raise($$($nesting, 'ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, $Kernel_format$1.$$arity = -2);
    Opal.alias(self, "sprintf", "format");
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/string/encoding"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var $$12, $$15, $$18, $$21, $$24, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$+', '$[]', '$new', '$to_proc', '$each', '$const_set', '$sub', '$==', '$default_external', '$upcase', '$raise', '$attr_accessor', '$attr_reader', '$register', '$length', '$bytes', '$to_a', '$each_byte', '$bytesize', '$enum_for', '$each_codepoint', '$force_encoding', '$dup', '$coerce_to!', '$find', '$getbyte']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_to_s$7, $Encoding_inspect$8, $Encoding_each_byte$9, $Encoding_getbyte$10, $Encoding_bytesize$11;

    self.$$prototype.ascii = self.$$prototype.dummy = self.$$prototype.name = nil;
    
    Opal.defineProperty(self, '$$register', {});
    Opal.defs(self, '$register', $Encoding_register$1 = function $$register(name, options) {
      var $iter = $Encoding_register$1.$$p, block = $iter || nil, $a, $$2, self = this, names = nil, encoding = nil, register = nil;

      if ($iter) $Encoding_register$1.$$p = null;
      
      
      if ($iter) $Encoding_register$1.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      names = $rb_plus([name], ($truthy($a = options['$[]']("aliases")) ? $a : []));
      encoding = $send($$($nesting, 'Class'), 'new', [self], block.$to_proc()).$new(name, names, ($truthy($a = options['$[]']("ascii")) ? $a : false), ($truthy($a = options['$[]']("dummy")) ? $a : false));
      register = self["$$register"];
      return $send(names, 'each', [], ($$2 = function(encoding_name){var self = $$2.$$s || this;

      
        
        if (encoding_name == null) {
          encoding_name = nil;
        };
        self.$const_set(encoding_name.$sub("-", "_"), encoding);
        return register["" + "$$" + (encoding_name)] = encoding;}, $$2.$$s = self, $$2.$$arity = 1, $$2));
    }, $Encoding_register$1.$$arity = -2);
    Opal.defs(self, '$find', $Encoding_find$3 = function $$find(name) {
      var $a, self = this, register = nil, encoding = nil;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      register = self["$$register"];
      encoding = ($truthy($a = register["" + "$$" + (name)]) ? $a : register["" + "$$" + (name.$upcase())]);
      if ($truthy(encoding)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "unknown encoding name - " + (name))
      };
      return encoding;
    }, $Encoding_find$3.$$arity = 1);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("default_external")
    })(Opal.get_singleton_class(self), $nesting);
    self.$attr_reader("name", "names");
    
    Opal.def(self, '$initialize', $Encoding_initialize$4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, $Encoding_initialize$4.$$arity = 4);
    
    Opal.def(self, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
      var self = this;

      return self.ascii
    }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
    
    Opal.def(self, '$dummy?', $Encoding_dummy$ques$6 = function() {
      var self = this;

      return self.dummy
    }, $Encoding_dummy$ques$6.$$arity = 0);
    
    Opal.def(self, '$to_s', $Encoding_to_s$7 = function $$to_s() {
      var self = this;

      return self.name
    }, $Encoding_to_s$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Encoding_inspect$8 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
      } else {
        return nil
      }; return nil; })()) + ">"
    }, $Encoding_inspect$8.$$arity = 0);
    
    Opal.def(self, '$each_byte', $Encoding_each_byte$9 = function $$each_byte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_each_byte$9.$$arity = -1);
    
    Opal.def(self, '$getbyte', $Encoding_getbyte$10 = function $$getbyte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_getbyte$10.$$arity = -1);
    
    Opal.def(self, '$bytesize', $Encoding_bytesize$11 = function $$bytesize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_bytesize$11.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EncodingError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompatibilityError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send($$($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], ($$12 = function(){var self = $$12.$$s || this, $each_byte$13, $bytesize$14;

  
    
    Opal.def(self, '$each_byte', $each_byte$13 = function $$each_byte(string) {
      var $iter = $each_byte$13.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$13.$$p = null;
      
      
      if ($iter) $each_byte$13.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        if (code <= 0x7f) {
          Opal.yield1(block, code);
        }
        else {
          var encoded = encodeURIComponent(string.charAt(i)).substr(1).split('%');

          for (var j = 0, encoded_length = encoded.length; j < encoded_length; j++) {
            Opal.yield1(block, parseInt(encoded[j], 16));
          }
        }
      }
    ;
    }, $each_byte$13.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$14 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$14.$$arity = 1), nil) && 'bytesize';}, $$12.$$s = self, $$12.$$arity = 0, $$12));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16LE"], ($$15 = function(){var self = $$15.$$s || this, $each_byte$16, $bytesize$17;

  
    
    Opal.def(self, '$each_byte', $each_byte$16 = function $$each_byte(string) {
      var $iter = $each_byte$16.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$16.$$p = null;
      
      
      if ($iter) $each_byte$16.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$16.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$17 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$17.$$arity = 1), nil) && 'bytesize';}, $$15.$$s = self, $$15.$$arity = 0, $$15));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16BE"], ($$18 = function(){var self = $$18.$$s || this, $each_byte$19, $bytesize$20;

  
    
    Opal.def(self, '$each_byte', $each_byte$19 = function $$each_byte(string) {
      var $iter = $each_byte$19.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$19.$$p = null;
      
      
      if ($iter) $each_byte$19.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$19.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$20 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$20.$$arity = 1), nil) && 'bytesize';}, $$18.$$s = self, $$18.$$arity = 0, $$18));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32LE"], ($$21 = function(){var self = $$21.$$s || this, $each_byte$22, $bytesize$23;

  
    
    Opal.def(self, '$each_byte', $each_byte$22 = function $$each_byte(string) {
      var $iter = $each_byte$22.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$22.$$p = null;
      
      
      if ($iter) $each_byte$22.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$22.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$23 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$23.$$arity = 1), nil) && 'bytesize';}, $$21.$$s = self, $$21.$$arity = 0, $$21));
  $send($$($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii", "dummy"], {"aliases": ["BINARY", "US-ASCII", "ASCII"], "ascii": true, "dummy": true})], ($$24 = function(){var self = $$24.$$s || this, $each_byte$25, $bytesize$26;

  
    
    Opal.def(self, '$each_byte', $each_byte$25 = function $$each_byte(string) {
      var $iter = $each_byte$25.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$25.$$p = null;
      
      
      if ($iter) $each_byte$25.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$25.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$26 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$26.$$arity = 1), nil) && 'bytesize';}, $$24.$$s = self, $$24.$$arity = 0, $$24));
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_bytes$27, $String_bytesize$28, $String_each_byte$29, $String_each_codepoint$30, $String_codepoints$31, $String_encode$32, $String_force_encoding$33, $String_getbyte$34, $String_valid_encoding$ques$35;

    self.$$prototype.encoding = nil;
    
    self.$attr_reader("encoding");
    Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_16LE'));
    
    Opal.def(self, '$bytes', $String_bytes$27 = function $$bytes() {
      var self = this;

      return self.$each_byte().$to_a()
    }, $String_bytes$27.$$arity = 0);
    
    Opal.def(self, '$bytesize', $String_bytesize$28 = function $$bytesize() {
      var self = this;

      return self.encoding.$bytesize(self)
    }, $String_bytesize$28.$$arity = 0);
    
    Opal.def(self, '$each_byte', $String_each_byte$29 = function $$each_byte() {
      var $iter = $String_each_byte$29.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_byte$29.$$p = null;
      
      
      if ($iter) $String_each_byte$29.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_byte")
      };
      $send(self.encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, $String_each_byte$29.$$arity = 0);
    
    Opal.def(self, '$each_codepoint', $String_each_codepoint$30 = function $$each_codepoint() {
      var $iter = $String_each_codepoint$30.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_codepoint$30.$$p = null;
      
      
      if ($iter) $String_each_codepoint$30.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, $String_each_codepoint$30.$$arity = 0);
    
    Opal.def(self, '$codepoints', $String_codepoints$31 = function $$codepoints() {
      var $iter = $String_codepoints$31.$$p, block = $iter || nil, self = this;

      if ($iter) $String_codepoints$31.$$p = null;
      
      
      if ($iter) $String_codepoints$31.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())};
      return self.$each_codepoint().$to_a();
    }, $String_codepoints$31.$$arity = 0);
    
    Opal.def(self, '$encode', $String_encode$32 = function $$encode(encoding) {
      var self = this;

      return self.$dup().$force_encoding(encoding)
    }, $String_encode$32.$$arity = 1);
    
    Opal.def(self, '$force_encoding', $String_force_encoding$33 = function $$force_encoding(encoding) {
      var self = this;

      
      if (encoding === self.encoding) { return self; }

      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
      encoding = $$($nesting, 'Encoding').$find(encoding);

      if (encoding === self.encoding) { return self; }

      self.encoding = encoding;
      return self;
    
    }, $String_force_encoding$33.$$arity = 1);
    
    Opal.def(self, '$getbyte', $String_getbyte$34 = function $$getbyte(idx) {
      var self = this;

      return self.encoding.$getbyte(self, idx)
    }, $String_getbyte$34.$$arity = 1);
    return (Opal.def(self, '$valid_encoding?', $String_valid_encoding$ques$35 = function() {
      var self = this;

      return true
    }, $String_valid_encoding$ques$35.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/math"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$raise', '$Float', '$type_error', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $Math_checked$1, $Math_float$excl$2, $Math_integer$excl$3, $Math_acos$4, $Math_acosh$5, $Math_asin$6, $Math_asinh$7, $Math_atan$8, $Math_atan2$9, $Math_atanh$10, $Math_cbrt$11, $Math_cos$12, $Math_cosh$13, $Math_erf$14, $Math_erfc$15, $Math_exp$16, $Math_frexp$17, $Math_gamma$18, $Math_hypot$19, $Math_ldexp$20, $Math_lgamma$21, $Math_log$22, $Math_log10$23, $Math_log2$24, $Math_sin$25, $Math_sinh$26, $Math_sqrt$27, $Math_tan$28, $Math_tanh$29;

    
    Opal.const_set($nesting[0], 'E', Math.E);
    Opal.const_set($nesting[0], 'PI', Math.PI);
    Opal.const_set($nesting[0], 'DomainError', $$($nesting, 'Class').$new($$($nesting, 'StandardError')));
    Opal.defs(self, '$checked', $Math_checked$1 = function $$checked(method, $a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        self.$raise($$($nesting, 'DomainError'), "" + "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, $Math_checked$1.$$arity = -2);
    Opal.defs(self, '$float!', $Math_float$excl$2 = function(value) {
      var self = this;

      try {
        return self.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($$($nesting, 'Opal').$type_error(value, $$($nesting, 'Float')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_float$excl$2.$$arity = 1);
    Opal.defs(self, '$integer!', $Math_integer$excl$3 = function(value) {
      var self = this;

      try {
        return self.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($$($nesting, 'Opal').$type_error(value, $$($nesting, 'Integer')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_integer$excl$3.$$arity = 1);
    self.$module_function();
    
    Opal.def(self, '$acos', $Math_acos$4 = function $$acos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acos$4.$$arity = 1);
    if ($truthy((typeof(Math.acosh) !== "undefined"))) {
    } else {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };
    
    Opal.def(self, '$acosh', $Math_acosh$5 = function $$acosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acosh$5.$$arity = 1);
    
    Opal.def(self, '$asin', $Math_asin$6 = function $$asin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asin$6.$$arity = 1);
    if ($truthy((typeof(Math.asinh) !== "undefined"))) {
    } else {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    
    };
    
    Opal.def(self, '$asinh', $Math_asinh$7 = function $$asinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asinh$7.$$arity = 1);
    
    Opal.def(self, '$atan', $Math_atan$8 = function $$atan(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan$8.$$arity = 1);
    
    Opal.def(self, '$atan2', $Math_atan2$9 = function $$atan2(y, x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan2", $$($nesting, 'Math')['$float!'](y), $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan2$9.$$arity = 2);
    if ($truthy((typeof(Math.atanh) !== "undefined"))) {
    } else {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };
    
    Opal.def(self, '$atanh', $Math_atanh$10 = function $$atanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atanh$10.$$arity = 1);
    if ($truthy((typeof(Math.cbrt) !== "undefined"))) {
    } else {
      
      Math.cbrt = function(x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r  = x,
            ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);

        return r;
      }
    
    };
    
    Opal.def(self, '$cbrt', $Math_cbrt$11 = function $$cbrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cbrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cbrt$11.$$arity = 1);
    
    Opal.def(self, '$cos', $Math_cos$12 = function $$cos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cos$12.$$arity = 1);
    if ($truthy((typeof(Math.cosh) !== "undefined"))) {
    } else {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$cosh', $Math_cosh$13 = function $$cosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cosh$13.$$arity = 1);
    if ($truthy((typeof(Math.erf) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    
    Opal.def(self, '$erf', $Math_erf$14 = function $$erf(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erf", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erf$14.$$arity = 1);
    if ($truthy((typeof(Math.erfc) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    
    Opal.def(self, '$erfc', $Math_erfc$15 = function $$erfc(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erfc", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erfc$15.$$arity = 1);
    
    Opal.def(self, '$exp', $Math_exp$16 = function $$exp(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("exp", $$($nesting, 'Math')['$float!'](x))
    }, $Math_exp$16.$$arity = 1);
    
    Opal.def(self, '$frexp', $Math_frexp$17 = function $$frexp(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, $Math_frexp$17.$$arity = 1);
    
    Opal.def(self, '$gamma', $Math_gamma$18 = function $$gamma(n) {
      var self = this;

      
      n = $$($nesting, 'Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        self.$raise($$($nesting, 'DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$($nesting, 'Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$($nesting, 'Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, $Math_gamma$18.$$arity = 1);
    if ($truthy((typeof(Math.hypot) !== "undefined"))) {
    } else {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    
    };
    
    Opal.def(self, '$hypot', $Math_hypot$19 = function $$hypot(x, y) {
      var self = this;

      return $$($nesting, 'Math').$checked("hypot", $$($nesting, 'Math')['$float!'](x), $$($nesting, 'Math')['$float!'](y))
    }, $Math_hypot$19.$$arity = 2);
    
    Opal.def(self, '$ldexp', $Math_ldexp$20 = function $$ldexp(mantissa, exponent) {
      var self = this;

      
      mantissa = $$($nesting, 'Math')['$float!'](mantissa);
      exponent = $$($nesting, 'Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        self.$raise($$($nesting, 'RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, $Math_ldexp$20.$$arity = 2);
    
    Opal.def(self, '$lgamma', $Math_lgamma$21 = function $$lgamma(n) {
      var self = this;

      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$($nesting, 'Math').$gamma(n))), $$($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, $Math_lgamma$21.$$arity = 1);
    
    Opal.def(self, '$log', $Math_log$22 = function $$log(x, base) {
      var self = this;

      
      ;
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};
      if ($truthy(base == null)) {
        return $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x))
      } else {
        
        if ($truthy($$($nesting, 'String')['$==='](base))) {
          self.$raise($$($nesting, 'Opal').$type_error(base, $$($nesting, 'Float')))};
        return $rb_divide($$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x)), $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](base)));
      };
    }, $Math_log$22.$$arity = -2);
    if ($truthy((typeof(Math.log10) !== "undefined"))) {
    } else {
      
      Math.log10 = function(x) {
        return Math.log(x) / Math.LN10;
      }
    
    };
    
    Opal.def(self, '$log10', $Math_log10$23 = function $$log10(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log10", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log10$23.$$arity = 1);
    if ($truthy((typeof(Math.log2) !== "undefined"))) {
    } else {
      
      Math.log2 = function(x) {
        return Math.log(x) / Math.LN2;
      }
    
    };
    
    Opal.def(self, '$log2', $Math_log2$24 = function $$log2(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($$($nesting, 'Opal').$type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log2", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log2$24.$$arity = 1);
    
    Opal.def(self, '$sin', $Math_sin$25 = function $$sin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sin$25.$$arity = 1);
    if ($truthy((typeof(Math.sinh) !== "undefined"))) {
    } else {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$sinh', $Math_sinh$26 = function $$sinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sinh$26.$$arity = 1);
    
    Opal.def(self, '$sqrt', $Math_sqrt$27 = function $$sqrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sqrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sqrt$27.$$arity = 1);
    
    Opal.def(self, '$tan', $Math_tan$28 = function $$tan(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$($nesting, 'Float'), 'NAN')};
      return $$($nesting, 'Math').$checked("tan", $$($nesting, 'Math')['$float!'](x));
    }, $Math_tan$28.$$arity = 1);
    if ($truthy((typeof(Math.tanh) !== "undefined"))) {
    } else {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };
    
    Opal.def(self, '$tanh', $Math_tanh$29 = function $$tanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("tanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_tanh$29.$$arity = 1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/complex"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$finite?', '$infinite?', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?', '$Rational']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $Complex_rect$1, $Complex_polar$2, $Complex_initialize$3, $Complex_coerce$4, $Complex_$eq_eq$5, $Complex_$minus$$6, $Complex_$plus$7, $Complex_$minus$8, $Complex_$$9, $Complex_$slash$10, $Complex_$$$11, $Complex_abs$12, $Complex_abs2$13, $Complex_angle$14, $Complex_conj$15, $Complex_denominator$16, $Complex_eql$ques$17, $Complex_fdiv$18, $Complex_finite$ques$19, $Complex_hash$20, $Complex_infinite$ques$21, $Complex_inspect$22, $Complex_numerator$23, $Complex_polar$24, $Complex_rationalize$25, $Complex_real$ques$26, $Complex_rect$27, $Complex_to_f$28, $Complex_to_i$29, $Complex_to_r$30, $Complex_to_s$31;

    self.$$prototype.real = self.$$prototype.imag = nil;
    
    Opal.defs(self, '$rect', $Complex_rect$1 = function $$rect(real, imag) {
      var $a, $b, $c, self = this;

      
      
      if (imag == null) {
        imag = 0;
      };
      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Numeric')['$==='](real)) ? real['$real?']() : $c)) ? $$($nesting, 'Numeric')['$==='](imag) : $b)) ? imag['$real?']() : $a))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, $Complex_rect$1.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return Opal.alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$polar', $Complex_polar$2 = function $$polar(r, theta) {
      var $a, $b, $c, self = this;

      
      
      if (theta == null) {
        theta = 0;
      };
      if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Numeric')['$==='](r)) ? r['$real?']() : $c)) ? $$($nesting, 'Numeric')['$==='](theta) : $b)) ? theta['$real?']() : $a))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$($nesting, 'Math').$cos(theta)), $rb_times(r, $$($nesting, 'Math').$sin(theta)));
    }, $Complex_polar$2.$$arity = -2);
    self.$attr_reader("real", "imag");
    
    Opal.def(self, '$initialize', $Complex_initialize$3 = function $$initialize(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = 0;
      };
      self.real = real;
      return (self.imag = imag);
    }, $Complex_initialize$3.$$arity = -2);
    
    Opal.def(self, '$coerce', $Complex_coerce$4 = function $$coerce(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return [other, self]
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return [$$($nesting, 'Complex').$new(other, 0), self]
      } else {
        return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, $Complex_coerce$4.$$arity = 1);
    
    Opal.def(self, '$==', $Complex_$eq_eq$5 = function(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return (($a = self.real['$=='](other.$real())) ? self.imag['$=='](other.$imag()) : self.real['$=='](other.$real()))
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return (($a = self.real['$=='](other)) ? self.imag['$=='](0) : self.real['$=='](other))
      } else {
        return other['$=='](self)
      }
    }, $Complex_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$-@', $Complex_$minus$$6 = function() {
      var self = this;

      return self.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, $Complex_$minus$$6.$$arity = 0);
    
    Opal.def(self, '$+', $Complex_$plus$7 = function(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, $Complex_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Complex_$minus$8 = function(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, $Complex_$minus$8.$$arity = 1);
    
    Opal.def(self, '$*', $Complex_$$9 = function(other) {
      var $a, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, $Complex_$$9.$$arity = 1);
    
    Opal.def(self, '$/', $Complex_$slash$10 = function(other) {
      var $a, $b, $c, $d, self = this;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = $$($nesting, 'Number')['$==='](self.real)) ? self.real['$nan?']() : $d)) ? $c : ($truthy($d = $$($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $d))) ? $b : ($truthy($c = $$($nesting, 'Number')['$==='](other.$real())) ? other.$real()['$nan?']() : $c))) ? $a : ($truthy($b = $$($nesting, 'Number')['$==='](other.$imag())) ? other.$imag()['$nan?']() : $b)))) {
          return $$($nesting, 'Complex').$new($$$($$($nesting, 'Float'), 'NAN'), $$$($$($nesting, 'Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](other)) ? other['$real?']() : $a))) {
        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, $Complex_$slash$10.$$arity = 1);
    
    Opal.def(self, '$**', $Complex_$$$11 = function(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil;

      
      if (other['$=='](0)) {
        return $$($nesting, 'Complex').$new(1, 0)};
      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$($nesting, 'Math').$exp($rb_minus($rb_times(ore, $$($nesting, 'Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$($nesting, 'Math').$log(r)));
        return $$($nesting, 'Complex').$polar(nr, ntheta);
      } else if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($truthy(n['$!='](0))) {
            
            $c = n.$divmod(2), $b = Opal.to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;
            while (mod['$=='](0)) {
              
              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if ($truthy(($truthy($a = $$($nesting, 'Float')['$==='](other)) ? $a : $$($nesting, 'Rational')['$==='](other)))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, $Complex_$$$11.$$arity = 1);
    
    Opal.def(self, '$abs', $Complex_abs$12 = function $$abs() {
      var self = this;

      return $$($nesting, 'Math').$hypot(self.real, self.imag)
    }, $Complex_abs$12.$$arity = 0);
    
    Opal.def(self, '$abs2', $Complex_abs2$13 = function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, $Complex_abs2$13.$$arity = 0);
    
    Opal.def(self, '$angle', $Complex_angle$14 = function $$angle() {
      var self = this;

      return $$($nesting, 'Math').$atan2(self.imag, self.real)
    }, $Complex_angle$14.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$conj', $Complex_conj$15 = function $$conj() {
      var self = this;

      return self.$Complex(self.real, self.imag['$-@']())
    }, $Complex_conj$15.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Complex_denominator$16 = function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, $Complex_denominator$16.$$arity = 0);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$eql?', $Complex_eql$ques$17 = function(other) {
      var $a, $b, self = this;

      return ($truthy($a = ($truthy($b = $$($nesting, 'Complex')['$==='](other)) ? self.real.$class()['$=='](self.imag.$class()) : $b)) ? self['$=='](other) : $a)
    }, $Complex_eql$ques$17.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Complex_fdiv$18 = function $$fdiv(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Numeric')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, $Complex_fdiv$18.$$arity = 1);
    
    Opal.def(self, '$finite?', $Complex_finite$ques$19 = function() {
      var $a, self = this;

      return ($truthy($a = self.real['$finite?']()) ? self.imag['$finite?']() : $a)
    }, $Complex_finite$ques$19.$$arity = 0);
    
    Opal.def(self, '$hash', $Complex_hash$20 = function $$hash() {
      var self = this;

      return "" + "Complex:" + (self.real) + ":" + (self.imag)
    }, $Complex_hash$20.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$infinite?', $Complex_infinite$ques$21 = function() {
      var $a, self = this;

      return ($truthy($a = self.real['$infinite?']()) ? $a : self.imag['$infinite?']())
    }, $Complex_infinite$ques$21.$$arity = 0);
    
    Opal.def(self, '$inspect', $Complex_inspect$22 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Complex_inspect$22.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.def(self, '$numerator', $Complex_numerator$23 = function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, $Complex_numerator$23.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Complex_polar$24 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Complex_polar$24.$$arity = 0);
    
    Opal.udef(self, '$' + "positive?");;
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Complex_rationalize$25 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy(self.imag['$!='](0))) {
        self.$raise($$($nesting, 'RangeError'), "" + "can't' convert " + (self) + " into Rational")};
      return self.$real().$rationalize(eps);
    }, $Complex_rationalize$25.$$arity = -1);
    
    Opal.def(self, '$real?', $Complex_real$ques$26 = function() {
      var self = this;

      return false
    }, $Complex_real$ques$26.$$arity = 0);
    
    Opal.def(self, '$rect', $Complex_rect$27 = function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, $Complex_rect$27.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$to_f', $Complex_to_f$28 = function $$to_f() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, $Complex_to_f$28.$$arity = 0);
    
    Opal.def(self, '$to_i', $Complex_to_i$29 = function $$to_i() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, $Complex_to_i$29.$$arity = 0);
    
    Opal.def(self, '$to_r', $Complex_to_r$30 = function $$to_r() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, $Complex_to_r$30.$$arity = 0);
    
    Opal.def(self, '$to_s', $Complex_to_s$31 = function $$to_s() {
      var $a, $b, $c, self = this, result = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (function() {if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = $$($nesting, 'Number')['$==='](self.imag)) ? self.imag['$nan?']() : $c)) ? $b : self.imag['$positive?']())) ? $a : self.imag['$zero?']()))) {
        return "+"
      } else {
        return "-"
      }; return nil; })());
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if ($truthy(($truthy($a = $$($nesting, 'Number')['$==='](self.imag)) ? ($truthy($b = self.imag['$nan?']()) ? $b : self.imag['$infinite?']()) : $a))) {
        result = $rb_plus(result, "*")};
      return $rb_plus(result, "i");
    }, $Complex_to_s$31.$$arity = 0);
    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Complex$32;

    
    Opal.def(self, '$Complex', $Kernel_Complex$32 = function $$Complex(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = nil;
      };
      if ($truthy(imag)) {
        return $$($nesting, 'Complex').$new(real, imag)
      } else {
        return $$($nesting, 'Complex').$new(real, 0)
      };
    }, $Kernel_Complex$32.$$arity = -2)
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_c$33;

    return (Opal.def(self, '$to_c', $String_to_c$33 = function $$to_c() {
      var self = this;

      
      var str = self,
          re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return self.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return self.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return self.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return self.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return self.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return self.$Complex(real, imag);
      }
    
    }, $String_to_c$33.$$arity = 0), nil) && 'to_c'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/rational"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$<=', '$truncate', '$send', '$convert']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Rational');

    var $nesting = [self].concat($parent_nesting), $Rational_reduce$1, $Rational_convert$2, $Rational_initialize$3, $Rational_numerator$4, $Rational_denominator$5, $Rational_coerce$6, $Rational_$eq_eq$7, $Rational_$lt_eq_gt$8, $Rational_$plus$9, $Rational_$minus$10, $Rational_$$11, $Rational_$slash$12, $Rational_$$$13, $Rational_abs$14, $Rational_ceil$15, $Rational_floor$16, $Rational_hash$17, $Rational_inspect$18, $Rational_rationalize$19, $Rational_round$20, $Rational_to_f$21, $Rational_to_i$22, $Rational_to_r$23, $Rational_to_s$24, $Rational_truncate$25, $Rational_with_precision$26;

    self.$$prototype.num = self.$$prototype.den = nil;
    
    Opal.defs(self, '$reduce', $Rational_reduce$1 = function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if (den['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if (den['$=='](1)) {
        return self.$new(num, den)};
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, $Rational_reduce$1.$$arity = 2);
    Opal.defs(self, '$convert', $Rational_convert$2 = function $$convert(num, den) {
      var $a, $b, self = this;

      
      if ($truthy(($truthy($a = num['$nil?']()) ? $a : den['$nil?']()))) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert nil into Rational")};
      if ($truthy(($truthy($a = $$($nesting, 'Integer')['$==='](num)) ? $$($nesting, 'Integer')['$==='](den) : $a))) {
        return self.$reduce(num, den)};
      if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Float')['$==='](num)) ? $b : $$($nesting, 'String')['$==='](num))) ? $a : $$($nesting, 'Complex')['$==='](num)))) {
        num = num.$to_r()};
      if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Float')['$==='](den)) ? $b : $$($nesting, 'String')['$==='](den))) ? $a : $$($nesting, 'Complex')['$==='](den)))) {
        den = den.$to_r()};
      if ($truthy(($truthy($a = den['$equal?'](1)) ? $$($nesting, 'Integer')['$==='](num)['$!']() : $a))) {
        return $$($nesting, 'Opal')['$coerce_to!'](num, $$($nesting, 'Rational'), "to_r")
      } else if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](num)) ? $$($nesting, 'Numeric')['$==='](den) : $a))) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, $Rational_convert$2.$$arity = 2);
    
    Opal.def(self, '$initialize', $Rational_initialize$3 = function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, $Rational_initialize$3.$$arity = 2);
    
    Opal.def(self, '$numerator', $Rational_numerator$4 = function $$numerator() {
      var self = this;

      return self.num
    }, $Rational_numerator$4.$$arity = 0);
    
    Opal.def(self, '$denominator', $Rational_denominator$5 = function $$denominator() {
      var self = this;

      return self.den
    }, $Rational_denominator$5.$$arity = 0);
    
    Opal.def(self, '$coerce', $Rational_coerce$6 = function $$coerce(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return [other, self]}
      else if ($$($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}
      else if ($$($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}
      else { return nil }})()
    }, $Rational_coerce$6.$$arity = 1);
    
    Opal.def(self, '$==', $Rational_$eq_eq$7 = function(other) {
      var $a, self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return (($a = self.num['$=='](other.$numerator())) ? self.den['$=='](other.$denominator()) : self.num['$=='](other.$numerator()))}
      else if ($$($nesting, 'Integer')['$===']($case)) {return (($a = self.num['$=='](other)) ? self.den['$=='](1) : self.num['$=='](other))}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}
      else {return other['$=='](self)}})()
    }, $Rational_$eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Rational_$lt_eq_gt$8 = function(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}
      else if ($$($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}
      else {return self.$__coerced__("<=>", other)}})()
    }, $Rational_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$+', $Rational_$plus$9 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}
      else {return self.$__coerced__("+", other)}})()
    }, $Rational_$plus$9.$$arity = 1);
    
    Opal.def(self, '$-', $Rational_$minus$10 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}
      else {return self.$__coerced__("-", other)}})()
    }, $Rational_$minus$10.$$arity = 1);
    
    Opal.def(self, '$*', $Rational_$$11 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$numerator());
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}
      else {return self.$__coerced__("*", other)}})()
    }, $Rational_$$11.$$arity = 1);
    
    Opal.def(self, '$/', $Rational_$slash$12 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$denominator());
      den = $rb_times(self.den, other.$numerator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {
        return $rb_divide(self.$to_f(), 0.0)
      } else {
        return self.$Rational(self.num, $rb_times(self.den, other))
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}
      else {return self.$__coerced__("/", other)}})()
    }, $Rational_$slash$12.$$arity = 1);
    
    Opal.def(self, '$**', $Rational_$$$13 = function(other) {
      var $a, self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {
        return $$$($$($nesting, 'Float'), 'INFINITY')
      } else if ($truthy($rb_gt(other, 0))) {
        return self.$Rational(self.num['$**'](other), self.den['$**'](other))
      } else if ($truthy($rb_lt(other, 0))) {
        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
      } else {
        return self.$Rational(1, 1)
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}
      else if ($$($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {
        return self.$Rational(1, 1)
      } else if (other.$denominator()['$=='](1)) {
        if ($truthy($rb_lt(other, 0))) {
          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
        } else {
          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
        }
      } else if ($truthy((($a = self['$=='](0)) ? $rb_lt(other, 0) : self['$=='](0)))) {
        return self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else {
        return self.$to_f()['$**'](other)
      }}
      else {return self.$__coerced__("**", other)}})()
    }, $Rational_$$$13.$$arity = 1);
    
    Opal.def(self, '$abs', $Rational_abs$14 = function $$abs() {
      var self = this;

      return self.$Rational(self.num.$abs(), self.den.$abs())
    }, $Rational_abs$14.$$arity = 0);
    
    Opal.def(self, '$ceil', $Rational_ceil$15 = function $$ceil(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, $Rational_ceil$15.$$arity = -1);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$floor', $Rational_floor$16 = function $$floor(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, $Rational_floor$16.$$arity = -1);
    
    Opal.def(self, '$hash', $Rational_hash$17 = function $$hash() {
      var self = this;

      return "" + "Rational:" + (self.num) + ":" + (self.den)
    }, $Rational_hash$17.$$arity = 0);
    
    Opal.def(self, '$inspect', $Rational_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Rational_inspect$18.$$arity = 0);
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Rational_rationalize$19 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return self.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, $Rational_rationalize$19.$$arity = -1);
    
    Opal.def(self, '$round', $Rational_round$20 = function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
      } else {
        return self.$with_precision("round", precision)
      };
      if (self.num['$=='](0)) {
        return 0};
      if (self.den['$=='](1)) {
        return self.num};
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, $Rational_round$20.$$arity = -1);
    
    Opal.def(self, '$to_f', $Rational_to_f$21 = function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, $Rational_to_f$21.$$arity = 0);
    
    Opal.def(self, '$to_i', $Rational_to_i$22 = function $$to_i() {
      var self = this;

      return self.$truncate()
    }, $Rational_to_i$22.$$arity = 0);
    
    Opal.def(self, '$to_r', $Rational_to_r$23 = function $$to_r() {
      var self = this;

      return self
    }, $Rational_to_r$23.$$arity = 0);
    
    Opal.def(self, '$to_s', $Rational_to_s$24 = function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, $Rational_to_s$24.$$arity = 0);
    
    Opal.def(self, '$truncate', $Rational_truncate$25 = function $$truncate(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, $Rational_truncate$25.$$arity = -1);
    return (Opal.def(self, '$with_precision', $Rational_with_precision$26 = function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if ($truthy($$($nesting, 'Integer')['$==='](precision))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return self.$Rational(s.$send(method), p)
      };
    }, $Rational_with_precision$26.$$arity = 2), nil) && 'with_precision';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Rational$27;

    
    Opal.def(self, '$Rational', $Kernel_Rational$27 = function $$Rational(numerator, denominator) {
      var self = this;

      
      
      if (denominator == null) {
        denominator = 1;
      };
      return $$($nesting, 'Rational').$convert(numerator, denominator);
    }, $Kernel_Rational$27.$$arity = -2)
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_r$28;

    return (Opal.def(self, '$to_r', $String_to_r$28 = function $$to_r() {
      var self = this;

      
      var str = self.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return self.$Rational(numerator, denominator);
          } else {
            return self.$Rational(numerator, 1);
          }
        } else {
          return self.$Rational(numerator, 1);
        }
      } else {
        return self.$Rational(0, 1);
      }
    
    }, $String_to_r$28.$$arity = 0), nil) && 'to_r'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/time"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_at$1, $Time_new$2, $Time_local$3, $Time_gm$4, $Time_now$5, $Time_$plus$6, $Time_$minus$7, $Time_$lt_eq_gt$8, $Time_$eq_eq$9, $Time_asctime$10, $Time_day$11, $Time_yday$12, $Time_isdst$13, $Time_dup$14, $Time_eql$ques$15, $Time_friday$ques$16, $Time_hash$17, $Time_hour$18, $Time_inspect$19, $Time_min$20, $Time_mon$21, $Time_monday$ques$22, $Time_saturday$ques$23, $Time_sec$24, $Time_succ$25, $Time_usec$26, $Time_zone$27, $Time_getgm$28, $Time_gmtime$29, $Time_gmt$ques$30, $Time_gmt_offset$31, $Time_strftime$32, $Time_sunday$ques$33, $Time_thursday$ques$34, $Time_to_a$35, $Time_to_f$36, $Time_to_i$37, $Time_tuesday$ques$38, $Time_wday$39, $Time_wednesday$ques$40, $Time_year$41, $Time_cweek_cyear$42;

    
    self.$include($$($nesting, 'Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    Opal.defs(self, '$at', $Time_at$1 = function $$at(seconds, frac) {
      var self = this;

      
      ;
      
      var result;

      if ($$($nesting, 'Time')['$==='](seconds)) {
        if (frac !== undefined) {
          self.$raise($$($nesting, 'TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.is_utc = seconds.is_utc;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $$($nesting, 'Opal')['$coerce_to!'](seconds, $$($nesting, 'Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $$($nesting, 'Opal')['$coerce_to!'](frac, $$($nesting, 'Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, $Time_at$1.$$arity = -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $$($nesting, 'Opal')['$coerce_to!'](year, $$($nesting, 'Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $$($nesting, 'Opal')['$coerce_to!'](month, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $$($nesting, 'Opal')['$coerce_to!'](day, $$($nesting, 'Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $$($nesting, 'Opal')['$coerce_to!'](hour, $$($nesting, 'Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $$($nesting, 'Opal')['$coerce_to!'](min, $$($nesting, 'Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $$($nesting, 'Opal')['$coerce_to!'](sec, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    Opal.defs(self, '$new', $Time_new$2 = function(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (utc_offset == null) {
        utc_offset = nil;
      };
      
      var args, result;

      if (year === undefined) {
        return new Date();
      }

      if (utc_offset !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time")
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_new$2.$$arity = -1);
    Opal.defs(self, '$local', $Time_local$3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_local$3.$$arity = -2);
    Opal.defs(self, '$gm', $Time_gm$4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.is_utc = true;
      return result;
    ;
    }, $Time_gm$4.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      
      Opal.alias(self, "mktime", "local");
      return Opal.alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$now', $Time_now$5 = function $$now() {
      var self = this;

      return self.$new()
    }, $Time_now$5.$$arity = 0);
    
    Opal.def(self, '$+', $Time_$plus$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        self.$raise($$($nesting, 'TypeError'), "time + time?")};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$plus$6.$$arity = 1);
    
    Opal.def(self, '$-', $Time_$minus$7 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return (self.getTime() - other.getTime()) / 1000};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$minus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Time_$lt_eq_gt$8 = function(other) {
      var self = this, r = nil;

      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, $Time_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $Time_$eq_eq$9 = function(other) {
      var $a, self = this;

      return ($truthy($a = $$($nesting, 'Time')['$==='](other)) ? self.$to_f() === other.$to_f() : $a)
    }, $Time_$eq_eq$9.$$arity = 1);
    
    Opal.def(self, '$asctime', $Time_asctime$10 = function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, $Time_asctime$10.$$arity = 0);
    Opal.alias(self, "ctime", "asctime");
    
    Opal.def(self, '$day', $Time_day$11 = function $$day() {
      var self = this;

      return self.is_utc ? self.getUTCDate() : self.getDate();
    }, $Time_day$11.$$arity = 0);
    
    Opal.def(self, '$yday', $Time_yday$12 = function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$($nesting, 'Time').$new(self.$year()).$to_i();
      start_of_day = $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, $Time_yday$12.$$arity = 0);
    
    Opal.def(self, '$isdst', $Time_isdst$13 = function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, $Time_isdst$13.$$arity = 0);
    Opal.alias(self, "dst?", "isdst");
    
    Opal.def(self, '$dup', $Time_dup$14 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Time_dup$14.$$arity = 0);
    
    Opal.def(self, '$eql?', $Time_eql$ques$15 = function(other) {
      var $a, self = this;

      return ($truthy($a = other['$is_a?']($$($nesting, 'Time'))) ? self['$<=>'](other)['$zero?']() : $a)
    }, $Time_eql$ques$15.$$arity = 1);
    
    Opal.def(self, '$friday?', $Time_friday$ques$16 = function() {
      var self = this;

      return self.$wday() == 5
    }, $Time_friday$ques$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Time_hash$17 = function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, $Time_hash$17.$$arity = 0);
    
    Opal.def(self, '$hour', $Time_hour$18 = function $$hour() {
      var self = this;

      return self.is_utc ? self.getUTCHours() : self.getHours();
    }, $Time_hour$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Time_inspect$19 = function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, $Time_inspect$19.$$arity = 0);
    Opal.alias(self, "mday", "day");
    
    Opal.def(self, '$min', $Time_min$20 = function $$min() {
      var self = this;

      return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
    }, $Time_min$20.$$arity = 0);
    
    Opal.def(self, '$mon', $Time_mon$21 = function $$mon() {
      var self = this;

      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
    }, $Time_mon$21.$$arity = 0);
    
    Opal.def(self, '$monday?', $Time_monday$ques$22 = function() {
      var self = this;

      return self.$wday() == 1
    }, $Time_monday$ques$22.$$arity = 0);
    Opal.alias(self, "month", "mon");
    
    Opal.def(self, '$saturday?', $Time_saturday$ques$23 = function() {
      var self = this;

      return self.$wday() == 6
    }, $Time_saturday$ques$23.$$arity = 0);
    
    Opal.def(self, '$sec', $Time_sec$24 = function $$sec() {
      var self = this;

      return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
    }, $Time_sec$24.$$arity = 0);
    
    Opal.def(self, '$succ', $Time_succ$25 = function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.is_utc = self.is_utc;
      return result;
    
    }, $Time_succ$25.$$arity = 0);
    
    Opal.def(self, '$usec', $Time_usec$26 = function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, $Time_usec$26.$$arity = 0);
    
    Opal.def(self, '$zone', $Time_zone$27 = function $$zone() {
      var self = this;

      
      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, $Time_zone$27.$$arity = 0);
    
    Opal.def(self, '$getgm', $Time_getgm$28 = function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.is_utc = true;
      return result;
    
    }, $Time_getgm$28.$$arity = 0);
    Opal.alias(self, "getutc", "getgm");
    
    Opal.def(self, '$gmtime', $Time_gmtime$29 = function $$gmtime() {
      var self = this;

      
      self.is_utc = true;
      return self;
    
    }, $Time_gmtime$29.$$arity = 0);
    Opal.alias(self, "utc", "gmtime");
    
    Opal.def(self, '$gmt?', $Time_gmt$ques$30 = function() {
      var self = this;

      return self.is_utc === true;
    }, $Time_gmt$ques$30.$$arity = 0);
    
    Opal.def(self, '$gmt_offset', $Time_gmt_offset$31 = function $$gmt_offset() {
      var self = this;

      return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
    }, $Time_gmt_offset$31.$$arity = 0);
    
    Opal.def(self, '$strftime', $Time_strftime$32 = function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "",
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = self.getTimezoneOffset(),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, $Time_strftime$32.$$arity = 1);
    
    Opal.def(self, '$sunday?', $Time_sunday$ques$33 = function() {
      var self = this;

      return self.$wday() == 0
    }, $Time_sunday$ques$33.$$arity = 0);
    
    Opal.def(self, '$thursday?', $Time_thursday$ques$34 = function() {
      var self = this;

      return self.$wday() == 4
    }, $Time_thursday$ques$34.$$arity = 0);
    
    Opal.def(self, '$to_a', $Time_to_a$35 = function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, $Time_to_a$35.$$arity = 0);
    
    Opal.def(self, '$to_f', $Time_to_f$36 = function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, $Time_to_f$36.$$arity = 0);
    
    Opal.def(self, '$to_i', $Time_to_i$37 = function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, $Time_to_i$37.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$tuesday?', $Time_tuesday$ques$38 = function() {
      var self = this;

      return self.$wday() == 2
    }, $Time_tuesday$ques$38.$$arity = 0);
    Opal.alias(self, "tv_sec", "to_i");
    Opal.alias(self, "tv_usec", "usec");
    Opal.alias(self, "utc?", "gmt?");
    Opal.alias(self, "gmtoff", "gmt_offset");
    Opal.alias(self, "utc_offset", "gmt_offset");
    
    Opal.def(self, '$wday', $Time_wday$39 = function $$wday() {
      var self = this;

      return self.is_utc ? self.getUTCDay() : self.getDay();
    }, $Time_wday$39.$$arity = 0);
    
    Opal.def(self, '$wednesday?', $Time_wednesday$ques$40 = function() {
      var self = this;

      return self.$wday() == 3
    }, $Time_wednesday$ques$40.$$arity = 0);
    
    Opal.def(self, '$year', $Time_year$41 = function $$year() {
      var self = this;

      return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
    }, $Time_year$41.$$arity = 0);
    return (Opal.def(self, '$cweek_cyear', $Time_cweek_cyear$42 = function $$cweek_cyear() {
      var $a, self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil;

      
      jan01 = $$($nesting, 'Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if ($truthy(($truthy($a = $rb_le(jan01_wday, 4)) ? jan01_wday['$!='](0) : $a))) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if (offset['$=='](-8)) {
          offset = -1};
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if (week['$=='](53)) {
        
        dec31 = $$($nesting, 'Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if ($truthy(($truthy($a = $rb_le(dec31_wday, 3)) ? dec31_wday['$!='](0) : $a))) {
          
          week = 1;
          year = $rb_plus(year, 1);};};
      return [week, year];
    }, $Time_cweek_cyear$42.$$arity = 0), nil) && 'cweek_cyear';
  })($nesting[0], Date, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/struct"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$alias_method', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$class', '$last', '$>', '$length', '$-', '$keys', '$any?', '$join', '$[]', '$[]=', '$each_with_index', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$each_pair', '$inspect', '$each_with_object', '$flatten', '$to_a', '$respond_to?', '$dig']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_new$1, $Struct_define_struct_attribute$6, $Struct_members$9, $Struct_inherited$10, $Struct_initialize$12, $Struct_members$15, $Struct_hash$16, $Struct_$$$17, $Struct_$$$eq$18, $Struct_$eq_eq$19, $Struct_eql$ques$20, $Struct_each$21, $Struct_each_pair$24, $Struct_length$27, $Struct_to_a$28, $Struct_inspect$30, $Struct_to_h$32, $Struct_values_at$34, $Struct_dig$36;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$new', $Struct_new$1 = function(const_name, $a, $b) {
      var $iter = $Struct_new$1.$$p, block = $iter || nil, $post_args, $kwargs, args, keyword_init, $$2, $$3, self = this, klass = nil;

      if ($iter) $Struct_new$1.$$p = null;
      
      
      if ($iter) $Struct_new$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) {
        keyword_init = false
      };
      if ($truthy(const_name)) {
        
        try {
          const_name = $$($nesting, 'Opal')['$const_name!'](const_name)
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'TypeError'), $$($nesting, 'NameError')])) {
            try {
              
              args.$unshift(const_name);
              const_name = nil;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };};
      $send(args, 'map', [], ($$2 = function(arg){var self = $$2.$$s || this;

      
        
        if (arg == null) {
          arg = nil;
        };
        return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), "to_str");}, $$2.$$s = self, $$2.$$arity = 1, $$2));
      klass = $send($$($nesting, 'Class'), 'new', [self], ($$3 = function(){var self = $$3.$$s || this, $$4;

      
        $send(args, 'each', [], ($$4 = function(arg){var self = $$4.$$s || this;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$define_struct_attribute(arg);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
        return (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $new$5;

          
          
          Opal.def(self, '$new', $new$5 = function($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', Opal.to_a(args));
            return instance;
          }, $new$5.$$arity = -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, $$3.$$s = self, $$3.$$arity = 0, $$3));
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())};
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$($nesting, 'Struct').$const_set(const_name, klass)};
      return klass;
    }, $Struct_new$1.$$arity = -2);
    Opal.defs(self, '$define_struct_attribute', $Struct_define_struct_attribute$6 = function $$define_struct_attribute(name) {
      var $$7, $$8, self = this;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class")};
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], ($$7 = function(){var self = $$7.$$s || this;

      return self.$$data[name];}, $$7.$$s = self, $$7.$$arity = 0, $$7));
      return $send(self, 'define_method', ["" + (name) + "="], ($$8 = function(value){var self = $$8.$$s || this;

      
        
        if (value == null) {
          value = nil;
        };
        return self.$$data[name] = value;;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
    }, $Struct_define_struct_attribute$6.$$arity = 1);
    Opal.defs(self, '$members', $Struct_members$9 = function $$members() {
      var $a, self = this;
      if (self.members == null) self.members = nil;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "the Struct class has no members")};
      return (self.members = ($truthy($a = self.members) ? $a : []));
    }, $Struct_members$9.$$arity = 0);
    Opal.defs(self, '$inherited', $Struct_inherited$10 = function $$inherited(klass) {
      var $$11, self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], ($$11 = function(){var self = $$11.$$s || this;

      return (self.members = members)}, $$11.$$s = self, $$11.$$arity = 0, $$11));
    }, $Struct_inherited$10.$$arity = 1);
    
    Opal.def(self, '$initialize', $Struct_initialize$12 = function $$initialize($a) {
      var $post_args, args, $b, $$13, $$14, self = this, kwargs = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy($b = args.$last()) ? $b : $hash2([], {}));
        if ($truthy(($truthy($b = $rb_gt(args.$length(), 1)) ? $b : (args.length === 1 && !kwargs.$$is_hash)))) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$length()) + ", expected 0)")};
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "unknown keywords: " + (extra.$join(", ")))};
        return $send(self.$class().$members(), 'each', [], ($$13 = function(name){var self = $$13.$$s || this, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          $writer = [name, kwargs['$[]'](name)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          self.$raise($$($nesting, 'ArgumentError'), "struct size differs")};
        return $send(self.$class().$members(), 'each_with_index', [], ($$14 = function(name, index){var self = $$14.$$s || this, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          $writer = [name, args['$[]'](index)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$14.$$s = self, $$14.$$arity = 2, $$14));
      };
    }, $Struct_initialize$12.$$arity = -1);
    
    Opal.def(self, '$members', $Struct_members$15 = function $$members() {
      var self = this;

      return self.$class().$members()
    }, $Struct_members$15.$$arity = 0);
    
    Opal.def(self, '$hash', $Struct_hash$16 = function $$hash() {
      var self = this;

      return $$($nesting, 'Hash').$new(self.$$data).$hash()
    }, $Struct_hash$16.$$arity = 0);
    
    Opal.def(self, '$[]', $Struct_$$$17 = function(name) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name];;
    }, $Struct_$$$17.$$arity = 1);
    
    Opal.def(self, '$[]=', $Struct_$$$eq$18 = function(name, value) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
        } else {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name] = value;;
    }, $Struct_$$$eq$18.$$arity = 2);
    
    Opal.def(self, '$==', $Struct_$eq_eq$19 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_$eq_eq$19.$$arity = 1);
    
    Opal.def(self, '$eql?', $Struct_eql$ques$20 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_eql$ques$20.$$arity = 1);
    
    Opal.def(self, '$each', $Struct_each$21 = function $$each() {
      var $$22, $$23, $iter = $Struct_each$21.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each$21.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$22 = function(){var self = $$22.$$s || this;

        return self.$size()}, $$22.$$s = self, $$22.$$arity = 0, $$22))
      };
      $send(self.$class().$members(), 'each', [], ($$23 = function(name){var self = $$23.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, self['$[]'](name));;}, $$23.$$s = self, $$23.$$arity = 1, $$23));
      return self;
    }, $Struct_each$21.$$arity = 0);
    
    Opal.def(self, '$each_pair', $Struct_each_pair$24 = function $$each_pair() {
      var $$25, $$26, $iter = $Struct_each_pair$24.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each_pair$24.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_pair"], ($$25 = function(){var self = $$25.$$s || this;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      $send(self.$class().$members(), 'each', [], ($$26 = function(name){var self = $$26.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, $$26.$$s = self, $$26.$$arity = 1, $$26));
      return self;
    }, $Struct_each_pair$24.$$arity = 0);
    
    Opal.def(self, '$length', $Struct_length$27 = function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, $Struct_length$27.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $Struct_to_a$28 = function $$to_a() {
      var $$29, self = this;

      return $send(self.$class().$members(), 'map', [], ($$29 = function(name){var self = $$29.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return self['$[]'](name);}, $$29.$$s = self, $$29.$$arity = 1, $$29))
    }, $Struct_to_a$28.$$arity = 0);
    Opal.alias(self, "values", "to_a");
    
    Opal.def(self, '$inspect', $Struct_inspect$30 = function $$inspect() {
      var $a, $$31, self = this, result = nil;

      
      result = "#<struct ";
      if ($truthy(($truthy($a = $$($nesting, 'Struct')['$==='](self)) ? self.$class().$name() : $a))) {
        result = $rb_plus(result, "" + (self.$class()) + " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$31 = function(name, value){var self = $$31.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$31.$$s = self, $$31.$$arity = 2, $$31)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
    }, $Struct_inspect$30.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$to_h', $Struct_to_h$32 = function $$to_h() {
      var $$33, self = this;

      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], ($$33 = function(name, h){var self = $$33.$$s || this, $writer = nil;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (h == null) {
          h = nil;
        };
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$33.$$s = self, $$33.$$arity = 2, $$33))
    }, $Struct_to_h$32.$$arity = 0);
    
    Opal.def(self, '$values_at', $Struct_values_at$34 = function $$values_at($a) {
      var $post_args, args, $$35, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      args = $send(args, 'map', [], ($$35 = function(arg){var self = $$35.$$s || this;

      
        
        if (arg == null) {
          arg = nil;
        };
        return arg.$$is_range ? arg.$to_a() : arg;}, $$35.$$s = self, $$35.$$arity = 1, $$35)).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, $Struct_values_at$34.$$arity = -1);
    return (Opal.def(self, '$dig', $Struct_dig$36 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = (function() {if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
        return self.$$data[key] || nil;
      } else {
        return nil
      }; return nil; })();
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Struct_dig$36.$$arity = -2), nil) && 'dig';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $writer = nil;

  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$join', '$map', '$String', '$empty?', '$concat', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_tty$ques$1, $IO_closed$ques$2, $IO_write$3, $IO_flush$4;

    self.$$prototype.tty = self.$$prototype.closed = nil;
    
    Opal.const_set($nesting[0], 'SEEK_SET', 0);
    Opal.const_set($nesting[0], 'SEEK_CUR', 1);
    Opal.const_set($nesting[0], 'SEEK_END', 2);
    
    Opal.def(self, '$tty?', $IO_tty$ques$1 = function() {
      var self = this;

      return self.tty
    }, $IO_tty$ques$1.$$arity = 0);
    
    Opal.def(self, '$closed?', $IO_closed$ques$2 = function() {
      var self = this;

      return self.closed
    }, $IO_closed$ques$2.$$arity = 0);
    self.$attr_accessor("write_proc");
    
    Opal.def(self, '$write', $IO_write$3 = function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, $IO_write$3.$$arity = 1);
    self.$attr_accessor("sync", "tty");
    
    Opal.def(self, '$flush', $IO_flush$4 = function $$flush() {
      var self = this;

      return nil
    }, $IO_flush$4.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Writable');

      var $nesting = [self].concat($parent_nesting), $Writable_$lt$lt$5, $Writable_print$6, $Writable_puts$8;

      
      
      Opal.def(self, '$<<', $Writable_$lt$lt$5 = function(string) {
        var self = this;

        
        self.$write(string);
        return self;
      }, $Writable_$lt$lt$5.$$arity = 1);
      
      Opal.def(self, '$print', $Writable_print$6 = function $$print($a) {
        var $post_args, args, $$7, self = this;
        if ($gvars[","] == null) $gvars[","] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        self.$write($send(args, 'map', [], ($$7 = function(arg){var self = $$7.$$s || this;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$String(arg);}, $$7.$$s = self, $$7.$$arity = 1, $$7)).$join($gvars[","]));
        return nil;
      }, $Writable_print$6.$$arity = -1);
      
      Opal.def(self, '$puts', $Writable_puts$8 = function $$puts($a) {
        var $post_args, args, $$9, self = this, newline = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        newline = $gvars["/"];
        if ($truthy(args['$empty?']())) {
          self.$write($gvars["/"])
        } else {
          self.$write($send(args, 'map', [], ($$9 = function(arg){var self = $$9.$$s || this;

          
            
            if (arg == null) {
              arg = nil;
            };
            return self.$String(arg).$chomp();}, $$9.$$s = self, $$9.$$arity = 1, $$9)).$concat([nil]).$join(newline))
        };
        return nil;
      }, $Writable_puts$8.$$arity = -1);
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Readable');

      var $nesting = [self].concat($parent_nesting), $Readable_readbyte$10, $Readable_readchar$11, $Readable_readline$12, $Readable_readpartial$13;

      
      
      Opal.def(self, '$readbyte', $Readable_readbyte$10 = function $$readbyte() {
        var self = this;

        return self.$getbyte()
      }, $Readable_readbyte$10.$$arity = 0);
      
      Opal.def(self, '$readchar', $Readable_readchar$11 = function $$readchar() {
        var self = this;

        return self.$getc()
      }, $Readable_readchar$11.$$arity = 0);
      
      Opal.def(self, '$readline', $Readable_readline$12 = function $$readline(sep) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        if (sep == null) {
          sep = $gvars["/"];
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readline$12.$$arity = -1);
      
      Opal.def(self, '$readpartial', $Readable_readpartial$13 = function $$readpartial(integer, outbuf) {
        var self = this;

        
        
        if (outbuf == null) {
          outbuf = nil;
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readpartial$13.$$arity = -2);
    })($nesting[0], $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = $$($nesting, 'IO').$new()));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  $$($nesting, 'STDOUT').$extend($$$($$($nesting, 'IO'), 'Writable'));
  return $$($nesting, 'STDERR').$extend($$$($$($nesting, 'IO'), 'Writable'));
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/main"] = function(Opal) {
  var $to_s$1, $include$2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$include']);
  
  Opal.defs(self, '$to_s', $to_s$1 = function $$to_s() {
    var self = this;

    return "main"
  }, $to_s$1.$$arity = 0);
  return (Opal.defs(self, '$include', $include$2 = function $$include(mod) {
    var self = this;

    return $$($nesting, 'Object').$include(mod)
  }, $include$2.$$arity = 1), nil) && 'include';
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $chdir$1, $pwd$2, $home$3;

      
      
      Opal.def(self, '$chdir', $chdir$1 = function $$chdir(dir) {
        var $iter = $chdir$1.$$p, $yield = $iter || nil, self = this, prev_cwd = nil;

        if ($iter) $chdir$1.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, $chdir$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return Opal.current_dir || '.';
      }, $pwd$2.$$arity = 0);
      Opal.alias(self, "getwd", "pwd");
      return (Opal.def(self, '$home', $home$3 = function $$home() {
        var $a, self = this;

        return ($truthy($a = $$($nesting, 'ENV')['$[]']("HOME")) ? $a : ".")
      }, $home$3.$$arity = 0), nil) && 'home';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$to_path', '$pwd', '$split', '$sub', '$+', '$unshift', '$join', '$home', '$raise', '$start_with?', '$absolute_path', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;

      
      
      Opal.def(self, '$absolute_path', $absolute_path$1 = function $$absolute_path(path, basedir) {
        var $a, self = this, sep = nil, sep_chars = nil, new_parts = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
          return path.$to_path()
        } else {
          return path
        }; return nil; })();
        basedir = ($truthy($a = basedir) ? $a : $$($nesting, 'Dir').$pwd());
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(new RegExp("" + "[" + (sep_chars) + "]"));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split(new RegExp("" + "[" + (sep_chars) + "]")), path.$split(new RegExp("" + "[" + (sep_chars) + "]")));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, $absolute_path$1.$$arity = -2);
      
      Opal.def(self, '$expand_path', $expand_path$2 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$($nesting, 'Dir').$home();
          if ($truthy(home)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          if ($truthy(home['$start_with?'](leading_sep))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = new RegExp("" + "^\\~(?:" + (sep) + "|$)");
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        return self.$absolute_path(path, basedir);
      }, $expand_path$2.$$arity = -2);
      Opal.alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.def(self, '$dirname', $dirname$3 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, $dirname$3.$$arity = 1);
      
      Opal.def(self, '$basename', $basename$4 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        
        
        if (suffix == null) {
          suffix = nil;
        };
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, $basename$4.$$arity = -2);
      
      Opal.def(self, '$extname', $extname$5 = function $$extname(path) {
        var $a, self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy(($truthy($a = last_dot_idx['$nil?']()) ? $a : $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, $extname$5.$$arity = 1);
      
      Opal.def(self, '$exist?', $exist$ques$6 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, $exist$ques$6.$$arity = 1);
      Opal.alias(self, "exists?", "exist?");
      
      Opal.def(self, '$directory?', $directory$ques$7 = function(path) {
        var $$8, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(new RegExp("" + "(^." + ($$($nesting, 'SEPARATOR')) + "+|" + ($$($nesting, 'SEPARATOR')) + "+$)"));
        file = $send(files, 'find', [], ($$8 = function(f){var self = $$8.$$s || this;

        
          
          if (f == null) {
            f = nil;
          };
          return f['$=~'](new RegExp("" + "^" + (path)));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        return file;
      }, $directory$ques$7.$$arity = 1);
      
      Opal.def(self, '$join', $join$9 = function $$join($a) {
        var $post_args, paths, $$10, $$11, self = this, result = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index){var self = $$10.$$s || this, $b;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy((($b = index['$=='](0)) ? item['$empty?']() : index['$=='](0)))) {
            return $$($nesting, 'SEPARATOR')
          } else if ($truthy((($b = paths.$length()['$==']($rb_plus(index, 1))) ? item['$empty?']() : paths.$length()['$==']($rb_plus(index, 1))))) {
            return $$($nesting, 'SEPARATOR')
          } else {
            return item
          };}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], ($$11 = function(item, index){var self = $$11.$$s || this, $b, next_item = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if ($truthy(($truthy($b = item['$end_with?']($$($nesting, 'SEPARATOR'))) ? next_item['$start_with?']($$($nesting, 'SEPARATOR')) : $b))) {
              item = item.$sub(new RegExp("" + ($$($nesting, 'SEPARATOR')) + "+$"), "")};
            return (result = (function() {if ($truthy(($truthy($b = item['$end_with?']($$($nesting, 'SEPARATOR'))) ? $b : next_item['$start_with?']($$($nesting, 'SEPARATOR'))))) {
              return "" + (result) + (item)
            } else {
              return "" + (result) + (item) + ($$($nesting, 'SEPARATOR'))
            }; return nil; })());
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        return result;
      }, $join$9.$$arity = -1);
      return (Opal.def(self, '$split', $split$12 = function $$split(path) {
        var self = this;

        return path.$split($$($nesting, 'SEPARATOR'))
      }, $split$12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/process"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Process');

    var $nesting = [self].concat($parent_nesting), $Process___register_clock__$1, $Process_pid$2, $Process_times$3, $Process_clock_gettime$4, monotonic = nil;

    
    self.__clocks__ = [];
    Opal.defs(self, '$__register_clock__', $Process___register_clock__$1 = function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, $Process___register_clock__$1.$$arity = 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)};
    Opal.defs(self, '$pid', $Process_pid$2 = function $$pid() {
      var self = this;

      return 0
    }, $Process_pid$2.$$arity = 0);
    Opal.defs(self, '$times', $Process_times$3 = function $$times() {
      var self = this, t = nil;

      
      t = $$($nesting, 'Time').$now().$to_f();
      return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, $Process_times$3.$$arity = 0);
    return (Opal.defs(self, '$clock_gettime', $Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
      var $a, self = this, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) {
        unit = "float_second";
      };
      ($truthy($a = (clock = self.__clocks__['$[]'](clock_id))) ? $a : self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id))));
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: self.$raise($$($nesting, 'ArgumentError'), "" + "unexpected unit: " + (unit))
      }
    ;
    }, $Process_clock_gettime$4.$$arity = -2), nil) && 'clock_gettime';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Signal');

    var $nesting = [self].concat($parent_nesting), $Signal_trap$5;

    return (Opal.defs(self, '$trap', $Signal_trap$5 = function $$trap($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Signal_trap$5.$$arity = -1), nil) && 'trap'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'GC');

    var $nesting = [self].concat($parent_nesting), $GC_start$6;

    return (Opal.defs(self, '$start', $GC_start$6 = function $$start() {
      var self = this;

      return nil
    }, $GC_start$6.$$arity = 0), nil) && 'start'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/random"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$new_seed', '$coerce_to!', '$reseed', '$rand', '$seed', '$<', '$raise', '$encode', '$join', '$new', '$chr', '$===', '$==', '$state', '$const_defined?', '$const_set']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $Random_initialize$1, $Random_reseed$2, $Random_new_seed$3, $Random_rand$4, $Random_srand$5, $Random_urandom$6, $Random_$eq_eq$8, $Random_bytes$9, $Random_rand$11, $Random_generator$eq$12;

    
    self.$attr_reader("seed", "state");
    
    Opal.def(self, '$initialize', $Random_initialize$1 = function $$initialize(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      seed = $$($nesting, 'Opal')['$coerce_to!'](seed, $$($nesting, 'Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, $Random_initialize$1.$$arity = -1);
    
    Opal.def(self, '$reseed', $Random_reseed$2 = function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, $Random_reseed$2.$$arity = 1);
    Opal.defs(self, '$new_seed', $Random_new_seed$3 = function $$new_seed() {
      var self = this;

      return Opal.$$rand.new_seed();
    }, $Random_new_seed$3.$$arity = 0);
    Opal.defs(self, '$rand', $Random_rand$4 = function $$rand(limit) {
      var self = this;

      
      ;
      return $$($nesting, 'DEFAULT').$rand(limit);
    }, $Random_rand$4.$$arity = -1);
    Opal.defs(self, '$srand', $Random_srand$5 = function $$srand(n) {
      var self = this, previous_seed = nil;

      
      
      if (n == null) {
        n = $$($nesting, 'Random').$new_seed();
      };
      n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      previous_seed = $$($nesting, 'DEFAULT').$seed();
      $$($nesting, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, $Random_srand$5.$$arity = -1);
    Opal.defs(self, '$urandom', $Random_urandom$6 = function $$urandom(size) {
      var $$7, self = this;

      
      size = $$($nesting, 'Opal')['$coerce_to!'](size, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(size, 0))) {
        self.$raise($$($nesting, 'ArgumentError'), "negative string size (or size too big)")};
      return $send($$($nesting, 'Array'), 'new', [size], ($$7 = function(){var self = $$7.$$s || this;

      return self.$rand(255).$chr()}, $$7.$$s = self, $$7.$$arity = 0, $$7)).$join().$encode("ASCII-8BIT");
    }, $Random_urandom$6.$$arity = 1);
    
    Opal.def(self, '$==', $Random_$eq_eq$8 = function(other) {
      var $a, self = this;

      
      if ($truthy($$($nesting, 'Random')['$==='](other))) {
      } else {
        return false
      };
      return (($a = self.$seed()['$=='](other.$seed())) ? self.$state()['$=='](other.$state()) : self.$seed()['$=='](other.$seed()));
    }, $Random_$eq_eq$8.$$arity = 1);
    
    Opal.def(self, '$bytes', $Random_bytes$9 = function $$bytes(length) {
      var $$10, self = this;

      
      length = $$($nesting, 'Opal')['$coerce_to!'](length, $$($nesting, 'Integer'), "to_int");
      return $send($$($nesting, 'Array'), 'new', [length], ($$10 = function(){var self = $$10.$$s || this;

      return self.$rand(255).$chr()}, $$10.$$s = self, $$10.$$arity = 0, $$10)).$join().$encode("ASCII-8BIT");
    }, $Random_bytes$9.$$arity = 1);
    
    Opal.def(self, '$rand', $Random_rand$11 = function $$rand(limit) {
      var self = this;

      
      ;
      
      function randomFloat() {
        self.state++;
        return Opal.$$rand.rand(self.$rng);
      }

      function randomInt() {
        return Math.floor(randomFloat() * limit);
      }

      function randomRange() {
        var min = limit.begin,
            max = limit.end;

        if (min === nil || max === nil) {
          return nil;
        }

        var length = max - min;

        if (length < 0) {
          return nil;
        }

        if (length === 0) {
          return min;
        }

        if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
          length++;
        }

        return self.$rand(length) + min;
      }

      if (limit == null) {
        return randomFloat();
      } else if (limit.$$is_range) {
        return randomRange();
      } else if (limit.$$is_number) {
        if (limit <= 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
        }

        if (limit % 1 === 0) {
          // integer
          return randomInt();
        } else {
          return randomFloat() * limit;
        }
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");

        if (limit <= 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
        }

        return randomInt();
      }
    ;
    }, $Random_rand$11.$$arity = -1);
    return (Opal.defs(self, '$generator=', $Random_generator$eq$12 = function(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$($nesting, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, $Random_generator$eq$12.$$arity = 1), nil) && 'generator=';
  })($nesting[0], null, $nesting)
};

/*
This is based on an adaptation of Makoto Matsumoto and Takuji Nishimura's code
done by Sean McCullough <banksean@gmail.com> and Dave Heitzman
<daveheitzman@yahoo.com>, subsequently readapted from an updated version of
ruby's random.c (rev c38a183032a7826df1adabd8aa0725c713d53e1c).

The original copyright notice from random.c follows.

  This is based on trimmed version of MT19937.  To get the original version,
  contact <http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html>.

  The original copyright notice follows.

     A C-program for MT19937, with initialization improved 2002/2/10.
     Coded by Takuji Nishimura and Makoto Matsumoto.
     This is a faster version by taking Shawn Cokus's optimization,
     Matthe Bellew's simplification, Isaku Wada's real version.

     Before using, initialize the state by using init_genrand(mt, seed)
     or init_by_array(mt, init_key, key_length).

     Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

       1. Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.

       2. Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.

       3. The names of its contributors may not be used to endorse or promote
          products derived from this software without specific prior written
          permission.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


     Any feedback is very welcome.
     http://www.math.keio.ac.jp/matumoto/emt.html
     email: matumoto@math.keio.ac.jp
*/
var MersenneTwister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
Opal.loaded(["corelib/random/MersenneTwister.js"]);
/* Generated by Opal 1.0.3 */
Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$require', '$generator=', '$-']);
  
  self.$require("corelib/random/MersenneTwister");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $writer = nil;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    Opal.const_set($nesting[0], 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return MersenneTwister.init(seed); },
    rand: function(mt) { return MersenneTwister.genrand_real(mt); }
  });
    
    $writer = [$$($nesting, 'MERSENNE_TWISTER_GENERATOR')];
    $send(self, 'generator=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["corelib/unsupported"] = function(Opal) {
  var $public$35, $private$36, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$raise', '$warn', '$%']);
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_$lt$lt$1, $String_capitalize$excl$2, $String_chomp$excl$3, $String_chop$excl$4, $String_downcase$excl$5, $String_gsub$excl$6, $String_lstrip$excl$7, $String_next$excl$8, $String_reverse$excl$9, $String_slice$excl$10, $String_squeeze$excl$11, $String_strip$excl$12, $String_sub$excl$13, $String_succ$excl$14, $String_swapcase$excl$15, $String_tr$excl$16, $String_tr_s$excl$17, $String_upcase$excl$18, $String_prepend$19, $String_$$$eq$20, $String_clear$21, $String_encode$excl$22, $String_unicode_normalize$excl$23;

    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    
    Opal.def(self, '$<<', $String_$lt$lt$1 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("<<"));
    }, $String_$lt$lt$1.$$arity = -1);
    
    Opal.def(self, '$capitalize!', $String_capitalize$excl$2 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("capitalize!"));
    }, $String_capitalize$excl$2.$$arity = -1);
    
    Opal.def(self, '$chomp!', $String_chomp$excl$3 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chomp!"));
    }, $String_chomp$excl$3.$$arity = -1);
    
    Opal.def(self, '$chop!', $String_chop$excl$4 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chop!"));
    }, $String_chop$excl$4.$$arity = -1);
    
    Opal.def(self, '$downcase!', $String_downcase$excl$5 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("downcase!"));
    }, $String_downcase$excl$5.$$arity = -1);
    
    Opal.def(self, '$gsub!', $String_gsub$excl$6 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("gsub!"));
    }, $String_gsub$excl$6.$$arity = -1);
    
    Opal.def(self, '$lstrip!', $String_lstrip$excl$7 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("lstrip!"));
    }, $String_lstrip$excl$7.$$arity = -1);
    
    Opal.def(self, '$next!', $String_next$excl$8 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("next!"));
    }, $String_next$excl$8.$$arity = -1);
    
    Opal.def(self, '$reverse!', $String_reverse$excl$9 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("reverse!"));
    }, $String_reverse$excl$9.$$arity = -1);
    
    Opal.def(self, '$slice!', $String_slice$excl$10 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("slice!"));
    }, $String_slice$excl$10.$$arity = -1);
    
    Opal.def(self, '$squeeze!', $String_squeeze$excl$11 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("squeeze!"));
    }, $String_squeeze$excl$11.$$arity = -1);
    
    Opal.def(self, '$strip!', $String_strip$excl$12 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("strip!"));
    }, $String_strip$excl$12.$$arity = -1);
    
    Opal.def(self, '$sub!', $String_sub$excl$13 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("sub!"));
    }, $String_sub$excl$13.$$arity = -1);
    
    Opal.def(self, '$succ!', $String_succ$excl$14 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("succ!"));
    }, $String_succ$excl$14.$$arity = -1);
    
    Opal.def(self, '$swapcase!', $String_swapcase$excl$15 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("swapcase!"));
    }, $String_swapcase$excl$15.$$arity = -1);
    
    Opal.def(self, '$tr!', $String_tr$excl$16 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr!"));
    }, $String_tr$excl$16.$$arity = -1);
    
    Opal.def(self, '$tr_s!', $String_tr_s$excl$17 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr_s!"));
    }, $String_tr_s$excl$17.$$arity = -1);
    
    Opal.def(self, '$upcase!', $String_upcase$excl$18 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("upcase!"));
    }, $String_upcase$excl$18.$$arity = -1);
    
    Opal.def(self, '$prepend', $String_prepend$19 = function $$prepend($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("prepend"));
    }, $String_prepend$19.$$arity = -1);
    
    Opal.def(self, '$[]=', $String_$$$eq$20 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("[]="));
    }, $String_$$$eq$20.$$arity = -1);
    
    Opal.def(self, '$clear', $String_clear$21 = function $$clear($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("clear"));
    }, $String_clear$21.$$arity = -1);
    
    Opal.def(self, '$encode!', $String_encode$excl$22 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("encode!"));
    }, $String_encode$excl$22.$$arity = -1);
    return (Opal.def(self, '$unicode_normalize!', $String_unicode_normalize$excl$23 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("unicode_normalize!"));
    }, $String_unicode_normalize$excl$23.$$arity = -1), nil) && 'unicode_normalize!';
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_freeze$24, $Kernel_frozen$ques$25;

    
    var ERROR = "Object freezing is not supported by Opal";
    
    Opal.def(self, '$freeze', $Kernel_freeze$24 = function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_freeze$24.$$arity = 0);
    
    Opal.def(self, '$frozen?', $Kernel_frozen$ques$25 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_frozen$ques$25.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_taint$26, $Kernel_untaint$27, $Kernel_tainted$ques$28;

    
    var ERROR = "Object tainting is not supported by Opal";
    
    Opal.def(self, '$taint', $Kernel_taint$26 = function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_taint$26.$$arity = 0);
    
    Opal.def(self, '$untaint', $Kernel_untaint$27 = function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_untaint$27.$$arity = 0);
    
    Opal.def(self, '$tainted?', $Kernel_tainted$ques$28 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_tainted$ques$28.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_public$29, $Module_private_class_method$30, $Module_private_method_defined$ques$31, $Module_private_constant$32;

    
    
    Opal.def(self, '$public', $Module_public$29 = function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    ;
    }, $Module_public$29.$$arity = -1);
    Opal.alias(self, "private", "public");
    Opal.alias(self, "protected", "public");
    Opal.alias(self, "nesting", "public");
    
    Opal.def(self, '$private_class_method', $Module_private_class_method$30 = function $$private_class_method($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self;
    }, $Module_private_class_method$30.$$arity = -1);
    Opal.alias(self, "public_class_method", "private_class_method");
    
    Opal.def(self, '$private_method_defined?', $Module_private_method_defined$ques$31 = function(obj) {
      var self = this;

      return false
    }, $Module_private_method_defined$ques$31.$$arity = 1);
    
    Opal.def(self, '$private_constant', $Module_private_constant$32 = function $$private_constant($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_private_constant$32.$$arity = -1);
    Opal.alias(self, "protected_method_defined?", "private_method_defined?");
    Opal.alias(self, "public_instance_methods", "instance_methods");
    Opal.alias(self, "public_instance_method", "instance_method");
    return Opal.alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_private_methods$33;

    
    
    Opal.def(self, '$private_methods', $Kernel_private_methods$33 = function $$private_methods($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return [];
    }, $Kernel_private_methods$33.$$arity = -1);
    Opal.alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_eval$34;

    
    Opal.def(self, '$eval', $Kernel_eval$34 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, $Kernel_eval$34.$$arity = -1)
  })($nesting[0], $nesting);
  Opal.defs(self, '$public', $public$35 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $public$35.$$arity = -1);
  return (Opal.defs(self, '$private', $private$36 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $private$36.$$arity = -1), nil) && 'private';
};

/* Generated by Opal 1.0.3 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/kernel/format");
  self.$require("corelib/string/encoding");
  self.$require("corelib/math");
  self.$require("corelib/complex");
  self.$require("corelib/rational");
  self.$require("corelib/time");
  self.$require("corelib/struct");
  self.$require("corelib/io");
  self.$require("corelib/main");
  self.$require("corelib/dir");
  self.$require("corelib/file");
  self.$require("corelib/process");
  self.$require("corelib/random");
  self.$require("corelib/random/mersenne_twister.js");
  return self.$require("corelib/unsupported");
})(Opal);

/* Generated by Opal 1.0.3 */
Opal.modules["native"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $range = Opal.range, $klass = Opal.klass, $gvars = Opal.gvars;

  Opal.add_stubs(['$try_convert', '$native?', '$respond_to?', '$to_n', '$raise', '$inspect', '$Native', '$proc', '$map!', '$end_with?', '$define_method', '$[]', '$convert', '$call', '$to_proc', '$new', '$each', '$native_reader', '$native_writer', '$extend', '$warn', '$include', '$is_a?', '$map', '$to_a', '$_Array', '$method_missing', '$bind', '$instance_method', '$slice', '$-', '$length', '$[]=', '$enum_for', '$===', '$>=', '$<<', '$each_pair', '$_initialize', '$name', '$native_module']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $Native_is_a$ques$1, $Native_try_convert$2, $Native_convert$3, $Native_call$4, $Native_proc$5, $Native_included$22;

    
    Opal.defs(self, '$is_a?', $Native_is_a$ques$1 = function(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    }, $Native_is_a$ques$1.$$arity = 2);
    Opal.defs(self, '$try_convert', $Native_try_convert$2 = function $$try_convert(value, default$) {
      var self = this;

      
      
      if (default$ == null) {
        default$ = nil;
      };
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, $Native_try_convert$2.$$arity = -2);
    Opal.defs(self, '$convert', $Native_convert$3 = function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$($nesting, 'ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    }, $Native_convert$3.$$arity = 1);
    Opal.defs(self, '$call', $Native_call$4 = function $$call(obj, key, $a) {
      var $iter = $Native_call$4.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Native_call$4.$$p = null;
      
      
      if ($iter) $Native_call$4.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 2, arguments.length);
      
      args = $post_args;;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, $Native_call$4.$$arity = -3);
    Opal.defs(self, '$proc', $Native_proc$5 = function $$proc() {
      var $iter = $Native_proc$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Native_proc$5.$$p = null;
      
      
      if ($iter) $Native_proc$5.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      };
      return $send($$$('::', 'Kernel'), 'proc', [], ($$6 = function($a){var self = $$6.$$s || this, $post_args, args, $$7, instance = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        $send(args, 'map!', [], ($$7 = function(arg){var self = $$7.$$s || this;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$Native(arg);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, $$6.$$s = self, $$6.$$arity = -1, $$6));
    }, $Native_proc$5.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $Helpers_alias_native$8, $Helpers_native_reader$12, $Helpers_native_writer$15, $Helpers_native_accessor$18;

      
      
      Opal.def(self, '$alias_native', $Helpers_alias_native$8 = function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $$9, $$10, $$11, $iter = $Helpers_alias_native$8.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Helpers_alias_native$8.$$p = null;
        
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        $kwargs = Opal.extract_kwargs($post_args);
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        if ($post_args.length > 0) {
          old = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (old == null) {
          old = new$;
        };
        
        as = $kwargs.$$smap["as"];
        if (as == null) {
          as = nil
        };
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], ($$9 = function(value){var self = $$9.$$s || this;
            if (self["native"] == null) self["native"] = nil;

          
            
            if (value == null) {
              value = nil;
            };
            self["native"][old['$[]']($range(0, -2, false))] = $$($nesting, 'Native').$convert(value);
            return value;}, $$9.$$s = self, $$9.$$arity = 1, $$9))
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], ($$10 = function($c){var self = $$10.$$s || this, $iter = $$10.$$p, block = $iter || nil, $post_args, args, value = nil;
            if (self["native"] == null) self["native"] = nil;

          
            
            if ($iter) $$10.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            value = $send($$($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, $$10.$$s = self, $$10.$$arity = -1, $$10))
        } else {
          return $send(self, 'define_method', [new$], ($$11 = function($c){var self = $$11.$$s || this, $iter = $$11.$$p, block = $iter || nil, $post_args, args;
            if (self["native"] == null) self["native"] = nil;

          
            
            if ($iter) $$11.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            return $send($$($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc());}, $$11.$$s = self, $$11.$$arity = -1, $$11))
        };
      }, $Helpers_alias_native$8.$$arity = -2);
      
      Opal.def(self, '$native_reader', $Helpers_native_reader$12 = function $$native_reader($a) {
        var $post_args, names, $$13, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        return $send(names, 'each', [], ($$13 = function(name){var self = $$13.$$s || this, $$14;

        
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', [name], ($$14 = function(){var self = $$14.$$s || this;
            if (self["native"] == null) self["native"] = nil;

          return self.$Native(self["native"][name])}, $$14.$$s = self, $$14.$$arity = 0, $$14));}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      }, $Helpers_native_reader$12.$$arity = -1);
      
      Opal.def(self, '$native_writer', $Helpers_native_writer$15 = function $$native_writer($a) {
        var $post_args, names, $$16, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        return $send(names, 'each', [], ($$16 = function(name){var self = $$16.$$s || this, $$17;

        
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', ["" + (name) + "="], ($$17 = function(value){var self = $$17.$$s || this;
            if (self["native"] == null) self["native"] = nil;

          
            
            if (value == null) {
              value = nil;
            };
            return self.$Native(self["native"][name] = value);}, $$17.$$s = self, $$17.$$arity = 1, $$17));}, $$16.$$s = self, $$16.$$arity = 1, $$16));
      }, $Helpers_native_writer$15.$$arity = -1);
      
      Opal.def(self, '$native_accessor', $Helpers_native_accessor$18 = function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        $send(self, 'native_reader', Opal.to_a(names));
        return $send(self, 'native_writer', Opal.to_a(names));
      }, $Helpers_native_accessor$18.$$arity = -1);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $Wrapper_initialize$19, $Wrapper_to_n$20, $Wrapper_included$21;

      
      
      Opal.def(self, '$initialize', $Wrapper_initialize$19 = function $$initialize(native$) {
        var self = this;

        
        if ($truthy($$$('::', 'Kernel')['$native?'](native$))) {
        } else {
          $$$('::', 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      }, $Wrapper_initialize$19.$$arity = 1);
      
      Opal.def(self, '$to_n', $Wrapper_to_n$20 = function $$to_n() {
        var self = this;
        if (self["native"] == null) self["native"] = nil;

        return self["native"]
      }, $Wrapper_to_n$20.$$arity = 0);
      Opal.defs(self, '$included', $Wrapper_included$21 = function $$included(klass) {
        var self = this;

        return klass.$extend($$($nesting, 'Helpers'))
      }, $Wrapper_included$21.$$arity = 1);
    })($nesting[0], $nesting);
    Opal.defs(self, '$included', $Native_included$22 = function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$($nesting, 'Wrapper'));
    }, $Native_included$22.$$arity = 1);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_native$ques$23, $Kernel_Native$24, $Kernel_Array$27;

    
    
    Opal.def(self, '$native?', $Kernel_native$ques$23 = function(value) {
      var self = this;

      return value == null || !value.$$class;
    }, $Kernel_native$ques$23.$$arity = 1);
    
    Opal.def(self, '$Native', $Kernel_Native$24 = function $$Native(obj) {
      var $$25, $$26, $iter = $Kernel_Native$24.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_Native$24.$$p = null;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$($nesting, 'Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$($nesting, 'Array')))) {
        return $send(obj, 'map', [], ($$25 = function(o){var self = $$25.$$s || this;

        
          
          if (o == null) {
            o = nil;
          };
          return self.$Native(o);}, $$25.$$s = self, $$25.$$arity = 1, $$25))
      } else if ($truthy(obj['$is_a?']($$($nesting, 'Proc')))) {
        return $send(self, 'proc', [], ($$26 = function($a){var self = $$26.$$s || this, $iter = $$26.$$p, block = $iter || nil, $post_args, args;

        
          
          if ($iter) $$26.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return self.$Native($send(obj, 'call', Opal.to_a(args), block.$to_proc()));}, $$26.$$s = self, $$26.$$arity = -1, $$26))
      } else {
        return obj
      }
    }, $Kernel_Native$24.$$arity = 1);
    Opal.alias(self, "_Array", "Array");
    
    Opal.def(self, '$Array', $Kernel_Array$27 = function $$Array(object, $a) {
      var $iter = $Kernel_Array$27.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_Array$27.$$p = null;
      
      
      if ($iter) $Kernel_Array$27.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$($nesting, 'Native'), 'Array'), 'new', [object].concat(Opal.to_a(args)), block.$to_proc()).$to_a()};
      return self.$_Array(object);
    }, $Kernel_Array$27.$$arity = -2);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $Object_$eq_eq$28, $Object_has_key$ques$29, $Object_each$30, $Object_$$$31, $Object_$$$eq$32, $Object_merge$excl$33, $Object_respond_to$ques$34, $Object_respond_to_missing$ques$35, $Object_method_missing$36, $Object_nil$ques$37, $Object_is_a$ques$38, $Object_instance_of$ques$39, $Object_class$40, $Object_to_a$41, $Object_inspect$42;

    self.$$prototype["native"] = nil;
    
    self.$include($$$($$$('::', 'Native'), 'Wrapper'));
    
    Opal.def(self, '$==', $Object_$eq_eq$28 = function(other) {
      var self = this;

      return self["native"] === $$$('::', 'Native').$try_convert(other)
    }, $Object_$eq_eq$28.$$arity = 1);
    
    Opal.def(self, '$has_key?', $Object_has_key$ques$29 = function(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    }, $Object_has_key$ques$29.$$arity = 1);
    Opal.alias(self, "key?", "has_key?");
    Opal.alias(self, "include?", "has_key?");
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$each', $Object_each$30 = function $$each($a) {
      var $post_args, args, $iter = $Object_each$30.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Object_each$30.$$p = null;
      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat(Opal.to_a(args)))
      };
    }, $Object_each$30.$$arity = -1);
    
    Opal.def(self, '$[]', $Object_$$$31 = function(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('::', 'Native').$call(self["native"], key)
      }
    
    }, $Object_$$$31.$$arity = 1);
    
    Opal.def(self, '$[]=', $Object_$$$eq$32 = function(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('::', 'Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    }, $Object_$$$eq$32.$$arity = 2);
    
    Opal.def(self, '$merge!', $Object_merge$excl$33 = function(other) {
      var self = this;

      
      
      other = $$$('::', 'Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    }, $Object_merge$excl$33.$$arity = 1);
    
    Opal.def(self, '$respond_to?', $Object_respond_to$ques$34 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return $$$('::', 'Kernel').$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, $Object_respond_to$ques$34.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Object_respond_to_missing$ques$35 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return Opal.hasOwnProperty.call(self["native"], name);
    }, $Object_respond_to_missing$ques$35.$$arity = -2);
    
    Opal.def(self, '$method_missing', $Object_method_missing$36 = function $$method_missing(mid, $a) {
      var $iter = $Object_method_missing$36.$$p, block = $iter || nil, $post_args, args, self = this, $writer = nil;

      if ($iter) $Object_method_missing$36.$$p = null;
      
      
      if ($iter) $Object_method_missing$36.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return (($writer = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)]), $send(self, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
      }
      else {
        return $send($$$('::', 'Native'), 'call', [self["native"], mid].concat(Opal.to_a(args)), block.$to_proc());
      }
    ;
    }, $Object_method_missing$36.$$arity = -2);
    
    Opal.def(self, '$nil?', $Object_nil$ques$37 = function() {
      var self = this;

      return false
    }, $Object_nil$ques$37.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Object_is_a$ques$38 = function(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    }, $Object_is_a$ques$38.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Object_instance_of$ques$39 = function(klass) {
      var self = this;

      return self.$$class === klass;
    }, $Object_instance_of$ques$39.$$arity = 1);
    
    Opal.def(self, '$class', $Object_class$40 = function() {
      var self = this;

      return self.$$class;
    }, $Object_class$40.$$arity = 0);
    
    Opal.def(self, '$to_a', $Object_to_a$41 = function $$to_a(options) {
      var $iter = $Object_to_a$41.$$p, block = $iter || nil, self = this;

      if ($iter) $Object_to_a$41.$$p = null;
      
      
      if ($iter) $Object_to_a$41.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      return $send($$$($$$('::', 'Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, $Object_to_a$41.$$arity = -1);
    return (Opal.def(self, '$inspect', $Object_inspect$42 = function $$inspect() {
      var self = this;

      return "" + "#<Native:" + (String(self["native"])) + ">"
    }, $Object_inspect$42.$$arity = 0), nil) && 'inspect';
  })($$($nesting, 'Native'), $$($nesting, 'BasicObject'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_initialize$43, $Array_each$44, $Array_$$$45, $Array_$$$eq$46, $Array_last$47, $Array_length$48, $Array_inspect$49;

    self.$$prototype.named = self.$$prototype["native"] = self.$$prototype.get = self.$$prototype.block = self.$$prototype.set = self.$$prototype.length = nil;
    
    self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
    self.$include($$($nesting, 'Enumerable'));
    
    Opal.def(self, '$initialize', $Array_initialize$43 = function $$initialize(native$, options) {
      var $iter = $Array_initialize$43.$$p, block = $iter || nil, $a, self = this;

      if ($iter) $Array_initialize$43.$$p = null;
      
      
      if ($iter) $Array_initialize$43.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $Array_initialize$43, false), [native$], null);
      self.get = ($truthy($a = options['$[]']("get")) ? $a : options['$[]']("access"));
      self.named = options['$[]']("named");
      self.set = ($truthy($a = options['$[]']("set")) ? $a : options['$[]']("access"));
      self.length = ($truthy($a = options['$[]']("length")) ? $a : "length");
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$($nesting, 'ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, $Array_initialize$43.$$arity = -2);
    
    Opal.def(self, '$each', $Array_each$44 = function $$each() {
      var $iter = $Array_each$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_each$44.$$p = null;
      
      
      if ($iter) $Array_each$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    }, $Array_each$44.$$arity = 0);
    
    Opal.def(self, '$[]', $Array_$$$45 = function(index) {
      var self = this, result = nil, $case = nil;

      
      result = (function() {$case = index;
      if ($$($nesting, 'String')['$===']($case) || $$($nesting, 'Symbol')['$===']($case)) {if ($truthy(self.named)) {
        return self["native"][self.named](index)
      } else {
        return self["native"][index]
      }}
      else if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy(self.get)) {
        return self["native"][self.get](index)
      } else {
        return self["native"][index]
      }}
      else { return nil }})();
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    }, $Array_$$$45.$$arity = 1);
    
    Opal.def(self, '$[]=', $Array_$$$eq$46 = function(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$($nesting, 'Native').$convert(value))
      } else {
        return self["native"][index] = $$($nesting, 'Native').$convert(value)
      }
    }, $Array_$$$eq$46.$$arity = 2);
    
    Opal.def(self, '$last', $Array_last$47 = function $$last(count) {
      var $a, self = this, index = nil, result = nil;

      
      
      if (count == null) {
        count = nil;
      };
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
          
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, $Array_last$47.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$48 = function $$length() {
      var self = this;

      return self["native"][self.length]
    }, $Array_length$48.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    return (Opal.def(self, '$inspect', $Array_inspect$49 = function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    }, $Array_inspect$49.$$arity = 0), nil) && 'inspect';
  })($$($nesting, 'Native'), null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_to_n$50;

    return (Opal.def(self, '$to_n', $Numeric_to_n$50 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Numeric_to_n$50.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_to_n$51;

    return (Opal.def(self, '$to_n', $Proc_to_n$51 = function $$to_n() {
      var self = this;

      return self
    }, $Proc_to_n$51.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_n$52;

    return (Opal.def(self, '$to_n', $String_to_n$52 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $String_to_n$52.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_to_n$53;

    return (Opal.def(self, '$to_n', $Regexp_to_n$53 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Regexp_to_n$53.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_to_n$54;

    self.$$prototype.matches = nil;
    return (Opal.def(self, '$to_n', $MatchData_to_n$54 = function $$to_n() {
      var self = this;

      return self.matches
    }, $MatchData_to_n$54.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_to_n$55;

    return (Opal.def(self, '$to_n', $Struct_to_n$55 = function $$to_n() {
      var $$56, self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], ($$56 = function(name, value){var self = $$56.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return result[name] = $$($nesting, 'Native').$try_convert(value, value);}, $$56.$$s = self, $$56.$$arity = 2, $$56));
      return result;
    }, $Struct_to_n$55.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_to_n$57;

    return (Opal.def(self, '$to_n', $Array_to_n$57 = function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$($nesting, 'Native').$try_convert(obj, obj));
      }

      return result;
    
    }, $Array_to_n$57.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean_to_n$58;

    return (Opal.def(self, '$to_n', $Boolean_to_n$58 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Boolean_to_n$58.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_to_n$59;

    return (Opal.def(self, '$to_n', $Time_to_n$59 = function $$to_n() {
      var self = this;

      return self
    }, $Time_to_n$59.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_to_n$60;

    return (Opal.def(self, '$to_n', $NilClass_to_n$60 = function $$to_n() {
      var self = this;

      return null;
    }, $NilClass_to_n$60.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_initialize$61, $Hash_to_n$62;

    
    Opal.alias(self, "_initialize", "initialize");
    
    Opal.def(self, '$initialize', $Hash_initialize$61 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$61.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$61.$$p = null;
      
      
      if ($iter) $Hash_initialize$61.$$p = null;;
      ;
      
      if (defaults != null &&
           (defaults.constructor === undefined ||
             defaults.constructor === Object)) {
        var smap = self.$$smap,
            keys = self.$$keys,
            key, value;

        for (key in defaults) {
          value = defaults[key];

          if (value &&
               (value.constructor === undefined ||
                 value.constructor === Object)) {
            smap[key] = $$($nesting, 'Hash').$new(value);
          } else if (value && value.$$is_array) {
            value = value.map(function(item) {
              if (item &&
                   (item.constructor === undefined ||
                     item.constructor === Object)) {
                return $$($nesting, 'Hash').$new(item);
              }

              return self.$Native(item);
            });
            smap[key] = value
          } else {
            smap[key] = self.$Native(value);
          }

          keys.push(key);
        }

        return self;
      }

      return $send(self, '_initialize', [defaults], block.$to_proc());
    ;
    }, $Hash_initialize$61.$$arity = -1);
    return (Opal.def(self, '$to_n', $Hash_to_n$62 = function $$to_n() {
      var self = this;

      
      var result = {},
          keys = self.$$keys,
          smap = self.$$smap,
          key, value;

      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = smap[key];
        } else {
          key = key.key;
          value = key.value;
        }

        result[key] = $$($nesting, 'Native').$try_convert(value, value);
      }

      return result;
    
    }, $Hash_to_n$62.$$arity = 0), nil) && 'to_n';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_native_module$63;

    return (Opal.def(self, '$native_module', $Module_native_module$63 = function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    }, $Module_native_module$63.$$arity = 0), nil) && 'native_module'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_native_alias$64, $Class_native_class$65;

    
    
    Opal.def(self, '$native_alias', $Class_native_alias$64 = function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype['$' + existing_mid];
      if (!aliased) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    }, $Class_native_alias$64.$$arity = 2);
    return (Opal.def(self, '$native_class', $Class_native_class$65 = function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    }, $Class_native_class$65.$$arity = 0), nil) && 'native_class';
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/utils"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$size', '$min', '$scan', '$gsub', '$proc', '$===', '$merge', '$to_proc', '$merge!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Utils');

      var $nesting = [self].concat($parent_nesting), $Utils_heredoc$1, $Utils_deep_merge$2, $Utils_deep_merge$excl$4;

      
      Opal.defs(self, '$heredoc', $Utils_heredoc$1 = function $$heredoc(string) {
        var self = this, indent = nil;

        
        indent = (function() { try {
          return string.$scan(/^[ \t]*(?=\S)/).$min().$size()
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
            try {
              return 0
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        }})();
        return string.$gsub(new RegExp("" + "^[ \\t]{" + (indent) + "}"), "");
      }, $Utils_heredoc$1.$$arity = 1);
      Opal.defs(self, '$deep_merge', $Utils_deep_merge$2 = function $$deep_merge(a, b) {
        var $$3, self = this, merger = nil;

        
        merger = $send(self, 'proc', [], ($$3 = function(key, v1, v2){var self = $$3.$$s || this, $a;

        
          
          if (key == null) {
            key = nil;
          };
          
          if (v1 == null) {
            v1 = nil;
          };
          
          if (v2 == null) {
            v2 = nil;
          };
          if ($truthy(($truthy($a = $$($nesting, 'Hash')['$==='](v1)) ? $$($nesting, 'Hash')['$==='](v2) : $a))) {
            return $send(v1, 'merge', [v2], merger.$to_proc())
          } else {
            return v2
          };}, $$3.$$s = self, $$3.$$arity = 3, $$3));
        return $send(a, 'merge', [b], merger.$to_proc());
      }, $Utils_deep_merge$2.$$arity = 2);
      Opal.defs(self, '$deep_merge!', $Utils_deep_merge$excl$4 = function(a, b) {
        var $$5, self = this, merger = nil;

        
        merger = $send(self, 'proc', [], ($$5 = function(key, v1, v2){var self = $$5.$$s || this, $a;

        
          
          if (key == null) {
            key = nil;
          };
          
          if (v1 == null) {
            v1 = nil;
          };
          
          if (v2 == null) {
            v2 = nil;
          };
          if ($truthy(($truthy($a = $$($nesting, 'Hash')['$==='](v1)) ? $$($nesting, 'Hash')['$==='](v2) : $a))) {
            
            $send(v1, 'merge!', [v2], merger.$to_proc());
            return v1;
          } else {
            return v2
          };}, $$5.$$s = self, $$5.$$arity = 3, $$5));
        return $send(a, 'merge!', [b], merger.$to_proc());
      }, $Utils_deep_merge$excl$4.$$arity = 2);
    })($nesting[0], $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/helpers"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$define_method', '$instance_exec', '$to_proc', '$do', '$defhelper', '$[]=', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $Element_defhelper$1, $Element_defhelper$excl$3;

        
        Opal.defs(self, '$defhelper', $Element_defhelper$1 = function $$defhelper(name) {
          var $iter = $Element_defhelper$1.$$p, block = $iter || nil, $$2, self = this;

          if ($iter) $Element_defhelper$1.$$p = null;
          
          
          if ($iter) $Element_defhelper$1.$$p = null;;
          return $send(self, 'define_method', [name], ($$2 = function($a){var self = $$2.$$s || this, $iter = $$2.$$p, body = $iter || nil, $post_args, args;

          
            
            if ($iter) $$2.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            $send(self, 'instance_exec', Opal.to_a(args), block.$to_proc());
            if ($truthy(body)) {
              $send(self, 'do', [], body.$to_proc())};
            return self;}, $$2.$$s = self, $$2.$$arity = -1, $$2));
        }, $Element_defhelper$1.$$arity = 1);
        return (Opal.defs(self, '$defhelper!', $Element_defhelper$excl$3 = function(name, attribute) {
          var $$4, self = this;

          
          
          if (attribute == null) {
            attribute = name;
          };
          return $send(self, 'defhelper', ["" + (name) + "!"], ($$4 = function(){var self = $$4.$$s || this, $writer = nil;
            if (self.attributes == null) self.attributes = nil;

          
            $writer = [attribute, true];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $$4.$$s = self, $$4.$$arity = 0, $$4));
        }, $Element_defhelper$excl$3.$$arity = -2), nil) && 'defhelper!';
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/a"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-', '$defhelper!', '$<<']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'A');

          var $nesting = [self].concat($parent_nesting), $A$1, $A$3;

          
          $send($hash2(["href", "url", "rel", "relative", "target", "type", "lang", "language", "media"], {"href": "href", "url": "href", "rel": "rel", "relative": "rel", "target": "target", "type": "type", "lang": "hreflang", "language": "hreflang", "media": "media"}), 'each', [], ($A$1 = function(name, attribute){var self = $A$1.$$s || this, $$2;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (attribute == null) {
              attribute = nil;
            };
            return $send(self, 'defhelper', [name], ($$2 = function(value){var self = $$2.$$s || this, $writer = nil;
              if (self.attributes == null) self.attributes = nil;

            
              
              if (value == null) {
                value = nil;
              };
              $writer = [attribute, value.$to_s()];
              $send(self.attributes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 1, $$2));}, $A$1.$$s = self, $A$1.$$arity = 2, $A$1));
          self['$defhelper!']("download");
          self['$defhelper!']("ping");
          return $send(self, 'defhelper', ["text"], ($A$3 = function(string){var self = $A$3.$$s || this;

          
            
            if (string == null) {
              string = nil;
            };
            return self['$<<'](string);}, $A$3.$$s = self, $A$3.$$arity = 1, $A$3));
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/base"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Base');

          var $nesting = [self].concat($parent_nesting), $Base$1;

          return $send($hash2(["href", "url", "target"], {"href": "href", "url": "href", "target": "target"}), 'each', [], ($Base$1 = function(name, attribute){var self = $Base$1.$$s || this, $$2;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (attribute == null) {
              attribute = nil;
            };
            return $send(self, 'defhelper', [name], ($$2 = function(value){var self = $$2.$$s || this, $writer = nil;
              if (self.attributes == null) self.attributes = nil;

            
              
              if (value == null) {
                value = nil;
              };
              $writer = [attribute, value.$to_s()];
              $send(self.attributes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 1, $$2));}, $Base$1.$$s = self, $Base$1.$$arity = 2, $Base$1))
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/blockquote"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$defhelper', '$to_s', '$[]=', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Blockquote');

          var $nesting = [self].concat($parent_nesting), $Blockquote$1;

          return $send(self, 'defhelper', ["cite"], ($Blockquote$1 = function(value){var self = $Blockquote$1.$$s || this, $writer = nil;
            if (self.attributes == null) self.attributes = nil;

          
            
            if (value == null) {
              value = nil;
            };
            $writer = ["cite", value.$to_s()];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $Blockquote$1.$$s = self, $Blockquote$1.$$arity = 1, $Blockquote$1))
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/button"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$each', '$defhelper', '$attribute', '$to_s', '$[]=', '$-', '$defhelper!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Button');

          var $nesting = [self].concat($parent_nesting), $Button$1;

          
          $send($hash2(["form", "name", "type", "value", "action", "encoding", "method", "target"], {"form": "form", "name": "name", "type": "type", "value": "value", "action": "formaction", "encoding": "formenctype", "method": "formmethod", "target": "formtarget"}), 'each', [], ($Button$1 = function(name, attributes){var self = $Button$1.$$s || this, $$2;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (attributes == null) {
              attributes = nil;
            };
            return $send(self, 'defhelper', [name], ($$2 = function(value){var self = $$2.$$s || this, $writer = nil;
              if (self.attributes == null) self.attributes = nil;

            
              
              if (value == null) {
                value = nil;
              };
              $writer = [self.$attribute(), value.$to_s()];
              $send(self.attributes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 1, $$2));}, $Button$1.$$s = self, $Button$1.$$arity = 2, $Button$1));
          self['$defhelper!']("autofocus");
          return self['$defhelper!']("disabled");
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/canvas"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Canvas');

          var $nesting = [self].concat($parent_nesting), $Canvas$1;

          return $send($hash2(["width", "height"], {"width": "width", "height": "height"}), 'each', [], ($Canvas$1 = function(name, attribute){var self = $Canvas$1.$$s || this, $$2;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (attribute == null) {
              attribute = nil;
            };
            return $send(self, 'defhelper', [name], ($$2 = function(value){var self = $$2.$$s || this, $writer = nil;
              if (self.attributes == null) self.attributes = nil;

            
              
              if (value == null) {
                value = nil;
              };
              $writer = [attribute, value.$to_s()];
              $send(self.attributes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 1, $$2));}, $Canvas$1.$$s = self, $Canvas$1.$$arity = 2, $Canvas$1))
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/img"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$each', '$defhelper', '$to_s', '$[]=', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Img');

          var $nesting = [self].concat($parent_nesting), $Img$1, $Img$3;

          
          $send($hash2(["src", "url", "alt", "description", "height", "width", "map"], {"src": "src", "url": "src", "alt": "alt", "description": "alt", "height": "height", "width": "width", "map": "usemap"}), 'each', [], ($Img$1 = function(name, attribute){var self = $Img$1.$$s || this, $$2;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (attribute == null) {
              attribute = nil;
            };
            return $send(self, 'defhelper', [name], ($$2 = function(value){var self = $$2.$$s || this, $writer = nil;
              if (self.attributes == null) self.attributes = nil;

            
              
              if (value == null) {
                value = nil;
              };
              $writer = [attribute, value.$to_s()];
              $send(self.attributes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 1, $$2));}, $Img$1.$$s = self, $Img$1.$$arity = 2, $Img$1));
          return $send(self, 'defhelper', ["map!"], ($Img$3 = function(){var self = $Img$3.$$s || this, $writer = nil;
            if (self.attributes == null) self.attributes = nil;

          
            $writer = ["ismap", true];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $Img$3.$$s = self, $Img$3.$$arity = 0, $Img$3));
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/input"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$each', '$defhelper', '$[]=', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Input');

          var $nesting = [self].concat($parent_nesting), $Input$1;

          return $send($hash2(["type", "name", "value", "size", "place_holder", "read_only", "required"], {"type": "type", "name": "name", "value": "value", "size": "size", "place_holder": "placeholder", "read_only": "readonly", "required": "required"}), 'each', [], ($Input$1 = function(name, attribute){var self = $Input$1.$$s || this, $$2;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (attribute == null) {
              attribute = nil;
            };
            return $send(self, 'defhelper', [name], ($$2 = function(value){var self = $$2.$$s || this, $writer = nil;
              if (self.attributes == null) self.attributes = nil;

            
              
              if (value == null) {
                value = nil;
              };
              $writer = [attribute, value];
              $send(self.attributes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 1, $$2));}, $Input$1.$$s = self, $Input$1.$$arity = 2, $Input$1))
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/object"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$each', '$defhelper', '$[]=', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Object');

          var $nesting = [self].concat($parent_nesting), $Object$1;

          return $send($hash2(["type", "data", "name", "height", "width"], {"type": "type", "data": "data", "name": "name", "height": "height", "width": "width"}), 'each', [], ($Object$1 = function(name, attribute){var self = $Object$1.$$s || this, $$2;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (attribute == null) {
              attribute = nil;
            };
            return $send(self, 'defhelper', [name], ($$2 = function(value){var self = $$2.$$s || this, $writer = nil;
              if (self.attributes == null) self.attributes = nil;

            
              
              if (value == null) {
                value = nil;
              };
              $writer = [attribute, value];
              $send(self.attributes, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 1, $$2));}, $Object$1.$$s = self, $Object$1.$$arity = 2, $Object$1))
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element/td"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$defhelper', '$to_s', '$[]=', '$-', '$join']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Td');

          var $nesting = [self].concat($parent_nesting), $Td$1, $Td$2, $Td$3;

          
          $send(self, 'defhelper', ["columns"], ($Td$1 = function(value){var self = $Td$1.$$s || this, $writer = nil;
            if (self.attributes == null) self.attributes = nil;

          
            
            if (value == null) {
              value = nil;
            };
            $writer = ["colspan", value.$to_s()];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $Td$1.$$s = self, $Td$1.$$arity = 1, $Td$1));
          $send(self, 'defhelper', ["rows"], ($Td$2 = function(value){var self = $Td$2.$$s || this, $writer = nil;
            if (self.attributes == null) self.attributes = nil;

          
            
            if (value == null) {
              value = nil;
            };
            $writer = ["rowspan", value.$to_s()];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $Td$2.$$s = self, $Td$2.$$arity = 1, $Td$2));
          return $send(self, 'defhelper', ["headers"], ($Td$3 = function($a){var self = $Td$3.$$s || this, $post_args, args, $writer = nil;
            if (self.attributes == null) self.attributes = nil;

          
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            $writer = ["headers", args.$join(" ")];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $Td$3.$$s = self, $Td$3.$$arity = -1, $Td$3));
        })($nesting[0], self, $nesting)
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html/element"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$==', '$capitalize', '$const_defined?', '$new', '$const_get', '$each', '$to_proc', '$<<', '$heredoc', '$to_s', '$end_with?', '$[]', '$[]=', '$-', '$push', '$extend!', '$pop', '$join', '$defhelper', '$map', '$empty?', '$upcase', '$inspect']);
  
  self.$require("paggio/html/element/a");
  self.$require("paggio/html/element/base");
  self.$require("paggio/html/element/blockquote");
  self.$require("paggio/html/element/button");
  self.$require("paggio/html/element/canvas");
  self.$require("paggio/html/element/img");
  self.$require("paggio/html/element/input");
  self.$require("paggio/html/element/object");
  self.$require("paggio/html/element/td");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $Element_new$1, $Element_initialize$2, $Element_each$3, $Element_$lt$lt$4, $Element_method_missing$5, $Element_$$$6, $Element_do$7, $Element$8, $Element$10, $Element_inspect$12;

        self.$$prototype.children = self.$$prototype.attributes = self.$$prototype.class_names = self.$$prototype.owner = self.$$prototype.last = self.$$prototype.name = nil;
        
        Opal.defs(self, '$new', $Element_new$1 = function(owner, name, attributes) {
          var $iter = $Element_new$1.$$p, $yield = $iter || nil, self = this, const$ = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $Element_new$1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          
          if (attributes == null) {
            attributes = $hash2([], {});
          };
          if (self['$==']($$($nesting, 'Element'))) {
          } else {
            return $send(self, Opal.find_super_dispatcher(self, 'new', $Element_new$1, false, self.$$class.$$prototype), $zuper, $iter)
          };
          const$ = name.$capitalize();
          if ($truthy(self['$const_defined?'](const$))) {
            return self.$const_get(const$).$new(owner, name, attributes)
          } else {
            return $send(self, Opal.find_super_dispatcher(self, 'new', $Element_new$1, false, self.$$class.$$prototype), $zuper, $iter)
          };
        }, $Element_new$1.$$arity = -3);
        
        Opal.def(self, '$initialize', $Element_initialize$2 = function $$initialize(owner, name, attributes) {
          var self = this;

          
          
          if (attributes == null) {
            attributes = $hash2([], {});
          };
          self.owner = owner;
          self.name = name;
          self.attributes = attributes;
          self.children = [];
          return (self.class_names = []);
        }, $Element_initialize$2.$$arity = -3);
        
        Opal.def(self, '$each', $Element_each$3 = function $$each() {
          var $iter = $Element_each$3.$$p, block = $iter || nil, self = this;

          if ($iter) $Element_each$3.$$p = null;
          
          
          if ($iter) $Element_each$3.$$p = null;;
          return $send(self.children, 'each', [], block.$to_proc());
        }, $Element_each$3.$$arity = 0);
        
        Opal.def(self, '$<<', $Element_$lt$lt$4 = function(what) {
          var self = this;

          
          self.children['$<<'](what);
          return self;
        }, $Element_$lt$lt$4.$$arity = 1);
        
        Opal.def(self, '$method_missing', $Element_method_missing$5 = function $$method_missing(name, content) {
          var $iter = $Element_method_missing$5.$$p, block = $iter || nil, self = this, $writer = nil;

          if ($iter) $Element_method_missing$5.$$p = null;
          
          
          if ($iter) $Element_method_missing$5.$$p = null;;
          
          if (content == null) {
            content = nil;
          };
          if ($truthy(content)) {
            self['$<<']($$$($$$('::', 'Paggio'), 'Utils').$heredoc(content.$to_s()))};
          if ($truthy(name.$to_s()['$end_with?']("!"))) {
            
            $writer = ["id", name['$[]']($range(0, -2, false))];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else {
            
            self.last = name;
            self.class_names.$push(name);
          };
          if ($truthy(block)) {
            $send(self.owner, 'extend!', [self], block.$to_proc())};
          return self;
        }, $Element_method_missing$5.$$arity = -2);
        
        Opal.def(self, '$[]', $Element_$$$6 = function($a) {
          var $post_args, names, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          names = $post_args;;
          if ($truthy(self.last)) {
          } else {
            return nil
          };
          self.class_names.$pop();
          self.class_names.$push([self.last].concat(Opal.to_a(names)).$join("-"));
          return self;
        }, $Element_$$$6.$$arity = -1);
        
        Opal.def(self, '$do', $Element_do$7 = function() {
          var $iter = $Element_do$7.$$p, block = $iter || nil, self = this;

          if ($iter) $Element_do$7.$$p = null;
          
          
          if ($iter) $Element_do$7.$$p = null;;
          $send(self.owner, 'extend!', [self], block.$to_proc());
          return self;
        }, $Element_do$7.$$arity = 0);
        $send(self, 'defhelper', ["style"], ($Element$8 = function(hash){var self = $Element$8.$$s || this, $$9, $writer = nil;
          if (self.attributes == null) self.attributes = nil;

        
          
          if (hash == null) {
            hash = nil;
          };
          $writer = ["style", $send(hash, 'map', [], ($$9 = function(name, value){var self = $$9.$$s || this;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (value == null) {
              value = nil;
            };
            return "" + (name) + ": " + (value);}, $$9.$$s = self, $$9.$$arity = 2, $$9)).$join(";")];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $Element$8.$$s = self, $Element$8.$$arity = 1, $Element$8));
        $send(self, 'defhelper', ["data"], ($Element$10 = function(hash){var self = $Element$10.$$s || this, $$11;

        
          
          if (hash == null) {
            hash = nil;
          };
          return $send(hash, 'each', [], ($$11 = function(name, value){var self = $$11.$$s || this, $writer = nil;
            if (self.attributes == null) self.attributes = nil;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (value == null) {
              value = nil;
            };
            $writer = ["" + "data-" + (name), value.$to_s()];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $$11.$$s = self, $$11.$$arity = 2, $$11));}, $Element$10.$$s = self, $Element$10.$$arity = 1, $Element$10));
        return (Opal.def(self, '$inspect', $Element_inspect$12 = function $$inspect() {
          var self = this;

          if ($truthy(self.children['$empty?']())) {
            return "" + "#<HTML::Element(" + (self.name.$upcase()) + ")>"
          } else {
            return "" + "#<HTML::Element(" + (self.name.$upcase()) + "): " + (self.children.$inspect()['$[]']($range(1, -2, false))) + ">"
          }
        }, $Element_inspect$12.$$arity = 0), nil) && 'inspect';
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/html"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs(['$require', '$attr_reader', '$raise', '$==', '$arity', '$instance_exec', '$to_proc', '$call', '$<<', '$first', '$===', '$instance_eval', '$each', '$end_with?', '$to_s', '$empty?', '$heredoc', '$shift', '$new', '$[]', '$inspect']);
  
  self.$require("paggio/html/helpers");
  self.$require("paggio/html/element");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $HTML_initialize$1, $HTML_$lt$lt$2, $HTML_root$excl$3, $HTML_roots$excl$4, $HTML_element$excl$5, $HTML_extend$excl$6, $HTML_each$8, $HTML_method_missing$9, $HTML_inspect$11;

      self.$$prototype.current = self.$$prototype.roots = self.$$prototype.version = nil;
      
      self.$attr_reader("version");
      
      Opal.def(self, '$initialize', $HTML_initialize$1 = function $$initialize(version) {
        var $iter = $HTML_initialize$1.$$p, block = $iter || nil, self = this;

        if ($iter) $HTML_initialize$1.$$p = null;
        
        
        if ($iter) $HTML_initialize$1.$$p = null;;
        
        if (version == null) {
          version = 5;
        };
        if ($truthy(block)) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
        };
        self.version = version;
        self.roots = [];
        self.current = nil;
        if (block.$arity()['$=='](0)) {
          return $send(self, 'instance_exec', [], block.$to_proc())
        } else {
          return block.$call(self)
        };
      }, $HTML_initialize$1.$$arity = -1);
      
      Opal.def(self, '$<<', $HTML_$lt$lt$2 = function(what) {
        var $a, self = this;

        return ($truthy($a = self.current) ? $a : self.roots)['$<<'](what)
      }, $HTML_$lt$lt$2.$$arity = 1);
      
      Opal.def(self, '$root!', $HTML_root$excl$3 = function() {
        var self = this;

        return self.roots.$first()
      }, $HTML_root$excl$3.$$arity = 0);
      
      Opal.def(self, '$roots!', $HTML_roots$excl$4 = function() {
        var self = this;

        return self.roots
      }, $HTML_roots$excl$4.$$arity = 0);
      
      Opal.def(self, '$element!', $HTML_element$excl$5 = function() {
        var self = this;

        return self.current
      }, $HTML_element$excl$5.$$arity = 0);
      
      Opal.def(self, '$extend!', $HTML_extend$excl$6 = function(element) {
        var $iter = $HTML_extend$excl$6.$$p, block = $iter || nil, $a, $$7, self = this, old = nil, result = nil;

        if ($iter) $HTML_extend$excl$6.$$p = null;
        
        
        if ($iter) $HTML_extend$excl$6.$$p = null;;
        
        if (element == null) {
          element = nil;
        };
        $a = [self.current, element], (old = $a[0]), (self.current = $a[1]), $a;
        result = block.$call(self);
        if ($truthy($$$('::', 'String')['$==='](result))) {
          $send(self.current, 'instance_eval', [], ($$7 = function(){var self = $$7.$$s || this;

          return (self.inner_html = result)}, $$7.$$s = self, $$7.$$arity = 0, $$7))};
        self.current = old;
        return self;
      }, $HTML_extend$excl$6.$$arity = -1);
      
      Opal.def(self, '$each', $HTML_each$8 = function $$each() {
        var $iter = $HTML_each$8.$$p, block = $iter || nil, self = this;

        if ($iter) $HTML_each$8.$$p = null;
        
        
        if ($iter) $HTML_each$8.$$p = null;;
        return $send(self.roots, 'each', [], block.$to_proc());
      }, $HTML_each$8.$$arity = 0);
      
      Opal.def(self, '$method_missing', $HTML_method_missing$9 = function $$method_missing(name, $a) {
        var $iter = $HTML_method_missing$9.$$p, block = $iter || nil, $post_args, args, $b, $$10, self = this, content = nil, element = nil, parent = nil, result = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $HTML_method_missing$9.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if ($iter) $HTML_method_missing$9.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        if ($truthy(name.$to_s()['$end_with?']("!"))) {
          return $send(self, Opal.find_super_dispatcher(self, 'method_missing', $HTML_method_missing$9, false), $zuper, $iter)};
        if ($truthy(($truthy($b = args['$empty?']()) ? $b : $$$('::', 'Hash')['$==='](args.$first())))) {
        } else {
          content = $$$($$$('::', 'Paggio'), 'Utils').$heredoc(args.$shift().$to_s())
        };
        element = $send($$($nesting, 'Element'), 'new', [self, name].concat(Opal.to_a(args)));
        if ($truthy(content)) {
          element['$<<'](content)};
        if ($truthy(block)) {
          
          parent = self.current;
          self.current = element;
          result = block.$call(self);
          self.current = parent;
          if ($truthy($$$('::', 'String')['$==='](result))) {
            $send(element, 'instance_eval', [], ($$10 = function(){var self = $$10.$$s || this;

            return (self.inner_html = result)}, $$10.$$s = self, $$10.$$arity = 0, $$10))};};
        self['$<<'](element);
        return element;
      }, $HTML_method_missing$9.$$arity = -2);
      return (Opal.def(self, '$inspect', $HTML_inspect$11 = function $$inspect() {
        var self = this;

        if ($truthy(self.roots['$empty?']())) {
          return "" + "#<HTML(" + (self.version) + ")>"
        } else {
          return "" + "#<HTML(" + (self.version) + "): " + (self.roots.$inspect()['$[]']($range(1, -2, false))) + ">"
        }
      }, $HTML_inspect$11.$$arity = 0), nil) && 'inspect';
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/css/unit"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var $$23, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$map', '$to_proc', '$attr_reader', '$===', '$respond_to?', '$raise', '$class', '$to_u', '$new', '$==', '$convert', '$type', '$number', '$hash', '$each', '$define_method', '$+', '$compatible?', '$-', '$*', '$/', '$to_i', '$to_f', '$private', '$include?', '$class_eval', '$old_percent', '$match', '$[]', '$__send__', '$downcase']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Unit');

        var $nesting = [self].concat($parent_nesting), $Unit_initialize$1, $Unit_coerce$2, $Unit_$eq_eq$3, $Unit_$eq_eq_eq$4, $Unit_hash$5, $Unit$6, $Unit_$plus$8, $Unit_$minus$9, $Unit_$$10, $Unit_$slash$11, $Unit_$minus$$12, $Unit_$plus$$13, $Unit_to_i$14, $Unit_to_f$15, $Unit_to_u$16, $Unit_to_s$17, $Unit_compatible$ques$18, $Unit_convert$19;

        self.$$prototype.type = self.$$prototype.number = nil;
        
        Opal.const_set($nesting[0], 'TYPES', $send(["em", "ex", "ch", "rem", "vh", "vw", "vmin", "vmax", "px", "mm", "cm", "in", "pt", "pc", "s", "deg"], 'map', [], "to_sym".$to_proc()));
        Opal.const_set($nesting[0], 'COMPATIBLE', $send(["in", "pt", "mm", "cm", "px", "pc"], 'map', [], "to_sym".$to_proc()));
        self.$attr_reader("type", "number");
        
        Opal.def(self, '$initialize', $Unit_initialize$1 = function $$initialize(number, type) {
          var self = this;

          
          self.number = number;
          return (self.type = type);
        }, $Unit_initialize$1.$$arity = 2);
        
        Opal.def(self, '$coerce', $Unit_coerce$2 = function $$coerce(other) {
          var self = this;

          return [self, other]
        }, $Unit_coerce$2.$$arity = 1);
        
        Opal.def(self, '$==', $Unit_$eq_eq$3 = function(other) {
          var self = this;

          
          if ($truthy($$($nesting, 'Unit')['$==='](other))) {
          } else {
            
            if ($truthy(other['$respond_to?']("to_u"))) {
            } else {
              self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (other.$class()) + " into Unit")
            };
            other = other.$to_u();
          };
          if ($truthy($$($nesting, 'Unit')['$==='](other))) {
          } else {
            other = $$($nesting, 'Unit').$new(other, self.type)
          };
          return self.number['$=='](self.$convert(other, self.type));
        }, $Unit_$eq_eq$3.$$arity = 1);
        
        Opal.def(self, '$===', $Unit_$eq_eq_eq$4 = function(other) {
          var $a, self = this;

          return (($a = self.type['$=='](other.$type())) ? self.number['$=='](other.$number()) : self.type['$=='](other.$type()))
        }, $Unit_$eq_eq_eq$4.$$arity = 1);
        Opal.alias(self, "eql?", "==");
        
        Opal.def(self, '$hash', $Unit_hash$5 = function $$hash() {
          var self = this;

          return [self.number, self.type].$hash()
        }, $Unit_hash$5.$$arity = 0);
        $send($$($nesting, 'TYPES'), 'each', [], ($Unit$6 = function(name){var self = $Unit$6.$$s || this, $$7;

        
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', [name], ($$7 = function(){var self = $$7.$$s || this;

          return $$($nesting, 'Unit').$new(self.$convert(self, name), name)}, $$7.$$s = self, $$7.$$arity = 0, $$7));}, $Unit$6.$$s = self, $Unit$6.$$arity = 1, $Unit$6));
        
        Opal.def(self, '$+', $Unit_$plus$8 = function(other) {
          var $a, self = this;

          
          if ($truthy($$($nesting, 'Unit')['$==='](other))) {
          } else {
            return $$($nesting, 'Unit').$new($rb_plus(self.number, other), self.type)
          };
          if (self.type['$=='](other.$type())) {
            return $$($nesting, 'Unit').$new($rb_plus(self.number, other.$number()), self.type)
          } else if ($truthy(($truthy($a = self['$compatible?'](self)) ? self['$compatible?'](other) : $a))) {
            return $$($nesting, 'Unit').$new($rb_plus(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$($nesting, 'ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        }, $Unit_$plus$8.$$arity = 1);
        
        Opal.def(self, '$-', $Unit_$minus$9 = function(other) {
          var $a, self = this;

          
          if ($truthy($$($nesting, 'Unit')['$==='](other))) {
          } else {
            return $$($nesting, 'Unit').$new($rb_minus(self.number, other), self.type)
          };
          if (self.type['$=='](other.$type())) {
            return $$($nesting, 'Unit').$new($rb_minus(self.number, other.$number()), self.type)
          } else if ($truthy(($truthy($a = self['$compatible?'](self)) ? self['$compatible?'](other) : $a))) {
            return $$($nesting, 'Unit').$new($rb_minus(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$($nesting, 'ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        }, $Unit_$minus$9.$$arity = 1);
        
        Opal.def(self, '$*', $Unit_$$10 = function(other) {
          var $a, self = this;

          
          if ($truthy($$($nesting, 'Unit')['$==='](other))) {
          } else {
            return $$($nesting, 'Unit').$new($rb_times(self.number, other), self.type)
          };
          if (self.type['$=='](other.$type())) {
            return $$($nesting, 'Unit').$new($rb_times(self.number, other.$number()), self.type)
          } else if ($truthy(($truthy($a = self['$compatible?'](self)) ? self['$compatible?'](other) : $a))) {
            return $$($nesting, 'Unit').$new($rb_times(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$($nesting, 'ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        }, $Unit_$$10.$$arity = 1);
        
        Opal.def(self, '$/', $Unit_$slash$11 = function(other) {
          var $a, self = this;

          
          if ($truthy($$($nesting, 'Unit')['$==='](other))) {
          } else {
            return $$($nesting, 'Unit').$new($rb_divide(self.number, other), self.type)
          };
          if (self.type['$=='](other.$type())) {
            return $$($nesting, 'Unit').$new($rb_divide(self.number, other.$number()), self.type)
          } else if ($truthy(($truthy($a = self['$compatible?'](self)) ? self['$compatible?'](other) : $a))) {
            return $$($nesting, 'Unit').$new($rb_divide(self.number, self.$convert(other, self.type)), self.type)
          } else {
            return self.$raise($$($nesting, 'ArgumentError'), "" + (other.$type()) + " isn't compatible with " + (self.type))
          };
        }, $Unit_$slash$11.$$arity = 1);
        
        Opal.def(self, '$-@', $Unit_$minus$$12 = function() {
          var self = this;

          return $$($nesting, 'Unit').$new($rb_times(self.number, -1), self.type)
        }, $Unit_$minus$$12.$$arity = 0);
        
        Opal.def(self, '$+@', $Unit_$plus$$13 = function() {
          var self = this;

          return $$($nesting, 'Unit').$new(self.number, self.type)
        }, $Unit_$plus$$13.$$arity = 0);
        
        Opal.def(self, '$to_i', $Unit_to_i$14 = function $$to_i() {
          var self = this;

          return self.number.$to_i()
        }, $Unit_to_i$14.$$arity = 0);
        
        Opal.def(self, '$to_f', $Unit_to_f$15 = function $$to_f() {
          var self = this;

          return self.number.$to_f()
        }, $Unit_to_f$15.$$arity = 0);
        
        Opal.def(self, '$to_u', $Unit_to_u$16 = function $$to_u() {
          var self = this;

          return self
        }, $Unit_to_u$16.$$arity = 0);
        
        Opal.def(self, '$to_s', $Unit_to_s$17 = function $$to_s() {
          var self = this;

          return "" + (self.number) + (self.type)
        }, $Unit_to_s$17.$$arity = 0);
        Opal.alias(self, "to_str", "to_s");
        Opal.alias(self, "inspect", "to_s");
        self.$private();
        
        Opal.def(self, '$compatible?', $Unit_compatible$ques$18 = function(unit) {
          var self = this;

          return $$($nesting, 'COMPATIBLE')['$include?'](unit.$type())
        }, $Unit_compatible$ques$18.$$arity = 1);
        return (Opal.def(self, '$convert', $Unit_convert$19 = function $$convert(unit, type) {
          var self = this, value = nil, px = nil, $case = nil;

          
          value = unit.$number();
          if (unit.$type()['$=='](type)) {
            return value};
          px = (function() {$case = unit.$type();
          if ("in"['$===']($case)) {return $rb_times(value, 96)}
          else if ("pt"['$===']($case)) {return $rb_divide($rb_times(value, 4.0), 3.0)}
          else if ("pc"['$===']($case)) {return $rb_divide($rb_times($rb_divide(value, 12), 4.0), 3.0)}
          else if ("mm"['$===']($case)) {return $rb_times(value, 3.77953)}
          else if ("cm"['$===']($case)) {return $rb_times($rb_times(value, 10), 3.77953)}
          else if ("px"['$===']($case)) {return value}
          else { return nil }})();
          return (function() {$case = type;
          if ("in"['$===']($case)) {return $rb_divide(px, 96.0)}
          else if ("pt"['$===']($case)) {return $rb_divide($rb_divide(px, 4.0), 3.0)}
          else if ("pc"['$===']($case)) {return $rb_divide($rb_divide($rb_times(px, 12), 4.0), 3.0)}
          else if ("mm"['$===']($case)) {return $rb_divide(px, 3.77953)}
          else if ("cm"['$===']($case)) {return $rb_divide($rb_divide(px, 10), 3.77953)}
          else if ("px"['$===']($case)) {return px}
          else { return nil }})();
        }, $Unit_convert$19.$$arity = 2), nil) && 'convert';
      })($nesting[0], null, $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric$20, $Numeric_to_u$22;

    
    $send($$$($$$($$$($$($nesting, 'Paggio'), 'CSS'), 'Unit'), 'TYPES'), 'each', [], ($Numeric$20 = function(name){var self = $Numeric$20.$$s || this, $$21;

    
      
      if (name == null) {
        name = nil;
      };
      return $send(self, 'define_method', [name], ($$21 = function(){var self = $$21.$$s || this;

      return $$$($$$($$($nesting, 'Paggio'), 'CSS'), 'Unit').$new(self, name)}, $$21.$$s = self, $$21.$$arity = 0, $$21));}, $Numeric$20.$$s = self, $Numeric$20.$$arity = 1, $Numeric$20));
    return (Opal.def(self, '$to_u', $Numeric_to_u$22 = function $$to_u() {
      var self = this;

      return self
    }, $Numeric_to_u$22.$$arity = 0), nil) && 'to_u';
  })($nesting[0], null, $nesting);
  $send([$$($nesting, 'Fixnum'), $$($nesting, 'Float')], 'each', [], ($$23 = function(klass){var self = $$23.$$s || this, $$24;

  
    
    if (klass == null) {
      klass = nil;
    };
    return $send(klass, 'class_eval', [], ($$24 = function(){var self = $$24.$$s || this, $percent$25;

    
      Opal.alias(self, "old_percent", "%");
      return (Opal.def(self, '$%', $percent$25 = function(other) {
        var self = this;

        
        
        if (other == null) {
          other = nil;
        };
        if ($truthy(other)) {
          return self.$old_percent(other)
        } else {
          return $$$($$$($$($nesting, 'Paggio'), 'CSS'), 'Unit').$new(self, "%")
        };
      }, $percent$25.$$arity = -1), nil) && '%';}, $$24.$$s = self, $$24.$$arity = 0, $$24));}, $$23.$$s = self, $$23.$$arity = 1, $$23));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_u$26;

    return (Opal.def(self, '$to_u', $String_to_u$26 = function $$to_u() {
      var self = this, matches = nil, value = nil, unit = nil;

      if ($truthy((matches = self.$match(/^([\d+.]+)(.+)?$/)))) {
        
        value = matches['$[]'](1).$to_f();
        if ($truthy((unit = matches['$[]'](2)))) {
          return value.$__send__(unit.$downcase())
        } else {
          return value
        };
      } else {
        return 0
      }
    }, $String_to_u$26.$$arity = 0), nil) && 'to_u'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_to_u$27;

    return (Opal.def(self, '$to_u', $NilClass_to_u$27 = function $$to_u() {
      var self = this;

      return 0
    }, $NilClass_to_u$27.$$arity = 0), nil) && 'to_u'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/css/color"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$each', '$map', '$to_proc', '$define_method', '$new']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Color');

        var $nesting = [self].concat($parent_nesting), $Color_initialize$1;

        return (Opal.def(self, '$initialize', $Color_initialize$1 = function $$initialize(value, type) {
          var self = this;

          
          self.internal = value;
          return (self.type = type);
        }, $Color_initialize$1.$$arity = 2), nil) && 'initialize'
      })($nesting[0], null, $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String$2;

    return $send($send(["rgb", "rgba", "hsl", "hsla"], 'map', [], "to_sym".$to_proc()), 'each', [], ($String$2 = function(name){var self = $String$2.$$s || this, $$3;

    
      
      if (name == null) {
        name = nil;
      };
      return $send(self, 'define_method', [name], ($$3 = function(){var self = $$3.$$s || this;

      return $$$($$$($$($nesting, 'Paggio'), 'CSS'), 'Color').$new(self, name)}, $$3.$$s = self, $$3.$$arity = 0, $$3));}, $String$2.$$s = self, $String$2.$$arity = 1, $String$2))
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array$4;

    return $send($send(["rgb", "rgba", "hsl", "hsla"], 'map', [], "to_sym".$to_proc()), 'each', [], ($Array$4 = function(name){var self = $Array$4.$$s || this, $$5;

    
      
      if (name == null) {
        name = nil;
      };
      return $send(self, 'define_method', [name], ($$5 = function(){var self = $$5.$$s || this;

      return $$$($$$($$($nesting, 'Paggio'), 'CSS'), 'Color').$new(self, name)}, $$5.$$s = self, $$5.$$arity = 0, $$5));}, $Array$4.$$s = self, $Array$4.$$arity = 1, $Array$4))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/css/definition"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new', '$==', '$arity', '$instance_exec', '$to_proc', '$call', '$empty?', '$each', '$inspect', '$===', '$first', '$>', '$length', '$raise', '$style', '$name', '$value', '$[]', '$join', '$map', '$to_i', '$*', '$to_s', '$end_with?', '$respond_to?', '$__send__', '$<<', '$last', '$pop', '$!', '$other', '$shift', '$horizontal?', '$private']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Definition');

        var $nesting = [self].concat($parent_nesting), $Definition_initialize$1, $Definition_empty$ques$2, $Definition_each$3, $Definition_gradient$4, $Definition_url$5, $Definition_background$6, $Definition_border$9, $Definition_box$14, $Definition_opacity$17, $Definition_animation$18, $Definition_transition$19, $Definition_method_missing$20, $Definition_style$22, $Definition_style$excl$23;

        self.$$prototype.style = self.$$prototype.important = nil;
        
        Opal.const_set($nesting[0], 'Style', $$$('::', 'Struct').$new("name", "value", "important"));
        
        Opal.def(self, '$initialize', $Definition_initialize$1 = function $$initialize() {
          var $iter = $Definition_initialize$1.$$p, block = $iter || nil, self = this;

          if ($iter) $Definition_initialize$1.$$p = null;
          
          
          if ($iter) $Definition_initialize$1.$$p = null;;
          self.style = [];
          if ($truthy(block)) {
            if (block.$arity()['$=='](0)) {
              return $send(self, 'instance_exec', [], block.$to_proc())
            } else {
              return block.$call(self)
            }
          } else {
            return nil
          };
        }, $Definition_initialize$1.$$arity = 0);
        
        Opal.def(self, '$empty?', $Definition_empty$ques$2 = function() {
          var self = this;

          return self.style['$empty?']()
        }, $Definition_empty$ques$2.$$arity = 0);
        
        Opal.def(self, '$each', $Definition_each$3 = function $$each() {
          var $iter = $Definition_each$3.$$p, block = $iter || nil, self = this;

          if ($iter) $Definition_each$3.$$p = null;
          
          
          if ($iter) $Definition_each$3.$$p = null;;
          return $send(self.style, 'each', [], block.$to_proc());
        }, $Definition_each$3.$$arity = 0);
        
        Opal.def(self, '$gradient', $Definition_gradient$4 = function $$gradient($a) {
          var $post_args, args, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send($$($nesting, 'Gradient'), 'new', Opal.to_a(args));
        }, $Definition_gradient$4.$$arity = -1);
        
        Opal.def(self, '$url', $Definition_url$5 = function $$url(arg) {
          var self = this;

          return "" + "url(" + (arg.$inspect()) + ")"
        }, $Definition_url$5.$$arity = 1);
        
        Opal.def(self, '$background', $Definition_background$6 = function $$background($a) {
          var $post_args, args, $$7, $$8, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          if ($truthy($$($nesting, 'Gradient')['$==='](args.$first()))) {
            
            if ($truthy($rb_gt(args.$length(), 1))) {
              self.$raise($$($nesting, 'NotImplementedError'), "multiple gradients not implemented yet")};
            return $send(args.$first(), 'each', [], ($$7 = function(s){var self = $$7.$$s || this, $b;

            
              
              if (s == null) {
                s = nil;
              };
              return self.$style(($truthy($b = s.$name()) ? $b : "background-image"), s.$value());}, $$7.$$s = self, $$7.$$arity = 1, $$7));
          } else if ($truthy($$$('::', 'Hash')['$==='](args.$first()))) {
            return $send(args.$first(), 'each', [], ($$8 = function(sub, value){var self = $$8.$$s || this;

            
              
              if (sub == null) {
                sub = nil;
              };
              
              if (value == null) {
                value = nil;
              };
              return self.$style("" + "background-" + (sub), value);}, $$8.$$s = self, $$8.$$arity = 2, $$8))
          } else {
            return self.$style("background", args)
          };
        }, $Definition_background$6.$$arity = -1);
        
        Opal.def(self, '$border', $Definition_border$9 = function $$border($a) {
          var $post_args, args, $$10, self = this, options = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          if ($truthy($$$('::', 'Hash')['$==='](args.$first()))) {
            
            if (args.$length()['$=='](1)) {
              options = args.$first()};
            return $send(options, 'each', [], ($$10 = function(name, value){var self = $$10.$$s || this, $$11, $$13, $case = nil;

            
              
              if (name == null) {
                name = nil;
              };
              
              if (value == null) {
                value = nil;
              };
              return (function() {$case = name;
              if ("radius"['$===']($case)) {if ($truthy($$$('::', 'Hash')['$==='](value))) {
                return $send(value, 'each', [], ($$11 = function(horizontal, value){var self = $$11.$$s || this, $$12;

                
                  
                  if (horizontal == null) {
                    horizontal = nil;
                  };
                  
                  if (value == null) {
                    value = nil;
                  };
                  return $send(value, 'each', [], ($$12 = function(vertical, value){var self = $$12.$$s || this;

                  
                    
                    if (vertical == null) {
                      vertical = nil;
                    };
                    
                    if (value == null) {
                      value = nil;
                    };
                    self.$style("" + "-moz-border-radius-" + (horizontal) + (vertical), value);
                    self.$style("" + "-webkit-border-" + (horizontal) + "-" + (vertical) + "-radius", value);
                    return self.$style("" + "border-" + (horizontal) + "-" + (vertical) + "-radius", value);}, $$12.$$s = self, $$12.$$arity = 2, $$12));}, $$11.$$s = self, $$11.$$arity = 2, $$11))
              } else {
                
                self.$style("-moz-border-radius", value);
                self.$style("-webkit-border-radius", value);
                return self.$style("border-radius", value);
              }}
              else if ("color"['$===']($case)) {if ($truthy($$$('::', 'Hash')['$==='](value))) {
                return $send(value, 'each', [], ($$13 = function(name, value){var self = $$13.$$s || this;

                
                  
                  if (name == null) {
                    name = nil;
                  };
                  
                  if (value == null) {
                    value = nil;
                  };
                  return self.$style("" + "border-" + (name) + "-color", value);}, $$13.$$s = self, $$13.$$arity = 2, $$13))
              } else {
                return self.$style("border-color", value)
              }}
              else {return self.$style("" + "border-" + (name), value)}})();}, $$10.$$s = self, $$10.$$arity = 2, $$10));
          } else {
            return self.$style("border", args)
          };
        }, $Definition_border$9.$$arity = -1);
        
        Opal.def(self, '$box', $Definition_box$14 = function $$box(options) {
          var $$15, self = this;

          if ($truthy($$$('::', 'Hash')['$==='](options))) {
            return $send(options, 'each', [], ($$15 = function(name, value){var self = $$15.$$s || this, $$16, $case = nil;

            
              
              if (name == null) {
                name = nil;
              };
              
              if (value == null) {
                value = nil;
              };
              return (function() {$case = name;
              if ("shadow"['$===']($case)) {
              if ($truthy($$$('::', 'Array')['$==='](value))) {
                if ($truthy($$$('::', 'Array')['$==='](value['$[]'](0)))) {
                  value = $send(value, 'map', [], ($$16 = function(v){var self = $$16.$$s || this;

                  
                    
                    if (v == null) {
                      v = nil;
                    };
                    return v.$join(" ");}, $$16.$$s = self, $$16.$$arity = 1, $$16)).$join(", ")
                } else {
                  value = value.$join(" ")
                }};
              self.$style("-moz-box-shadow", value);
              self.$style("-webkit-box-shadow", value);
              return self.$style("box-shadow", value);}
              else {return self.$style("" + "box-" + (name), value)}})();}, $$15.$$s = self, $$15.$$arity = 2, $$15))
          } else {
            return self.$style("box", options)
          }
        }, $Definition_box$14.$$arity = 1);
        
        Opal.def(self, '$opacity', $Definition_opacity$17 = function $$opacity(value) {
          var self = this;

          
          self.$style("opacity", value);
          self.$style("-moz-opacity", value);
          self.$style("-ms-filter", "" + "\"progid:DXImageTransform.Microsoft.Alpha(Opacity=" + ($rb_times(value, 100).$to_i()) + ")\"");
          return self.$style("filter", "" + "alpha(opacity=" + ($rb_times(value, 100).$to_i()) + ")");
        }, $Definition_opacity$17.$$arity = 1);
        
        Opal.def(self, '$animation', $Definition_animation$18 = function $$animation($a) {
          var $post_args, args, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          self.$style("animation", args);
          return self.$style("-webkit-animation", args);
        }, $Definition_animation$18.$$arity = -1);
        
        Opal.def(self, '$transition', $Definition_transition$19 = function $$transition($a) {
          var $post_args, args, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          self.$style("transition", args);
          self.$style("-webkit-transition", args);
          return self.$style("-moz-transition", args);
        }, $Definition_transition$19.$$arity = -1);
        
        Opal.def(self, '$method_missing', $Definition_method_missing$20 = function $$method_missing(name, $a) {
          var $iter = $Definition_method_missing$20.$$p, block = $iter || nil, $post_args, args, $b, $$21, self = this, important = nil, argument = nil;

          if ($iter) $Definition_method_missing$20.$$p = null;
          
          
          if ($iter) $Definition_method_missing$20.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          name = name.$to_s();
          important = name['$end_with?']("!");
          if ($truthy(important)) {
            name = name['$[]']($range(0, -2, false))};
          if ($truthy(important)) {
            self.important = true};
          if ($truthy(($truthy($b = important) ? self['$respond_to?'](name) : $b))) {
            
            $send(self, '__send__', [name].concat(Opal.to_a(args)), block.$to_proc());
            self.important = false;
            return nil;};
          if (args.$length()['$=='](1)) {
            
            argument = args.$first();
            if ($truthy($$$('::', 'Hash')['$==='](argument))) {
              $send(argument, 'each', [], ($$21 = function(sub, value){var self = $$21.$$s || this;

              
                
                if (sub == null) {
                  sub = nil;
                };
                
                if (value == null) {
                  value = nil;
                };
                return self.$style("" + (name) + "-" + (sub), value);}, $$21.$$s = self, $$21.$$arity = 2, $$21))
            } else {
              self.$style(name, argument)
            };
          } else {
            self.$style(name, args.$join(" "))
          };
          self.important = false;
          return self;
        }, $Definition_method_missing$20.$$arity = -2);
        
        Opal.def(self, '$style', $Definition_style$22 = function $$style(name, value, important) {
          var self = this;

          
          
          if (value == null) {
            value = nil;
          };
          
          if (important == null) {
            important = self.important;
          };
          if ($truthy($$$('::', 'Array')['$==='](value))) {
            value = value.$join(" ")};
          if ($truthy($$($nesting, 'Style')['$==='](name))) {
            return self.style['$<<'](name)
          } else {
            return self.style['$<<']($$($nesting, 'Style').$new(name, value, important))
          };
        }, $Definition_style$22.$$arity = -2);
        
        Opal.def(self, '$style!', $Definition_style$excl$23 = function(name, value) {
          var self = this;

          
          
          if (value == null) {
            value = nil;
          };
          return self.$style(name, value, true);
        }, $Definition_style$excl$23.$$arity = -2);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Gradient');

          var $nesting = [self].concat($parent_nesting), $Gradient_initialize$24, $Gradient_each$25, $Gradient_horizontal$ques$26, $Gradient_vertical$ques$27, $Gradient_other$28, $Gradient_style$29;

          self.$$prototype.to = self.$$prototype.from = self.$$prototype.start = self.$$prototype.end = nil;
          
          
          Opal.def(self, '$initialize', $Gradient_initialize$24 = function $$initialize($a) {
            var $post_args, args, $b, self = this, options = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            options = (function() {if ($truthy($$$('::', 'Hash')['$==='](args.$last()))) {
              return args.$pop()
            } else {
              return $hash2([], {})
            }; return nil; })();
            self.to = options['$[]']("to");
            self.from = options['$[]']("from");
            if ($truthy(($truthy($b = self.to) ? self.from['$!']() : $b))) {
              self.from = self.$other(self.to)
            } else if ($truthy(($truthy($b = self.from) ? self.to['$!']() : $b))) {
              self.to = self.$other(self.from)};
            self.start = args.$shift();
            return (self.end = args.$shift());
          }, $Gradient_initialize$24.$$arity = -1);
          
          Opal.def(self, '$each', $Gradient_each$25 = function $$each() {
            var $iter = $Gradient_each$25.$$p, block = $iter || nil, self = this;

            if ($iter) $Gradient_each$25.$$p = null;
            
            
            if ($iter) $Gradient_each$25.$$p = null;;
            block.$call(self.$style("" + "-moz-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            if ($truthy(self['$horizontal?']())) {
              block.$call(self.$style("" + "-webkit-gradient(linear, " + (self.from) + " top, " + (self.to) + " top, color-stop(0%, " + (self.start) + "), color-stop(100%, " + (self.end) + "))"))
            } else {
              block.$call(self.$style("" + "-webkit-gradient(linear, left " + (self.from) + ", left " + (self.to) + ", color-stop(0%, " + (self.start) + "), color-stop(100%, " + (self.end) + "))"))
            };
            block.$call(self.$style("" + "-webkit-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            block.$call(self.$style("" + "-o-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            block.$call(self.$style("" + "-ms-linear-gradient(" + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
            return block.$call(self.$style("" + "linear-gradient(to " + (self.to) + ", " + (self.start) + " 0%, " + (self.end) + " 100%)"));
          }, $Gradient_each$25.$$arity = 0);
          
          Opal.def(self, '$horizontal?', $Gradient_horizontal$ques$26 = function() {
            var $a, self = this;

            return ($truthy($a = self.to['$==']("left")) ? $a : self.to['$==']("right"))
          }, $Gradient_horizontal$ques$26.$$arity = 0);
          
          Opal.def(self, '$vertical?', $Gradient_vertical$ques$27 = function() {
            var $a, self = this;

            return ($truthy($a = self.to['$==']("top")) ? $a : self.to['$==']("bottom"))
          }, $Gradient_vertical$ques$27.$$arity = 0);
          self.$private();
          
          Opal.def(self, '$other', $Gradient_other$28 = function $$other(side) {
            var self = this, $case = nil;

            return (function() {$case = side;
            if ("left"['$===']($case)) {return "right"}
            else if ("right"['$===']($case)) {return "left"}
            else if ("top"['$===']($case)) {return "bottom"}
            else if ("bottom"['$===']($case)) {return "top"}
            else { return nil }})()
          }, $Gradient_other$28.$$arity = 1);
          return (Opal.def(self, '$style', $Gradient_style$29 = function $$style($a) {
            var $post_args, args, self = this;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            if (args.$length()['$=='](1)) {
              return $$($nesting, 'Style').$new(nil, args.$first())
            } else {
              return $send($$($nesting, 'Style'), 'new', Opal.to_a(args))
            };
          }, $Gradient_style$29.$$arity = -1), nil) && 'style';
        })($nesting[0], null, $nesting);
      })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/css"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$new', '$each', '$start_with?', '$+', '$[]', '$==', '$attr_reader', '$raise', '$arity', '$instance_exec', '$to_proc', '$call', '$any?', '$include?', '$<<', '$selector', '$pop', '$__send__', '$definition', '$last']);
  
  self.$require("paggio/css/unit");
  self.$require("paggio/css/color");
  self.$require("paggio/css/definition");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CSS');

      var $nesting = [self].concat($parent_nesting), $CSS_selector$1, $CSS_initialize$3, $CSS_rule$4, $CSS_method_missing$7;

      self.$$prototype.current = nil;
      
      Opal.const_set($nesting[0], 'Rule', $$$('::', 'Struct').$new("selector", "definition"));
      Opal.defs(self, '$selector', $CSS_selector$1 = function $$selector(list) {
        var $$2, self = this, result = nil;

        
        result = "";
        $send(list, 'each', [], ($$2 = function(part){var self = $$2.$$s || this;

        
          
          if (part == null) {
            part = nil;
          };
          if ($truthy(part['$start_with?']("&"))) {
            return (result = $rb_plus(result, part['$[]']($range(1, -1, false))))
          } else {
            return (result = $rb_plus(result, $rb_plus(" ", part)))
          };}, $$2.$$s = self, $$2.$$arity = 1, $$2));
        if (result['$[]'](0)['$=='](" ")) {
          return result['$[]']($range(1, -1, false))
        } else {
          return result
        };
      }, $CSS_selector$1.$$arity = 1);
      self.$attr_reader("rules");
      
      Opal.def(self, '$initialize', $CSS_initialize$3 = function $$initialize() {
        var $iter = $CSS_initialize$3.$$p, block = $iter || nil, self = this;

        if ($iter) $CSS_initialize$3.$$p = null;
        
        
        if ($iter) $CSS_initialize$3.$$p = null;;
        if ($truthy(block)) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
        };
        self.selector = [];
        self.current = [];
        self.rules = [];
        if (block.$arity()['$=='](0)) {
          return $send(self, 'instance_exec', [], block.$to_proc())
        } else {
          return block.$call(self)
        };
      }, $CSS_initialize$3.$$arity = 0);
      
      Opal.def(self, '$rule', $CSS_rule$4 = function $$rule($a) {
        var $iter = $CSS_rule$4.$$p, block = $iter || nil, $post_args, names, $$5, $$6, self = this;

        if ($iter) $CSS_rule$4.$$p = null;
        
        
        if ($iter) $CSS_rule$4.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        if ($truthy(block)) {
        } else {
          return nil
        };
        if ($truthy($send(names, 'any?', [], ($$5 = function(n){var self = $$5.$$s || this;

        
          
          if (n == null) {
            n = nil;
          };
          return n['$include?'](",");}, $$5.$$s = self, $$5.$$arity = 1, $$5)))) {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "selectors cannot contain commas")};
        return $send(names, 'each', [], ($$6 = function(name){var self = $$6.$$s || this;
          if (self.selector == null) self.selector = nil;
          if (self.current == null) self.current = nil;
          if (self.rules == null) self.rules = nil;

        
          
          if (name == null) {
            name = nil;
          };
          self.selector['$<<'](name);
          self.current['$<<']($$($nesting, 'Rule').$new($$($nesting, 'CSS').$selector(self.selector), $$($nesting, 'Definition').$new()));
          block.$call(self);
          self.selector.$pop();
          return self.rules['$<<'](self.current.$pop());}, $$6.$$s = self, $$6.$$arity = 1, $$6));
      }, $CSS_rule$4.$$arity = -1);
      return (Opal.def(self, '$method_missing', $CSS_method_missing$7 = function $$method_missing(name, $a) {
        var $iter = $CSS_method_missing$7.$$p, block = $iter || nil, $post_args, args, self = this;

        if ($iter) $CSS_method_missing$7.$$p = null;
        
        
        if ($iter) $CSS_method_missing$7.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $send(self.current.$last().$definition(), '__send__', [name].concat(Opal.to_a(args)), block.$to_proc());
      }, $CSS_method_missing$7.$$arity = -2), nil) && 'method_missing';
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HTML');

      var $nesting = [self].concat($parent_nesting), $HTML_style$8;

      self.$$prototype.current = self.$$prototype.roots = nil;
      return (Opal.def(self, '$style', $HTML_style$8 = function $$style() {
        var $iter = $HTML_style$8.$$p, block = $iter || nil, $a, self = this;

        if ($iter) $HTML_style$8.$$p = null;
        
        
        if ($iter) $HTML_style$8.$$p = null;;
        return ($truthy($a = self.current) ? $a : self.roots)['$<<']($send($$($nesting, 'CSS'), 'new', [], block.$to_proc()));
      }, $HTML_style$8.$$arity = 0), nil) && 'style'
    })($nesting[0], $$($nesting, 'BasicObject'), $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["stringio"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$include', '$new', '$call', '$close', '$attr_accessor', '$length', '$include?', '$!', '$check_readable', '$==', '$===', '$>=', '$raise', '$>', '$+', '$-', '$seek', '$enum_for', '$eof?', '$ord', '$[]', '$to_str', '$chomp', '$check_writable', '$String', '$write', '$closed_write?', '$closed_read?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $StringIO_open$1, $StringIO_initialize$2, $StringIO_eof$ques$3, $StringIO_seek$4, $StringIO_tell$5, $StringIO_rewind$6, $StringIO_each_byte$7, $StringIO_each_char$8, $StringIO_each$9, $StringIO_write$10, $StringIO_read$11, $StringIO_close$12, $StringIO_close_read$13, $StringIO_close_write$14, $StringIO_closed$ques$15, $StringIO_closed_read$ques$16, $StringIO_closed_write$ques$17, $StringIO_check_writable$18, $StringIO_check_readable$19;

    self.$$prototype.position = self.$$prototype.string = self.$$prototype.closed = nil;
    
    self.$include($$$($$($nesting, 'IO'), 'Readable'));
    self.$include($$$($$($nesting, 'IO'), 'Writable'));
    Opal.defs(self, '$open', $StringIO_open$1 = function $$open(string, mode) {
      var $iter = $StringIO_open$1.$$p, block = $iter || nil, self = this, io = nil, res = nil;

      if ($iter) $StringIO_open$1.$$p = null;
      
      
      if ($iter) $StringIO_open$1.$$p = null;;
      
      if (string == null) {
        string = "";
      };
      
      if (mode == null) {
        mode = nil;
      };
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, $StringIO_open$1.$$arity = -1);
    self.$attr_accessor("string");
    
    Opal.def(self, '$initialize', $StringIO_initialize$2 = function $$initialize(string, mode) {
      var $a, self = this;

      
      
      if (string == null) {
        string = "";
      };
      
      if (mode == null) {
        mode = "rw";
      };
      self.string = string;
      self.position = string.$length();
      if ($truthy(($truthy($a = mode['$include?']("r")) ? mode['$include?']("w")['$!']() : $a))) {
        return (self.closed = "write")
      } else if ($truthy(($truthy($a = mode['$include?']("w")) ? mode['$include?']("r")['$!']() : $a))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, $StringIO_initialize$2.$$arity = -1);
    
    Opal.def(self, '$eof?', $StringIO_eof$ques$3 = function() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, $StringIO_eof$ques$3.$$arity = 0);
    Opal.alias(self, "eof", "eof?");
    
    Opal.def(self, '$seek', $StringIO_seek$4 = function $$seek(pos, whence) {
      var self = this, $case = nil;

      
      
      if (whence == null) {
        whence = $$$($$($nesting, 'IO'), 'SEEK_SET');
      };
      $case = whence;
      if ($$$($$($nesting, 'IO'), 'SEEK_SET')['$===']($case)) {
      if ($truthy($rb_ge(pos, 0))) {
      } else {
        self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'))
      };
      self.position = pos;}
      else if ($$$($$($nesting, 'IO'), 'SEEK_CUR')['$===']($case)) {if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
        self.position = self.string.$length()
      } else {
        self.position = $rb_plus(self.position, pos)
      }}
      else if ($$$($$($nesting, 'IO'), 'SEEK_END')['$===']($case)) {if ($truthy($rb_gt(pos, self.string.$length()))) {
        self.position = 0
      } else {
        self.position = $rb_minus(self.position, pos)
      }};
      return 0;
    }, $StringIO_seek$4.$$arity = -2);
    
    Opal.def(self, '$tell', $StringIO_tell$5 = function $$tell() {
      var self = this;

      return self.position
    }, $StringIO_tell$5.$$arity = 0);
    Opal.alias(self, "pos", "tell");
    Opal.alias(self, "pos=", "seek");
    
    Opal.def(self, '$rewind', $StringIO_rewind$6 = function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, $StringIO_rewind$6.$$arity = 0);
    
    Opal.def(self, '$each_byte', $StringIO_each_byte$7 = function $$each_byte() {
      var $iter = $StringIO_each_byte$7.$$p, block = $iter || nil, $a, self = this, i = nil;

      if ($iter) $StringIO_each_byte$7.$$p = null;
      
      
      if ($iter) $StringIO_each_byte$7.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each_byte")
      };
      self.$check_readable();
      i = self.position;
      while (!($truthy(self['$eof?']()))) {
        
        block.$call(self.string['$[]'](i).$ord());
        i = $rb_plus(i, 1);
      };
      return self;
    }, $StringIO_each_byte$7.$$arity = 0);
    
    Opal.def(self, '$each_char', $StringIO_each_char$8 = function $$each_char() {
      var $iter = $StringIO_each_char$8.$$p, block = $iter || nil, $a, self = this, i = nil;

      if ($iter) $StringIO_each_char$8.$$p = null;
      
      
      if ($iter) $StringIO_each_char$8.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each_char")
      };
      self.$check_readable();
      i = self.position;
      while (!($truthy(self['$eof?']()))) {
        
        block.$call(self.string['$[]'](i));
        i = $rb_plus(i, 1);
      };
      return self;
    }, $StringIO_each_char$8.$$arity = 0);
    
    Opal.def(self, '$each', $StringIO_each$9 = function $$each(separator) {
      var $iter = $StringIO_each$9.$$p, $yield = $iter || nil, self = this, chomp_lines = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $StringIO_each$9.$$p = null;
      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if (($yield !== nil)) {
      } else {
        return self.$enum_for("each_line")
      };
      self.$check_readable();
      chomp_lines = false;
      if ($truthy($$$('::', 'Hash')['$==='](separator))) {
        separator = (function() {if ($truthy((chomp_lines = separator['$[]']("chomp")))) {
          return /\r?\n/
        } else {
          return $gvars["/"]
        }; return nil; })()
      } else if ($truthy(separator)) {
        separator = separator.$to_str()
      } else {
        separator = undefined
      };
      
      var str = self.string, stringLength = str.length;
      if (self.position < stringLength) str = str.substr(self.position);
      if (separator) {
        var chomped = (str).$chomp(), trailing = str.length !== chomped.length, splitted = chomped.split(separator);
        for (var i = 0, len = splitted.length; i < len; i++) {
          var line = chomp_lines ? splitted[i] : (i < len - 1 || trailing ? splitted[i] + separator : splitted[i]);
          Opal.yield1($yield, line);
        }
      } else if (separator === undefined) {
        Opal.yield1($yield, str);
      } else {
        var m, re = /(.+(?:\n\n|$))\n*/g;
        while ((m = re.exec(str))) Opal.yield1($yield, m[1]);
      }
      self.position = stringLength;
    ;
      return self;
    }, $StringIO_each$9.$$arity = -1);
    Opal.alias(self, "each_line", "each");
    
    Opal.def(self, '$write', $StringIO_write$10 = function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      string = self.$String(string);
      if (self.string.$length()['$=='](self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, $StringIO_write$10.$$arity = 1);
    
    Opal.def(self, '$read', $StringIO_read$11 = function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      
      if (length == null) {
        length = nil;
      };
      
      if (outbuf == null) {
        outbuf = nil;
      };
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil};
      string = (function() {if ($truthy(length)) {
        
        str = self.string['$[]'](self.position, length);
        self.position = $rb_plus(self.position, length);
        return str;
      } else {
        
        str = self.string['$[]'](Opal.Range.$new(self.position, -1, false));
        self.position = self.string.$length();
        return str;
      }; return nil; })();
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, $StringIO_read$11.$$arity = -1);
    
    Opal.def(self, '$close', $StringIO_close$12 = function $$close() {
      var self = this;

      return (self.closed = "both")
    }, $StringIO_close$12.$$arity = 0);
    
    Opal.def(self, '$close_read', $StringIO_close_read$13 = function $$close_read() {
      var self = this;

      if (self.closed['$==']("write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    }, $StringIO_close_read$13.$$arity = 0);
    
    Opal.def(self, '$close_write', $StringIO_close_write$14 = function $$close_write() {
      var self = this;

      if (self.closed['$==']("read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    }, $StringIO_close_write$14.$$arity = 0);
    
    Opal.def(self, '$closed?', $StringIO_closed$ques$15 = function() {
      var self = this;

      return self.closed['$==']("both")
    }, $StringIO_closed$ques$15.$$arity = 0);
    
    Opal.def(self, '$closed_read?', $StringIO_closed_read$ques$16 = function() {
      var $a, self = this;

      return ($truthy($a = self.closed['$==']("read")) ? $a : self.closed['$==']("both"))
    }, $StringIO_closed_read$ques$16.$$arity = 0);
    
    Opal.def(self, '$closed_write?', $StringIO_closed_write$ques$17 = function() {
      var $a, self = this;

      return ($truthy($a = self.closed['$==']("write")) ? $a : self.closed['$==']("both"))
    }, $StringIO_closed_write$ques$17.$$arity = 0);
    
    Opal.def(self, '$check_writable', $StringIO_check_writable$18 = function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return self.$raise($$($nesting, 'IOError'), "not opened for writing")
      } else {
        return nil
      }
    }, $StringIO_check_writable$18.$$arity = 0);
    return (Opal.def(self, '$check_readable', $StringIO_check_readable$19 = function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return self.$raise($$($nesting, 'IOError'), "not opened for reading")
      } else {
        return nil
      }
    }, $StringIO_check_readable$19.$$arity = 0), nil) && 'check_readable';
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio/formatter"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$require', '$[]=', '$to_h', '$-', '$[]', '$dup', '$deep_merge!', '$call', '$replace', '$===', '$new', '$merge', '$each', '$string', '$indent?', '$+', '$lines', '$puts', '$*', '$chomp', '$print', '$gsub', '$to_s', '$for', '$version', '$indent', '$format', '$instance_eval', '$empty?', '$map', '$escape', '$<<', '$join', '$reverse', '$rules', '$definition', '$selector', '$name', '$value', '$important']);
  
  self.$require("stringio");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $Paggio$13, $Paggio$16, $Paggio$23;

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $Formatter_to_h$1, $Formatter_for$2, $Formatter_options$3, $Formatter_initialize$4, $Formatter_format$5, $Formatter_to_s$7, $Formatter_indent$ques$8, $Formatter_indent$9, $Formatter_print$10, $Formatter_escape$12;

      self.$$prototype.options = self.$$prototype.io = nil;
      
      Opal.defs(self, '$to_h', $Formatter_to_h$1 = function $$to_h() {
        var $a, self = this;
        if (self.formatters == null) self.formatters = nil;

        return (self.formatters = ($truthy($a = self.formatters) ? $a : $hash2([], {})))
      }, $Formatter_to_h$1.$$arity = 0);
      Opal.defs(self, '$for', $Formatter_for$2 = function(klass) {
        var $iter = $Formatter_for$2.$$p, block = $iter || nil, self = this, $writer = nil;

        if ($iter) $Formatter_for$2.$$p = null;
        
        
        if ($iter) $Formatter_for$2.$$p = null;;
        if ($truthy(block)) {
          
          $writer = [klass, block];
          $send(self.$to_h(), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        } else {
          return self.$to_h()['$[]'](klass)
        };
      }, $Formatter_for$2.$$arity = 1);
      Opal.defs(self, '$options', $Formatter_options$3 = function $$options(options) {
        var $iter = $Formatter_options$3.$$p, block = $iter || nil, self = this, old = nil, result = nil;

        if ($iter) $Formatter_options$3.$$p = null;
        
        
        if ($iter) $Formatter_options$3.$$p = null;;
        old = $$($nesting, 'OPTIONS').$dup();
        $$($nesting, 'Utils')['$deep_merge!']($$($nesting, 'OPTIONS'), options);
        result = block.$call();
        $$($nesting, 'OPTIONS').$replace(old);
        return result;
      }, $Formatter_options$3.$$arity = 1);
      Opal.const_set($nesting[0], 'OPTIONS', $hash2(["indent"], {"indent": $hash2(["level", "with"], {"level": 0, "with": "\t"})}));
      
      Opal.def(self, '$initialize', $Formatter_initialize$4 = function $$initialize(io, options) {
        var $a, self = this;

        
        
        if (io == null) {
          io = nil;
        };
        
        if (options == null) {
          options = $hash2([], {});
        };
        if ($truthy($$($nesting, 'Hash')['$==='](io))) {
          
          self.io = $$($nesting, 'StringIO').$new();
          self.options = io;
        } else {
          
          self.io = ($truthy($a = io) ? $a : $$($nesting, 'StringIO').$new());
          self.options = options;
        };
        return (self.options = $$($nesting, 'OPTIONS').$merge(self.options));
      }, $Formatter_initialize$4.$$arity = -1);
      
      Opal.def(self, '$format', $Formatter_format$5 = function $$format(item) {
        var $$6, self = this;

        
        (function(){var $brk = Opal.new_brk(); try {return $send($$($nesting, 'Formatter').$to_h(), 'each', [], ($$6 = function(klass, block){var self = $$6.$$s || this;

        
          
          if (klass == null) {
            klass = nil;
          };
          
          if (block == null) {
            block = nil;
          };
          if ($truthy(klass['$==='](item))) {
            
            block.$call(self, item);
            
            Opal.brk(nil, $brk);
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$brk = $brk, $$6.$$arity = 2, $$6))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        return self;
      }, $Formatter_format$5.$$arity = 1);
      
      Opal.def(self, '$to_s', $Formatter_to_s$7 = function $$to_s() {
        var self = this;

        return self.io.$string()
      }, $Formatter_to_s$7.$$arity = 0);
      
      Opal.def(self, '$indent?', $Formatter_indent$ques$8 = function() {
        var $iter = $Formatter_indent$ques$8.$$p, block = $iter || nil, self = this;

        if ($iter) $Formatter_indent$ques$8.$$p = null;
        
        
        if ($iter) $Formatter_indent$ques$8.$$p = null;;
        try {
          return self.options['$[]']("indent")['$[]']("level")
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
            try {
              return false
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      }, $Formatter_indent$ques$8.$$arity = 0);
      
      Opal.def(self, '$indent', $Formatter_indent$9 = function $$indent() {
        var $iter = $Formatter_indent$9.$$p, block = $iter || nil, self = this, $binary_op_recvr_tmp_1 = nil, $writer = nil, $binary_op_recvr_tmp_2 = nil;

        if ($iter) $Formatter_indent$9.$$p = null;
        
        
        if ($iter) $Formatter_indent$9.$$p = null;;
        if ($truthy(self['$indent?']())) {
          
          
          $binary_op_recvr_tmp_1 = self.options['$[]']("indent");
          
          $writer = ["level", $rb_plus($binary_op_recvr_tmp_1['$[]']("level"), 1)];
          $send($binary_op_recvr_tmp_1, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;;
          block.$call();
          
          $binary_op_recvr_tmp_2 = self.options['$[]']("indent");
          
          $writer = ["level", $rb_minus($binary_op_recvr_tmp_2['$[]']("level"), 1)];
          $send($binary_op_recvr_tmp_2, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;;
        } else {
          return block.$call()
        };
      }, $Formatter_indent$9.$$arity = 0);
      
      Opal.def(self, '$print', $Formatter_print$10 = function $$print(text) {
        var $$11, self = this, level = nil;

        if ($truthy((level = self['$indent?']()))) {
          return $send(text.$lines(), 'each', [], ($$11 = function(line){var self = $$11.$$s || this;
            if (self.io == null) self.io = nil;
            if (self.options == null) self.options = nil;

          
            
            if (line == null) {
              line = nil;
            };
            return self.io.$puts("" + ($rb_times(self.options['$[]']("indent")['$[]']("with"), level)) + (line.$chomp()));}, $$11.$$s = self, $$11.$$arity = 1, $$11))
        } else {
          return self.io.$print(text)
        }
      }, $Formatter_print$10.$$arity = 1);
      return (Opal.def(self, '$escape', $Formatter_escape$12 = function $$escape(string) {
        var self = this;

        return string.$to_s().$gsub(/["><']|&(?!([a-zA-Z]+|(#\d+));)/, $hash2(["&", ">", "<", "\"", "'"], {"&": "&amp;", ">": "&gt;", "<": "&lt;", "\"": "&quot;", "'": "&#39;"}))
      }, $Formatter_escape$12.$$arity = 1), nil) && 'escape';
    })($nesting[0], null, $nesting);
    $send($$($nesting, 'Formatter'), 'for', [$$($nesting, 'HTML')], ($Paggio$13 = function(f, item){var self = $Paggio$13.$$s || this, $$14, $case = nil;

    
      
      if (f == null) {
        f = nil;
      };
      
      if (item == null) {
        item = nil;
      };
      $case = item.$version();
      if ((5)['$===']($case)) {f.$print("<!DOCTYPE html>")};
      f.$print("<html>");
      $send(f, 'indent', [], ($$14 = function(){var self = $$14.$$s || this, $$15;

      return $send(item, 'each', [], ($$15 = function(root){var self = $$15.$$s || this;

        
          
          if (root == null) {
            root = nil;
          };
          return f.$format(root);}, $$15.$$s = self, $$15.$$arity = 1, $$15))}, $$14.$$s = self, $$14.$$arity = 0, $$14));
      return f.$print("</html>");}, $Paggio$13.$$s = self, $Paggio$13.$$arity = 2, $Paggio$13));
    $send($$($nesting, 'Formatter'), 'for', [$$$($$($nesting, 'HTML'), 'Element')], ($Paggio$16 = function(f, item){var self = $Paggio$16.$$s || this, $a, $b, $$17, $$18, $$19, name = nil, attributes = nil, class_names = nil, attrs = nil;

    
      
      if (f == null) {
        f = nil;
      };
      
      if (item == null) {
        item = nil;
      };
      $b = $send(item, 'instance_eval', [], ($$17 = function(){var self = $$17.$$s || this;
        if (self.name == null) self.name = nil;
        if (self.attributes == null) self.attributes = nil;
        if (self.class_names == null) self.class_names = nil;

      return [self.name, self.attributes, self.class_names]}, $$17.$$s = self, $$17.$$arity = 0, $$17)), $a = Opal.to_ary($b), (name = ($a[0] == null ? nil : $a[0])), (attributes = ($a[1] == null ? nil : $a[1])), (class_names = ($a[2] == null ? nil : $a[2])), $b;
      if ($truthy(($truthy($a = attributes['$empty?']()) ? class_names['$empty?']() : $a))) {
        f.$print("" + "<" + (name) + ">")
      } else {
        
        attrs = $send(attributes, 'map', [], ($$18 = function(key, value){var self = $$18.$$s || this;

        
          
          if (key == null) {
            key = nil;
          };
          
          if (value == null) {
            value = nil;
          };
          return "" + (f.$escape(key)) + "=\"" + (f.$escape(value)) + "\"";}, $$18.$$s = self, $$18.$$arity = 2, $$18));
        if ($truthy(class_names['$empty?']())) {
        } else {
          attrs['$<<']("" + "class=\"" + (f.$escape(class_names.$join(" "))) + "\"")
        };
        f.$print("" + "<" + (name) + " " + (attrs.$join(" ")) + ">");
      };
      $send(f, 'indent', [], ($$19 = function(){var self = $$19.$$s || this, $$20, $$21, inner = nil;

      if ($truthy((inner = $send(item, 'instance_eval', [], ($$20 = function(){var self = $$20.$$s || this;
          if (self.inner_html == null) self.inner_html = nil;

        return self.inner_html}, $$20.$$s = self, $$20.$$arity = 0, $$20))))) {
          return f.$print(inner)
        } else {
          return $send(item, 'each', [], ($$21 = function(child){var self = $$21.$$s || this, $$22, $case = nil;

          
            
            if (child == null) {
              child = nil;
            };
            return (function() {$case = child;
            if ($$($nesting, 'String')['$===']($case)) {return f.$print(f.$escape(child))}
            else if ($$($nesting, 'CSS')['$===']($case)) {
            f.$print("<style>");
            $send(f, 'indent', [], ($$22 = function(){var self = $$22.$$s || this;

            return f.$format(child)}, $$22.$$s = self, $$22.$$arity = 0, $$22));
            return f.$print("</style>");}
            else {return f.$format(child)}})();}, $$21.$$s = self, $$21.$$arity = 1, $$21))
        }}, $$19.$$s = self, $$19.$$arity = 0, $$19));
      return f.$print("" + "</" + (name) + ">");}, $Paggio$16.$$s = self, $Paggio$16.$$arity = 2, $Paggio$16));
    return $send($$($nesting, 'Formatter'), 'for', [$$($nesting, 'CSS')], ($Paggio$23 = function(f, item){var self = $Paggio$23.$$s || this, $$24;

    
      
      if (f == null) {
        f = nil;
      };
      
      if (item == null) {
        item = nil;
      };
      return $send(item.$rules().$reverse(), 'each', [], ($$24 = function(rule){var self = $$24.$$s || this, $$25;

      
        
        if (rule == null) {
          rule = nil;
        };
        if ($truthy(rule.$definition()['$empty?']())) {
          return nil;};
        f.$print("" + (rule.$selector()) + " {");
        $send(f, 'indent', [], ($$25 = function(){var self = $$25.$$s || this, $$26;

        return $send(rule.$definition(), 'each', [], ($$26 = function(style){var self = $$26.$$s || this;

          
            
            if (style == null) {
              style = nil;
            };
            return f.$print("" + (style.$name()) + ": " + (style.$value()) + ((function() {if ($truthy(style.$important())) {
              return " !important"
            } else {
              return nil
            }; return nil; })()) + ";");}, $$26.$$s = self, $$26.$$arity = 1, $$26))}, $$25.$$s = self, $$25.$$arity = 0, $$25));
        return f.$print("}");}, $$24.$$s = self, $$24.$$arity = 1, $$24));}, $Paggio$23.$$s = self, $Paggio$23.$$arity = 2, $Paggio$23));
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["paggio"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$options', '$to_proc', '$to_s', '$format', '$new', '$tap', '$each']);
  
  self.$require("paggio/utils");
  self.$require("paggio/html");
  self.$require("paggio/css");
  self.$require("paggio/formatter");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Paggio');

    var $nesting = [self].concat($parent_nesting), $Paggio_options$1, $Paggio_indent$2, $Paggio_css$3, $Paggio_html$4, $Paggio_html$excl$5;

    
    Opal.defs(self, '$options', $Paggio_options$1 = function $$options(options) {
      var $iter = $Paggio_options$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Paggio_options$1.$$p = null;
      
      
      if ($iter) $Paggio_options$1.$$p = null;;
      return $send($$($nesting, 'Formatter'), 'options', [options], block.$to_proc());
    }, $Paggio_options$1.$$arity = 1);
    Opal.defs(self, '$indent', $Paggio_indent$2 = function $$indent(options) {
      var $iter = $Paggio_indent$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Paggio_indent$2.$$p = null;
      
      
      if ($iter) $Paggio_indent$2.$$p = null;;
      return $send(self, 'options', [$hash2(["indent"], {"indent": options})], block.$to_proc());
    }, $Paggio_indent$2.$$arity = 1);
    Opal.defs(self, '$css', $Paggio_css$3 = function $$css($a) {
      var $iter = $Paggio_css$3.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Paggio_css$3.$$p = null;
      
      
      if ($iter) $Paggio_css$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $$($nesting, 'Formatter').$new().$format($send($$($nesting, 'CSS'), 'new', Opal.to_a(args), block.$to_proc())).$to_s();
    }, $Paggio_css$3.$$arity = -1);
    Opal.defs(self, '$html', $Paggio_html$4 = function $$html($a) {
      var $iter = $Paggio_html$4.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Paggio_html$4.$$p = null;
      
      
      if ($iter) $Paggio_html$4.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $$($nesting, 'Formatter').$new().$format($send($$($nesting, 'HTML'), 'new', Opal.to_a(args), block.$to_proc())).$to_s();
    }, $Paggio_html$4.$$arity = -1);
    return (Opal.defs(self, '$html!', $Paggio_html$excl$5 = function() {
      var $iter = $Paggio_html$excl$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Paggio_html$excl$5.$$p = null;
      
      
      if ($iter) $Paggio_html$excl$5.$$p = null;;
      return $send($$($nesting, 'Formatter').$new(), 'tap', [], ($$6 = function(f){var self = $$6.$$s || this, $$7;

      
        
        if (f == null) {
          f = nil;
        };
        return $send($send($$($nesting, 'HTML'), 'new', [], block.$to_proc()), 'each', [], ($$7 = function(root){var self = $$7.$$s || this;

        
          
          if (root == null) {
            root = nil;
          };
          return f.$format(root);}, $$7.$$s = self, $$7.$$arity = 1, $$7));}, $$6.$$s = self, $$6.$$arity = 1, $$6)).$to_s();
    }, $Paggio_html$excl$5.$$arity = 0), nil) && 'html!';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/version"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    Opal.const_set($nesting[0], 'VERSION', "0.2.0")
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/utils"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $klass = Opal.klass;

  Opal.add_stubs(['$new', '$include', '$extend', '$!', '$private', '$restricted?', '$allocate', '$instance_variable_set', '$native?', '$raise', '$warn', '$encode_uri', '$to_s', '$encode', '$decode', '$decode_uri', '$parse_query', '$build_query']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'Size', $$($nesting, 'Struct').$new("width", "height"));
    Opal.const_set($nesting[0], 'Position', $$($nesting, 'Struct').$new("x", "y"));
    (function($base, $parent_nesting) {
      var self = $module($base, 'NativeCachedWrapper');

      var $nesting = [self].concat($parent_nesting), $NativeCachedWrapper_included$1, $NativeCachedWrapper_restricted$ques$2, $NativeCachedWrapper_set_native_reference$3;

      
      Opal.defs(self, '$included', $NativeCachedWrapper_included$1 = function $$included(klass) {
        var self = this;

        
        klass.$include($$$($$($nesting, 'Native'), 'Wrapper'));
        return klass.$extend($$($nesting, 'NativeCachedWrapperClassMethods'));
      }, $NativeCachedWrapper_included$1.$$arity = 1);
      
      Opal.def(self, '$restricted?', $NativeCachedWrapper_restricted$ques$2 = function() {
        var self = this;
        if (self.restricted == null) self.restricted = nil;

        return self.restricted['$!']()['$!']()
      }, $NativeCachedWrapper_restricted$ques$2.$$arity = 0);
      
      Opal.def(self, '$set_native_reference', $NativeCachedWrapper_set_native_reference$3 = function $$set_native_reference(native$) {
        var self = this;

        
        native$.$$opal_native_cached = self;
        return (self["native"] = native$);
      }, $NativeCachedWrapper_set_native_reference$3.$$arity = 1);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'NativeCachedWrapperClassMethods');

      var $nesting = [self].concat($parent_nesting), $NativeCachedWrapperClassMethods_restricted$ques$4, $NativeCachedWrapperClassMethods_new$5;

      
      self.$private((Opal.def(self, '$restricted?', $NativeCachedWrapperClassMethods_restricted$ques$4 = function(native$) {
        var self = this;

        
        try {
          typeof(native$.$$try_restricted_access);
        } catch (e) {
          if (e.name == 'SecurityError') return true;
        }
        return false;
      
      }, $NativeCachedWrapperClassMethods_restricted$ques$4.$$arity = 1), nil) && 'restricted?');
      
      Opal.def(self, '$new', $NativeCachedWrapperClassMethods_new$5 = function(native$) {
        var $iter = $NativeCachedWrapperClassMethods_new$5.$$p, $yield = $iter || nil, self = this, obj = nil;

        if ($iter) $NativeCachedWrapperClassMethods_new$5.$$p = null;
        
        if ($truthy(self['$restricted?'](native$))) {
          
          obj = self.$allocate();
          obj.$instance_variable_set("@native", native$);
          obj.$instance_variable_set("@restricted", true);
          return obj;};
        if ($truthy(self['$native?'](native$)['$!']())) {
          self.$raise($$($nesting, 'ArgumentError'))};
        if ($truthy((typeof(native$.$$opal_native_cached) !== "undefined"))) {
          return native$.$$opal_native_cached
        } else {
          return native$.$$opal_native_cached = $send(self, Opal.find_super_dispatcher(self, 'new', $NativeCachedWrapperClassMethods_new$5, false), [native$], null)
        };
      }, $NativeCachedWrapperClassMethods_new$5.$$arity = 1);
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $Object_encode_uri$6, $Object_encode_uri_component$7;

    
    
    Opal.def(self, '$encode_uri', $Object_encode_uri$6 = function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: Object#encode_uri is deprecated. Please use FormData.encode_uri");
      return $$($nesting, 'FormData').$encode_uri(self.$to_s());
    }, $Object_encode_uri$6.$$arity = 0);
    return (Opal.def(self, '$encode_uri_component', $Object_encode_uri_component$7 = function $$encode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: Object#encode_uri_component is deprecated. Please use FormData.encode");
      return $$($nesting, 'FormData').$encode(self.$to_s());
    }, $Object_encode_uri_component$7.$$arity = 0), nil) && 'encode_uri_component';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_encode_uri_component$8, $String_encode_uri$9, $String_decode_uri_component$10, $String_decode_uri$11;

    
    
    Opal.def(self, '$encode_uri_component', $String_encode_uri_component$8 = function $$encode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: String#encode_uri_component is deprecated. Please use FormData.encode");
      return $$($nesting, 'FormData').$encode(self);
    }, $String_encode_uri_component$8.$$arity = 0);
    
    Opal.def(self, '$encode_uri', $String_encode_uri$9 = function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: String#encode_uri is deprecated. Please use FormData.encode_uri");
      return $$($nesting, 'FormData').$encode_uri(self);
    }, $String_encode_uri$9.$$arity = 0);
    
    Opal.def(self, '$decode_uri_component', $String_decode_uri_component$10 = function $$decode_uri_component() {
      var self = this;

      
      self.$warn("opal-browser: String#decode_uri_component is deprecated. Please use FormData.decode");
      return $$($nesting, 'FormData').$decode(self);
    }, $String_decode_uri_component$10.$$arity = 0);
    return (Opal.def(self, '$decode_uri', $String_decode_uri$11 = function $$decode_uri() {
      var self = this;

      
      self.$warn("opal-browser: String#decode_uri is deprecated. Please use FormData.decode_uri");
      return $$($nesting, 'FormData').$decode_uri(self);
    }, $String_decode_uri$11.$$arity = 0), nil) && 'decode_uri';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_decode_uri$12, $Hash_encode_uri$13;

    
    Opal.defs(self, '$decode_uri', $Hash_decode_uri$12 = function $$decode_uri(string) {
      var self = this;

      
      self.$warn("opal-browser: Hash.decode_uri is deprecated. Please use FormData.parse_query");
      return $$($nesting, 'FormData').$parse_query(string);
    }, $Hash_decode_uri$12.$$arity = 1);
    return (Opal.def(self, '$encode_uri', $Hash_encode_uri$13 = function $$encode_uri() {
      var self = this;

      
      self.$warn("opal-browser: Hash#encode_uri is deprecated. Please use FormData.build_query");
      return $$($nesting, 'FormData').$build_query(self);
    }, $Hash_encode_uri$13.$$arity = 0), nil) && 'encode_uri';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/form_data"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$include', '$===', '$each', '$!=', '$+', '$flatten', '$first', '$split', '$scan', '$proc', '$call', '$<<', '$last', '$[]', '$[]=', '$-', '$!', '$any?', '$include?', '$class', '$join', '$map', '$encode', '$to_s', '$create', '$unflatten', '$to_proc', '$method', '$extend', '$build_form_data', '$new', '$to_n', '$convert', '$Native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'FormData');

      var $nesting = [self].concat($parent_nesting), $FormData_create$22, $FormData_$lt$lt$23, $FormData_$$$24, $FormData_set$25, $FormData_include$ques$26, $FormData_delete$27;

      self.$$prototype["native"] = nil;
      
      self.$include($$($nesting, 'NativeCachedWrapper'));
      (function($base, $parent_nesting) {
        var self = $module($base, 'Converter');

        var $nesting = [self].concat($parent_nesting), $Converter_encode$1, $Converter_decode$2, $Converter_encode_uri$3, $Converter_decode_uri$4, $Converter_flatten$5, $Converter_unflatten$8, $Converter_contain_files$ques$14, $Converter_build_query$16, $Converter_build_form_data$18, $Converter_parse_query$20;

        
        
        Opal.def(self, '$encode', $Converter_encode$1 = function $$encode(string) {
          var self = this;

          return encodeURIComponent(string)
        }, $Converter_encode$1.$$arity = 1);
        
        Opal.def(self, '$decode', $Converter_decode$2 = function $$decode(string) {
          var self = this;

          return decodeURIComponent(string)
        }, $Converter_decode$2.$$arity = 1);
        
        Opal.def(self, '$encode_uri', $Converter_encode_uri$3 = function $$encode_uri(string) {
          var self = this;

          return encodeURI(string)
        }, $Converter_encode_uri$3.$$arity = 1);
        
        Opal.def(self, '$decode_uri', $Converter_decode_uri$4 = function $$decode_uri(string) {
          var self = this;

          return decodeURI(string)
        }, $Converter_decode_uri$4.$$arity = 1);
        
        Opal.def(self, '$flatten', $Converter_flatten$5 = function $$flatten(value, key) {
          var $$6, $$7, self = this, $case = nil, out = nil;

          
          
          if (key == null) {
            key = "";
          };
          return (function() {$case = value;
          if ($$($nesting, 'Hash')['$===']($case)) {
          out = [];
          $send(value, 'each', [], ($$6 = function(k, v){var self = $$6.$$s || this;

          
            
            if (k == null) {
              k = nil;
            };
            
            if (v == null) {
              v = nil;
            };
            if ($truthy(key['$!='](""))) {
              k = "" + (key) + "[" + (k) + "]"};
            return (out = $rb_plus(out, self.$flatten(v, k)));}, $$6.$$s = self, $$6.$$arity = 2, $$6));
          return out;}
          else if ($$($nesting, 'Array')['$===']($case)) {
          out = [];
          $send(value, 'each', [], ($$7 = function(v){var self = $$7.$$s || this, k = nil;

          
            
            if (v == null) {
              v = nil;
            };
            k = "" + (key) + "[]";
            return (out = $rb_plus(out, self.$flatten(v, k)));}, $$7.$$s = self, $$7.$$arity = 1, $$7));
          return out;}
          else {return [[key, value]]}})();
        }, $Converter_flatten$5.$$arity = -2);
        
        Opal.def(self, '$unflatten', $Converter_unflatten$8 = function $$unflatten(array) {
          var $$9, self = this, out = nil;

          
          out = $hash2([], {});
          $send(array, 'each', [], ($$9 = function(k, v){var self = $$9.$$s || this, $$10, $$11, path = nil, c = nil, set = nil;

          
            
            if (k == null) {
              k = nil;
            };
            
            if (v == null) {
              v = nil;
            };
            path = $rb_plus([k.$split("[").$first()], k.$scan(/\[(.*?)\]/).$flatten());
            c = out;
            set = $send(self, 'proc', [], ($$10 = function(v, weak){var self = $$10.$$s || this;

            
              
              if (v == null) {
                v = nil;
              };
              
              if (weak == null) {
                weak = nil;
              };
              return nil;}, $$10.$$s = self, $$10.$$arity = 2, $$10));
            $send(path, 'each', [], ($$11 = function(i){var self = $$11.$$s || this, $$12, $$13, $case = nil;

            
              
              if (i == null) {
                i = nil;
              };
              return (function() {$case = i;
              if (""['$===']($case)) {
              set.$call([], true);
              return (set = $send(self, 'proc', [], ($$12 = function(v, weak){var self = $$12.$$s || this;

              
                
                if (v == null) {
                  v = nil;
                };
                
                if (weak == null) {
                  weak = nil;
                };
                c['$<<'](v);
                return (c = c.$last());}, $$12.$$s = self, $$12.$$arity = 2, $$12)));}
              else {
              set.$call($hash2([], {}), true);
              return (set = $send(self, 'proc', [], ($$13 = function(v, weak){var self = $$13.$$s || this, $a, $writer = nil;

              
                
                if (v == null) {
                  v = nil;
                };
                
                if (weak == null) {
                  weak = nil;
                };
                ($truthy($a = c['$[]'](i)) ? $a : (($writer = [i, v]), $send(c, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
                if ($truthy(weak['$!']())) {
                  
                  $writer = [i, v];
                  $send(c, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
                return (c = c['$[]'](i));}, $$13.$$s = self, $$13.$$arity = 2, $$13)));}})();}, $$11.$$s = self, $$11.$$arity = 1, $$11));
            return set.$call(v, false);}, $$9.$$s = self, $$9.$$arity = 2, $$9));
          return out;
        }, $Converter_unflatten$8.$$arity = 1);
        
        Opal.def(self, '$contain_files?', $Converter_contain_files$ques$14 = function(hash) {
          var $$15, self = this;

          return $send(self.$flatten(hash), 'any?', [], ($$15 = function(k, v){var self = $$15.$$s || this;

          
            
            if (k == null) {
              k = nil;
            };
            
            if (v == null) {
              v = nil;
            };
            return [$$($nesting, 'File'), $$($nesting, 'Blob')]['$include?'](v.$class());}, $$15.$$s = self, $$15.$$arity = 2, $$15))
        }, $Converter_contain_files$ques$14.$$arity = 1);
        
        Opal.def(self, '$build_query', $Converter_build_query$16 = function $$build_query(hash, sep) {
          var $$17, self = this;

          
          
          if (sep == null) {
            sep = "&";
          };
          return $send(self.$flatten(hash), 'map', [], ($$17 = function(k, v){var self = $$17.$$s || this;

          
            
            if (k == null) {
              k = nil;
            };
            
            if (v == null) {
              v = nil;
            };
            return $rb_plus($rb_plus(self.$encode(k), "="), self.$encode(v.$to_s()));}, $$17.$$s = self, $$17.$$arity = 2, $$17)).$join(sep);
        }, $Converter_build_query$16.$$arity = -2);
        
        Opal.def(self, '$build_form_data', $Converter_build_form_data$18 = function $$build_form_data(hash) {
          var $$19, self = this, fd = nil;

          
          fd = $$($nesting, 'FormData').$create();
          $send(self.$flatten(hash), 'each', [], ($$19 = function(k, v){var self = $$19.$$s || this;

          
            
            if (k == null) {
              k = nil;
            };
            
            if (v == null) {
              v = nil;
            };
            return fd['$<<']([k, v]);}, $$19.$$s = self, $$19.$$arity = 2, $$19));
          return fd;
        }, $Converter_build_form_data$18.$$arity = 1);
        
        Opal.def(self, '$parse_query', $Converter_parse_query$20 = function $$parse_query(string, sep) {
          var $$21, self = this;

          
          
          if (sep == null) {
            sep = "&";
          };
          return self.$unflatten($send(string.$split(sep), 'map', [], ($$21 = function(s){var self = $$21.$$s || this;

          
            
            if (s == null) {
              s = nil;
            };
            return $send(s.$split("="), 'map', [], self.$method("decode").$to_proc());}, $$21.$$s = self, $$21.$$arity = 1, $$21)));
        }, $Converter_parse_query$20.$$arity = -2);
      })($nesting[0], $nesting);
      self.$extend($$($nesting, 'Converter'));
      Opal.defs(self, '$create', $FormData_create$22 = function $$create(hash) {
        var self = this;

        
        
        if (hash == null) {
          hash = nil;
        };
        if ($truthy($$($nesting, 'Hash')['$==='](hash))) {
          return $$($nesting, 'FormData').$build_form_data(hash)
        } else if ($truthy($$$($$$($$($nesting, 'DOM'), 'Element'), 'Form')['$==='](hash))) {
          return self.$new(new FormData(hash.$to_n()))
        } else {
          return self.$new(new FormData())
        };
      }, $FormData_create$22.$$arity = -1);
      
      Opal.def(self, '$<<', $FormData_$lt$lt$23 = function(tuple) {
        var $a, $b, self = this, key = nil, value = nil, filename = nil;

        
        $b = tuple, $a = Opal.to_ary($b), (key = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), (filename = ($a[2] == null ? nil : $a[2])), $b;
        if ($truthy(filename)) {
          return self["native"].append(key, $$($nesting, 'Native').$convert(value), filename)
        } else {
          return self["native"].append(key, $$($nesting, 'Native').$convert(value))
        };
      }, $FormData_$lt$lt$23.$$arity = 1);
      
      Opal.def(self, '$[]', $FormData_$$$24 = function(key) {
        var self = this;

        return self.$Native(self["native"].get(key))
      }, $FormData_$$$24.$$arity = 1);
      
      Opal.def(self, '$set', $FormData_set$25 = function $$set(key, value, filename) {
        var self = this;

        
        
        if (filename == null) {
          filename = nil;
        };
        if ($truthy(filename)) {
          return self["native"].set(key, $$($nesting, 'Native').$convert(value), filename)
        } else {
          return self["native"].set(key, $$($nesting, 'Native').$convert(value))
        };
      }, $FormData_set$25.$$arity = -3);
      Opal.alias(self, "[]=", "set");
      
      Opal.def(self, '$include?', $FormData_include$ques$26 = function(key) {
        var self = this;

        return self["native"].has(key)
      }, $FormData_include$ques$26.$$arity = 1);
      return (Opal.def(self, '$delete', $FormData_delete$27 = function(key) {
        var self = this;

        return self["native"].delete(key)
      }, $FormData_delete$27.$$arity = 1), nil) && 'delete';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/support"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$downcase', '$===', '$!', '$supports?']);
  
  Opal.const_set($nesting[0], 'BROWSER_ENGINE', (function() { try {
    return (/MSIE|WebKit|Presto|Gecko/.exec(navigator.userAgent)[0]).$downcase()
  } catch ($err) {
    if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
      try {
        return "unknown"
      } finally { Opal.pop_exception() }
    } else { throw $err; }
  }})());
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting), $Browser_supports$ques$1, $Browser_loaded$ques$2;

    
    self.support = {};
    Opal.defs(self, '$supports?', $Browser_supports$ques$1 = function(feature) {
      var $a, self = this, support = nil, $case = nil;
      if (self.support == null) self.support = nil;

      
      if ($truthy((typeof(self.support[feature]) !== "undefined"))) {
        return self.support[feature]};
      support = (function() {$case = feature;
      if ("MutationObserver"['$===']($case)) {return (typeof(window.MutationObserver) !== "undefined")}
      else if ("WebSocket"['$===']($case)) {return (typeof(window.WebSocket) !== "undefined")}
      else if ("EventSource"['$===']($case)) {return (typeof(window.EventSource) !== "undefined")}
      else if ("XHR"['$===']($case)) {return (typeof(window.XMLHttpRequest) !== "undefined")}
      else if ("ActiveX"['$===']($case)) {return (typeof(window.ActiveXObject) !== "undefined")}
      else if ("WebSQL"['$===']($case)) {return (typeof(window.openDatabase) !== "undefined")}
      else if ("Query.css"['$===']($case)) {return (typeof(document.querySelectorAll) !== "undefined")}
      else if ("Query.xpath"['$===']($case)) {return (typeof(document.evaluate) !== "undefined")}
      else if ("Storage.local"['$===']($case)) {return (typeof(window.localStorage) !== "undefined")}
      else if ("Storage.global"['$===']($case)) {return (typeof(window.globalStorage) !== "undefined")}
      else if ("Storage.session"['$===']($case)) {return (typeof(window.sessionStorage) !== "undefined")}
      else if ("Immediate"['$===']($case)) {return (typeof(window.setImmediate) !== "undefined")}
      else if ("Immediate (Internet Explorer)"['$===']($case)) {return (typeof(window.msSetImmediate) !== "undefined")}
      else if ("Immediate (Firefox)"['$===']($case)) {return (typeof(window.mozSetImmediate) !== "undefined")}
      else if ("Immediate (Opera)"['$===']($case)) {return (typeof(window.oSetImmediate) !== "undefined")}
      else if ("Immediate (Chrome)"['$===']($case) || "setImmediate (Safari)"['$===']($case)) {return (typeof(window.webkitSetImmediate) !== "undefined")}
      else if ("CSS.computed"['$===']($case)) {return (typeof(window.getComputedStyle) !== "undefined")}
      else if ("CSS.current"['$===']($case)) {return (typeof(document.documentElement.currentStyle) !== "undefined")}
      else if ("Window.send"['$===']($case)) {return (typeof(window.postMessage) !== "undefined")}
      else if ("Window.send (Asynchronous)"['$===']($case)) {if ($truthy(($truthy($a = (typeof(window.postMessage) !== "undefined")) ? (typeof(window.importScripts) !== "undefined")['$!']() : $a))) {
        
            var ok  = true,
                old = window.onmessage;

            window.onmessage = function() { ok = false; };
            window.postMessage("", "*")
            window.onmessage = old;

            return ok;
          
      } else {
        return nil
      }}
      else if ("Window.send (Synchronous)"['$===']($case)) {return self['$supports?']("Window.send (Asynchronous)")['$!']()}
      else if ("Window.innerSize"['$===']($case)) {return (typeof(window.innerHeight) !== "undefined")}
      else if ("Window.outerSize"['$===']($case)) {return (typeof(window.outerHeight) !== "undefined")}
      else if ("Window.scroll"['$===']($case)) {return (typeof(document.documentElement.scrollLeft) !== "undefined")}
      else if ("Window.scrollBy"['$===']($case)) {return (typeof(document.documentElement.scrollBy) !== "undefined")}
      else if ("Window.pageOffset"['$===']($case)) {return (typeof(window.pageXOffset) !== "undefined")}
      else if ("Attr.isId"['$===']($case)) {
          var div = document.createElement('div');
              div.setAttribute('id', 'xxxxxxxxxxxxx');

          return typeof(div.attributes['id'].isId) !== "undefined";
        }
      else if ("Element.addBehavior"['$===']($case)) {return (typeof(document.documentElement.addBehavior) !== "undefined")}
      else if ("Element.className"['$===']($case)) {
          var div = document.createElement("div");
              div.setAttribute('className', 'x');

          return div.className === 'x';
        }
      else if ("Element.class"['$===']($case)) {
          var div = document.createElement("div");
              div.setAttribute('class', 'x');

          return div.className === 'x';
        }
      else if ("Element.for"['$===']($case)) {
          var label = document.createElement("label");
              label.setAttribute('for', 'x');

          return label.htmlFor === 'x';
        }
      else if ("Element.htmlFor"['$===']($case)) {
          var label = document.createElement("label");
              label.setAttribute('htmlFor', 'x');

          return label.htmlFor === 'x';
        }
      else if ("Element.clientSize"['$===']($case)) {return (typeof(document.documentElement.clientHeight) !== "undefined")}
      else if ("Element.scroll"['$===']($case)) {return (typeof(document.documentElement.scrollLeft) !== "undefined")}
      else if ("Element.textContent"['$===']($case)) {return (typeof(document.documentElement.textContent) !== "undefined")}
      else if ("Element.innerText"['$===']($case)) {return (typeof(document.documentElement.innerText) !== "undefined")}
      else if ("Element.matches"['$===']($case)) {return (typeof(document.documentElement.matches) !== "undefined")}
      else if ("Element.matches (Internet Explorer)"['$===']($case)) {return (typeof(document.documentElement.msMatchesSelector) !== "undefined")}
      else if ("Element.matches (Firefox)"['$===']($case)) {return (typeof(document.documentElement.mozMatchesSelector) !== "undefined")}
      else if ("Element.matches (Opera)"['$===']($case)) {return (typeof(document.documentElement.oMatchesSelector) !== "undefined")}
      else if ("Element.matches (Chrome)"['$===']($case) || "Element.matches (Safari)"['$===']($case)) {return (typeof(document.documentElement.webkitMatchesSelector) !== "undefined")}
      else if ("Element.getBoundingClientRect"['$===']($case)) {return (typeof(document.documentElement.getBoundingClientRect) !== "undefined")}
      else if ("Event.readystatechange"['$===']($case)) {return "onreadystatechange" in window.document.createElement("script");}
      else if ("Event.constructor"['$===']($case)) {
      try {
        
        new MouseEvent("click");
        return true;
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'StandardError'), $$$($$($nesting, 'JS'), 'Error')])) {
          try {
            return false
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };}
      else if ("Event.create"['$===']($case)) {return (typeof(document.createEvent) !== "undefined")}
      else if ("Event.createObject"['$===']($case)) {return (typeof(document.createEventObject) !== "undefined")}
      else if ("Event.addListener"['$===']($case)) {return (typeof(document.addEventListener) !== "undefined")}
      else if ("Event.attach"['$===']($case)) {return (typeof(document.attachEvent) !== "undefined")}
      else if ("Event.removeListener"['$===']($case)) {return (typeof(document.removeEventListener) !== "undefined")}
      else if ("Event.detach"['$===']($case)) {return (typeof(document.detachEvent) !== "undefined")}
      else if ("Event.dispatch"['$===']($case)) {return (typeof(document.dispatchEvent) !== "undefined")}
      else if ("Event.fire"['$===']($case)) {return (typeof(document.fireEvent) !== "undefined")}
      else if (/^Event\.([A-Z].*?)$/['$===']($case)) {return ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)) + "Event") in window}
      else if ("Document.view"['$===']($case)) {return (typeof(document.defaultView) !== "undefined")}
      else if ("Document.window"['$===']($case)) {return (typeof(document.parentWindow) !== "undefined")}
      else if ("History"['$===']($case)) {return (typeof(window.history.pushState) !== "undefined")}
      else if ("History.state"['$===']($case)) {return (typeof(window.history.state) !== "undefined")}
      else if ("Animation.request"['$===']($case)) {return (typeof(window.requestAnimationFrame) !== "undefined")}
      else if ("Animation.request (Internet Explorer)"['$===']($case)) {return (typeof(window.msRequestAnimationFrame) !== "undefined")}
      else if ("Animation.request (Firefox)"['$===']($case)) {return (typeof(window.mozRequestAnimationFrame) !== "undefined")}
      else if ("Animation.request (Opera)"['$===']($case)) {return (typeof(window.oRequestAnimationFrame) !== "undefined")}
      else if ("Animation.request (Chrome)"['$===']($case) || "Animation.request (Safari)"['$===']($case)) {return (typeof(window.webkitRequestAnimationFrame) !== "undefined")}
      else if ("Animation.cancel"['$===']($case)) {return (typeof(window.cancelAnimationFrame) !== "undefined")}
      else if ("Animation.cancel (Internet Explorer)"['$===']($case)) {return (typeof(window.msCancelAnimationFrame) !== "undefined")}
      else if ("Animation.cancel (Firefox)"['$===']($case)) {return (typeof(window.mozCancelAnimationFrame) !== "undefined")}
      else if ("Animation.cancel (Opera)"['$===']($case)) {return (typeof(window.oCancelAnimationFrame) !== "undefined")}
      else if ("Animation.cancel (Chrome)"['$===']($case) || "Animation.cancel (Safari)"['$===']($case)) {return (typeof(window.webkitCancelAnimationFrame) !== "undefined")}
      else if ("Animation.cancelRequest"['$===']($case)) {return (typeof(window.cancelRequestAnimationFrame) !== "undefined")}
      else if ("Animation.cancelRequest (Internet Explorer)"['$===']($case)) {return (typeof(window.msCancelRequestAnimationFrame) !== "undefined")}
      else if ("Animation.cancelRequest (Firefox)"['$===']($case)) {return (typeof(window.mozCancelRequestAnimationFrame) !== "undefined")}
      else if ("Animation.cancelRequest (Opera)"['$===']($case)) {return (typeof(window.oCancelRequestAnimationFrame) !== "undefined")}
      else if ("Animation.cancelRequest (Chrome)"['$===']($case) || "Animation.cancelRequest (Safari)"['$===']($case)) {return (typeof(window.webkitCancelRequestAnimationFrame) !== "undefined")}
      else if ("Audio"['$===']($case)) {return (typeof(window.AudioContext) !== "undefined")}
      else if ("Audio (Safari)"['$===']($case) || "Audio (Chrome)"['$===']($case)) {return (typeof(window.webkitAudioContext) !== "undefined")}
      else { return nil }})();
      return self.support[feature] = support;
    }, $Browser_supports$ques$1.$$arity = 1);
    Opal.defs(self, '$loaded?', $Browser_loaded$ques$2 = function(name) {
      var self = this, $case = nil;

      return (function() {$case = name;
      if ("Sizzle"['$===']($case)) {return (typeof(window.Sizzle) !== "undefined")}
      else if ("wicked-good-xpath"['$===']($case)) {return (typeof(window.wgxpath) !== "undefined")}
      else { return nil }})()
    }, $Browser_loaded$ques$2.$$arity = 1);
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/base"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $lambda = Opal.lambda, $hash2 = Opal.hash2;

  Opal.add_stubs(['$include', '$call', '$to_n', '$<<', '$converters', '$native?', '$each', '$instance_eval', '$register', '$to_proc', '$attr_reader', '$new', '$stopped?', '$arguments', '$!', '$prevented?', '$class_for', '$off', '$target', '$[]', '$delegated', '$delete', '$last', '$empty?', '$first', '$raise', '$name_for', '$handlers', '$[]=', '$-', '$include?', '$on!', '$delegate', '$callback=', '$on', '$handlers=', '$push', '$callbacks', '$attach', '$attach!', '$supports?', '$name', '$==', '$event', '$===', '$warn', '$detach', '$gsub', '$delete_if', '$=~', '$clear', '$none?', '$is_a?', '$create', '$dispatch', '$trigger', '$bubbles=', '$private', '$nil?', '$dup', '$on=', '$parent']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      
      self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Definition');

        var $nesting = [self].concat($parent_nesting), $Definition_new$1, $Definition_bubbles$eq$2, $Definition_cancelable$eq$3;

        self.$$prototype["native"] = nil;
        
        self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
        Opal.defs(self, '$new', $Definition_new$1 = function() {
          var $iter = $Definition_new$1.$$p, block = $iter || nil, self = this, data = nil;

          if ($iter) $Definition_new$1.$$p = null;
          
          
          if ($iter) $Definition_new$1.$$p = null;;
          data = $send(self, Opal.find_super_dispatcher(self, 'new', $Definition_new$1, false, self.$$class.$$prototype), [{ bubbles: true, cancelable: true }], null);
          if ($truthy(block)) {
            block.$call(data)};
          return data.$to_n();
        }, $Definition_new$1.$$arity = 0);
        
        Opal.def(self, '$bubbles=', $Definition_bubbles$eq$2 = function(value) {
          var self = this;

          return self["native"].bubbles = value
        }, $Definition_bubbles$eq$2.$$arity = 1);
        return (Opal.def(self, '$cancelable=', $Definition_cancelable$eq$3 = function(value) {
          var self = this;

          return self["native"].cancelable = value
        }, $Definition_cancelable$eq$3.$$arity = 1), nil) && 'cancelable=';
      })($nesting[0], null, $nesting);
      return (function($base, $parent_nesting) {
        var self = $module($base, 'Target');

        var $nesting = [self].concat($parent_nesting), $Target_converters$4, $Target_register$5, $Target_convert$6, $Target_included$8, $Target_on$19, $Target_on$excl$22, $Target_attach$23, $Target_attach$excl$24, $Target_attach$25, $Target_attach$excl$26, $Target_attach$27, $Target_attach$excl$28, $Target_one$29, $Target_off$31, $Target_detach$35, $Target_detach$36, $Target_detach$38, $Target_trigger$39, $Target_trigger$excl$40, $Target_dispatch$42, $Target_dispatch$43, $Target_dispatch$44, $Target_callbacks$45, $Target_delegated$46, $Target_delegate$47;

        
        Opal.defs(self, '$converters', $Target_converters$4 = function $$converters() {
          var $a, self = this;
          if (self.converters == null) self.converters = nil;

          return (self.converters = ($truthy($a = self.converters) ? $a : []))
        }, $Target_converters$4.$$arity = 0);
        Opal.defs(self, '$register', $Target_register$5 = function $$register() {
          var $iter = $Target_register$5.$$p, block = $iter || nil, self = this;

          if ($iter) $Target_register$5.$$p = null;
          
          
          if ($iter) $Target_register$5.$$p = null;;
          return self.$converters()['$<<'](block);
        }, $Target_register$5.$$arity = 0);
        Opal.defs(self, '$convert', $Target_convert$6 = function $$convert(value) {try {

          var $$7, self = this;

          
          if ($truthy(self['$native?'](value))) {
          } else {
            return value
          };
          $send(self.$converters(), 'each', [], ($$7 = function(block){var self = $$7.$$s || this, result = nil;

          
            
            if (block == null) {
              block = nil;
            };
            if ($truthy((result = block.$call(value)))) {
              Opal.ret(result)
            } else {
              return nil
            };}, $$7.$$s = self, $$7.$$arity = 1, $$7));
          return nil;
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, $Target_convert$6.$$arity = 1);
        Opal.defs(self, '$included', $Target_included$8 = function $$included(klass) {
          var $$9, self = this;

          return $send(klass, 'instance_eval', [], ($$9 = function(){var self = $$9.$$s || this, $target$10;

          return (Opal.defs(self, '$target', $target$10 = function $$target() {
              var $iter = $target$10.$$p, block = $iter || nil, self = this;

              if ($iter) $target$10.$$p = null;
              
              
              if ($iter) $target$10.$$p = null;;
              return $send($$$($$($nesting, 'Event'), 'Target'), 'register', [], block.$to_proc());
            }, $target$10.$$arity = 0), nil) && 'target'}, $$9.$$s = self, $$9.$$arity = 0, $$9))
        }, $Target_included$8.$$arity = 1);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Callback');

          var $nesting = [self].concat($parent_nesting), $Callback_initialize$11, $Callback_call$12, $Callback_to_proc$13, $Callback_event$15, $Callback_off$16;

          self.$$prototype.proc = self.$$prototype.name = nil;
          
          self.$attr_reader("target", "name", "selector");
          
          Opal.def(self, '$initialize', $Callback_initialize$11 = function $$initialize(target, name, selector) {
            var $iter = $Callback_initialize$11.$$p, block = $iter || nil, self = this;

            if ($iter) $Callback_initialize$11.$$p = null;
            
            
            if ($iter) $Callback_initialize$11.$$p = null;;
            
            if (selector == null) {
              selector = nil;
            };
            self.target = target;
            self.name = name;
            self.selector = selector;
            return (self.block = block);
          }, $Callback_initialize$11.$$arity = -3);
          
          Opal.def(self, '$call', $Callback_call$12 = function $$call(event) {
            var self = this;

            return self.$to_proc().$call(event)
          }, $Callback_call$12.$$arity = 1);
          
          Opal.def(self, '$to_proc', $Callback_to_proc$13 = function $$to_proc() {
            var $a, $$14, self = this;

            return (self.proc = ($truthy($a = self.proc) ? $a : $lambda(($$14 = function(event){var self = $$14.$$s || this;
              if (self.block == null) self.block = nil;

            
              
              if (event == null) {
                event = nil;
              };
              
            if (!event.currentTarget) {
              event.currentTarget = self.target.native;
            }
          ;
              event = $$($nesting, 'Event').$new(event, self);
              if ($truthy(event['$stopped?']())) {
              } else {
                $send(self.block, 'call', [event].concat(Opal.to_a(event.$arguments())))
              };
              return event['$prevented?']()['$!']();}, $$14.$$s = self, $$14.$$arity = 1, $$14))))
          }, $Callback_to_proc$13.$$arity = 0);
          
          Opal.def(self, '$event', $Callback_event$15 = function $$event() {
            var self = this;

            return $$($nesting, 'Event').$class_for(self.name)
          }, $Callback_event$15.$$arity = 0);
          return (Opal.def(self, '$off', $Callback_off$16 = function $$off() {
            var self = this;

            return self.$target().$off(self)
          }, $Callback_off$16.$$arity = 0), nil) && 'off';
        })($nesting[0], null, $nesting);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Delegate');

          var $nesting = [self].concat($parent_nesting), $Delegate_initialize$17, $Delegate_off$18;

          self.$$prototype.target = self.$$prototype.name = self.$$prototype.pair = nil;
          
          
          Opal.def(self, '$initialize', $Delegate_initialize$17 = function $$initialize(target, name, pair) {
            var self = this;

            
            self.target = target;
            self.name = name;
            return (self.pair = pair);
          }, $Delegate_initialize$17.$$arity = 3);
          return (Opal.def(self, '$off', $Delegate_off$18 = function $$off() {
            var self = this, delegate = nil;

            
            delegate = self.target.$delegated()['$[]'](self.name);
            delegate.$last().$delete(self.pair);
            if ($truthy(delegate.$last()['$empty?']())) {
              
              delegate.$first().$off();
              return delegate.$delete(self.name);
            } else {
              return nil
            };
          }, $Delegate_off$18.$$arity = 0), nil) && 'off';
        })($nesting[0], null, $nesting);
        Opal.const_set($nesting[0], 'Delegates', $$($nesting, 'Struct').$new("callback", "handlers"));
        
        Opal.def(self, '$on', $Target_on$19 = function $$on(name, selector) {
          var $iter = $Target_on$19.$$p, block = $iter || nil, $$20, $$21, self = this, delegate = nil, pair = nil, $writer = nil, callback = nil;

          if ($iter) $Target_on$19.$$p = null;
          
          
          if ($iter) $Target_on$19.$$p = null;;
          
          if (selector == null) {
            selector = nil;
          };
          if ($truthy(block)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "no block has been given")
          };
          name = $$($nesting, 'Event').$name_for(name);
          if ($truthy(selector)) {
            if ($truthy((delegate = self.$delegated()['$[]'](name)))) {
              
              pair = [selector, block];
              delegate.$handlers()['$<<'](pair);
              return $$($nesting, 'Delegate').$new(self, name, pair);
            } else {
              
              delegate = (($writer = [name, $$($nesting, 'Delegates').$new()]), $send(self.$delegated(), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
              if ($truthy(["blur", "focus"]['$include?'](name))) {
                
                $writer = [$send(self, 'on!', [name], ($$20 = function(e){var self = $$20.$$s || this;

                
                  
                  if (e == null) {
                    e = nil;
                  };
                  return self.$delegate(delegate, e);}, $$20.$$s = self, $$20.$$arity = 1, $$20))];
                $send(delegate, 'callback=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              } else {
                
                $writer = [$send(self, 'on', [name], ($$21 = function(e){var self = $$21.$$s || this;

                
                  
                  if (e == null) {
                    e = nil;
                  };
                  return self.$delegate(delegate, e);}, $$21.$$s = self, $$21.$$arity = 1, $$21))];
                $send(delegate, 'callback=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              };
              pair = [selector, block];
              
              $writer = [[pair]];
              $send(delegate, 'handlers=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return $$($nesting, 'Delegate').$new(self, name, pair);
            }
          } else {
            
            callback = $send($$($nesting, 'Callback'), 'new', [self, name, selector], block.$to_proc());
            self.$callbacks().$push(callback);
            return self.$attach(callback);
          };
        }, $Target_on$19.$$arity = -2);
        
        Opal.def(self, '$on!', $Target_on$excl$22 = function(name) {
          var $iter = $Target_on$excl$22.$$p, block = $iter || nil, self = this, callback = nil;

          if ($iter) $Target_on$excl$22.$$p = null;
          
          
          if ($iter) $Target_on$excl$22.$$p = null;;
          if ($truthy(block)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "no block has been given")
          };
          name = $$($nesting, 'Event').$name_for(name);
          callback = $send($$($nesting, 'Callback'), 'new', [self, name], block.$to_proc());
          self.$callbacks().$push(callback);
          return self['$attach!'](callback);
        }, $Target_on$excl$22.$$arity = 1);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Event.addListener"))) {
          
          
          Opal.def(self, '$attach', $Target_attach$23 = function $$attach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            self["native"].addEventListener(callback.$name(), callback.$to_proc());
            return callback;
          }, $Target_attach$23.$$arity = 1);
          
          Opal.def(self, '$attach!', $Target_attach$excl$24 = function(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            self["native"].addEventListener(callback.$name(), callback.$to_proc(), true);
            return callback;
          }, $Target_attach$excl$24.$$arity = 1);
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.attach"))) {
          
          
          Opal.def(self, '$attach', $Target_attach$25 = function $$attach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            
            if (callback.$event()['$==']($$($nesting, 'Custom'))) {
              
            if (!self["native"].$custom) {
              self["native"].$custom = function(event) {
                for (var i = 0, length = self["native"].$callbacks.length; i < length; i++) {
                  var callback = self["native"].$callbacks[i];

                  if ((callback).$event()['$==']($$($nesting, 'Custom'))) {
                    event.type = callback.name;

                    (callback).$call(event);
                  }
                }
              };

              self["native"].attachEvent("ondataavailable", self["native"].$custom);
            }
          
            } else {
              self["native"].attachEvent("on" + callback.$name(), callback.$to_proc())
            };
            return callback;
          }, $Target_attach$25.$$arity = 1);
          
          Opal.def(self, '$attach!', $Target_attach$excl$26 = function(callback) {
            var self = this, $case = nil;
            if (self["native"] == null) self["native"] = nil;

            
            $case = callback.$name();
            if ("blur"['$===']($case)) {self["native"].attachEvent("onfocusout", callback.$to_proc())}
            else if ("focus"['$===']($case)) {self["native"].attachEvent("onfocusin", callback.$to_proc())}
            else {
            self.$warn("attach: capture doesn't work on this browser");
            self.$attach(callback);};
            return callback;
          }, $Target_attach$excl$26.$$arity = 1);
        } else {
          
          
          Opal.def(self, '$attach', $Target_attach$27 = function $$attach($a) {
            var $post_args, self = this;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            ;
            return self.$raise($$($nesting, 'NotImplementedError'));
          }, $Target_attach$27.$$arity = -1);
          
          Opal.def(self, '$attach!', $Target_attach$excl$28 = function($a) {
            var $post_args, self = this;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            ;
            return self.$raise($$($nesting, 'NotImplementedError'));
          }, $Target_attach$excl$28.$$arity = -1);
        };
        
        Opal.def(self, '$one', $Target_one$29 = function $$one(name, selector) {
          var $iter = $Target_one$29.$$p, block = $iter || nil, $$30, self = this, cb = nil;

          if ($iter) $Target_one$29.$$p = null;
          
          
          if ($iter) $Target_one$29.$$p = null;;
          
          if (selector == null) {
            selector = nil;
          };
          if ($truthy(block)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "no block has been given")
          };
          return (cb = $send(self, 'on', [name, selector], ($$30 = function($a){var self = $$30.$$s || this, $post_args, args, out = nil;

          
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            out = $send(block, 'call', Opal.to_a(args));
            cb.$off();
            return out;}, $$30.$$s = self, $$30.$$arity = -1, $$30)));
        }, $Target_one$29.$$arity = -2);
        
        Opal.def(self, '$off', $Target_off$31 = function $$off(what) {
          var $a, $$32, $$33, $$34, self = this, $case = nil;

          
          
          if (what == null) {
            what = nil;
          };
          return (function() {$case = what;
          if ($$($nesting, 'Callback')['$===']($case)) {
          self.$callbacks().$delete(what);
          return self.$detach(what);}
          else if ($$($nesting, 'String')['$===']($case)) {if ($truthy(($truthy($a = what['$include?']("*")) ? $a : what['$include?']("?")))) {
            return self.$off($$($nesting, 'Regexp').$new(what.$gsub(/\*/, ".*?").$gsub(/\?/, ".")))
          } else {
            
            what = $$($nesting, 'Event').$name_for(what);
            return $send(self.$callbacks(), 'delete_if', [], ($$32 = function(callback){var self = $$32.$$s || this;

            
              
              if (callback == null) {
                callback = nil;
              };
              if (callback.$name()['$=='](what)) {
                
                self.$detach(callback);
                return true;
              } else {
                return nil
              };}, $$32.$$s = self, $$32.$$arity = 1, $$32));
          }}
          else if ($$($nesting, 'Regexp')['$===']($case)) {return $send(self.$callbacks(), 'delete_if', [], ($$33 = function(callback){var self = $$33.$$s || this;

          
            
            if (callback == null) {
              callback = nil;
            };
            if ($truthy(callback.$name()['$=~'](what))) {
              
              self.$detach(callback);
              return true;
            } else {
              return nil
            };}, $$33.$$s = self, $$33.$$arity = 1, $$33))}
          else {
          $send(self.$callbacks(), 'each', [], ($$34 = function(callback){var self = $$34.$$s || this;

          
            
            if (callback == null) {
              callback = nil;
            };
            return self.$detach(callback);}, $$34.$$s = self, $$34.$$arity = 1, $$34));
          return self.$callbacks().$clear();}})();
        }, $Target_off$31.$$arity = -1);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Event.removeListener"))) {
          
          Opal.def(self, '$detach', $Target_detach$35 = function $$detach(callback) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            return self["native"].removeEventListener(callback.$name(), callback.$to_proc(), false)
          }, $Target_detach$35.$$arity = 1)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.detach"))) {
          
          Opal.def(self, '$detach', $Target_detach$36 = function $$detach(callback) {
            var $$37, self = this;
            if (self["native"] == null) self["native"] = nil;

            if (callback.$event()['$==']($$($nesting, 'Custom'))) {
              if ($truthy($send(self.$callbacks(), 'none?', [], ($$37 = function(c){var self = $$37.$$s || this;

              
                
                if (c == null) {
                  c = nil;
                };
                return c.$event()['$==']($$($nesting, 'Custom'));}, $$37.$$s = self, $$37.$$arity = 1, $$37)))) {
                
              self["native"].detachEvent("ondataavailable", self["native"].$custom);

              delete self["native"].$custom;
            
              } else {
                return nil
              }
            } else {
              return self["native"].detachEvent("on" + callback.$name(), callback.$to_proc())
            }
          }, $Target_detach$36.$$arity = 1)
        } else {
          
          Opal.def(self, '$detach', $Target_detach$38 = function $$detach(callback) {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'))
          }, $Target_detach$38.$$arity = 1)
        };
        
        Opal.def(self, '$trigger', $Target_trigger$39 = function $$trigger(event, $a) {
          var $iter = $Target_trigger$39.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Target_trigger$39.$$p = null;
          
          
          if ($iter) $Target_trigger$39.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(event['$is_a?']($$($nesting, 'String')))) {
            event = $send($$($nesting, 'Event'), 'create', [event].concat(Opal.to_a(args)), block.$to_proc())};
          return self.$dispatch(event);
        }, $Target_trigger$39.$$arity = -2);
        
        Opal.def(self, '$trigger!', $Target_trigger$excl$40 = function(event, $a) {
          var $iter = $Target_trigger$excl$40.$$p, block = $iter || nil, $post_args, args, $$41, self = this;

          if ($iter) $Target_trigger$excl$40.$$p = null;
          
          
          if ($iter) $Target_trigger$excl$40.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          return $send(self, 'trigger', [event].concat(Opal.to_a(args)), ($$41 = function(e){var self = $$41.$$s || this, $writer = nil;

          
            
            if (e == null) {
              e = nil;
            };
            if ($truthy(block)) {
              block.$call(e)};
            
            $writer = [false];
            $send(e, 'bubbles=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, $$41.$$s = self, $$41.$$arity = 1, $$41));
        }, $Target_trigger$excl$40.$$arity = -2);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Event.dispatch"))) {
          
          Opal.def(self, '$dispatch', $Target_dispatch$42 = function $$dispatch(event) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            return self["native"].dispatchEvent(event.$to_n())
          }, $Target_dispatch$42.$$arity = 1)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.fire"))) {
          
          Opal.def(self, '$dispatch', $Target_dispatch$43 = function $$dispatch(event) {
            var self = this;
            if (self["native"] == null) self["native"] = nil;

            if ($truthy($$($nesting, 'Custom')['$==='](event))) {
              return self["native"].fireEvent("ondataavailable", event.$to_n())
            } else {
              return self["native"].fireEvent("on" + event.$name(), event.$to_n())
            }
          }, $Target_dispatch$43.$$arity = 1)
        } else {
          
          Opal.def(self, '$dispatch', $Target_dispatch$44 = function $$dispatch($a) {
            var $post_args, self = this;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            ;
            return self.$raise($$($nesting, 'NotImplementedError'));
          }, $Target_dispatch$44.$$arity = -1)
        };
        self.$private();
        
        Opal.def(self, '$callbacks', $Target_callbacks$45 = function $$callbacks() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          
        if (!self["native"].$callbacks) {
          self["native"].$callbacks = [];
        }

        return self["native"].$callbacks;
      
        }, $Target_callbacks$45.$$arity = 0);
        
        Opal.def(self, '$delegated', $Target_delegated$46 = function $$delegated() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          
        if (!self["native"].$delegated) {
          self["native"].$delegated = $hash2([], {});
        }

        return self["native"].$delegated;
      
        }, $Target_delegated$46.$$arity = 0);
        
        Opal.def(self, '$delegate', $Target_delegate$47 = function $$delegate(delegates, event, element) {
          var $a, $$48, self = this;

          
          
          if (element == null) {
            element = event.$target();
          };
          if ($truthy(($truthy($a = element['$nil?']()) ? $a : element['$=='](event.$on())))) {
            return nil};
          $send(delegates.$handlers(), 'each', [], ($$48 = function(selector, block){var self = $$48.$$s || this, new$ = nil, $writer = nil;

          
            
            if (selector == null) {
              selector = nil;
            };
            
            if (block == null) {
              block = nil;
            };
            if ($truthy(element['$=~'](selector))) {
              
              new$ = event.$dup();
              
              $writer = [element];
              $send(new$, 'on=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return $send(block, 'call', [new$].concat(Opal.to_a(new$.$arguments())));
            } else {
              return nil
            };}, $$48.$$s = self, $$48.$$arity = 2, $$48));
          return self.$delegate(delegates, event, element.$parent());
        }, $Target_delegate$47.$$arity = -3);
      })($nesting[0], $nesting);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/ui"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'UI');

        var $nesting = [self].concat($parent_nesting), $UI_supported$ques$1, $UI_construct$4, $UI_construct$5;

        
        Opal.defs(self, '$supported?', $UI_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.UI")
        }, $UI_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_detail$eq$2, $Definition_view$eq$3;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$detail=', $Definition_detail$eq$2 = function(value) {
            var self = this;

            return self["native"].detail = value
          }, $Definition_detail$eq$2.$$arity = 1);
          return (Opal.def(self, '$view=', $Definition_view$eq$3 = function(value) {
            var self = this;

            return self["native"].view = value
          }, $Definition_view$eq$3.$$arity = 1), nil) && 'view=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $UI_construct$4 = function $$construct(name, desc) {
              var self = this;

              return new UIEvent(name, desc)
            }, $UI_construct$4.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $UI_construct$5 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("UIEvent");
            event.initUIEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.detail || 0);

        return event;
      
            }, $UI_construct$5.$$arity = 2)}};
        self.$alias_native("detail");
        return self.$alias_native("view");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/mouse"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars, $truthy = Opal.truthy;

  Opal.add_stubs(['$!', '$nil?', '$[]', '$include', '$new', '$try_convert', '$supported?', '$supports?', '$alias_native', '$x', '$screen', '$y', '$DOM', '$==', '$downcase', '$name']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Mouse');

        var $nesting = [self].concat($parent_nesting), $Mouse_supported$ques$1, $Mouse_construct$29, $Mouse_construct$30, $Mouse_client$31, $Mouse_layer$32, $Mouse_offset$33, $Mouse_page$34, $Mouse_screen$35, $Mouse_ancestor$36, $Mouse_x$37, $Mouse_y$38, $Mouse_related$39, $Mouse_from$40, $Mouse_to$41, $Mouse_click$ques$42, $Mouse_double_click$ques$43, $Mouse_down$ques$44, $Mouse_enter$ques$45, $Mouse_leave$ques$46, $Mouse_move$ques$47, $Mouse_out$ques$48, $Mouse_over$ques$49, $Mouse_up$ques$50, $Mouse_show$ques$51;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $Mouse_supported$ques$1 = function() {
          var self = this;
          if ($gvars.$ == null) $gvars.$ = nil;

          return $gvars.$['$[]']("MouseEvent")['$nil?']()['$!']()
        }, $Mouse_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_x$eq$14, $Definition_y$eq$15, $Definition_alt$excl$16, $Definition_ctrl$excl$17, $Definition_meta$excl$18, $Definition_button$eq$19, $Definition_client$20, $Definition_layer$21, $Definition_offset$22, $Definition_page$23, $Definition_screen$24, $Definition_ancestor$25, $Definition_related$eq$26, $Definition_from$eq$27, $Definition_to$eq$28;

          self.$$prototype["native"] = nil;
          
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Client');

            var $nesting = [self].concat($parent_nesting), $Client_x$eq$2, $Client_y$eq$3;

            self.$$prototype["native"] = nil;
            
            self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
            
            Opal.def(self, '$x=', $Client_x$eq$2 = function(value) {
              var self = this;

              return self["native"].clientX = value
            }, $Client_x$eq$2.$$arity = 1);
            return (Opal.def(self, '$y=', $Client_y$eq$3 = function(value) {
              var self = this;

              return self["native"].clientY = value
            }, $Client_y$eq$3.$$arity = 1), nil) && 'y=';
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Layer');

            var $nesting = [self].concat($parent_nesting), $Layer_x$eq$4, $Layer_y$eq$5;

            self.$$prototype["native"] = nil;
            
            self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
            
            Opal.def(self, '$x=', $Layer_x$eq$4 = function(value) {
              var self = this;

              return self["native"].layerX = value
            }, $Layer_x$eq$4.$$arity = 1);
            return (Opal.def(self, '$y=', $Layer_y$eq$5 = function(value) {
              var self = this;

              return self["native"].layerY = value
            }, $Layer_y$eq$5.$$arity = 1), nil) && 'y=';
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Offset');

            var $nesting = [self].concat($parent_nesting), $Offset_x$eq$6, $Offset_y$eq$7;

            self.$$prototype["native"] = nil;
            
            self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
            
            Opal.def(self, '$x=', $Offset_x$eq$6 = function(value) {
              var self = this;

              return self["native"].offsetX = value
            }, $Offset_x$eq$6.$$arity = 1);
            return (Opal.def(self, '$y=', $Offset_y$eq$7 = function(value) {
              var self = this;

              return self["native"].offsetY= value
            }, $Offset_y$eq$7.$$arity = 1), nil) && 'y=';
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Page');

            var $nesting = [self].concat($parent_nesting), $Page_x$eq$8, $Page_y$eq$9;

            self.$$prototype["native"] = nil;
            
            self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
            
            Opal.def(self, '$x=', $Page_x$eq$8 = function(value) {
              var self = this;

              return self["native"].pageX = value
            }, $Page_x$eq$8.$$arity = 1);
            return (Opal.def(self, '$y=', $Page_y$eq$9 = function(value) {
              var self = this;

              return self["native"].pageY = value
            }, $Page_y$eq$9.$$arity = 1), nil) && 'y=';
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Screen');

            var $nesting = [self].concat($parent_nesting), $Screen_x$eq$10, $Screen_y$eq$11;

            self.$$prototype["native"] = nil;
            
            self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
            
            Opal.def(self, '$x=', $Screen_x$eq$10 = function(value) {
              var self = this;

              return self["native"].screenX = value
            }, $Screen_x$eq$10.$$arity = 1);
            return (Opal.def(self, '$y=', $Screen_y$eq$11 = function(value) {
              var self = this;

              return self["native"].screenY = value
            }, $Screen_y$eq$11.$$arity = 1), nil) && 'y=';
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Ancestor');

            var $nesting = [self].concat($parent_nesting), $Ancestor_x$eq$12, $Ancestor_y$eq$13;

            self.$$prototype["native"] = nil;
            
            self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
            
            Opal.def(self, '$x=', $Ancestor_x$eq$12 = function(value) {
              var self = this;

              return self["native"].x = value
            }, $Ancestor_x$eq$12.$$arity = 1);
            return (Opal.def(self, '$y=', $Ancestor_y$eq$13 = function(value) {
              var self = this;

              return self["native"].y = value
            }, $Ancestor_y$eq$13.$$arity = 1), nil) && 'y=';
          })($nesting[0], null, $nesting);
          
          Opal.def(self, '$x=', $Definition_x$eq$14 = function(value) {
            var self = this;

            return self["native"].screenX = value
          }, $Definition_x$eq$14.$$arity = 1);
          
          Opal.def(self, '$y=', $Definition_y$eq$15 = function(value) {
            var self = this;

            return self["native"].screenY = value
          }, $Definition_y$eq$15.$$arity = 1);
          
          Opal.def(self, '$alt!', $Definition_alt$excl$16 = function() {
            var self = this;

            return self["native"].altKey = true
          }, $Definition_alt$excl$16.$$arity = 0);
          
          Opal.def(self, '$ctrl!', $Definition_ctrl$excl$17 = function() {
            var self = this;

            return self["native"].ctrlKey = true
          }, $Definition_ctrl$excl$17.$$arity = 0);
          
          Opal.def(self, '$meta!', $Definition_meta$excl$18 = function() {
            var self = this;

            return self["native"].metaKey = true
          }, $Definition_meta$excl$18.$$arity = 0);
          
          Opal.def(self, '$button=', $Definition_button$eq$19 = function(value) {
            var self = this;

            return self["native"].button = value
          }, $Definition_button$eq$19.$$arity = 1);
          
          Opal.def(self, '$client', $Definition_client$20 = function $$client() {
            var self = this;

            return $$($nesting, 'Client').$new(self["native"])
          }, $Definition_client$20.$$arity = 0);
          
          Opal.def(self, '$layer', $Definition_layer$21 = function $$layer() {
            var self = this;

            return $$($nesting, 'Layer').$new(self["native"])
          }, $Definition_layer$21.$$arity = 0);
          
          Opal.def(self, '$offset', $Definition_offset$22 = function $$offset() {
            var self = this;

            return $$($nesting, 'Offset').$new(self["native"])
          }, $Definition_offset$22.$$arity = 0);
          
          Opal.def(self, '$page', $Definition_page$23 = function $$page() {
            var self = this;

            return $$($nesting, 'Page').$new(self["native"])
          }, $Definition_page$23.$$arity = 0);
          
          Opal.def(self, '$screen', $Definition_screen$24 = function $$screen() {
            var self = this;

            return $$($nesting, 'Screen').$new(self["native"])
          }, $Definition_screen$24.$$arity = 0);
          
          Opal.def(self, '$ancestor', $Definition_ancestor$25 = function $$ancestor() {
            var self = this;

            return $$($nesting, 'Ancestor').$new(self["native"])
          }, $Definition_ancestor$25.$$arity = 0);
          
          Opal.def(self, '$related=', $Definition_related$eq$26 = function(elem) {
            var self = this;

            return self["native"].relatedTarget = $$($nesting, 'Native').$try_convert(elem)
          }, $Definition_related$eq$26.$$arity = 1);
          
          Opal.def(self, '$from=', $Definition_from$eq$27 = function(elem) {
            var self = this;

            return self["native"].fromElement = $$($nesting, 'Native').$try_convert(elem)
          }, $Definition_from$eq$27.$$arity = 1);
          return (Opal.def(self, '$to=', $Definition_to$eq$28 = function(elem) {
            var self = this;

            return self["native"].toElement = $$($nesting, 'Native').$try_convert(elem)
          }, $Definition_to$eq$28.$$arity = 1), nil) && 'to=';
        })($nesting[0], $$$($$($nesting, 'UI'), 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Mouse_construct$29 = function $$construct(name, desc) {
              var self = this;

              return new MouseEvent(name, desc)
            }, $Mouse_construct$29.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Mouse_construct$30 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("MouseEvent");
            event.initMouseEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.detail || 0,
              desc.screenX || 0, desc.screenY || 0,
              desc.clientX || 0, desc.clientY || 0,
              desc.ctrlKey || false, desc.altKey || false,
              desc.shiftKey || false, desc.metaKey || false,
              desc.button || 0, desc.relatedTarget || null);

        return event;
      
            }, $Mouse_construct$30.$$arity = 2)}};
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("button");
        
        Opal.def(self, '$client', $Mouse_client$31 = function $$client() {
          var self = this;

          return $$($nesting, 'Position').$new(self["native"].clientX, self["native"].clientY)
        }, $Mouse_client$31.$$arity = 0);
        
        Opal.def(self, '$layer', $Mouse_layer$32 = function $$layer() {
          var self = this;

          if ($truthy(self["native"].layerX == null)) {
            return nil
          } else {
            return $$($nesting, 'Position').$new(self["native"].layerX, self["native"].layerY)
          }
        }, $Mouse_layer$32.$$arity = 0);
        
        Opal.def(self, '$offset', $Mouse_offset$33 = function $$offset() {
          var self = this;

          if ($truthy(self["native"].offsetX == null)) {
            return nil
          } else {
            return $$($nesting, 'Position').$new(self["native"].offsetX, self["native"].offsetY)
          }
        }, $Mouse_offset$33.$$arity = 0);
        
        Opal.def(self, '$page', $Mouse_page$34 = function $$page() {
          var self = this;

          if ($truthy(self["native"].pageX == null)) {
            return nil
          } else {
            return $$($nesting, 'Position').$new(self["native"].pageX, self["native"].pageY)
          }
        }, $Mouse_page$34.$$arity = 0);
        
        Opal.def(self, '$screen', $Mouse_screen$35 = function $$screen() {
          var self = this;

          if ($truthy(self["native"].screenX == null)) {
            return nil
          } else {
            return $$($nesting, 'Position').$new(self["native"].screenX, self["native"].screenY)
          }
        }, $Mouse_screen$35.$$arity = 0);
        
        Opal.def(self, '$ancestor', $Mouse_ancestor$36 = function $$ancestor() {
          var self = this;

          if ($truthy(self["native"].x == null)) {
            return nil
          } else {
            return $$($nesting, 'Position').$new(self["native"].x, self["native"].y)
          }
        }, $Mouse_ancestor$36.$$arity = 0);
        
        Opal.def(self, '$x', $Mouse_x$37 = function $$x() {
          var self = this;

          return self.$screen().$x()
        }, $Mouse_x$37.$$arity = 0);
        
        Opal.def(self, '$y', $Mouse_y$38 = function $$y() {
          var self = this;

          return self.$screen().$y()
        }, $Mouse_y$38.$$arity = 0);
        
        Opal.def(self, '$related', $Mouse_related$39 = function $$related() {
          var self = this;

          if ($truthy(self["native"].relatedTarget == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].relatedTarget)
          }
        }, $Mouse_related$39.$$arity = 0);
        
        Opal.def(self, '$from', $Mouse_from$40 = function $$from() {
          var self = this;

          if ($truthy(self["native"].fromElement == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].fromElement)
          }
        }, $Mouse_from$40.$$arity = 0);
        
        Opal.def(self, '$to', $Mouse_to$41 = function $$to() {
          var self = this;

          if ($truthy(self["native"].toElement == null)) {
            return nil
          } else {
            return self.$DOM(self["native"].toElement)
          }
        }, $Mouse_to$41.$$arity = 0);
        
        Opal.def(self, '$click?', $Mouse_click$ques$42 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("click")
        }, $Mouse_click$ques$42.$$arity = 0);
        
        Opal.def(self, '$double_click?', $Mouse_double_click$ques$43 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("dblclick")
        }, $Mouse_double_click$ques$43.$$arity = 0);
        
        Opal.def(self, '$down?', $Mouse_down$ques$44 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("mousedown")
        }, $Mouse_down$ques$44.$$arity = 0);
        
        Opal.def(self, '$enter?', $Mouse_enter$ques$45 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseenter")
        }, $Mouse_enter$ques$45.$$arity = 0);
        
        Opal.def(self, '$leave?', $Mouse_leave$ques$46 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseleave")
        }, $Mouse_leave$ques$46.$$arity = 0);
        
        Opal.def(self, '$move?', $Mouse_move$ques$47 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("mousemove")
        }, $Mouse_move$ques$47.$$arity = 0);
        
        Opal.def(self, '$out?', $Mouse_out$ques$48 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseout")
        }, $Mouse_out$ques$48.$$arity = 0);
        
        Opal.def(self, '$over?', $Mouse_over$ques$49 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseover")
        }, $Mouse_over$ques$49.$$arity = 0);
        
        Opal.def(self, '$up?', $Mouse_up$ques$50 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("mouseup")
        }, $Mouse_up$ques$50.$$arity = 0);
        return (Opal.def(self, '$show?', $Mouse_show$ques$51 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("show")
        }, $Mouse_show$ques$51.$$arity = 0), nil) && 'show?';
      })($nesting[0], $$($nesting, 'UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/keyboard"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native', '$code', '$chr', '$==', '$downcase', '$name']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Keyboard');

        var $nesting = [self].concat($parent_nesting), $Keyboard_supported$ques$1, $Keyboard_construct$11, $Keyboard_construct$12, $Keyboard_key$13, $Keyboard_code$14, $Keyboard_char$15, $Keyboard_down$ques$16, $Keyboard_press$ques$17, $Keyboard_up$ques$18;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $Keyboard_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Keyboard")
        }, $Keyboard_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_alt$excl$2, $Definition_ctrl$excl$3, $Definition_meta$excl$4, $Definition_shift$excl$5, $Definition_code$eq$6, $Definition_key$eq$7, $Definition_char$eq$8, $Definition_repeat$excl$9, $Definition_locale$eq$10;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$alt!', $Definition_alt$excl$2 = function() {
            var self = this;

            return self["native"].altKey = true
          }, $Definition_alt$excl$2.$$arity = 0);
          
          Opal.def(self, '$ctrl!', $Definition_ctrl$excl$3 = function() {
            var self = this;

            return self["native"].ctrlKey = true
          }, $Definition_ctrl$excl$3.$$arity = 0);
          
          Opal.def(self, '$meta!', $Definition_meta$excl$4 = function() {
            var self = this;

            return self["native"].metaKey = true
          }, $Definition_meta$excl$4.$$arity = 0);
          
          Opal.def(self, '$shift!', $Definition_shift$excl$5 = function() {
            var self = this;

            return self["native"].shiftKey = true
          }, $Definition_shift$excl$5.$$arity = 0);
          
          Opal.def(self, '$code=', $Definition_code$eq$6 = function(code) {
            var self = this;

            return self["native"].keyCode = self["native"].which = code
          }, $Definition_code$eq$6.$$arity = 1);
          
          Opal.def(self, '$key=', $Definition_key$eq$7 = function(key) {
            var self = this;

            return self["native"].key = key
          }, $Definition_key$eq$7.$$arity = 1);
          
          Opal.def(self, '$char=', $Definition_char$eq$8 = function(char$) {
            var self = this;

            return self["native"].char = self["native"].charCode = char$
          }, $Definition_char$eq$8.$$arity = 1);
          
          Opal.def(self, '$repeat!', $Definition_repeat$excl$9 = function() {
            var self = this;

            return self["native"].repeat = true
          }, $Definition_repeat$excl$9.$$arity = 0);
          return (Opal.def(self, '$locale=', $Definition_locale$eq$10 = function(value) {
            var self = this;

            return self["native"].locale = value
          }, $Definition_locale$eq$10.$$arity = 1), nil) && 'locale=';
        })($nesting[0], $$$($$($nesting, 'UI'), 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Keyboard_construct$11 = function $$construct(name, desc) {
              var self = this;

              return new KeyboardEvent(name, desc)
            }, $Keyboard_construct$11.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Keyboard_construct$12 = function $$construct(name, desc) {
              var self = this;

              
        var modifiers = "";

        if (desc.altKey) {
          modifiers += "Alt ";
        }

        if (desc.ctrlKey) {
          modifiers += "Ctrl ";
        }

        if (desc.shiftKey) {
          modifiers += "Shift" ;
        }

        if (desc.metaKey) {
          modifiers += "Meta ";
        }

        var event = document.createEvent("KeyboardEvent");
            event.initKeyboardEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.which, 0,
              modifiers, desc.repeat, desc.locale);

        return event;
      
            }, $Keyboard_construct$12.$$arity = 2)}};
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("locale");
        self.$alias_native("repeat?", "repeat");
        
        Opal.def(self, '$key', $Keyboard_key$13 = function $$key() {
          var self = this;

          return self["native"].key || self["native"].keyIdentifier || nil
        }, $Keyboard_key$13.$$arity = 0);
        
        Opal.def(self, '$code', $Keyboard_code$14 = function $$code() {
          var self = this;

          return self["native"].keyCode || self["native"].which || nil
        }, $Keyboard_code$14.$$arity = 0);
        
        Opal.def(self, '$char', $Keyboard_char$15 = function() {
          var self = this;

          return self["native"].char || self["native"].charCode || (function() {if ($truthy(self.$code())) {
            return self.$code().$chr()
          } else {
            return nil
          }; return nil; })()
        }, $Keyboard_char$15.$$arity = 0);
        Opal.alias(self, "to_i", "key");
        
        Opal.def(self, '$down?', $Keyboard_down$ques$16 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("keydown")
        }, $Keyboard_down$ques$16.$$arity = 0);
        
        Opal.def(self, '$press?', $Keyboard_press$ques$17 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("keypress")
        }, $Keyboard_press$ques$17.$$arity = 0);
        return (Opal.def(self, '$up?', $Keyboard_up$ques$18 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("keyup")
        }, $Keyboard_up$ques$18.$$arity = 0), nil) && 'up?';
      })($nesting[0], $$($nesting, 'UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/focus"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$convert', '$supported?', '$DOM']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Focus');

        var $nesting = [self].concat($parent_nesting), $Focus_supported$ques$1, $Focus_construct$4, $Focus_construct$5, $Focus_related$6;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $Focus_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Focus")
        }, $Focus_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_view$eq$2, $Definition_related$eq$3;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$view=', $Definition_view$eq$2 = function(value) {
            var self = this;

            return self["native"].view = $$($nesting, 'Native').$convert(value)
          }, $Definition_view$eq$2.$$arity = 1);
          return (Opal.def(self, '$related=', $Definition_related$eq$3 = function(elem) {
            var self = this;

            return self["native"].relatedTarget = $$($nesting, 'Native').$convert(elem)
          }, $Definition_related$eq$3.$$arity = 1), nil) && 'related=';
        })($nesting[0], $$$($$($nesting, 'UI'), 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Focus_construct$4 = function $$construct(name, desc) {
              var self = this;

              return new FocusEvent(name, desc)
            }, $Focus_construct$4.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Focus_construct$5 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("FocusEvent");
            event.initFocusEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, 0, desc.relatedTarget);

        return event;
      
            }, $Focus_construct$5.$$arity = 2)}};
        return (Opal.def(self, '$related', $Focus_related$6 = function $$related() {
          var self = this;

          return self.$DOM(self["native"].relatedTarget)
        }, $Focus_related$6.$$arity = 0), nil) && 'related';
      })($nesting[0], $$($nesting, 'UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/wheel"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars;

  Opal.add_stubs(['$!', '$nil?', '$[]', '$===', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Wheel');

        var $nesting = [self].concat($parent_nesting), $Wheel_supported$ques$1, $Wheel_construct$6, $Wheel_mode$7;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $Wheel_supported$ques$1 = function() {
          var self = this;
          if ($gvars.$ == null) $gvars.$ = nil;

          return $gvars.$['$[]']("WheelEvent")['$nil?']()['$!']()
        }, $Wheel_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_x$eq$2, $Definition_y$eq$3, $Definition_z$eq$4, $Definition_mode$eq$5;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$x=', $Definition_x$eq$2 = function(value) {
            var self = this;

            return self["native"].deltaX = value
          }, $Definition_x$eq$2.$$arity = 1);
          
          Opal.def(self, '$y=', $Definition_y$eq$3 = function(value) {
            var self = this;

            return self["native"].deltaY = value
          }, $Definition_y$eq$3.$$arity = 1);
          
          Opal.def(self, '$z=', $Definition_z$eq$4 = function(value) {
            var self = this;

            return self["native"].deltaZ = value
          }, $Definition_z$eq$4.$$arity = 1);
          return (Opal.def(self, '$mode=', $Definition_mode$eq$5 = function(value) {
            var self = this, $case = nil;

            
            value = (function() {$case = value;
            if ("pixel"['$===']($case)) {return WheelEvent.DOM_DELTA_PIXEL;}
            else if ("line"['$===']($case)) {return WheelEvent.DOM_DELTA_LINE;}
            else if ("page"['$===']($case)) {return WheelEvent.DOM_DELTA_PAGE;}
            else { return nil }})();
            return self["native"].deltaMode = value;
          }, $Definition_mode$eq$5.$$arity = 1), nil) && 'mode=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        Opal.defs(self, '$construct', $Wheel_construct$6 = function $$construct(name, desc) {
          var self = this;

          return new WheelEvent(name, desc)
        }, $Wheel_construct$6.$$arity = 2);
        self.$alias_native("x", "deltaX");
        self.$alias_native("y", "deltaY");
        self.$alias_native("z", "deltaZ");
        return (Opal.def(self, '$mode', $Wheel_mode$7 = function $$mode() {
          var self = this, $case = nil;

          return (function() {$case = self["native"].deltaMode;
          if ((WheelEvent.DOM_DELTA_PIXEL)['$===']($case)) {return "pixel"}
          else if ((WheelEvent.DOM_DELTA_LINE)['$===']($case)) {return "line"}
          else if ((WheelEvent.DOM_DELTA_PAGE)['$===']($case)) {return "page"}
          else { return nil }})()
        }, $Wheel_mode$7.$$arity = 0), nil) && 'mode';
      })($nesting[0], $$($nesting, 'UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/blob"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$new', '$convert', '$to_n', '$proc', '$resolve', '$call', '$create', '$type', '$respond_to?', '$last_modified', '$now', '$at', '$/']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Blob');

      var $nesting = [self].concat($parent_nesting), $Blob_create$1, $Blob_size$2, $Blob_type$3, $Blob_text$4, $Blob_buffer$6, $Blob_slice$9, $Blob_to_url$10, $Blob_rename$11;

      self.$$prototype["native"] = nil;
      
      self.$include($$($nesting, 'NativeCachedWrapper'));
      Opal.defs(self, '$create', $Blob_create$1 = function $$create(from, options) {
        var self = this;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        return self.$new(new Blob($$($nesting, 'Native').$convert(from), options.$to_n()));
      }, $Blob_create$1.$$arity = -2);
      
      Opal.def(self, '$size', $Blob_size$2 = function $$size() {
        var self = this;

        return self["native"].size
      }, $Blob_size$2.$$arity = 0);
      
      Opal.def(self, '$type', $Blob_type$3 = function $$type() {
        var self = this;

        return self["native"].type
      }, $Blob_type$3.$$arity = 0);
      
      Opal.def(self, '$text', $Blob_text$4 = function $$text() {
        var $iter = $Blob_text$4.$$p, block = $iter || nil, $$5, self = this, promise = nil;

        if ($iter) $Blob_text$4.$$p = null;
        
        
        if ($iter) $Blob_text$4.$$p = null;;
        promise = nil;
        if ((block !== nil)) {
        } else {
          
          promise = $$($nesting, 'Promise').$new();
          block = $send(self, 'proc', [], ($$5 = function(i){var self = $$5.$$s || this;

          
            
            if (i == null) {
              i = nil;
            };
            return promise.$resolve(i);}, $$5.$$s = self, $$5.$$arity = 1, $$5));
        };
        self["native"].text().then(block.$to_n());
        return promise;
      }, $Blob_text$4.$$arity = 0);
      
      Opal.def(self, '$buffer', $Blob_buffer$6 = function $$buffer() {
        var $$7, $$8, $iter = $Blob_buffer$6.$$p, $yield = $iter || nil, self = this, promise = nil, block = nil, resblock = nil;

        if ($iter) $Blob_buffer$6.$$p = null;
        
        promise = nil;
        if (($yield !== nil)) {
        } else {
          
          promise = $$($nesting, 'Promise').$new();
          block = $send(self, 'proc', [], ($$7 = function(i){var self = $$7.$$s || this;

          
            
            if (i == null) {
              i = nil;
            };
            return promise.$resolve(i);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        };
        resblock = $send(self, 'proc', [], ($$8 = function(i){var self = $$8.$$s || this;

        
          
          if (i == null) {
            i = nil;
          };
          return block.$call($$($nesting, 'Buffer').$new(i));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        self["native"].arrayBuffer().then(resblock.$to_n());
        return promise;
      }, $Blob_buffer$6.$$arity = 0);
      
      Opal.def(self, '$slice', $Blob_slice$9 = function $$slice(start, finish) {
        var self = this;

        
        
        if (finish == null) {
          finish = nil;
        };
        return $$($nesting, 'Blob').$new(self["native"].slice(start, finish));
      }, $Blob_slice$9.$$arity = -2);
      
      Opal.def(self, '$to_url', $Blob_to_url$10 = function $$to_url(window) {
        var self = this;
        if ($gvars.window == null) $gvars.window = nil;

        
        
        if (window == null) {
          window = $gvars.window;
        };
        return window.$to_n().URL.createObjectURL(self["native"]);
      }, $Blob_to_url$10.$$arity = -1);
      return (Opal.def(self, '$rename', $Blob_rename$11 = function $$rename(new_filename) {
        var self = this;

        return $$($nesting, 'File').$create([self], new_filename, $hash2(["type", "lastModified"], {"type": self.$type(), "lastModified": (function() {if ($truthy(self['$respond_to?']("last_modified"))) {
          return self.$last_modified()
        } else {
          return $$($nesting, 'Time').$now()
        }; return nil; })()}))
      }, $Blob_rename$11.$$arity = 1), nil) && 'rename';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'File');

      var $nesting = [self].concat($parent_nesting), $File_create$12, $File_last_modified$13, $File_name$14;

      self.$$prototype["native"] = nil;
      
      Opal.defs(self, '$create', $File_create$12 = function $$create(from, name, options) {
        var self = this;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        return self.$new(new File($$($nesting, 'Native').$convert(from), name, options.$to_n()));
      }, $File_create$12.$$arity = -3);
      
      Opal.def(self, '$last_modified', $File_last_modified$13 = function $$last_modified() {
        var self = this;

        return $$($nesting, 'Time').$at($rb_divide(self["native"].lastModified, 1000.0))
      }, $File_last_modified$13.$$arity = 0);
      return (Opal.def(self, '$name', $File_name$14 = function $$name() {
        var self = this;

        return self["native"].name
      }, $File_name$14.$$arity = 0), nil) && 'name';
    })($nesting[0], $$($nesting, 'Blob'), $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/data_transfer"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$convert', '$to_n', '$map', '$new', '$==', '$kind', '$to_file', '$!', '$proc', '$resolve']);
  
  self.$require("browser/blob");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DataTransfer');

        var $nesting = [self].concat($parent_nesting), $DataTransfer_effect$1, $DataTransfer_effect$eq$2, $DataTransfer_$$$3, $DataTransfer_$$$eq$4, $DataTransfer_clear$5, $DataTransfer_drag_image$eq$6, $DataTransfer_files$7, $DataTransfer_items$9;

        self.$$prototype["native"] = nil;
        
        self.$include($$($nesting, 'NativeCachedWrapper'));
        
        Opal.def(self, '$effect', $DataTransfer_effect$1 = function $$effect() {
          var self = this;

          return self["native"].dropEffect
        }, $DataTransfer_effect$1.$$arity = 0);
        
        Opal.def(self, '$effect=', $DataTransfer_effect$eq$2 = function(effect) {
          var self = this;

          return self["native"].dropEffect = effect
        }, $DataTransfer_effect$eq$2.$$arity = 1);
        
        Opal.def(self, '$[]', $DataTransfer_$$$3 = function(type) {
          var self = this;

          return self["native"].getData(type)
        }, $DataTransfer_$$$3.$$arity = 1);
        
        Opal.def(self, '$[]=', $DataTransfer_$$$eq$4 = function(type, value) {
          var self = this;

          return self["native"].setData(type, $$($nesting, 'Native').$convert(value))
        }, $DataTransfer_$$$eq$4.$$arity = 2);
        
        Opal.def(self, '$clear', $DataTransfer_clear$5 = function $$clear(type) {
          var self = this;

          
          
          if (type == null) {
            type = nil;
          };
          return self["native"].clearData(type.$to_n());
        }, $DataTransfer_clear$5.$$arity = -1);
        
        Opal.def(self, '$drag_image=', $DataTransfer_drag_image$eq$6 = function(image) {
          var self = this;

          return self["native"].setDragImage($$($nesting, 'Native').$convert(image))
        }, $DataTransfer_drag_image$eq$6.$$arity = 1);
        
        Opal.def(self, '$files', $DataTransfer_files$7 = function $$files() {
          var $$8, self = this;

          return $send($$$($$($nesting, 'Native'), 'Array').$new(self["native"].files), 'map', [], ($$8 = function(f){var self = $$8.$$s || this;

          
            
            if (f == null) {
              f = nil;
            };
            return $$($nesting, 'File').$new(f.$to_n());}, $$8.$$s = self, $$8.$$arity = 1, $$8))
        }, $DataTransfer_files$7.$$arity = 0);
        
        Opal.def(self, '$items', $DataTransfer_items$9 = function $$items() {
          var $$10, self = this;

          return $send($$$($$($nesting, 'Native'), 'Array').$new(self["native"].items), 'map', [], ($$10 = function(i){var self = $$10.$$s || this;

          
            
            if (i == null) {
              i = nil;
            };
            return $$($nesting, 'Item').$new(i.$to_n());}, $$10.$$s = self, $$10.$$arity = 1, $$10))
        }, $DataTransfer_items$9.$$arity = 0);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Item');

          var $nesting = [self].concat($parent_nesting), $Item_kind$11, $Item_string$ques$12, $Item_file$ques$13, $Item_type$14, $Item_to_string$15, $Item_to_file$17;

          self.$$prototype["native"] = nil;
          
          self.$include($$($nesting, 'NativeCachedWrapper'));
          
          Opal.def(self, '$kind', $Item_kind$11 = function $$kind() {
            var self = this;

            return self["native"].kind
          }, $Item_kind$11.$$arity = 0);
          
          Opal.def(self, '$string?', $Item_string$ques$12 = function() {
            var self = this;

            return self.$kind()['$==']("string")
          }, $Item_string$ques$12.$$arity = 0);
          
          Opal.def(self, '$file?', $Item_file$ques$13 = function() {
            var $a, self = this;

            return (($a = self.$kind()['$==']("file")) ? self.$to_file() : self.$kind()['$==']("file"))
          }, $Item_file$ques$13.$$arity = 0);
          
          Opal.def(self, '$type', $Item_type$14 = function $$type() {
            var self = this;

            return self["native"].type
          }, $Item_type$14.$$arity = 0);
          
          Opal.def(self, '$to_string', $Item_to_string$15 = function $$to_string() {
            var $iter = $Item_to_string$15.$$p, block = $iter || nil, $$16, self = this, promise = nil;

            if ($iter) $Item_to_string$15.$$p = null;
            
            
            if ($iter) $Item_to_string$15.$$p = null;;
            promise = nil;
            if ($truthy(block['$!']())) {
              
              promise = $$($nesting, 'Promise').$new();
              block = $send(self, 'proc', [], ($$16 = function(i){var self = $$16.$$s || this;

              
                
                if (i == null) {
                  i = nil;
                };
                return promise.$resolve(i);}, $$16.$$s = self, $$16.$$arity = 1, $$16));};
            self["native"].getAsString(block.$to_n());
            return promise;
          }, $Item_to_string$15.$$arity = 0);
          return (Opal.def(self, '$to_file', $Item_to_file$17 = function $$to_file() {
            var self = this, as_file = nil;

            
            as_file = self["native"].getAsFile();
            if ($truthy(as_file)) {
              return $$($nesting, 'File').$new(as_file)
            } else {
              return nil
            };
          }, $Item_to_file$17.$$arity = 0), nil) && 'to_file';
        })($nesting[0], null, $nesting);
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/composition"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native', '$==', '$downcase', '$name']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Composition');

        var $nesting = [self].concat($parent_nesting), $Composition_supported$ques$1, $Composition_construct$4, $Composition_construct$5, $Composition_start$ques$6, $Composition_update$ques$7, $Composition_end$ques$8;

        
        Opal.defs(self, '$supported?', $Composition_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Composition")
        }, $Composition_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_data$eq$2, $Definition_locale$eq$3;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$data=', $Definition_data$eq$2 = function(value) {
            var self = this;

            return self["native"].data = value
          }, $Definition_data$eq$2.$$arity = 1);
          return (Opal.def(self, '$locale=', $Definition_locale$eq$3 = function(value) {
            var self = this;

            return self["native"].locale = value
          }, $Definition_locale$eq$3.$$arity = 1), nil) && 'locale=';
        })($nesting[0], $$$($$($nesting, 'UI'), 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Composition_construct$4 = function $$construct(name, desc) {
              var self = this;

              return new CompositionEvent(name, desc)
            }, $Composition_construct$4.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Composition_construct$5 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("CompositionEvent");
            event.initCompositionEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, desc.data, desc.locale);

        return event;
      
            }, $Composition_construct$5.$$arity = 2)}};
        self.$alias_native("data");
        self.$alias_native("locale");
        
        Opal.def(self, '$start?', $Composition_start$ques$6 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionstart")
        }, $Composition_start$ques$6.$$arity = 0);
        
        Opal.def(self, '$update?', $Composition_update$ques$7 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionupdate")
        }, $Composition_update$ques$7.$$arity = 0);
        return (Opal.def(self, '$end?', $Composition_end$ques$8 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("compositionend")
        }, $Composition_end$ques$8.$$arity = 0), nil) && 'end?';
      })($nesting[0], $$($nesting, 'UI'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/animation"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Animation');

        var $nesting = [self].concat($parent_nesting), $Animation_supported$ques$1, $Animation_construct$4, $Animation_construct$5;

        
        Opal.defs(self, '$supported?', $Animation_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Animation")
        }, $Animation_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_animation$eq$2, $Definition_elapsed$eq$3;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$animation=', $Definition_animation$eq$2 = function(value) {
            var self = this;

            return self["native"].animationName = value
          }, $Definition_animation$eq$2.$$arity = 1);
          return (Opal.def(self, '$elapsed=', $Definition_elapsed$eq$3 = function(value) {
            var self = this;

            return self["native"].elapsedTime = value
          }, $Definition_elapsed$eq$3.$$arity = 1), nil) && 'elapsed=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Animation_construct$4 = function $$construct(name, desc) {
              var self = this;

              return new AnimationEvent(name, desc)
            }, $Animation_construct$4.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Animation_construct$5 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("AnimationEvent");
            event.initAnimationEvent(name, desc.bubbles, desc.cancelable,
              desc.animationName, desc.elapsedTime);

        return event;
      
            }, $Animation_construct$5.$$arity = 2)}};
        self.$alias_native("name", "animationName");
        return self.$alias_native("elapsed", "elapsedTime");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/audio_processing"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'AudioProcessing');

        var $nesting = [self].concat($parent_nesting), $AudioProcessing_supported$ques$1, $AudioProcessing_construct$5;

        
        Opal.defs(self, '$supported?', $AudioProcessing_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.AudioProcessing")
        }, $AudioProcessing_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_time$eq$2, $Definition_input$eq$3, $Definition_output$eq$4;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$time=', $Definition_time$eq$2 = function(value) {
            var self = this;

            return self["native"].playbackTime = value
          }, $Definition_time$eq$2.$$arity = 1);
          
          Opal.def(self, '$input=', $Definition_input$eq$3 = function(value) {
            var self = this;

            return self["native"].inputBuffer = value
          }, $Definition_input$eq$3.$$arity = 1);
          return (Opal.def(self, '$output=', $Definition_output$eq$4 = function(value) {
            var self = this;

            return self["native"].outputBuffer = value
          }, $Definition_output$eq$4.$$arity = 1), nil) && 'output=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $AudioProcessing_construct$5 = function $$construct(name, desc) {
              var self = this;

              return new AudioProcessingEvent(name, desc)
            }, $AudioProcessing_construct$5.$$arity = 2)}};
        self.$alias_native("time", "playbackTime");
        self.$alias_native("input", "inputBuffer");
        return self.$alias_native("output", "outputBuffer");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/before_unload"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BeforeUnload');

        var $nesting = [self].concat($parent_nesting), $BeforeUnload_supported$ques$1, $BeforeUnload_construct$2;

        
        Opal.defs(self, '$supported?', $BeforeUnload_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.BeforeUnload")
        }, $BeforeUnload_supported$ques$1.$$arity = 0);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            return (Opal.defs(self, '$construct', $BeforeUnload_construct$2 = function $$construct(name, desc) {
              var self = this;

              return new BeforeUnloadEvent(name, desc)
            }, $BeforeUnload_construct$2.$$arity = 2), nil) && 'construct'
          } else {
            return nil
          }
        } else {
          return nil
        };
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/clipboard"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native', '$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Clipboard');

        var $nesting = [self].concat($parent_nesting), $Clipboard_supported$ques$1, $Clipboard_construct$4, $Clipboard_transfer$5;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $Clipboard_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Clipboard")
        }, $Clipboard_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_data$eq$2, $Definition_type$eq$3;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$data=', $Definition_data$eq$2 = function(value) {
            var self = this;

            return self["native"].data = value
          }, $Definition_data$eq$2.$$arity = 1);
          return (Opal.def(self, '$type=', $Definition_type$eq$3 = function(value) {
            var self = this;

            return self["native"].dataType = value
          }, $Definition_type$eq$3.$$arity = 1), nil) && 'type=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Clipboard_construct$4 = function $$construct(name, desc) {
              var self = this;

              return new ClipboardEvent(name, desc)
            }, $Clipboard_construct$4.$$arity = 2)}};
        self.$alias_native("data");
        self.$alias_native("type", "dataType");
        return (Opal.def(self, '$transfer', $Clipboard_transfer$5 = function $$transfer() {
          var self = this;

          return $$($nesting, 'DataTransfer').$new(self["native"].clipboardData)
        }, $Clipboard_transfer$5.$$arity = 0), nil) && 'transfer';
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/device_light"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceLight');

        var $nesting = [self].concat($parent_nesting), $DeviceLight_supported$ques$1, $DeviceLight_construct$3;

        
        Opal.defs(self, '$supported?', $DeviceLight_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.DeviceLight")
        }, $DeviceLight_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_value$eq$2;

          self.$$prototype["native"] = nil;
          return (Opal.def(self, '$value=', $Definition_value$eq$2 = function(value) {
            var self = this;

            return self["native"].value = value
          }, $Definition_value$eq$2.$$arity = 1), nil) && 'value='
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $DeviceLight_construct$3 = function $$construct(name, desc) {
              var self = this;

              return new DeviceLightEvent(name, desc)
            }, $DeviceLight_construct$3.$$arity = 2)}};
        return self.$alias_native("value");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/device_motion"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$new', '$to_n', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceMotion');

        var $nesting = [self].concat($parent_nesting), $DeviceMotion_supported$ques$1, $DeviceMotion_construct$6, $DeviceMotion_construct$7;

        
        Opal.defs(self, '$supported?', $DeviceMotion_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.DeviceMotion")
        }, $DeviceMotion_supported$ques$1.$$arity = 0);
        Opal.const_set($nesting[0], 'Acceleration', $$($nesting, 'Struct').$new("x", "y", "z"));
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_acceleration$eq$2, $Definition_acceleration_with_gravity$eq$3, $Definition_rotation$eq$4, $Definition_interval$eq$5;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$acceleration=', $Definition_acceleration$eq$2 = function(value) {
            var self = this;

            return self["native"].acceleration = value.$to_n()
          }, $Definition_acceleration$eq$2.$$arity = 1);
          
          Opal.def(self, '$acceleration_with_gravity=', $Definition_acceleration_with_gravity$eq$3 = function(value) {
            var self = this;

            return self["native"].accelerationIncludingGravity = value.$to_n()
          }, $Definition_acceleration_with_gravity$eq$3.$$arity = 1);
          
          Opal.def(self, '$rotation=', $Definition_rotation$eq$4 = function(value) {
            var self = this;

            return self["native"].rotationRate = value
          }, $Definition_rotation$eq$4.$$arity = 1);
          return (Opal.def(self, '$interval=', $Definition_interval$eq$5 = function(value) {
            var self = this;

            return self["native"].interval = value
          }, $Definition_interval$eq$5.$$arity = 1), nil) && 'interval=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $DeviceMotion_construct$6 = function $$construct(name, desc) {
              var self = this;

              return new DeviceMotionEvent(name, desc)
            }, $DeviceMotion_construct$6.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $DeviceMotion_construct$7 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("DeviceMotionEvent");
            event.initDeviceMotionEvent(name, desc.bubbles, desc.cancelable,
              desc.acceleration, desc.accelerationIncludingGravity,
              desc.rotationRate, desc.interval);

        return event;
      
            }, $DeviceMotion_construct$7.$$arity = 2)}};
        self.$alias_native("acceleration");
        self.$alias_native("acceleration_with_gravity", "accelerationIncludingGravity");
        self.$alias_native("rotation", "rotationRate");
        return self.$alias_native("interval");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/device_orientation"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceOrientation');

        var $nesting = [self].concat($parent_nesting), $DeviceOrientation_supported$ques$1, $DeviceOrientation_construct$6, $DeviceOrientation_construct$7;

        
        Opal.defs(self, '$supported?', $DeviceOrientation_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.DeviceOrientation")
        }, $DeviceOrientation_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_absolute$eq$2, $Definition_alpha$eq$3, $Definition_beta$eq$4, $Definition_gamma$eq$5;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$absolute=', $Definition_absolute$eq$2 = function(value) {
            var self = this;

            return self["native"].absolute = value
          }, $Definition_absolute$eq$2.$$arity = 1);
          
          Opal.def(self, '$alpha=', $Definition_alpha$eq$3 = function(value) {
            var self = this;

            return self["native"].alpha = value
          }, $Definition_alpha$eq$3.$$arity = 1);
          
          Opal.def(self, '$beta=', $Definition_beta$eq$4 = function(value) {
            var self = this;

            return self["native"].beta = value
          }, $Definition_beta$eq$4.$$arity = 1);
          return (Opal.def(self, '$gamma=', $Definition_gamma$eq$5 = function(value) {
            var self = this;

            return self["native"].gamma = value
          }, $Definition_gamma$eq$5.$$arity = 1), nil) && 'gamma=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $DeviceOrientation_construct$6 = function $$construct(name, desc) {
              var self = this;

              return new DeviceOrientationEvent(name, desc)
            }, $DeviceOrientation_construct$6.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $DeviceOrientation_construct$7 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("DeviceOrientationEvent");
            event.initDeviceOrientationEvent(name, desc.bubbles, desc.cancelable,
              desc.alpha, desc.beta, desc.gamma, desc.absolute);

        return event;
      
            }, $DeviceOrientation_construct$7.$$arity = 2)}};
        self.$alias_native("absolute");
        self.$alias_native("alpha");
        self.$alias_native("beta");
        return self.$alias_native("gamma");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/device_proximity"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DeviceProximity');

        var $nesting = [self].concat($parent_nesting), $DeviceProximity_supported$ques$1, $DeviceProximity_construct$5;

        
        Opal.defs(self, '$supported?', $DeviceProximity_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.DeviceProximity")
        }, $DeviceProximity_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_value$eq$2, $Definition_min$eq$3, $Definition_max$eq$4;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$value=', $Definition_value$eq$2 = function(value) {
            var self = this;

            return self["native"].value = value
          }, $Definition_value$eq$2.$$arity = 1);
          
          Opal.def(self, '$min=', $Definition_min$eq$3 = function(value) {
            var self = this;

            return self["native"].min = value
          }, $Definition_min$eq$3.$$arity = 1);
          return (Opal.def(self, '$max=', $Definition_max$eq$4 = function(value) {
            var self = this;

            return self["native"].max = value
          }, $Definition_max$eq$4.$$arity = 1), nil) && 'max=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $DeviceProximity_construct$5 = function $$construct(name, desc) {
              var self = this;

              return new DeviceProximityEvent(name, desc)
            }, $DeviceProximity_construct$5.$$arity = 2)}};
        self.$alias_native("value");
        self.$alias_native("min");
        return self.$alias_native("max");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/drag"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$include', '$new', '$convert', '$supported?', '$alias_native', '$x', '$screen', '$y', '$DOM']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Drag');

        var $nesting = [self].concat($parent_nesting), $Drag_supported$ques$1, $Drag_construct$14, $Drag_construct$15, $Drag_client$16, $Drag_screen$17, $Drag_x$18, $Drag_y$19, $Drag_related$20, $Drag_transfer$21;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $Drag_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Drag")
        }, $Drag_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_alt$excl$6, $Definition_ctrl$excl$7, $Definition_meta$excl$8, $Definition_button$eq$9, $Definition_client$10, $Definition_screen$11, $Definition_related$eq$12, $Definition_transfer$eq$13;

          self.$$prototype["native"] = nil;
          
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Client');

            var $nesting = [self].concat($parent_nesting), $Client_x$eq$2, $Client_y$eq$3;

            self.$$prototype["native"] = nil;
            
            self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
            
            Opal.def(self, '$x=', $Client_x$eq$2 = function(value) {
              var self = this;

              return self["native"].clientX = value
            }, $Client_x$eq$2.$$arity = 1);
            return (Opal.def(self, '$y=', $Client_y$eq$3 = function(value) {
              var self = this;

              return self["native"].clientY = value
            }, $Client_y$eq$3.$$arity = 1), nil) && 'y=';
          })($nesting[0], null, $nesting);
          (function($base, $super, $parent_nesting) {
            var self = $klass($base, $super, 'Screen');

            var $nesting = [self].concat($parent_nesting), $Screen_x$eq$4, $Screen_y$eq$5;

            self.$$prototype["native"] = nil;
            
            self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
            
            Opal.def(self, '$x=', $Screen_x$eq$4 = function(value) {
              var self = this;

              return self["native"].screenX = value
            }, $Screen_x$eq$4.$$arity = 1);
            return (Opal.def(self, '$y=', $Screen_y$eq$5 = function(value) {
              var self = this;

              return self["native"].screenY = value
            }, $Screen_y$eq$5.$$arity = 1), nil) && 'y=';
          })($nesting[0], null, $nesting);
          
          Opal.def(self, '$alt!', $Definition_alt$excl$6 = function() {
            var self = this;

            return self["native"].altKey = true
          }, $Definition_alt$excl$6.$$arity = 0);
          
          Opal.def(self, '$ctrl!', $Definition_ctrl$excl$7 = function() {
            var self = this;

            return self["native"].ctrlKey = true
          }, $Definition_ctrl$excl$7.$$arity = 0);
          
          Opal.def(self, '$meta!', $Definition_meta$excl$8 = function() {
            var self = this;

            return self["native"].metaKey = true
          }, $Definition_meta$excl$8.$$arity = 0);
          
          Opal.def(self, '$button=', $Definition_button$eq$9 = function(value) {
            var self = this;

            return self["native"].button = value
          }, $Definition_button$eq$9.$$arity = 1);
          
          Opal.def(self, '$client', $Definition_client$10 = function $$client() {
            var self = this;

            return $$($nesting, 'Client').$new(self["native"])
          }, $Definition_client$10.$$arity = 0);
          
          Opal.def(self, '$screen', $Definition_screen$11 = function $$screen() {
            var self = this;

            return $$($nesting, 'Screen').$new(self["native"])
          }, $Definition_screen$11.$$arity = 0);
          
          Opal.def(self, '$related=', $Definition_related$eq$12 = function(elem) {
            var self = this;

            return self["native"].relatedTarget = $$($nesting, 'Native').$convert(elem)
          }, $Definition_related$eq$12.$$arity = 1);
          return (Opal.def(self, '$transfer=', $Definition_transfer$eq$13 = function(value) {
            var self = this;

            return self["native"].dataTransfer = $$($nesting, 'Native').$convert(value)
          }, $Definition_transfer$eq$13.$$arity = 1), nil) && 'transfer=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Drag_construct$14 = function $$construct(name, desc) {
              var self = this;

              return new DragEvent(name, desc)
            }, $Drag_construct$14.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Drag_construct$15 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("DragEvent");
            event.initDragEvent(name, desc.bubbles, desc.cancelable,
              desc.view || window, 0,
              desc.screenX || 0, desc.screenY || 0,
              desc.clientX || 0, desc.clientY || 0,
              desc.ctrlKey, desc.altKey, desc.shiftKey, desc.metaKey,
              desc.button || 0, desc.relatedTarget, desc.dataTransfer);

        return event;
      
            }, $Drag_construct$15.$$arity = 2)}};
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        self.$alias_native("button");
        
        Opal.def(self, '$client', $Drag_client$16 = function $$client() {
          var self = this;

          return $$($nesting, 'Position').$new(self["native"].clientX, self["native"].clientY)
        }, $Drag_client$16.$$arity = 0);
        
        Opal.def(self, '$screen', $Drag_screen$17 = function $$screen() {
          var self = this;

          if ($truthy((typeof(self["native"].screenX) !== "undefined"))) {
            return $$($nesting, 'Position').$new(self["native"].screenX, self["native"].screenY)
          } else {
            return nil
          }
        }, $Drag_screen$17.$$arity = 0);
        
        Opal.def(self, '$x', $Drag_x$18 = function $$x() {
          var self = this;

          return self.$screen().$x()
        }, $Drag_x$18.$$arity = 0);
        
        Opal.def(self, '$y', $Drag_y$19 = function $$y() {
          var self = this;

          return self.$screen().$y()
        }, $Drag_y$19.$$arity = 0);
        
        Opal.def(self, '$related', $Drag_related$20 = function $$related() {
          var self = this;

          return self.$DOM(self["native"].relatedTarget)
        }, $Drag_related$20.$$arity = 0);
        return (Opal.def(self, '$transfer', $Drag_transfer$21 = function $$transfer() {
          var self = this;

          return $$($nesting, 'DataTransfer').$new(self["native"].dataTransfer)
        }, $Drag_transfer$21.$$arity = 0), nil) && 'transfer';
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/gamepad"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Gamepad');

        var $nesting = [self].concat($parent_nesting), $Gamepad_supported$ques$1, $Gamepad_construct$7, $Gamepad_id$8, $Gamepad_index$9, $Gamepad_at$10, $Gamepad_axes$11, $Gamepad_buttons$12;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $Gamepad_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Gamepad")
        }, $Gamepad_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_id$eq$2, $Definition_index$eq$3, $Definition_at$eq$4, $Definition_axes$eq$5, $Definition_buttons$eq$6;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$id=', $Definition_id$eq$2 = function(value) {
            var self = this;

            return self["native"].id = value
          }, $Definition_id$eq$2.$$arity = 1);
          
          Opal.def(self, '$index=', $Definition_index$eq$3 = function(value) {
            var self = this;

            return self["native"].index = value
          }, $Definition_index$eq$3.$$arity = 1);
          
          Opal.def(self, '$at=', $Definition_at$eq$4 = function(value) {
            var self = this;

            return self["native"].timestamp = value
          }, $Definition_at$eq$4.$$arity = 1);
          
          Opal.def(self, '$axes=', $Definition_axes$eq$5 = function(value) {
            var self = this;

            return self["native"].axes = value
          }, $Definition_axes$eq$5.$$arity = 1);
          return (Opal.def(self, '$buttons=', $Definition_buttons$eq$6 = function(value) {
            var self = this;

            return self["native"].buttons = value
          }, $Definition_buttons$eq$6.$$arity = 1), nil) && 'buttons=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Gamepad_construct$7 = function $$construct(name, desc) {
              var self = this;

              return new GamepadEvent(name, {
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        gamepad:    desc })
            }, $Gamepad_construct$7.$$arity = 2)}};
        
        Opal.def(self, '$id', $Gamepad_id$8 = function $$id() {
          var self = this;

          return self["native"].gamepad.id
        }, $Gamepad_id$8.$$arity = 0);
        
        Opal.def(self, '$index', $Gamepad_index$9 = function $$index() {
          var self = this;

          return self["native"].gamepad.index
        }, $Gamepad_index$9.$$arity = 0);
        
        Opal.def(self, '$at', $Gamepad_at$10 = function $$at() {
          var self = this;

          return self["native"].gamepad.timestamp
        }, $Gamepad_at$10.$$arity = 0);
        
        Opal.def(self, '$axes', $Gamepad_axes$11 = function $$axes() {
          var self = this;

          return self["native"].gamepad.axes
        }, $Gamepad_axes$11.$$arity = 0);
        return (Opal.def(self, '$buttons', $Gamepad_buttons$12 = function $$buttons() {
          var self = this;

          return self["native"].gamepad.buttons
        }, $Gamepad_buttons$12.$$arity = 0), nil) && 'buttons';
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/hash_change"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'HashChange');

        var $nesting = [self].concat($parent_nesting), $HashChange_supported$ques$1, $HashChange_construct$4;

        
        Opal.defs(self, '$supported?', $HashChange_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.HashChange")
        }, $HashChange_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_old$eq$2, $Definition_new$eq$3;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$old=', $Definition_old$eq$2 = function(value) {
            var self = this;

            return self["native"].oldURL = value
          }, $Definition_old$eq$2.$$arity = 1);
          return (Opal.def(self, '$new=', $Definition_new$eq$3 = function(value) {
            var self = this;

            return self["native"].newURL = value
          }, $Definition_new$eq$3.$$arity = 1), nil) && 'new=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $HashChange_construct$4 = function $$construct(name, desc) {
              var self = this;

              return new HashChangeEvent(name, desc)
            }, $HashChange_construct$4.$$arity = 2)}};
        self.$alias_native("old", "oldURL");
        return self.$alias_native("new", "newURL");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/progress"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Progress');

        var $nesting = [self].concat($parent_nesting), $Progress_supported$ques$1, $Progress_construct$5, $Progress_construct$6;

        
        Opal.defs(self, '$supported?', $Progress_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Progress")
        }, $Progress_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_computable$eq$2, $Definition_loaded$eq$3, $Definition_total$eq$4;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$computable=', $Definition_computable$eq$2 = function(value) {
            var self = this;

            return self["native"].computableLength = value
          }, $Definition_computable$eq$2.$$arity = 1);
          
          Opal.def(self, '$loaded=', $Definition_loaded$eq$3 = function(value) {
            var self = this;

            return self["native"].loaded = value
          }, $Definition_loaded$eq$3.$$arity = 1);
          return (Opal.def(self, '$total=', $Definition_total$eq$4 = function(value) {
            var self = this;

            return self["native"].total = value
          }, $Definition_total$eq$4.$$arity = 1), nil) && 'total=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Progress_construct$5 = function $$construct(name, desc) {
              var self = this;

              return new ProgressEvent(name, desc)
            }, $Progress_construct$5.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Progress_construct$6 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("ProgressEvent");
            event.initProgressEvent(name, desc.bubbles, desc.cancelable,
              desc.computable, desc.loaded, desc.total);

        return event;
      
            }, $Progress_construct$6.$$arity = 2)}};
        self.$alias_native("computable?", "computableLength");
        self.$alias_native("loaded");
        return self.$alias_native("total");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/page_transition"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'PageTransition');

        var $nesting = [self].concat($parent_nesting), $PageTransition_supported$ques$1, $PageTransition_construct$3;

        
        Opal.defs(self, '$supported?', $PageTransition_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.PageTransition")
        }, $PageTransition_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_persisted$eq$2;

          self.$$prototype["native"] = nil;
          return (Opal.def(self, '$persisted=', $Definition_persisted$eq$2 = function(value) {
            var self = this;

            return self["native"].persisted = value
          }, $Definition_persisted$eq$2.$$arity = 1), nil) && 'persisted='
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.PageTransition"))) {
            Opal.defs(self, '$construct', $PageTransition_construct$3 = function $$construct(name, desc) {
              var self = this;

              return new PageTransitionEvent(name, desc);
            }, $PageTransition_construct$3.$$arity = 2)}};
        return self.$alias_native("persisted?", "persisted");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/pop_state"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'PopState');

        var $nesting = [self].concat($parent_nesting), $PopState_supported$ques$1, $PopState_construct$3, $PopState_construct$4;

        
        Opal.defs(self, '$supported?', $PopState_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.PopState")
        }, $PopState_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_state$eq$2;

          self.$$prototype["native"] = nil;
          return (Opal.def(self, '$state=', $Definition_state$eq$2 = function(value) {
            var self = this;

            return self["native"].state = value
          }, $Definition_state$eq$2.$$arity = 1), nil) && 'state='
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $PopState_construct$3 = function $$construct(name, desc) {
              var self = this;

              return new PopStateEvent(name, desc)
            }, $PopState_construct$3.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $PopState_construct$4 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent('PopStateEvent');
            event.initPopStateEvent(name, desc.bubbles, desc.cancelable,
              desc.state);

        return event;
      
            }, $PopState_construct$4.$$arity = 2)}};
        return self.$alias_native("state");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/storage"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Storage');

        var $nesting = [self].concat($parent_nesting), $Storage_supported$ques$1, $Storage_construct$7;

        
        Opal.defs(self, '$supported?', $Storage_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Storage")
        }, $Storage_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_key$eq$2, $Definition_new$eq$3, $Definition_old$eq$4, $Definition_area$eq$5, $Definition_url$eq$6;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$key=', $Definition_key$eq$2 = function(value) {
            var self = this;

            return self["native"].key = value
          }, $Definition_key$eq$2.$$arity = 1);
          
          Opal.def(self, '$new=', $Definition_new$eq$3 = function(value) {
            var self = this;

            return self["native"].newValue = value
          }, $Definition_new$eq$3.$$arity = 1);
          
          Opal.def(self, '$old=', $Definition_old$eq$4 = function(value) {
            var self = this;

            return self["native"].oldValue = value
          }, $Definition_old$eq$4.$$arity = 1);
          
          Opal.def(self, '$area=', $Definition_area$eq$5 = function(value) {
            var self = this;

            return self["native"].storageArea = value
          }, $Definition_area$eq$5.$$arity = 1);
          return (Opal.def(self, '$url=', $Definition_url$eq$6 = function(value) {
            var self = this;

            return self["native"].url = value
          }, $Definition_url$eq$6.$$arity = 1), nil) && 'url=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Storage_construct$7 = function $$construct(name, desc) {
              var self = this;

              return new StorageEvent(name, desc)
            }, $Storage_construct$7.$$arity = 2)}};
        self.$alias_native("key");
        self.$alias_native("new", "newValue");
        self.$alias_native("old", "oldValue");
        self.$alias_native("area", "storageArea");
        return self.$alias_native("url");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/touch"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native', '$==', '$downcase', '$name']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Touch');

        var $nesting = [self].concat($parent_nesting), $Touch_supported$ques$1, $Touch_construct$6, $Touch_cancel$ques$7, $Touch_end$ques$8, $Touch_leave$ques$9, $Touch_move$ques$10, $Touch_start$ques$11;

        
        Opal.defs(self, '$supported?', $Touch_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Touch")
        }, $Touch_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_alt$excl$2, $Definition_ctrl$excl$3, $Definition_meta$excl$4, $Definition_shift$excl$5;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$alt!', $Definition_alt$excl$2 = function() {
            var self = this;

            return self["native"].altKey = true
          }, $Definition_alt$excl$2.$$arity = 0);
          
          Opal.def(self, '$ctrl!', $Definition_ctrl$excl$3 = function() {
            var self = this;

            return self["native"].ctrlKey = true
          }, $Definition_ctrl$excl$3.$$arity = 0);
          
          Opal.def(self, '$meta!', $Definition_meta$excl$4 = function() {
            var self = this;

            return self["native"].metaKey = true
          }, $Definition_meta$excl$4.$$arity = 0);
          return (Opal.def(self, '$shift!', $Definition_shift$excl$5 = function() {
            var self = this;

            return self["native"].shiftKey = true
          }, $Definition_shift$excl$5.$$arity = 0), nil) && 'shift!';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Touch_construct$6 = function $$construct(name, desc) {
              var self = this;

              return new TouchEvent(name, desc)
            }, $Touch_construct$6.$$arity = 2)}};
        self.$alias_native("alt?", "altKey");
        self.$alias_native("ctrl?", "ctrlKey");
        self.$alias_native("meta?", "metaKey");
        self.$alias_native("shift?", "shiftKey");
        
        Opal.def(self, '$cancel?', $Touch_cancel$ques$7 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("touchcancel")
        }, $Touch_cancel$ques$7.$$arity = 0);
        
        Opal.def(self, '$end?', $Touch_end$ques$8 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("touchend")
        }, $Touch_end$ques$8.$$arity = 0);
        
        Opal.def(self, '$leave?', $Touch_leave$ques$9 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("touchleave")
        }, $Touch_leave$ques$9.$$arity = 0);
        
        Opal.def(self, '$move?', $Touch_move$ques$10 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("touchmove")
        }, $Touch_move$ques$10.$$arity = 0);
        return (Opal.def(self, '$start?', $Touch_start$ques$11 = function() {
          var self = this;

          return self.$name().$downcase()['$==']("touchstart")
        }, $Touch_start$ques$11.$$arity = 0), nil) && 'start?';
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/sensor"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Sensor');

        var $nesting = [self].concat($parent_nesting), $Sensor_supported$ques$1, $Sensor_construct$2;

        
        Opal.defs(self, '$supported?', $Sensor_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Sensor")
        }, $Sensor_supported$ques$1.$$arity = 0);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            return (Opal.defs(self, '$construct', $Sensor_construct$2 = function $$construct(name, desc) {
              var self = this;

              return new SensorEvent(name, desc)
            }, $Sensor_construct$2.$$arity = 2), nil) && 'construct'
          } else {
            return nil
          }
        } else {
          return nil
        };
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["ostruct"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs(['$each_pair', '$new_ostruct_member', '$[]=', '$-', '$[]', '$to_sym', '$>', '$length', '$raise', '$new', '$end_with?', '$!=', '$enum_for', '$is_a?', '$==', '$instance_variable_get', '$===', '$eql?', '$dup', '$to_n', '$hash', '$attr_reader', '$__send__', '$singleton_class', '$delete', '$respond_to?', '$define_singleton_method', '$__id__', '$class', '$any?', '$+', '$join', '$map', '$inspect']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'OpenStruct');

    var $nesting = [self].concat($parent_nesting), $OpenStruct_initialize$1, $OpenStruct_$$$3, $OpenStruct_$$$eq$4, $OpenStruct_method_missing$5, $OpenStruct_each_pair$6, $OpenStruct_$eq_eq$8, $OpenStruct_$eq_eq_eq$9, $OpenStruct_eql$ques$10, $OpenStruct_to_h$11, $OpenStruct_to_n$12, $OpenStruct_hash$13, $OpenStruct_delete_field$14, $OpenStruct_new_ostruct_member$15, $OpenStruct_inspect$18;

    self.$$prototype.table = nil;
    
    
    Opal.def(self, '$initialize', $OpenStruct_initialize$1 = function $$initialize(hash) {
      var $$2, self = this;

      
      
      if (hash == null) {
        hash = nil;
      };
      self.table = $hash2([], {});
      if ($truthy(hash)) {
        return $send(hash, 'each_pair', [], ($$2 = function(key, value){var self = $$2.$$s || this, $writer = nil;
          if (self.table == null) self.table = nil;

        
          
          if (key == null) {
            key = nil;
          };
          
          if (value == null) {
            value = nil;
          };
          $writer = [self.$new_ostruct_member(key), value];
          $send(self.table, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 2, $$2))
      } else {
        return nil
      };
    }, $OpenStruct_initialize$1.$$arity = -1);
    
    Opal.def(self, '$[]', $OpenStruct_$$$3 = function(name) {
      var self = this;

      return self.table['$[]'](name.$to_sym())
    }, $OpenStruct_$$$3.$$arity = 1);
    
    Opal.def(self, '$[]=', $OpenStruct_$$$eq$4 = function(name, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$new_ostruct_member(name), value];
      $send(self.table, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, $OpenStruct_$$$eq$4.$$arity = 2);
    
    Opal.def(self, '$method_missing', $OpenStruct_method_missing$5 = function $$method_missing(name, $a) {
      var $post_args, args, self = this, $writer = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 2))) {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (name) + "' for #<OpenStruct>", name))};
      if ($truthy(name['$end_with?']("="))) {
        
        if ($truthy(args.$length()['$!='](1))) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")};
        
        $writer = [self.$new_ostruct_member(name['$[]']($range(0, -2, false))), args['$[]'](0)];
        $send(self.table, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      } else {
        return self.table['$[]'](name.$to_sym())
      };
    }, $OpenStruct_method_missing$5.$$arity = -2);
    
    Opal.def(self, '$each_pair', $OpenStruct_each_pair$6 = function $$each_pair() {
      var $$7, $iter = $OpenStruct_each_pair$6.$$p, $yield = $iter || nil, self = this;

      if ($iter) $OpenStruct_each_pair$6.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return self.$enum_for("each_pair")
      };
      return $send(self.table, 'each_pair', [], ($$7 = function(pair){var self = $$7.$$s || this;

      
        
        if (pair == null) {
          pair = nil;
        };
        return Opal.yield1($yield, pair);;}, $$7.$$s = self, $$7.$$arity = 1, $$7));
    }, $OpenStruct_each_pair$6.$$arity = 0);
    
    Opal.def(self, '$==', $OpenStruct_$eq_eq$8 = function(other) {
      var self = this;

      
      if ($truthy(other['$is_a?']($$($nesting, 'OpenStruct')))) {
      } else {
        return false
      };
      return self.table['$=='](other.$instance_variable_get("@table"));
    }, $OpenStruct_$eq_eq$8.$$arity = 1);
    
    Opal.def(self, '$===', $OpenStruct_$eq_eq_eq$9 = function(other) {
      var self = this;

      
      if ($truthy(other['$is_a?']($$($nesting, 'OpenStruct')))) {
      } else {
        return false
      };
      return self.table['$==='](other.$instance_variable_get("@table"));
    }, $OpenStruct_$eq_eq_eq$9.$$arity = 1);
    
    Opal.def(self, '$eql?', $OpenStruct_eql$ques$10 = function(other) {
      var self = this;

      
      if ($truthy(other['$is_a?']($$($nesting, 'OpenStruct')))) {
      } else {
        return false
      };
      return self.table['$eql?'](other.$instance_variable_get("@table"));
    }, $OpenStruct_eql$ques$10.$$arity = 1);
    
    Opal.def(self, '$to_h', $OpenStruct_to_h$11 = function $$to_h() {
      var self = this;

      return self.table.$dup()
    }, $OpenStruct_to_h$11.$$arity = 0);
    
    Opal.def(self, '$to_n', $OpenStruct_to_n$12 = function $$to_n() {
      var self = this;

      return self.table.$to_n()
    }, $OpenStruct_to_n$12.$$arity = 0);
    
    Opal.def(self, '$hash', $OpenStruct_hash$13 = function $$hash() {
      var self = this;

      return self.table.$hash()
    }, $OpenStruct_hash$13.$$arity = 0);
    self.$attr_reader("table");
    
    Opal.def(self, '$delete_field', $OpenStruct_delete_field$14 = function $$delete_field(name) {
      var self = this, sym = nil;

      
      sym = name.$to_sym();
      
      try {
        self.$singleton_class().$__send__("remove_method", sym, "" + (sym) + "=")
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'NameError')])) {
          try {
            nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return self.table.$delete(sym);
    }, $OpenStruct_delete_field$14.$$arity = 1);
    
    Opal.def(self, '$new_ostruct_member', $OpenStruct_new_ostruct_member$15 = function $$new_ostruct_member(name) {
      var $$16, $$17, self = this;

      
      name = name.$to_sym();
      if ($truthy(self['$respond_to?'](name))) {
      } else {
        
        $send(self, 'define_singleton_method', [name], ($$16 = function(){var self = $$16.$$s || this;
          if (self.table == null) self.table = nil;

        return self.table['$[]'](name)}, $$16.$$s = self, $$16.$$arity = 0, $$16));
        $send(self, 'define_singleton_method', ["" + (name) + "="], ($$17 = function(x){var self = $$17.$$s || this, $writer = nil;
          if (self.table == null) self.table = nil;

        
          
          if (x == null) {
            x = nil;
          };
          $writer = [name, x];
          $send(self.table, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$17.$$s = self, $$17.$$arity = 1, $$17));
      };
      return name;
    }, $OpenStruct_new_ostruct_member$15.$$arity = 1);
    var ostruct_ids;;
    
    Opal.def(self, '$inspect', $OpenStruct_inspect$18 = function $$inspect() {
      var $$19, self = this, result = nil;

      
      
      var top = (ostruct_ids === undefined),
          ostruct_id = self.$__id__();
    ;
      
      return (function() { try {
      
      result = "" + "#<" + (self.$class());
      
        if (top) {
          ostruct_ids = {};
        }
        if (ostruct_ids.hasOwnProperty(ostruct_id)) {
          return result + ' ...>';
        }
        ostruct_ids[ostruct_id] = true;
      ;
      if ($truthy(self.table['$any?']())) {
        result = $rb_plus(result, " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$19 = function(name, value){var self = $$19.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$19.$$s = self, $$19.$$arity = 2, $$19)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
      } finally {
        
        if (top) {
          ostruct_ids = undefined;
        }
      
      }; })();;
    }, $OpenStruct_inspect$18.$$arity = 0);
    return Opal.alias(self, "to_s", "inspect");
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/custom"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$require', '$supports?', '$end_with?', '$[]', '$to_n', '$merge!', '$Native', '$new', '$has_key?']);
  
  self.$require("ostruct");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Custom');

        var $nesting = [self].concat($parent_nesting), $Custom_supported$ques$1, $Custom_construct$3, $Custom_construct$4, $Custom_construct$5, $Custom_construct$6, $Custom_initialize$7, $Custom_method_missing$8;

        self.$$prototype.detail = nil;
        
        Opal.defs(self, '$supported?', $Custom_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Custom")
        }, $Custom_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_method_missing$2;

          self.$$prototype["native"] = nil;
          return (Opal.def(self, '$method_missing', $Definition_method_missing$2 = function $$method_missing(name, value) {
            var self = this;

            if ($truthy(name['$end_with?']("="))) {
              return self["native"][name['$[]']($range(0, -2, false))] = value
            } else {
              return nil
            }
          }, $Definition_method_missing$2.$$arity = 2), nil) && 'method_missing'
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
          Opal.defs(self, '$construct', $Custom_construct$3 = function $$construct(name, desc) {
            var self = this;

            return new CustomEvent(name, {
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc })
          }, $Custom_construct$3.$$arity = 2)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
          Opal.defs(self, '$construct', $Custom_construct$4 = function $$construct(name, desc) {
            var self = this;

            
        var event = document.createEvent("CustomEvent");
            event.initCustomEvent(name, desc.bubbles, desc.cancelable, desc);

        return event;
      
          }, $Custom_construct$4.$$arity = 2)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.createObject"))) {
          Opal.defs(self, '$construct', $Custom_construct$5 = function $$construct(name, desc) {
            var self = this;

            return self.$Native(document.createEventObject())['$merge!']({
        type:       name,
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc }).$to_n()
          }, $Custom_construct$5.$$arity = 2)
        } else {
          Opal.defs(self, '$construct', $Custom_construct$6 = function $$construct(name, desc) {
            var self = this;

            return self.$Native(desc)['$merge!']({
        type:       name,
        bubbles:    desc.bubbles,
        cancelable: desc.cancelable,
        detail:     desc }).$to_n()
          }, $Custom_construct$6.$$arity = 2)
        };
        
        Opal.def(self, '$initialize', $Custom_initialize$7 = function $$initialize(event, callback) {
          var $iter = $Custom_initialize$7.$$p, $yield = $iter || nil, self = this;

          if ($iter) $Custom_initialize$7.$$p = null;
          
          
          if (callback == null) {
            callback = nil;
          };
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $Custom_initialize$7, false), [event, callback], null);
          return (self.detail = $$($nesting, 'Hash').$new(event.detail));
        }, $Custom_initialize$7.$$arity = -2);
        return (Opal.def(self, '$method_missing', $Custom_method_missing$8 = function $$method_missing(id, $a) {
          var $post_args, $iter = $Custom_method_missing$8.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $Custom_method_missing$8.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          ;
          if ($truthy(self.detail['$has_key?'](id))) {
            return self.detail['$[]'](id)};
          return $send(self, Opal.find_super_dispatcher(self, 'method_missing', $Custom_method_missing$8, false), $zuper, $iter);
        }, $Custom_method_missing$8.$$arity = -2), nil) && 'method_missing';
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["buffer/array"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $gvars = Opal.gvars, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$[]', '$name_for', '$attr_reader', '$==', '$for', '$to_n', '$enum_for']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Array');

      var $nesting = [self].concat($parent_nesting), $Array_for$1, $Array_initialize$2, $Array_bits$3, $Array_$$$4, $Array_$$$eq$5, $Array_bytesize$6, $Array_each$7, $Array_length$8, $Array_merge$excl$9;

      self.$$prototype["native"] = nil;
      
      self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
      Opal.defs(self, '$for', $Array_for$1 = function(bits, type) {
        var self = this;
        if ($gvars.$ == null) $gvars.$ = nil;

        return $gvars.$['$[]']("" + ($$($nesting, 'Buffer').$name_for(bits, type)) + "Array")
      }, $Array_for$1.$$arity = 2);
      self.$include($$($nesting, 'Enumerable'));
      self.$attr_reader("buffer", "type");
      
      Opal.def(self, '$initialize', $Array_initialize$2 = function $$initialize(buffer, bits, type) {
        var $iter = $Array_initialize$2.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Array_initialize$2.$$p = null;
        
        
        if (bits == null) {
          bits = nil;
        };
        
        if (type == null) {
          type = nil;
        };
        if ($$($nesting, 'Native')['$=='](buffer)) {
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $Array_initialize$2, false), [buffer], null)
        } else {
          
          var klass = $$($nesting, 'Array').$for(bits, type);

          $send(self, Opal.find_super_dispatcher(self, 'initialize', $Array_initialize$2, false), [new klass(buffer.$to_n())], null)
        
        };
        self.buffer = buffer;
        return (self.type = type);
      }, $Array_initialize$2.$$arity = -2);
      
      Opal.def(self, '$bits', $Array_bits$3 = function $$bits() {
        var self = this;

        return self["native"].BYTES_PER_ELEMENT * 8
      }, $Array_bits$3.$$arity = 0);
      
      Opal.def(self, '$[]', $Array_$$$4 = function(index, offset) {
        var self = this;

        
        
        if (offset == null) {
          offset = nil;
        };
        if ($truthy(offset)) {
          return self["native"].subarray(index, offset)
        } else {
          return self["native"][index]
        };
      }, $Array_$$$4.$$arity = -2);
      
      Opal.def(self, '$[]=', $Array_$$$eq$5 = function(index, value) {
        var self = this;

        return self["native"][index] = value
      }, $Array_$$$eq$5.$$arity = 2);
      
      Opal.def(self, '$bytesize', $Array_bytesize$6 = function $$bytesize() {
        var self = this;

        return self["native"].byteLength
      }, $Array_bytesize$6.$$arity = 0);
      
      Opal.def(self, '$each', $Array_each$7 = function $$each() {
        var $iter = $Array_each$7.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Array_each$7.$$p = null;
        
        if (($yield !== nil)) {
        } else {
          return self.$enum_for("each")
        };
        
        for (var i = 0, length = self["native"].length; i < length; i++) {
          Opal.yield1($yield, self["native"][i])
        }
      ;
        return self;
      }, $Array_each$7.$$arity = 0);
      
      Opal.def(self, '$length', $Array_length$8 = function $$length() {
        var self = this;

        return self["native"].length
      }, $Array_length$8.$$arity = 0);
      
      Opal.def(self, '$merge!', $Array_merge$excl$9 = function(other, offset) {
        var self = this;

        
        ;
        return self["native"].set(other.$to_n(), offset);
      }, $Array_merge$excl$9.$$arity = -2);
      return Opal.alias(self, "size", "length");
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["buffer/view"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $gvars = Opal.gvars, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$!', '$nil?', '$[]', '$attr_reader', '$native?', '$to_n', '$name_for']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'View');

      var $nesting = [self].concat($parent_nesting), $View_supported$ques$1, $View_initialize$2, $View_length$3, $View_get$4, $View_set$5, $View_get_int8$6, $View_set_int8$7, $View_get_uint8$8, $View_set_uint8$9, $View_get_int16$10, $View_set_int16$11, $View_get_uint16$12, $View_set_uint16$13, $View_get_int32$14, $View_set_int32$15, $View_get_uint32$16, $View_set_uint32$17, $View_get_float32$18, $View_set_float32$19, $View_get_float64$20, $View_set_float64$21;

      self.$$prototype["native"] = nil;
      
      self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
      Opal.defs(self, '$supported?', $View_supported$ques$1 = function() {
        var self = this;
        if ($gvars.$ == null) $gvars.$ = nil;

        return $gvars.$['$[]']("DataView")['$nil?']()['$!']()
      }, $View_supported$ques$1.$$arity = 0);
      self.$attr_reader("buffer", "offset");
      
      Opal.def(self, '$initialize', $View_initialize$2 = function $$initialize(buffer, offset, length) {
        var $a, $iter = $View_initialize$2.$$p, $yield = $iter || nil, self = this;

        if ($iter) $View_initialize$2.$$p = null;
        
        
        if (offset == null) {
          offset = nil;
        };
        
        if (length == null) {
          length = nil;
        };
        if ($truthy(self['$native?'](buffer))) {
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $View_initialize$2, false), [buffer], null)
        } else if ($truthy(($truthy($a = offset) ? length : $a))) {
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $View_initialize$2, false), [new DataView(buffer.$to_n(), offset.$to_n(), length.$to_n())], null)
        } else if ($truthy(offset)) {
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $View_initialize$2, false), [new DataView(buffer.$to_n(), offset.$to_n())], null)
        } else {
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $View_initialize$2, false), [new DataView(buffer.$to_n())], null)
        };
        self.buffer = buffer;
        return (self.offset = offset);
      }, $View_initialize$2.$$arity = -2);
      
      Opal.def(self, '$length', $View_length$3 = function $$length() {
        var self = this;

        return self["native"].byteLength
      }, $View_length$3.$$arity = 0);
      Opal.alias(self, "size", "length");
      
      Opal.def(self, '$get', $View_get$4 = function $$get(offset, bits, type, little) {
        var self = this;

        
        
        if (bits == null) {
          bits = 8;
        };
        
        if (type == null) {
          type = "unsigned";
        };
        
        if (little == null) {
          little = false;
        };
        return self["native"]["get" + $$($nesting, 'Buffer').$name_for(bits, type)](offset, little);
      }, $View_get$4.$$arity = -2);
      Opal.alias(self, "[]", "get");
      
      Opal.def(self, '$set', $View_set$5 = function $$set(offset, value, bits, type, little) {
        var self = this;

        
        
        if (bits == null) {
          bits = 8;
        };
        
        if (type == null) {
          type = "unsigned";
        };
        
        if (little == null) {
          little = false;
        };
        return self["native"]["set" + $$($nesting, 'Buffer').$name_for(bits, type)](offset, value, little);
      }, $View_set$5.$$arity = -3);
      Opal.alias(self, "[]=", "set");
      
      Opal.def(self, '$get_int8', $View_get_int8$6 = function $$get_int8(offset, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].getInt8(offset, little);
      }, $View_get_int8$6.$$arity = -2);
      
      Opal.def(self, '$set_int8', $View_set_int8$7 = function $$set_int8(offset, value, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].setInt8(offset, value, little);
      }, $View_set_int8$7.$$arity = -3);
      
      Opal.def(self, '$get_uint8', $View_get_uint8$8 = function $$get_uint8(offset, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].getUint8(offset, little);
      }, $View_get_uint8$8.$$arity = -2);
      
      Opal.def(self, '$set_uint8', $View_set_uint8$9 = function $$set_uint8(offset, value, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].setUint8(offset, value, little);
      }, $View_set_uint8$9.$$arity = -3);
      
      Opal.def(self, '$get_int16', $View_get_int16$10 = function $$get_int16(offset, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].getInt16(offset, little);
      }, $View_get_int16$10.$$arity = -2);
      
      Opal.def(self, '$set_int16', $View_set_int16$11 = function $$set_int16(offset, value, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].setInt16(offset, value, little);
      }, $View_set_int16$11.$$arity = -3);
      
      Opal.def(self, '$get_uint16', $View_get_uint16$12 = function $$get_uint16(offset, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].getUint16(offset, little);
      }, $View_get_uint16$12.$$arity = -2);
      
      Opal.def(self, '$set_uint16', $View_set_uint16$13 = function $$set_uint16(offset, value, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].setUint16(offset, value, little);
      }, $View_set_uint16$13.$$arity = -3);
      
      Opal.def(self, '$get_int32', $View_get_int32$14 = function $$get_int32(offset, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].getInt32(offset, little);
      }, $View_get_int32$14.$$arity = -2);
      
      Opal.def(self, '$set_int32', $View_set_int32$15 = function $$set_int32(offset, value, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].setInt32(offset, value, little);
      }, $View_set_int32$15.$$arity = -3);
      
      Opal.def(self, '$get_uint32', $View_get_uint32$16 = function $$get_uint32(offset, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].getUint32(offset, little);
      }, $View_get_uint32$16.$$arity = -2);
      
      Opal.def(self, '$set_uint32', $View_set_uint32$17 = function $$set_uint32(offset, value, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].setUint32(offset, value, little);
      }, $View_set_uint32$17.$$arity = -3);
      
      Opal.def(self, '$get_float32', $View_get_float32$18 = function $$get_float32(offset, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].getFloat32(offset, little);
      }, $View_get_float32$18.$$arity = -2);
      
      Opal.def(self, '$set_float32', $View_set_float32$19 = function $$set_float32(offset, value, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].setFloat32(offset, value, little);
      }, $View_set_float32$19.$$arity = -3);
      
      Opal.def(self, '$get_float64', $View_get_float64$20 = function $$get_float64(offset, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].getFloat64(offset, little);
      }, $View_get_float64$20.$$arity = -2);
      return (Opal.def(self, '$set_float64', $View_set_float64$21 = function $$set_float64(offset, value, little) {
        var self = this;

        
        
        if (little == null) {
          little = false;
        };
        return self["native"].setFloat64(offset, value, little);
      }, $View_set_float64$21.$$arity = -3), nil) && 'set_float64';
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["buffer"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $gvars = Opal.gvars, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$!', '$nil?', '$[]', '$===', '$native?', '$new']);
  
  self.$require("native");
  self.$require("buffer/array");
  self.$require("buffer/view");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Buffer');

    var $nesting = [self].concat($parent_nesting), $Buffer_supported$ques$1, $Buffer_name_for$2, $Buffer_initialize$3, $Buffer_length$4, $Buffer_to_a$5, $Buffer_view$6;

    self.$$prototype["native"] = nil;
    
    self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
    Opal.defs(self, '$supported?', $Buffer_supported$ques$1 = function() {
      var self = this;
      if ($gvars.$ == null) $gvars.$ = nil;

      return $gvars.$['$[]']("ArrayBuffer")['$nil?']()['$!']()
    }, $Buffer_supported$ques$1.$$arity = 0);
    Opal.defs(self, '$name_for', $Buffer_name_for$2 = function $$name_for(bits, type) {
      var self = this, part = nil, $case = nil;

      
      part = (function() {$case = type;
      if ("unsigned"['$===']($case)) {return "Uint"}
      else if ("signed"['$===']($case)) {return "Int"}
      else if ("float"['$===']($case)) {return "Float"}
      else { return nil }})();
      return "" + (part) + (bits);
    }, $Buffer_name_for$2.$$arity = 2);
    
    Opal.def(self, '$initialize', $Buffer_initialize$3 = function $$initialize(size, bits) {
      var $iter = $Buffer_initialize$3.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Buffer_initialize$3.$$p = null;
      
      
      if (bits == null) {
        bits = 8;
      };
      if ($truthy(self['$native?'](size))) {
        return $send(self, Opal.find_super_dispatcher(self, 'initialize', $Buffer_initialize$3, false), [size], null)
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'initialize', $Buffer_initialize$3, false), [new ArrayBuffer(size * (bits / 8))], null)
      };
    }, $Buffer_initialize$3.$$arity = -2);
    
    Opal.def(self, '$length', $Buffer_length$4 = function $$length() {
      var self = this;

      return self["native"].byteLength
    }, $Buffer_length$4.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $Buffer_to_a$5 = function $$to_a(bits, type) {
      var self = this;

      
      
      if (bits == null) {
        bits = 8;
      };
      
      if (type == null) {
        type = "unsigned";
      };
      return $$($nesting, 'Array').$new(self, bits, type);
    }, $Buffer_to_a$5.$$arity = -1);
    return (Opal.def(self, '$view', $Buffer_view$6 = function $$view(offset, length) {
      var self = this;

      
      
      if (offset == null) {
        offset = nil;
      };
      
      if (length == null) {
        length = nil;
      };
      return $$($nesting, 'View').$new(self, offset, length);
    }, $Buffer_view$6.$$arity = -1), nil) && 'view';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/message"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$supports?', '$convert', '$supported?', '$new', '$alias_native']);
  
  self.$require("buffer");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Message');

        var $nesting = [self].concat($parent_nesting), $Message_supported$ques$1, $Message_construct$5, $Message_construct$6, $Message_data$7, $Message_source$8;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $Message_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Message")
        }, $Message_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_data$eq$2, $Definition_origin$eq$3, $Definition_source$eq$4;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$data=', $Definition_data$eq$2 = function(value) {
            var self = this;

            return self["native"].data = value
          }, $Definition_data$eq$2.$$arity = 1);
          
          Opal.def(self, '$origin=', $Definition_origin$eq$3 = function(value) {
            var self = this;

            return self["native"].origin = value
          }, $Definition_origin$eq$3.$$arity = 1);
          return (Opal.def(self, '$source=', $Definition_source$eq$4 = function(value) {
            var self = this;

            return self["native"].source = $$($nesting, 'Native').$convert(value)
          }, $Definition_source$eq$4.$$arity = 1), nil) && 'source=';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Message_construct$5 = function $$construct(name, desc) {
              var self = this;

              return new MessageEvent(name, desc)
            }, $Message_construct$5.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Message_construct$6 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("MessageEvent");
            event.initMessageEvent(name, desc.bubbles, desc.cancelable,
              desc.data, desc.origin, "", desc.source || window);

        return event;
      
            }, $Message_construct$6.$$arity = 2)}};
        
        Opal.def(self, '$data', $Message_data$7 = function $$data() {
          var self = this;

          
      if (window.ArrayBuffer && self["native"].data instanceof ArrayBuffer) {
        return $$($nesting, 'Buffer').$new(self["native"].data);
      }
      else if (window.Blob && self["native"].data instanceof Blob) {
        return $$($nesting, 'Blob').$new(self["native"].data);
      }
      else {
        return self["native"].data;
      }
    
        }, $Message_data$7.$$arity = 0);
        self.$alias_native("origin");
        return (Opal.def(self, '$source', $Message_source$8 = function $$source() {
          var self = this;

          
      var source = self["native"].source;

      if (window.Window && source instanceof window.Window) {
        return $$($nesting, 'Window').$new(source);
      }
      else {
        return nil;
      }
    
        }, $Message_source$8.$$arity = 0), nil) && 'source';
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event/close"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$supports?', '$supported?', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Close');

        var $nesting = [self].concat($parent_nesting), $Close_supported$ques$1, $Close_construct$6, $Close_construct$7;

        
        Opal.defs(self, '$supported?', $Close_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("Event.Close")
        }, $Close_supported$ques$1.$$arity = 0);
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Definition');

          var $nesting = [self].concat($parent_nesting), $Definition_code$eq$2, $Definition_reason$eq$3, $Definition_clean$excl$4, $Definition_not_clean$excl$5;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$code=', $Definition_code$eq$2 = function(value) {
            var self = this;

            return self["native"].code = value
          }, $Definition_code$eq$2.$$arity = 1);
          
          Opal.def(self, '$reason=', $Definition_reason$eq$3 = function(value) {
            var self = this;

            return self["native"].reason = value
          }, $Definition_reason$eq$3.$$arity = 1);
          
          Opal.def(self, '$clean!', $Definition_clean$excl$4 = function(value) {
            var self = this;

            return self["native"].wasClean = true
          }, $Definition_clean$excl$4.$$arity = 1);
          return (Opal.def(self, '$not_clean!', $Definition_not_clean$excl$5 = function(value) {
            var self = this;

            return self["native"].wasClean = false
          }, $Definition_not_clean$excl$5.$$arity = 1), nil) && 'not_clean!';
        })($nesting[0], $$($nesting, 'Definition'), $nesting);
        if ($truthy(self['$supported?']())) {
          if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
            Opal.defs(self, '$construct', $Close_construct$6 = function $$construct(name, desc) {
              var self = this;

              return new CloseEvent(name, desc)
            }, $Close_construct$6.$$arity = 2)
          } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
            Opal.defs(self, '$construct', $Close_construct$7 = function $$construct(name, desc) {
              var self = this;

              
        var event = document.createEvent("CloseEvent");
            event.initCloseEvent(name, desc.bubbles, desc.cancelable,
              desc.wasClean, desc.code, desc.reason);

        return event;
      
            }, $Close_construct$7.$$arity = 2)}};
        self.$alias_native("code");
        self.$alias_native("reason");
        return self.$alias_native("clean?", "wasClean");
      })($nesting[0], $$($nesting, 'Event'), $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/event"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$require', '$gsub', '$[]', '$aliases', '$name_for', '$===', '$class_for', '$new', '$construct', '$const_get', '$to_proc', '$arguments=', '$-', '$supports?', '$merge!', '$Native', '$to_n', '$==', '$name', '$attr_reader', '$attr_writer', '$convert', '$alias_native', '$off', '$prevent', '$stop']);
  
  self.$require("browser/event/base");
  self.$require("browser/event/ui");
  self.$require("browser/event/mouse");
  self.$require("browser/event/keyboard");
  self.$require("browser/event/focus");
  self.$require("browser/event/wheel");
  self.$require("browser/event/data_transfer");
  self.$require("browser/event/composition");
  self.$require("browser/event/animation");
  self.$require("browser/event/audio_processing");
  self.$require("browser/event/before_unload");
  self.$require("browser/event/composition");
  self.$require("browser/event/clipboard");
  self.$require("browser/event/device_light");
  self.$require("browser/event/device_motion");
  self.$require("browser/event/device_orientation");
  self.$require("browser/event/device_proximity");
  self.$require("browser/event/drag");
  self.$require("browser/event/gamepad");
  self.$require("browser/event/hash_change");
  self.$require("browser/event/progress");
  self.$require("browser/event/page_transition");
  self.$require("browser/event/pop_state");
  self.$require("browser/event/storage");
  self.$require("browser/event/touch");
  self.$require("browser/event/sensor");
  self.$require("browser/event/custom");
  self.$require("browser/event/message");
  self.$require("browser/event/close");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Event');

      var $nesting = [self].concat($parent_nesting), $Event_aliases$1, $Event_name_for$2, $Event_class_for$3, $Event_supported$ques$4, $Event_create$5, $Event_construct$6, $Event_construct$7, $Event_construct$8, $Event_construct$9, $Event_new$10, $Event_initialize$11, $Event_name$12, $Event_on$13, $Event_target$14, $Event_arguments$15, $Event_arguments$eq$16, $Event_off$17, $Event_stopped$ques$18, $Event_stop$19, $Event_prevent$20, $Event_prevented$ques$21, $Event_stop$excl$22;

      self.$$prototype["native"] = self.$$prototype.on = self.$$prototype.callback = nil;
      
      Opal.defs(self, '$aliases', $Event_aliases$1 = function $$aliases() {
        var $a, self = this;
        if (self.aliases == null) self.aliases = nil;

        return (self.aliases = ($truthy($a = self.aliases) ? $a : $hash2(["dom:load", "hover"], {"dom:load": "DOMContentLoaded", "hover": "mouse:over"})))
      }, $Event_aliases$1.$$arity = 0);
      Opal.defs(self, '$name_for', $Event_name_for$2 = function $$name_for(name) {
        var $a, self = this;

        return ($truthy($a = self.$aliases()['$[]'](name)) ? $a : name).$gsub(":", "")
      }, $Event_name_for$2.$$arity = 1);
      Opal.defs(self, '$class_for', $Event_class_for$3 = function $$class_for(name) {
        var self = this, $case = nil;

        return (function() {$case = self.$name_for(name);
        if ("animationend"['$===']($case) || "animationiteration"['$===']($case) || "animationstart"['$===']($case)) {return $$($nesting, 'Animation')}
        else if ("audioprocess"['$===']($case)) {return $$($nesting, 'AudioProcessing')}
        else if ("beforeunload"['$===']($case)) {return $$($nesting, 'BeforeUnload')}
        else if ("compositionend"['$===']($case) || "compositionstart"['$===']($case) || "compositionupdate"['$===']($case)) {return $$($nesting, 'Composition')}
        else if ("copy"['$===']($case) || "cut"['$===']($case) || "paste"['$===']($case)) {return $$($nesting, 'Clipboard')}
        else if ("devicelight"['$===']($case)) {return $$($nesting, 'DeviceLight')}
        else if ("devicemotion"['$===']($case)) {return $$($nesting, 'DeviceMotion')}
        else if ("deviceorientation"['$===']($case)) {return $$($nesting, 'DeviceOrientation')}
        else if ("deviceproximity"['$===']($case)) {return $$($nesting, 'DeviceProximity')}
        else if ("drag"['$===']($case) || "dragend"['$===']($case) || "dragenter"['$===']($case) || "dragexit"['$===']($case) || "dragleave"['$===']($case) || "dragover"['$===']($case) || "dragstart"['$===']($case) || "drop"['$===']($case)) {return $$($nesting, 'Drag')}
        else if ("gamepadconnected"['$===']($case) || "gamepaddisconnected"['$===']($case)) {return $$($nesting, 'Gamepad')}
        else if ("hashchange"['$===']($case)) {return $$($nesting, 'HashChange')}
        else if ("progress"['$===']($case) || "load"['$===']($case) || "loadend"['$===']($case) || "loadstart"['$===']($case)) {return $$($nesting, 'Progress')}
        else if ("pagehide"['$===']($case) || "pageshow"['$===']($case)) {return $$($nesting, 'PageTransition')}
        else if ("popstate"['$===']($case)) {return $$($nesting, 'PopState')}
        else if ("storage"['$===']($case)) {return $$($nesting, 'Storage')}
        else if ("touchcancel"['$===']($case) || "touchend"['$===']($case) || "touchleave"['$===']($case) || "touchmove"['$===']($case) || "touchstart"['$===']($case)) {return $$($nesting, 'Touch')}
        else if ("compassneedscalibration"['$===']($case) || "userproximity"['$===']($case)) {return $$($nesting, 'Sensor')}
        else if ("message"['$===']($case)) {return $$($nesting, 'Message')}
        else if ("close"['$===']($case)) {return $$($nesting, 'Close')}
        else if ("click"['$===']($case) || "contextmenu"['$===']($case) || "dblclick"['$===']($case) || "mousedown"['$===']($case) || "mouseenter"['$===']($case) || "mouseleave"['$===']($case) || "mousemove"['$===']($case) || "mouseout"['$===']($case) || "mouseover"['$===']($case) || "mouseup"['$===']($case) || "show"['$===']($case)) {return $$($nesting, 'Mouse')}
        else if ("keydown"['$===']($case) || "keypress"['$===']($case) || "keyup"['$===']($case)) {return $$($nesting, 'Keyboard')}
        else if ("blur"['$===']($case) || "focus"['$===']($case) || "focusin"['$===']($case) || "focusout"['$===']($case)) {return $$($nesting, 'Focus')}
        else if ("wheel"['$===']($case) || "mousewheel"['$===']($case)) {return $$($nesting, 'Wheel')}
        else if ("abort"['$===']($case) || "afterprint"['$===']($case) || "beforeprint"['$===']($case) || "cached"['$===']($case) || "canplay"['$===']($case) || "canplaythrough"['$===']($case) || "change"['$===']($case) || "chargingchange"['$===']($case) || "chargingtimechange"['$===']($case) || "checking"['$===']($case) || "close"['$===']($case) || "dischargingtimechange"['$===']($case) || "DOMContentLoaded"['$===']($case) || "downloading"['$===']($case) || "durationchange"['$===']($case) || "emptied"['$===']($case) || "ended"['$===']($case) || "error"['$===']($case) || "fullscreenchange"['$===']($case) || "fullscreenerror"['$===']($case) || "input"['$===']($case) || "invalid"['$===']($case) || "levelchange"['$===']($case) || "loadeddata"['$===']($case) || "loadedmetadata"['$===']($case) || "noupdate"['$===']($case) || "obsolete"['$===']($case) || "offline"['$===']($case) || "online"['$===']($case) || "open"['$===']($case) || "orientationchange"['$===']($case) || "pause"['$===']($case) || "pointerlockchange"['$===']($case) || "pointerlockerror"['$===']($case) || "play"['$===']($case) || "playing"['$===']($case) || "ratechange"['$===']($case) || "readystatechange"['$===']($case) || "reset"['$===']($case) || "seeked"['$===']($case) || "seeking"['$===']($case) || "stalled"['$===']($case) || "submit"['$===']($case) || "success"['$===']($case) || "suspend"['$===']($case) || "timeupdate"['$===']($case) || "updateready"['$===']($case) || "visibilitychange"['$===']($case) || "volumechange"['$===']($case) || "waiting"['$===']($case)) {return $$($nesting, 'Event')}
        else {return $$($nesting, 'Custom')}})()
      }, $Event_class_for$3.$$arity = 1);
      Opal.defs(self, '$supported?', $Event_supported$ques$4 = function() {
        var self = this;

        return true
      }, $Event_supported$ques$4.$$arity = 0);
      Opal.defs(self, '$create', $Event_create$5 = function $$create(name, $a) {
        var $iter = $Event_create$5.$$p, block = $iter || nil, $post_args, args, self = this, klass = nil, event = nil, $writer = nil;

        if ($iter) $Event_create$5.$$p = null;
        
        
        if ($iter) $Event_create$5.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        name = self.$name_for(name);
        klass = self.$class_for(name);
        event = klass.$new(klass.$construct(name, $send(klass.$const_get("Definition"), 'new', [], block.$to_proc())));
        
        $writer = [args];
        $send(event, 'arguments=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return event;
      }, $Event_create$5.$$arity = -2);
      if ($truthy($$($nesting, 'Browser')['$supports?']("Event.constructor"))) {
        Opal.defs(self, '$construct', $Event_construct$6 = function $$construct(name, desc) {
          var self = this;

          return new Event(name, desc)
        }, $Event_construct$6.$$arity = 2)
      } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.create"))) {
        Opal.defs(self, '$construct', $Event_construct$7 = function $$construct(name, desc) {try {

          var self = this;

          
        var event = document.createEvent("HTMLEvents");
            event.initEvent(name, desc.bubbles, desc.cancelable);

        Opal.ret(self.$Native(event)['$merge!'](desc));
      
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, $Event_construct$7.$$arity = 2)
      } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.createObject"))) {
        Opal.defs(self, '$construct', $Event_construct$8 = function $$construct(name, desc) {
          var self = this;

          return self.$Native(document.createEventObject())['$merge!'](desc)['$merge!']({ type: name }).$to_n()
        }, $Event_construct$8.$$arity = 2)
      } else {
        Opal.defs(self, '$construct', $Event_construct$9 = function $$construct(name, desc) {
          var self = this;

          return self.$Native(desc)['$merge!']({ type: name }).$to_n()
        }, $Event_construct$9.$$arity = 2)
      };
      Opal.defs(self, '$new', $Event_new$10 = function(value, callback) {
        var $iter = $Event_new$10.$$p, $yield = $iter || nil, self = this, klass = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Event_new$10.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if (callback == null) {
          callback = nil;
        };
        if (self['$==']($$($nesting, 'Event'))) {
        } else {
          return $send(self, Opal.find_super_dispatcher(self, 'new', $Event_new$10, false, self.$$class.$$prototype), $zuper, $iter)
        };
        klass = self.$class_for((function() {if ($truthy(callback)) {
          return callback.$name()
        } else {
          return value.type;
        }; return nil; })());
        if (klass['$==']($$($nesting, 'Event'))) {
          return $send(self, Opal.find_super_dispatcher(self, 'new', $Event_new$10, false, self.$$class.$$prototype), $zuper, $iter)
        } else {
          return klass.$new(value, callback)
        };
      }, $Event_new$10.$$arity = -2);
      self.$attr_reader("callback");
      self.$attr_writer("on");
      
      Opal.def(self, '$initialize', $Event_initialize$11 = function $$initialize(event, callback) {
        var $iter = $Event_initialize$11.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Event_initialize$11.$$p = null;
        
        
        if (callback == null) {
          callback = nil;
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Event_initialize$11, false), [event], null);
        return (self.callback = callback);
      }, $Event_initialize$11.$$arity = -2);
      
      Opal.def(self, '$name', $Event_name$12 = function $$name() {
        var self = this;

        return self["native"].type
      }, $Event_name$12.$$arity = 0);
      
      Opal.def(self, '$on', $Event_on$13 = function $$on() {
        var $a, self = this;

        return ($truthy($a = self.on) ? $a : $$($nesting, 'Target').$convert(self["native"].currentTarget))
      }, $Event_on$13.$$arity = 0);
      
      Opal.def(self, '$target', $Event_target$14 = function $$target() {
        var self = this;

        return $$($nesting, 'Target').$convert(self["native"].srcElement || self["native"].target)
      }, $Event_target$14.$$arity = 0);
      
      Opal.def(self, '$arguments', $Event_arguments$15 = function() {
        var self = this;

        return self["native"].arguments || []
      }, $Event_arguments$15.$$arity = 0);
      
      Opal.def(self, '$arguments=', $Event_arguments$eq$16 = function(args) {
        var self = this;

        return self["native"].arguments = args
      }, $Event_arguments$eq$16.$$arity = 1);
      self.$alias_native("bubbles?", "bubbles");
      self.$alias_native("cancelable?", "cancelable");
      self.$alias_native("data");
      self.$alias_native("phase", "eventPhase");
      self.$alias_native("at", "timeStamp");
      
      Opal.def(self, '$off', $Event_off$17 = function $$off() {
        var self = this;

        if ($truthy(self.callback)) {
          return self.callback.$off()
        } else {
          return nil
        }
      }, $Event_off$17.$$arity = 0);
      
      Opal.def(self, '$stopped?', $Event_stopped$ques$18 = function() {
        var self = this;

        return !!self["native"].stopped
      }, $Event_stopped$ques$18.$$arity = 0);
      
      Opal.def(self, '$stop', $Event_stop$19 = function $$stop() {
        var self = this;

        
        if ($truthy((typeof(self["native"].stopPropagation) !== "undefined"))) {
          self["native"].stopPropagation()};
        return self["native"].stopped = true;
      }, $Event_stop$19.$$arity = 0);
      
      Opal.def(self, '$prevent', $Event_prevent$20 = function $$prevent() {
        var self = this;

        
        if ($truthy((typeof(self["native"].preventDefault) !== "undefined"))) {
          self["native"].preventDefault()};
        return self["native"].prevented = true;
      }, $Event_prevent$20.$$arity = 0);
      
      Opal.def(self, '$prevented?', $Event_prevented$ques$21 = function() {
        var self = this;

        return !!self["native"].prevented
      }, $Event_prevented$ques$21.$$arity = 0);
      return (Opal.def(self, '$stop!', $Event_stop$excl$22 = function() {
        var self = this;

        
        self.$prevent();
        return self.$stop();
      }, $Event_stop$excl$22.$$arity = 0), nil) && 'stop!';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/window/view"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$to_n', '$supports?', '$raise']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'View');

        var $nesting = [self].concat($parent_nesting), $View_initialize$1, $View_width$2, $View_height$3, $View_height$4, $View_width$5, $View_width$6, $View_height$7;

        self.$$prototype["native"] = nil;
        
        
        Opal.def(self, '$initialize', $View_initialize$1 = function $$initialize(window) {
          var self = this;

          
          self.window = window;
          return (self["native"] = window.$to_n());
        }, $View_initialize$1.$$arity = 1);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Window.innerSize"))) {
          
          
          Opal.def(self, '$width', $View_width$2 = function $$width() {
            var self = this;

            return self["native"].innerWidth
          }, $View_width$2.$$arity = 0);
          return (Opal.def(self, '$height', $View_height$3 = function $$height() {
            var self = this;

            return self["native"].innerHeight
          }, $View_height$3.$$arity = 0), nil) && 'height';
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Element.clientSize"))) {
          
          
          Opal.def(self, '$height', $View_height$4 = function $$height() {
            var self = this;

            return self["native"].document.documentElement.clientHeight
          }, $View_height$4.$$arity = 0);
          return (Opal.def(self, '$width', $View_width$5 = function $$width() {
            var self = this;

            return self["native"].document.documentElement.clientWidth
          }, $View_width$5.$$arity = 0), nil) && 'width';
        } else {
          
          
          Opal.def(self, '$width', $View_width$6 = function $$width() {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "window size unsupported")
          }, $View_width$6.$$arity = 0);
          return (Opal.def(self, '$height', $View_height$7 = function $$height() {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "window size unsupported")
          }, $View_height$7.$$arity = 0), nil) && 'height';
        };
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/window/size"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$to_n', '$===', '$first', '$values_at', '$width', '$height', '$supports?', '$raise', '$set']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Size');

        var $nesting = [self].concat($parent_nesting), $Size_initialize$1, $Size_set$2, $Size_width$3, $Size_height$4, $Size_width$5, $Size_height$6, $Size_width$eq$7, $Size_height$eq$8;

        self.$$prototype["native"] = nil;
        
        
        Opal.def(self, '$initialize', $Size_initialize$1 = function $$initialize(window) {
          var self = this;

          
          self.window = window;
          return (self["native"] = window.$to_n());
        }, $Size_initialize$1.$$arity = 1);
        
        Opal.def(self, '$set', $Size_set$2 = function $$set($a) {
          var $post_args, args, $b, $c, self = this, width = nil, height = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          if ($truthy($$($nesting, 'Hash')['$==='](args.$first()))) {
            $c = args.$first().$values_at("width", "height"), $b = Opal.to_ary($c), (width = ($b[0] == null ? nil : $b[0])), (height = ($b[1] == null ? nil : $b[1])), $c
          } else {
            $c = args, $b = Opal.to_ary($c), (width = ($b[0] == null ? nil : $b[0])), (height = ($b[1] == null ? nil : $b[1])), $c
          };
          width = ($truthy($b = width) ? $b : self.$width());
          height = ($truthy($b = height) ? $b : self.$height());
          self["native"].resizeTo(width, height);
          return self;
        }, $Size_set$2.$$arity = -1);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Window.outerSize"))) {
          
          
          Opal.def(self, '$width', $Size_width$3 = function $$width() {
            var self = this;

            return self["native"].outerWidth
          }, $Size_width$3.$$arity = 0);
          
          Opal.def(self, '$height', $Size_height$4 = function $$height() {
            var self = this;

            return self["native"].outerHeight
          }, $Size_height$4.$$arity = 0);
        } else {
          
          
          Opal.def(self, '$width', $Size_width$5 = function $$width() {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "window outer size not supported")
          }, $Size_width$5.$$arity = 0);
          
          Opal.def(self, '$height', $Size_height$6 = function $$height() {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "window outer size not supported")
          }, $Size_height$6.$$arity = 0);
        };
        
        Opal.def(self, '$width=', $Size_width$eq$7 = function(value) {
          var self = this;

          return self.$set($hash2(["width"], {"width": value}))
        }, $Size_width$eq$7.$$arity = 1);
        return (Opal.def(self, '$height=', $Size_height$eq$8 = function(value) {
          var self = this;

          return self.$set($hash2(["height"], {"height": value}))
        }, $Size_height$eq$8.$$arity = 1), nil) && 'height=';
      })($nesting[0], null, $nesting)
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/window"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$delete', '$join', '$map', '$===', '$new', '$include', '$target', '$supports?', '$[]', '$raise', '$alert', '$prompt', '$confirm']);
  
  self.$require("browser/window/view");
  self.$require("browser/window/size");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $Window_open$1, $Window$3, $Window_alert$4, $Window_prompt$5, $Window_confirm$6, $Window_parent$7, $Window_top$8, $Window_opener$9, $Window_view$10, $Window_size$11, $Window_scroll$12, $Window_send$13, $Window_send$14, $Window_close$15;

      self.$$prototype["native"] = self.$$prototype.parent = self.$$prototype.top = self.$$prototype.opener = self.$$prototype.view = self.$$prototype.size = self.$$prototype.scroll = nil;
      
      Opal.defs(self, '$open', $Window_open$1 = function $$open(url, options) {
        var $$2, self = this, name = nil, features = nil;

        
        name = options.$delete("name");
        features = $send(options, 'map', [], ($$2 = function(key, value){var self = $$2.$$s || this, $case = nil;

        
          
          if (key == null) {
            key = nil;
          };
          
          if (value == null) {
            value = nil;
          };
          value = (function() {$case = value;
          if (true['$===']($case)) {return "yes"}
          else if (false['$===']($case)) {return "no"}
          else {return value}})();
          return "" + (key) + "=" + (value);}, $$2.$$s = self, $$2.$$arity = 2, $$2)).$join(",");
        
      var win = window.open(url, name, features);

      if (win == null) {
        return nil;
      }

      return self.$new(win);
    ;
      }, $Window_open$1.$$arity = 2);
      self.$include($$$($$($nesting, 'Browser'), 'NativeCachedWrapper'));
      self.$include($$$($$($nesting, 'Event'), 'Target'));
      $send(self, 'target', [], ($Window$3 = function(value){var self = $Window$3.$$s || this;
        if ($gvars.window == null) $gvars.window = nil;

      
        
        if (value == null) {
          value = nil;
        };
        if ($truthy(value == window)) {
          return $gvars.window
        } else {
          return nil
        };}, $Window$3.$$s = self, $Window$3.$$arity = 1, $Window$3));
      
      Opal.def(self, '$alert', $Window_alert$4 = function $$alert(value) {
        var self = this;

        
        self["native"].alert(value);
        return value;
      }, $Window_alert$4.$$arity = 1);
      
      Opal.def(self, '$prompt', $Window_prompt$5 = function $$prompt(value) {
        var self = this;

        return self["native"].prompt(value) || nil
      }, $Window_prompt$5.$$arity = 1);
      
      Opal.def(self, '$confirm', $Window_confirm$6 = function $$confirm(value) {
        var self = this;

        return self["native"].confirm(value) || false
      }, $Window_confirm$6.$$arity = 1);
      
      Opal.def(self, '$parent', $Window_parent$7 = function $$parent() {
        var $a, self = this;

        return (self.parent = ($truthy($a = self.parent) ? $a : $$$($$($nesting, 'Browser'), 'Window').$new(self["native"].parent)))
      }, $Window_parent$7.$$arity = 0);
      
      Opal.def(self, '$top', $Window_top$8 = function $$top() {
        var $a, self = this;

        return (self.top = ($truthy($a = self.top) ? $a : $$$($$($nesting, 'Browser'), 'Window').$new(self["native"].top)))
      }, $Window_top$8.$$arity = 0);
      
      Opal.def(self, '$opener', $Window_opener$9 = function $$opener() {
        var $a, self = this;

        return (self.opener = ($truthy($a = self.opener) ? $a : $$$($$($nesting, 'Browser'), 'Window').$new(self["native"].opener)))
      }, $Window_opener$9.$$arity = 0);
      
      Opal.def(self, '$view', $Window_view$10 = function $$view() {
        var $a, self = this;

        return (self.view = ($truthy($a = self.view) ? $a : $$($nesting, 'View').$new(self)))
      }, $Window_view$10.$$arity = 0);
      
      Opal.def(self, '$size', $Window_size$11 = function $$size() {
        var $a, self = this;

        return (self.size = ($truthy($a = self.size) ? $a : $$($nesting, 'Size').$new(self)))
      }, $Window_size$11.$$arity = 0);
      
      Opal.def(self, '$scroll', $Window_scroll$12 = function $$scroll() {
        var $a, self = this;

        return (self.scroll = ($truthy($a = self.scroll) ? $a : $$$($$$($$($nesting, 'DOM'), 'Element'), 'Scroll').$new(self)))
      }, $Window_scroll$12.$$arity = 0);
      if ($truthy($$($nesting, 'Browser')['$supports?']("Window.send"))) {
        
        Opal.def(self, '$send', $Window_send$13 = function $$send(message, options) {
          var $a, self = this;

          
          
          if (options == null) {
            options = $hash2([], {});
          };
          return self["native"].postMessage(message, ($truthy($a = options['$[]']("to")) ? $a : "*"));
        }, $Window_send$13.$$arity = -2)
      } else {
        
        Opal.def(self, '$send', $Window_send$14 = function $$send(message, options) {
          var self = this;

          
          
          if (options == null) {
            options = $hash2([], {});
          };
          return self.$raise($$($nesting, 'NotImplementedError'), "message sending unsupported");
        }, $Window_send$14.$$arity = -2)
      };
      return (Opal.def(self, '$close', $Window_close$15 = function $$close() {
        var self = this;

        return self["native"].close()
      }, $Window_close$15.$$arity = 0), nil) && 'close';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  $gvars.window = $$$($$($nesting, 'Browser'), 'Window').$new(window);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_alert$16, $Kernel_prompt$17, $Kernel_confirm$18;

    
    
    Opal.def(self, '$alert', $Kernel_alert$16 = function $$alert(value) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$alert(value)
    }, $Kernel_alert$16.$$arity = 1);
    
    Opal.def(self, '$prompt', $Kernel_prompt$17 = function $$prompt(value) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$prompt(value)
    }, $Kernel_prompt$17.$$arity = 1);
    
    Opal.def(self, '$confirm', $Kernel_confirm$18 = function $$confirm(value) {
      var self = this;
      if ($gvars.window == null) $gvars.window = nil;

      return $gvars.window.$confirm(value)
    }, $Kernel_confirm$18.$$arity = 1);
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/node_set"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$uniq', '$map', '$flatten', '$DOM', '$convert', '$respond_to?', '$each', '$__send__', '$to_proc', '$===', '$at_css', '$at_xpath', '$[]', '$css', '$select', '$=~', '$search', '$xpath']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NodeSet');

        var $nesting = [self].concat($parent_nesting), $NodeSet_$$$1, $NodeSet_initialize$3, $NodeSet_method_missing$4, $NodeSet_respond_to_missing$ques$6, $NodeSet_at_css$7, $NodeSet_at_xpath$9, $NodeSet_css$11, $NodeSet_filter$13, $NodeSet_search$15, $NodeSet_xpath$17, $NodeSet_to_ary$19;

        self.$$prototype.literal = nil;
        
        Opal.defs(self, '$[]', $NodeSet_$$$1 = function($a) {
          var $post_args, nodes, $$2, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          nodes = $post_args;;
          return self.$new($send(nodes.$flatten(), 'map', [], ($$2 = function(x){var self = $$2.$$s || this;

          
            
            if (x == null) {
              x = nil;
            };
            return self.$DOM($$($nesting, 'Native').$convert(x));}, $$2.$$s = self, $$2.$$arity = 1, $$2)).$uniq());
        }, $NodeSet_$$$1.$$arity = -1);
        
        Opal.def(self, '$initialize', $NodeSet_initialize$3 = function $$initialize(literal) {
          var self = this;

          return (self.literal = literal)
        }, $NodeSet_initialize$3.$$arity = 1);
        
        Opal.def(self, '$method_missing', $NodeSet_method_missing$4 = function $$method_missing(name, $a) {
          var $iter = $NodeSet_method_missing$4.$$p, block = $iter || nil, $post_args, args, $$5, self = this, result = nil;

          if ($iter) $NodeSet_method_missing$4.$$p = null;
          
          
          if ($iter) $NodeSet_method_missing$4.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(self.literal['$respond_to?'](name))) {
          } else {
            
            $send(self, 'each', [], ($$5 = function(el){var self = $$5.$$s || this;

            
              
              if (el == null) {
                el = nil;
              };
              return $send(el, '__send__', [name].concat(Opal.to_a(args)), block.$to_proc());}, $$5.$$s = self, $$5.$$arity = 1, $$5));
            return self;
          };
          result = $send(self.literal, '__send__', [name].concat(Opal.to_a(args)), block.$to_proc());
          if ($truthy(result === self.literal)) {
            return self
          } else if ($truthy($$($nesting, 'Array')['$==='](result))) {
            return $$($nesting, 'NodeSet').$new(result)
          } else {
            return result
          };
        }, $NodeSet_method_missing$4.$$arity = -2);
        
        Opal.def(self, '$respond_to_missing?', $NodeSet_respond_to_missing$ques$6 = function(name, $a) {
          var $post_args, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          ;
          return self.literal['$respond_to?'](name);
        }, $NodeSet_respond_to_missing$ques$6.$$arity = -2);
        
        Opal.def(self, '$at_css', $NodeSet_at_css$7 = function $$at_css($a) {try {

          var $post_args, rules, $$8, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          rules = $post_args;;
          $send(self, 'each', [], ($$8 = function(node){var self = $$8.$$s || this;

          
            
            if (node == null) {
              node = nil;
            };
            if ($truthy((node = $send(node, 'at_css', Opal.to_a(rules))))) {
              Opal.ret(node)
            } else {
              return nil
            };}, $$8.$$s = self, $$8.$$arity = 1, $$8));
          return nil;
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, $NodeSet_at_css$7.$$arity = -1);
        
        Opal.def(self, '$at_xpath', $NodeSet_at_xpath$9 = function $$at_xpath($a) {try {

          var $post_args, paths, $$10, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          paths = $post_args;;
          $send(self, 'each', [], ($$10 = function(node){var self = $$10.$$s || this;

          
            
            if (node == null) {
              node = nil;
            };
            if ($truthy((node = $send(node, 'at_xpath', Opal.to_a(paths))))) {
              Opal.ret(node)
            } else {
              return nil
            };}, $$10.$$s = self, $$10.$$arity = 1, $$10));
          return nil;
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, $NodeSet_at_xpath$9.$$arity = -1);
        
        Opal.def(self, '$css', $NodeSet_css$11 = function $$css(path) {
          var $$12, self = this;

          return $$($nesting, 'NodeSet')['$[]']($send(self.literal, 'map', [], ($$12 = function(node){var self = $$12.$$s || this;

          
            
            if (node == null) {
              node = nil;
            };
            return node.$css(path);}, $$12.$$s = self, $$12.$$arity = 1, $$12)))
        }, $NodeSet_css$11.$$arity = 1);
        
        Opal.def(self, '$filter', $NodeSet_filter$13 = function $$filter(expression) {
          var $$14, self = this;

          return $$($nesting, 'NodeSet')['$[]']($send(self.literal, 'select', [], ($$14 = function(node){var self = $$14.$$s || this;

          
            
            if (node == null) {
              node = nil;
            };
            return node['$=~'](expression);}, $$14.$$s = self, $$14.$$arity = 1, $$14)))
        }, $NodeSet_filter$13.$$arity = 1);
        
        Opal.def(self, '$search', $NodeSet_search$15 = function $$search($a) {
          var $post_args, what, $$16, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          what = $post_args;;
          return $$($nesting, 'NodeSet')['$[]']($send(self.literal, 'map', [], ($$16 = function(node){var self = $$16.$$s || this;

          
            
            if (node == null) {
              node = nil;
            };
            return $send(node, 'search', Opal.to_a(what));}, $$16.$$s = self, $$16.$$arity = 1, $$16)));
        }, $NodeSet_search$15.$$arity = -1);
        
        Opal.def(self, '$xpath', $NodeSet_xpath$17 = function $$xpath(path) {
          var $$18, self = this;

          return $$($nesting, 'NodeSet')['$[]']($send(self.literal, 'map', [], ($$18 = function(node){var self = $$18.$$s || this;

          
            
            if (node == null) {
              node = nil;
            };
            return node.$xpath(path);}, $$18.$$s = self, $$18.$$arity = 1, $$18)))
        }, $NodeSet_xpath$17.$$arity = 1);
        return (Opal.def(self, '$to_ary', $NodeSet_to_ary$19 = function $$to_ary() {
          var self = this;

          return self.literal
        }, $NodeSet_to_ary$19.$$arity = 0), nil) && 'to_ary';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/node"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$include', '$==', '$[]', '$new', '$raise', '$convert', '$set_native_reference', '$to_n', '$respond_to?', '$each', '$<<', '$native?', '$===', '$>>', '$DOM', '$to_proc', '$parent', '$last', '$pop', '$select!', '$=~', '$remove_child', '$remove', '$children', '$supports?', '$node_type', '$first', '$try_convert', '$select', '$element_children', '$to_s', '$next', '$!', '$element?', '$previous', '$name']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Node');

        var $nesting = [self].concat($parent_nesting), $Node_new$1, $Node_$eq_eq$2, $Node_initialize_copy$3, $Node_$lt$lt$4, $Node_$gt$gt$6, $Node_add_child$8, $Node_add_next_sibling$9, $Node_add_previous_sibling$10, $Node_append_to$11, $Node_ancestors$12, $Node_remove$14, $Node_clear$15, $Node_content$16, $Node_content$eq$17, $Node_content$18, $Node_content$eq$19, $Node_content$20, $Node_content$eq$21, $Node_blank$ques$22, $Node_cdata$ques$23, $Node_child$24, $Node_children$25, $Node_children$eq$26, $Node_comment$ques$27, $Node_document$28, $Node_document$eq$29, $Node_document$ques$30, $Node_elem$ques$31, $Node_element_children$32, $Node_first_element_child$33, $Node_fragment$ques$34, $Node_inner_html$35, $Node_inner_html$eq$36, $Node_last_element_child$37, $Node_name$38, $Node_name$eq$39, $Node_namespace$40, $Node_next$41, $Node_next_element$42, $Node_node_type$43, $Node_parent$44, $Node_parent$eq$45, $Node_parse$46, $Node_path$47, $Node_prepend_to$48, $Node_previous$49, $Node_previous_element$50, $Node_remove_child$51, $Node_replace$52, $Node_text$ques$53, $Node_traverse$54, $Node_value$55, $Node_value$eq$56, $Node_inspect$57;

        self.$$prototype["native"] = nil;
        
        self.$include($$$($$($nesting, 'Browser'), 'NativeCachedWrapper'));
        Opal.const_set($nesting[0], 'ELEMENT_NODE', 1);
        Opal.const_set($nesting[0], 'ATTRIBUTE_NODE', 2);
        Opal.const_set($nesting[0], 'TEXT_NODE', 3);
        Opal.const_set($nesting[0], 'CDATA_SECTION_NODE', 4);
        Opal.const_set($nesting[0], 'ENTITY_REFERENCE_NOCE', 5);
        Opal.const_set($nesting[0], 'ENTITY_NODE', 6);
        Opal.const_set($nesting[0], 'PROCESSING_INSTRUCTION_NODE', 7);
        Opal.const_set($nesting[0], 'COMMENT_NODE', 8);
        Opal.const_set($nesting[0], 'DOCUMENT_NODE', 9);
        Opal.const_set($nesting[0], 'DOCUMENT_TYPE_NODE', 10);
        Opal.const_set($nesting[0], 'DOCUMENT_FRAGMENT_NODE', 11);
        Opal.const_set($nesting[0], 'NOTATION_NODE', 12);
        Opal.defs(self, '$new', $Node_new$1 = function(value) {
          var $a, $iter = $Node_new$1.$$p, $yield = $iter || nil, self = this, klass = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;
          if (self.classes == null) self.classes = nil;

          if ($iter) $Node_new$1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          if (self['$==']($$($nesting, 'Node'))) {
            
            self.classes = ($truthy($a = self.classes) ? $a : [nil, $$($nesting, 'Element'), $$($nesting, 'Attribute'), $$($nesting, 'Text'), $$($nesting, 'CDATA'), nil, nil, nil, $$($nesting, 'Comment'), $$($nesting, 'Document'), nil, $$($nesting, 'DocumentFragment')]);
            if ($truthy((klass = self.classes['$[]'](value.nodeType)))) {
              return klass.$new(value)
            } else {
              return self.$raise($$($nesting, 'ArgumentError'), "cannot instantiate a non derived Node object")
            };
          } else {
            return $send(self, Opal.find_super_dispatcher(self, 'new', $Node_new$1, false, self.$$class.$$prototype), $zuper, $iter)
          }
        }, $Node_new$1.$$arity = 1);
        
        Opal.def(self, '$==', $Node_$eq_eq$2 = function(other) {
          var self = this;

          return self["native"] === $$($nesting, 'Native').$convert(other)
        }, $Node_$eq_eq$2.$$arity = 1);
        
        Opal.def(self, '$initialize_copy', $Node_initialize_copy$3 = function $$initialize_copy(old) {
          var self = this;

          return self.$set_native_reference(old.$to_n().cloneNode(true))
        }, $Node_initialize_copy$3.$$arity = 1);
        
        Opal.def(self, '$<<', $Node_$lt$lt$4 = function(node) {
          var $$5, self = this;

          
          if ($truthy($$($nesting, 'Opal')['$respond_to?'](node, "each"))) {
            
            $send(node, 'each', [], ($$5 = function(n){var self = $$5.$$s || this;

            
              
              if (n == null) {
                n = nil;
              };
              return self['$<<'](n);}, $$5.$$s = self, $$5.$$arity = 1, $$5));
            return self;};
          if ($truthy(self['$native?'](node))) {
          } else if ($truthy($$($nesting, 'String')['$==='](node))) {
            node = self["native"].ownerDocument.createTextNode(node)
          } else {
            node = $$($nesting, 'Native').$convert(node)
          };
          self["native"].appendChild(node);
          return self;
        }, $Node_$lt$lt$4.$$arity = 1);
        
        Opal.def(self, '$>>', $Node_$gt$gt$6 = function(node) {
          var $$7, self = this;

          
          if ($truthy($$($nesting, 'Opal')['$respond_to?'](node, "each"))) {
            
            $send(node, 'each', [], ($$7 = function(n){var self = $$7.$$s || this;

            
              
              if (n == null) {
                n = nil;
              };
              return self['$>>'](n);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
            return self;};
          if ($truthy(self['$native?'](node))) {
          } else if ($truthy($$($nesting, 'String')['$==='](node))) {
            node = self["native"].ownerDocument.createTextNode(node)
          } else {
            node = $$($nesting, 'Native').$convert(node)
          };
          if ($truthy(self["native"].firstChild == null)) {
            self["native"].appendChild(node)
          } else {
            self["native"].insertBefore(node, self["native"].firstChild)
          };
          return self;
        }, $Node_$gt$gt$6.$$arity = 1);
        
        Opal.def(self, '$add_child', $Node_add_child$8 = function $$add_child(node) {
          var $iter = $Node_add_child$8.$$p, block = $iter || nil, self = this;

          if ($iter) $Node_add_child$8.$$p = null;
          
          
          if ($iter) $Node_add_child$8.$$p = null;;
          
          if (node == null) {
            node = nil;
          };
          if ($truthy(node)) {
          } else {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          return self['$<<'](node);
        }, $Node_add_child$8.$$arity = -1);
        
        Opal.def(self, '$add_next_sibling', $Node_add_next_sibling$9 = function $$add_next_sibling(node) {
          var $iter = $Node_add_next_sibling$9.$$p, block = $iter || nil, self = this;

          if ($iter) $Node_add_next_sibling$9.$$p = null;
          
          
          if ($iter) $Node_add_next_sibling$9.$$p = null;;
          
          if (node == null) {
            node = nil;
          };
          if ($truthy(node)) {
          } else {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          if ($truthy(self['$native?'](node))) {
          } else if ($truthy($$($nesting, 'String')['$==='](node))) {
            node = self["native"].ownerDocument.createTextNode(node)
          } else {
            node = $$($nesting, 'Native').$convert(node)
          };
          return self["native"].parentNode.insertBefore(node, self["native"].nextSibling);
        }, $Node_add_next_sibling$9.$$arity = -1);
        
        Opal.def(self, '$add_previous_sibling', $Node_add_previous_sibling$10 = function $$add_previous_sibling(node) {
          var $iter = $Node_add_previous_sibling$10.$$p, block = $iter || nil, self = this;

          if ($iter) $Node_add_previous_sibling$10.$$p = null;
          
          
          if ($iter) $Node_add_previous_sibling$10.$$p = null;;
          
          if (node == null) {
            node = nil;
          };
          if ($truthy(node)) {
          } else {
            node = $send(self, 'DOM', [], block.$to_proc())
          };
          if ($truthy(self['$native?'](node))) {
          } else if ($truthy($$($nesting, 'String')['$==='](node))) {
            node = self["native"].ownerDocument.createTextNode(node)
          } else {
            node = $$($nesting, 'Native').$convert(node)
          };
          return self["native"].parentNode.insertBefore(node, self["native"]);
        }, $Node_add_previous_sibling$10.$$arity = -1);
        Opal.alias(self, "after", "add_next_sibling");
        
        Opal.def(self, '$append_to', $Node_append_to$11 = function $$append_to(node) {
          var self = this;

          return node['$<<'](self)
        }, $Node_append_to$11.$$arity = 1);
        
        Opal.def(self, '$ancestors', $Node_ancestors$12 = function $$ancestors(expression) {
          var $a, $$13, self = this, parents = nil, parent = nil;

          
          
          if (expression == null) {
            expression = nil;
          };
          if ($truthy(self.$parent())) {
          } else {
            return $$($nesting, 'NodeSet')['$[]']()
          };
          parents = [self.$parent()];
          while ($truthy((parent = parents.$last().$parent()))) {
            parents['$<<'](parent)
          };
          if ($truthy($$($nesting, 'Document')['$==='](parents.$last()))) {
            parents.$pop()};
          if ($truthy(expression)) {
            $send(parents, 'select!', [], ($$13 = function(p){var self = $$13.$$s || this;

            
              
              if (p == null) {
                p = nil;
              };
              return p['$=~'](expression);}, $$13.$$s = self, $$13.$$arity = 1, $$13))};
          return $$($nesting, 'NodeSet').$new(parents);
        }, $Node_ancestors$12.$$arity = -1);
        Opal.alias(self, "before", "add_previous_sibling");
        
        Opal.def(self, '$remove', $Node_remove$14 = function $$remove() {
          var self = this;

          if ($truthy(self.$parent())) {
            return self.$parent().$remove_child(self)
          } else {
            return nil
          }
        }, $Node_remove$14.$$arity = 0);
        
        Opal.def(self, '$clear', $Node_clear$15 = function $$clear() {
          var self = this;

          return self.$children().$remove()
        }, $Node_clear$15.$$arity = 0);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Element.textContent"))) {
          
          
          Opal.def(self, '$content', $Node_content$16 = function $$content() {
            var self = this;

            return self["native"].textContent
          }, $Node_content$16.$$arity = 0);
          
          Opal.def(self, '$content=', $Node_content$eq$17 = function(value) {
            var self = this;

            return self["native"].textContent = value
          }, $Node_content$eq$17.$$arity = 1);
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Element.innerText"))) {
          
          
          Opal.def(self, '$content', $Node_content$18 = function $$content() {
            var self = this;

            return self["native"].innerText
          }, $Node_content$18.$$arity = 0);
          
          Opal.def(self, '$content=', $Node_content$eq$19 = function(value) {
            var self = this;

            return self["native"].innerText = value
          }, $Node_content$eq$19.$$arity = 1);
        } else {
          
          
          Opal.def(self, '$content', $Node_content$20 = function $$content() {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "node text content unsupported")
          }, $Node_content$20.$$arity = 0);
          
          Opal.def(self, '$content=', $Node_content$eq$21 = function(value) {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "node text content unsupported")
          }, $Node_content$eq$21.$$arity = 1);
        };
        
        Opal.def(self, '$blank?', $Node_blank$ques$22 = function() {
          var self = this;

          return self.$raise($$($nesting, 'NotImplementedError'))
        }, $Node_blank$ques$22.$$arity = 0);
        
        Opal.def(self, '$cdata?', $Node_cdata$ques$23 = function() {
          var self = this;

          return self.$node_type()['$==']($$($nesting, 'CDATA_SECTION_NODE'))
        }, $Node_cdata$ques$23.$$arity = 0);
        
        Opal.def(self, '$child', $Node_child$24 = function $$child() {
          var self = this;

          return self.$children().$first()
        }, $Node_child$24.$$arity = 0);
        
        Opal.def(self, '$children', $Node_children$25 = function $$children() {
          var self = this;

          return $$($nesting, 'NodeSet')['$[]']($$$($$($nesting, 'Native'), 'Array').$new(self["native"].childNodes))
        }, $Node_children$25.$$arity = 0);
        
        Opal.def(self, '$children=', $Node_children$eq$26 = function(node) {
          var self = this;

          return self.$raise($$($nesting, 'NotImplementedError'))
        }, $Node_children$eq$26.$$arity = 1);
        
        Opal.def(self, '$comment?', $Node_comment$ques$27 = function() {
          var self = this;

          return self.$node_type()['$==']($$($nesting, 'COMMENT_NODE'))
        }, $Node_comment$ques$27.$$arity = 0);
        
        Opal.def(self, '$document', $Node_document$28 = function $$document() {
          var self = this;

          if ($truthy((typeof(self["native"].ownerDocument) !== "undefined"))) {
            return self.$DOM(self["native"].ownerDocument)
          } else {
            return nil
          }
        }, $Node_document$28.$$arity = 0);
        
        Opal.def(self, '$document=', $Node_document$eq$29 = function(new_document) {
          var self = this;

          return $$($nesting, 'Native').$try_convert(new_document, new_document).adoptNode(self["native"])
        }, $Node_document$eq$29.$$arity = 1);
        
        Opal.def(self, '$document?', $Node_document$ques$30 = function() {
          var self = this;

          return self.$node_type()['$==']($$($nesting, 'DOCUMENT_NODE'))
        }, $Node_document$ques$30.$$arity = 0);
        
        Opal.def(self, '$elem?', $Node_elem$ques$31 = function() {
          var self = this;

          return self.$node_type()['$==']($$($nesting, 'ELEMENT_NODE'))
        }, $Node_elem$ques$31.$$arity = 0);
        Opal.alias(self, "element?", "elem?");
        
        Opal.def(self, '$element_children', $Node_element_children$32 = function $$element_children() {
          var self = this;

          return $send(self.$children(), 'select', [], "element?".$to_proc())
        }, $Node_element_children$32.$$arity = 0);
        Opal.alias(self, "elements", "element_children");
        
        Opal.def(self, '$first_element_child', $Node_first_element_child$33 = function $$first_element_child() {
          var self = this;

          return self.$element_children().$first()
        }, $Node_first_element_child$33.$$arity = 0);
        
        Opal.def(self, '$fragment?', $Node_fragment$ques$34 = function() {
          var self = this;

          return self.$node_type()['$==']($$($nesting, 'DOCUMENT_FRAGMENT_NODE'))
        }, $Node_fragment$ques$34.$$arity = 0);
        
        Opal.def(self, '$inner_html', $Node_inner_html$35 = function $$inner_html() {
          var self = this;

          return self["native"].innerHTML
        }, $Node_inner_html$35.$$arity = 0);
        
        Opal.def(self, '$inner_html=', $Node_inner_html$eq$36 = function(value) {
          var self = this;

          return self["native"].innerHTML = value
        }, $Node_inner_html$eq$36.$$arity = 1);
        Opal.alias(self, "inner_text", "content");
        Opal.alias(self, "inner_text=", "content=");
        
        Opal.def(self, '$last_element_child', $Node_last_element_child$37 = function $$last_element_child() {
          var self = this;

          return self.$element_children().$last()
        }, $Node_last_element_child$37.$$arity = 0);
        
        Opal.def(self, '$name', $Node_name$38 = function $$name() {
          var self = this;

          return self["native"].nodeName || nil
        }, $Node_name$38.$$arity = 0);
        
        Opal.def(self, '$name=', $Node_name$eq$39 = function(value) {
          var self = this;

          return self["native"].nodeName = value.$to_s()
        }, $Node_name$eq$39.$$arity = 1);
        
        Opal.def(self, '$namespace', $Node_namespace$40 = function $$namespace() {
          var self = this;

          return self["native"].namespaceURI || nil
        }, $Node_namespace$40.$$arity = 0);
        
        Opal.def(self, '$next', $Node_next$41 = function $$next() {
          var self = this;

          if ($truthy(self["native"].nextSibling != null)) {
            return self.$DOM(self["native"].nextSibling)
          } else {
            return nil
          }
        }, $Node_next$41.$$arity = 0);
        Opal.alias(self, "next=", "add_next_sibling");
        
        Opal.def(self, '$next_element', $Node_next_element$42 = function $$next_element() {
          var $a, $b, self = this, current = nil;

          
          current = self.$next();
          while ($truthy(($truthy($b = current) ? current['$element?']()['$!']() : $b))) {
            current = current.$next()
          };
          return current;
        }, $Node_next_element$42.$$arity = 0);
        Opal.alias(self, "next_sibling", "next");
        Opal.alias(self, "node_name", "name");
        Opal.alias(self, "node_name=", "name=");
        
        Opal.def(self, '$node_type', $Node_node_type$43 = function $$node_type() {
          var self = this;

          return self["native"].nodeType
        }, $Node_node_type$43.$$arity = 0);
        
        Opal.def(self, '$parent', $Node_parent$44 = function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentNode != null)) {
            return self.$DOM(self["native"].parentNode)
          } else {
            return nil
          }
        }, $Node_parent$44.$$arity = 0);
        
        Opal.def(self, '$parent=', $Node_parent$eq$45 = function(node) {
          var self = this;

          return self["native"].parentNode = $$($nesting, 'Native').$convert(node)
        }, $Node_parent$eq$45.$$arity = 1);
        
        Opal.def(self, '$parse', $Node_parse$46 = function $$parse(text, options) {
          var self = this;

          
          
          if (options == null) {
            options = $hash2([], {});
          };
          return self.$raise($$($nesting, 'NotImplementedError'));
        }, $Node_parse$46.$$arity = -2);
        
        Opal.def(self, '$path', $Node_path$47 = function $$path() {
          var self = this;

          return self.$raise($$($nesting, 'NotImplementedError'))
        }, $Node_path$47.$$arity = 0);
        
        Opal.def(self, '$prepend_to', $Node_prepend_to$48 = function $$prepend_to(node) {
          var self = this;

          return node['$>>'](self)
        }, $Node_prepend_to$48.$$arity = 1);
        
        Opal.def(self, '$previous', $Node_previous$49 = function $$previous() {
          var self = this;

          if ($truthy(self["native"].previousSibling != null)) {
            return self.$DOM(self["native"].previousSibling)
          } else {
            return nil
          }
        }, $Node_previous$49.$$arity = 0);
        Opal.alias(self, "previous=", "add_previous_sibling");
        
        Opal.def(self, '$previous_element', $Node_previous_element$50 = function $$previous_element() {
          var $a, $b, self = this, current = nil;

          
          current = self.$previous();
          while ($truthy(($truthy($b = current) ? current['$element?']()['$!']() : $b))) {
            current = current.$previous()
          };
          return current;
        }, $Node_previous_element$50.$$arity = 0);
        Opal.alias(self, "previous_sibling", "previous");
        
        Opal.def(self, '$remove_child', $Node_remove_child$51 = function $$remove_child(node) {
          var self = this;

          return self["native"].removeChild($$($nesting, 'Native').$try_convert(node))
        }, $Node_remove_child$51.$$arity = 1);
        
        Opal.def(self, '$replace', $Node_replace$52 = function $$replace(node) {
          var self = this;

          
          if ($truthy(self['$native?'](node))) {
          } else if ($truthy($$($nesting, 'String')['$==='](node))) {
            node = self["native"].ownerDocument.createTextNode(node)
          } else {
            node = $$($nesting, 'Native').$convert(node)
          };
          self["native"].parentNode.replaceChild(node, self["native"]);
          return node;
        }, $Node_replace$52.$$arity = 1);
        Opal.alias(self, "replace_with", "replace");
        Opal.alias(self, "text", "content");
        Opal.alias(self, "text=", "content=");
        
        Opal.def(self, '$text?', $Node_text$ques$53 = function() {
          var self = this;

          return self.$node_type()['$==']($$($nesting, 'TEXT_NODE'))
        }, $Node_text$ques$53.$$arity = 0);
        
        Opal.def(self, '$traverse', $Node_traverse$54 = function $$traverse() {
          var $iter = $Node_traverse$54.$$p, block = $iter || nil, self = this;

          if ($iter) $Node_traverse$54.$$p = null;
          
          
          if ($iter) $Node_traverse$54.$$p = null;;
          return self.$raise($$($nesting, 'NotImplementedError'));
        }, $Node_traverse$54.$$arity = 0);
        Opal.alias(self, "type", "node_type");
        
        Opal.def(self, '$value', $Node_value$55 = function $$value() {
          var self = this;

          return self["native"].nodeValue || nil
        }, $Node_value$55.$$arity = 0);
        
        Opal.def(self, '$value=', $Node_value$eq$56 = function(value) {
          var self = this;

          return self["native"].nodeValue = value
        }, $Node_value$eq$56.$$arity = 1);
        return (Opal.def(self, '$inspect', $Node_inspect$57 = function $$inspect() {
          var self = this;

          return "" + "#<DOM::Node: " + (self.$name()) + ">"
        }, $Node_inspect$57.$$arity = 0), nil) && 'inspect';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/attribute"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$alias_native', '$supports?', '$==', '$name']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Attribute');

        var $nesting = [self].concat($parent_nesting), $Attribute_id$ques$1;

        
        self.$include($$$($$($nesting, 'Browser'), 'NativeCachedWrapper'));
        self.$alias_native("name");
        self.$alias_native("value");
        self.$alias_native("value=");
        if ($truthy($$($nesting, 'Browser')['$supports?']("Attr.isId"))) {
          return self.$alias_native("id?", "isId")
        } else {
          return (Opal.def(self, '$id?', $Attribute_id$ques$1 = function() {
            var self = this;

            return self.$name()['$==']("id")
          }, $Attribute_id$ques$1.$$arity = 0), nil) && 'id?'
        };
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/character_data"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CharacterData');

        var $nesting = [self].concat($parent_nesting), $CharacterData_append$1, $CharacterData_data$2, $CharacterData_delete$3, $CharacterData_insert$4, $CharacterData_replace$5, $CharacterData_substring$6;

        self.$$prototype["native"] = nil;
        
        
        Opal.def(self, '$append', $CharacterData_append$1 = function $$append(string) {
          var self = this;

          
          self["native"].appendData(string);
          return self;
        }, $CharacterData_append$1.$$arity = 1);
        
        Opal.def(self, '$data', $CharacterData_data$2 = function $$data() {
          var self = this;

          return self["native"].data
        }, $CharacterData_data$2.$$arity = 0);
        
        Opal.def(self, '$delete', $CharacterData_delete$3 = function(count, offset) {
          var self = this;

          
          
          if (offset == null) {
            offset = 0;
          };
          self["native"].deleteData(offset, count);
          return self;
        }, $CharacterData_delete$3.$$arity = -2);
        
        Opal.def(self, '$insert', $CharacterData_insert$4 = function $$insert(string, offset) {
          var self = this;

          
          
          if (offset == null) {
            offset = 0;
          };
          self["native"].insertData(offset, string);
          return self;
        }, $CharacterData_insert$4.$$arity = -2);
        self.$alias_native("length");
        
        Opal.def(self, '$replace', $CharacterData_replace$5 = function $$replace(string, offset, count) {
          var self = this;

          
          
          if (offset == null) {
            offset = 0;
          };
          
          if (count == null) {
            count = self["native"].length;
          };
          self["native"].replaceData(offset, count, string);
          return self;
        }, $CharacterData_replace$5.$$arity = -2);
        return (Opal.def(self, '$substring', $CharacterData_substring$6 = function $$substring(count, offset) {
          var self = this;

          
          
          if (offset == null) {
            offset = 0;
          };
          return self["native"].substringData(offset, count);
        }, $CharacterData_substring$6.$$arity = -2), nil) && 'substring';
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/text"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $gvars = Opal.gvars;

  Opal.add_stubs(['$create_text', '$DOM', '$data']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Text');

        var $nesting = [self].concat($parent_nesting), $Text_create$1, $Text_whole$2, $Text_split$3, $Text_inspect$4;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$create', $Text_create$1 = function $$create(content) {
          var self = this;
          if ($gvars.document == null) $gvars.document = nil;

          return $gvars.document.$create_text(content)
        }, $Text_create$1.$$arity = 1);
        
        Opal.def(self, '$whole', $Text_whole$2 = function $$whole() {
          var self = this;

          return self["native"].wholeText
        }, $Text_whole$2.$$arity = 0);
        
        Opal.def(self, '$split', $Text_split$3 = function $$split(offset) {
          var self = this;

          return self.$DOM(self["native"].splitText(offset))
        }, $Text_split$3.$$arity = 1);
        return (Opal.def(self, '$inspect', $Text_inspect$4 = function $$inspect() {
          var self = this;

          return "" + "#<DOM::Text: " + (self.$data()) + ">"
        }, $Text_inspect$4.$$arity = 0), nil) && 'inspect';
      })($nesting[0], $$($nesting, 'CharacterData'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/cdata"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$value']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CDATA');

        var $nesting = [self].concat($parent_nesting), $CDATA_inspect$1;

        return (Opal.def(self, '$inspect', $CDATA_inspect$1 = function $$inspect() {
          var self = this;

          return "" + "#<DOM::CDATA: " + (self.$value()) + ">"
        }, $CDATA_inspect$1.$$arity = 0), nil) && 'inspect'
      })($nesting[0], $$($nesting, 'Text'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/comment"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$value']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Comment');

        var $nesting = [self].concat($parent_nesting), $Comment_inspect$1;

        return (Opal.def(self, '$inspect', $Comment_inspect$1 = function $$inspect() {
          var self = this;

          return "" + "#<DOM::Comment: " + (self.$value()) + ">"
        }, $Comment_inspect$1.$$arity = 0), nil) && 'inspect'
      })($nesting[0], $$($nesting, 'CharacterData'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/attributes"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$to_n', '$[]', '$supports?', '$==', '$to_s', '$include', '$enum_for', '$each', '$attribute_nodes', '$name', '$value', '$!', '$[]=', '$-']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Attributes');

          var $nesting = [self].concat($parent_nesting), $Attributes_initialize$1, $a, $Attributes_$$$2, $Attributes_$$$eq$3, $Attributes_$$$4, $Attributes_$$$eq$5, $Attributes_each$6, $Attributes_has_key$ques$8, $Attributes_merge$excl$9;

          self.$$prototype.namespace = self.$$prototype["native"] = self.$$prototype.element = nil;
          
          self.$attr_reader("namespace");
          
          Opal.def(self, '$initialize', $Attributes_initialize$1 = function $$initialize(element, options) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            return (self.namespace = options['$[]']("namespace"));
          }, $Attributes_initialize$1.$$arity = 2);
          if ($truthy(($truthy($a = $$($nesting, 'Browser')['$supports?']("Element.className")) ? $a : $$($nesting, 'Browser')['$supports?']("Element.htmlFor")))) {
            
            
            Opal.def(self, '$[]', $Attributes_$$$2 = function(name, options) {
              var $a, self = this, namespace = nil;

              
              
              if (options == null) {
                options = $hash2([], {});
              };
              if ($truthy((($a = name['$==']("class")) ? $$($nesting, 'Browser')['$supports?']("Element.className") : name['$==']("class")))) {
                name = "className"
              } else if ($truthy((($a = name['$==']("for")) ? $$($nesting, 'Browser')['$supports?']("Element.htmlFor") : name['$==']("for")))) {
                name = "htmlFor"};
              if ($truthy((namespace = ($truthy($a = options['$[]']("namespace")) ? $a : self.namespace)))) {
                return self["native"].getAttributeNS(namespace.$to_s(), name.$to_s()) || nil
              } else {
                return self["native"].getAttribute(name.$to_s()) || nil
              };
            }, $Attributes_$$$2.$$arity = -2);
            
            Opal.def(self, '$[]=', $Attributes_$$$eq$3 = function(name, value, options) {
              var $a, self = this, namespace = nil;

              
              
              if (options == null) {
                options = $hash2([], {});
              };
              if ($truthy((($a = name['$==']("class")) ? $$($nesting, 'Browser')['$supports?']("Element.className") : name['$==']("class")))) {
                name = "className"
              } else if ($truthy((($a = name['$==']("for")) ? $$($nesting, 'Browser')['$supports?']("Element.htmlFor") : name['$==']("for")))) {
                name = "htmlFor"};
              if ($truthy((namespace = ($truthy($a = options['$[]']("namespace")) ? $a : self.namespace)))) {
                return self["native"].setAttributeNS(namespace.$to_s(), name.$to_s(), value)
              } else {
                return self["native"].setAttribute(name.$to_s(), value.$to_s())
              };
            }, $Attributes_$$$eq$3.$$arity = -3);
          } else {
            
            
            Opal.def(self, '$[]', $Attributes_$$$4 = function(name, options) {
              var $a, self = this, namespace = nil;

              
              
              if (options == null) {
                options = $hash2([], {});
              };
              if ($truthy((namespace = ($truthy($a = options['$[]']("namespace")) ? $a : self.namespace)))) {
                return self["native"].getAttributeNS(namespace.$to_s(), name.$to_s()) || nil
              } else {
                return self["native"].getAttribute(name.$to_s()) || nil
              };
            }, $Attributes_$$$4.$$arity = -2);
            
            Opal.def(self, '$[]=', $Attributes_$$$eq$5 = function(name, value, options) {
              var $a, self = this, namespace = nil;

              
              
              if (options == null) {
                options = $hash2([], {});
              };
              if ($truthy((namespace = ($truthy($a = options['$[]']("namespace")) ? $a : self.namespace)))) {
                return self["native"].setAttributeNS(namespace.$to_s(), name.$to_s(), value)
              } else {
                return self["native"].setAttribute(name.$to_s(), value.$to_s())
              };
            }, $Attributes_$$$eq$5.$$arity = -3);
          };
          self.$include($$($nesting, 'Enumerable'));
          
          Opal.def(self, '$each', $Attributes_each$6 = function $$each() {
            var $iter = $Attributes_each$6.$$p, block = $iter || nil, $$7, self = this;

            if ($iter) $Attributes_each$6.$$p = null;
            
            
            if ($iter) $Attributes_each$6.$$p = null;;
            if ((block !== nil)) {
            } else {
              return self.$enum_for("each")
            };
            $send(self.element.$attribute_nodes(), 'each', [], ($$7 = function(attr){var self = $$7.$$s || this;

            
              
              if (attr == null) {
                attr = nil;
              };
              return Opal.yieldX(block, [attr.$name(), attr.$value()]);;}, $$7.$$s = self, $$7.$$arity = 1, $$7));
            return self;
          }, $Attributes_each$6.$$arity = 0);
          Opal.alias(self, "get", "[]");
          
          Opal.def(self, '$has_key?', $Attributes_has_key$ques$8 = function(name) {
            var self = this;

            return self['$[]'](name)['$!']()['$!']()
          }, $Attributes_has_key$ques$8.$$arity = 1);
          
          Opal.def(self, '$merge!', $Attributes_merge$excl$9 = function(hash) {
            var $$10, self = this;

            
            $send(hash, 'each', [], ($$10 = function(name, value){var self = $$10.$$s || this, $writer = nil;

            
              
              if (name == null) {
                name = nil;
              };
              
              if (value == null) {
                value = nil;
              };
              $writer = [name, value];
              $send(self, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$10.$$s = self, $$10.$$arity = 2, $$10));
            return self;
          }, $Attributes_merge$excl$9.$$arity = 1);
          return Opal.alias(self, "set", "[]=");
        })($nesting[0], null, $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/data"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$attr_reader', '$to_n', '$include', '$enum_for', '$call', '$each', '$attributes', '$=~', '$[]']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Data');

          var $nesting = [self].concat($parent_nesting), $Data_initialize$1, $Data_each$2, $Data_assign$4, $Data_$$$6, $Data_$$$eq$7;

          self.$$prototype["native"] = self.$$prototype.element = nil;
          
          self.$attr_reader("element");
          
          Opal.def(self, '$initialize', $Data_initialize$1 = function $$initialize(element) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            if ($truthy((typeof(self["native"].$data) !== "undefined"))) {
              return nil
            } else {
              return self["native"].$data = {}
            };
          }, $Data_initialize$1.$$arity = 1);
          self.$include($$($nesting, 'Enumerable'));
          
          Opal.def(self, '$each', $Data_each$2 = function $$each() {
            var $iter = $Data_each$2.$$p, block = $iter || nil, $$3, self = this;

            if ($iter) $Data_each$2.$$p = null;
            
            
            if ($iter) $Data_each$2.$$p = null;;
            if ($truthy(block)) {
            } else {
              return self.$enum_for("each")
            };
            
      var data = self["native"].$data;

      for (var key in data) {
        block.$call(key, data[key]);
      }
    ;
            $send(self.element.$attributes(), 'each', [], ($$3 = function(name, value){var self = $$3.$$s || this, $a;

            
              
              if (name == null) {
                name = nil;
              };
              
              if (value == null) {
                value = nil;
              };
              if ($truthy(name['$=~'](/^data-(.*)$/))) {
                return block.$call((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), value)
              } else {
                return nil
              };}, $$3.$$s = self, $$3.$$arity = 2, $$3));
            return self;
          }, $Data_each$2.$$arity = 0);
          
          Opal.def(self, '$assign', $Data_assign$4 = function $$assign(data) {
            var $$5, self = this;

            
            $send(data, 'each', [], ($$5 = function(name, value){var self = $$5.$$s || this;
              if (self["native"] == null) self["native"] = nil;

            
              
              if (name == null) {
                name = nil;
              };
              
              if (value == null) {
                value = nil;
              };
              return self["native"].$data[name] = value;}, $$5.$$s = self, $$5.$$arity = 2, $$5));
            return self;
          }, $Data_assign$4.$$arity = 1);
          
          Opal.def(self, '$[]', $Data_$$$6 = function(name) {
            var self = this, data = nil;

            
            if ($truthy((data = self.element['$[]']("" + "data-" + (name))))) {
              return data};
            
      var value = self["native"].$data[name];

      if (value === undefined) {
        return nil;
      }
      else {
        return value;
      }
    ;
          }, $Data_$$$6.$$arity = 1);
          return (Opal.def(self, '$[]=', $Data_$$$eq$7 = function(name, value) {
            var self = this;

            return self["native"].$data[name] = value
          }, $Data_$$$eq$7.$$arity = 2), nil) && '[]=';
        })($nesting[0], null, $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/position"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$to_n', '$offset', '$get', '$parent', '$new', '$==', '$[]', '$style', '$=~', '$+', '$x', '$to_i', '$x=', '$-', '$y', '$y=']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Position');

          var $nesting = [self].concat($parent_nesting), $Position_initialize$1, $Position_get$2, $Position_x$3, $Position_y$4;

          self.$$prototype.element = nil;
          
          self.$attr_reader("element");
          
          Opal.def(self, '$initialize', $Position_initialize$1 = function $$initialize(element) {
            var self = this;

            
            self.element = element;
            return (self["native"] = element.$to_n());
          }, $Position_initialize$1.$$arity = 1);
          
          Opal.def(self, '$get', $Position_get$2 = function $$get() {
            var self = this, offset = nil, position = nil, parent = nil, parent_offset = nil, $writer = nil;

            
            offset = self.element.$offset();
            position = offset.$get();
            parent = offset.$parent();
            parent_offset = $$$($$($nesting, 'Browser'), 'Position').$new(0, 0);
            if (self.element.$style()['$[]']("position")['$==']("fixed")) {
              
              if ($truthy(parent['$=~']("html"))) {
              } else {
                parent_offset = parent.$offset()
              };
              
              $writer = [$rb_plus(parent_offset.$x(), parent.$style()['$[]']("border-top-width").$to_i())];
              $send(parent_offset, 'x=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [$rb_plus(parent_offset.$y(), parent.$style()['$[]']("border-left-width").$to_i())];
              $send(parent_offset, 'y=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;};
            return $$$($$($nesting, 'Browser'), 'Position').$new($rb_minus($rb_minus(position.$x(), parent_offset.$x()), self.element.$style()['$[]']("margin-left").$to_i()), $rb_minus($rb_minus(position.$y(), parent_offset.$y()), self.element.$style()['$[]']("margin-top").$to_i()));
          }, $Position_get$2.$$arity = 0);
          
          Opal.def(self, '$x', $Position_x$3 = function $$x() {
            var self = this;

            return self.$get().$x()
          }, $Position_x$3.$$arity = 0);
          return (Opal.def(self, '$y', $Position_y$4 = function $$y() {
            var self = this;

            return self.$get().$y()
          }, $Position_y$4.$$arity = 0), nil) && 'y';
        })($nesting[0], null, $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/offset"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$to_n', '$DOM', '$root', '$document', '$x', '$get', '$set', '$y', '$supports?', '$window', '$new', '$[]', '$style!', '$==', '$[]=', '$style', '$-', '$to_u', '$===', '$first', '$+', '$px']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Offset');

          var $nesting = [self].concat($parent_nesting), $Offset_initialize$1, $Offset_parent$2, $Offset_x$3, $Offset_x$eq$4, $Offset_y$5, $Offset_y$eq$6, $Offset_get$7, $Offset_get$8, $Offset_set$9;

          self.$$prototype["native"] = self.$$prototype.element = nil;
          
          self.$attr_reader("element");
          
          Opal.def(self, '$initialize', $Offset_initialize$1 = function $$initialize(element) {
            var self = this;

            
            self.element = element;
            return (self["native"] = element.$to_n());
          }, $Offset_initialize$1.$$arity = 1);
          
          Opal.def(self, '$parent', $Offset_parent$2 = function $$parent() {
            var self = this;

            return self.$DOM(self["native"].offsetParent || self.element.$document().$root().$to_n())
          }, $Offset_parent$2.$$arity = 0);
          
          Opal.def(self, '$x', $Offset_x$3 = function $$x() {
            var self = this;

            return self.$get().$x()
          }, $Offset_x$3.$$arity = 0);
          
          Opal.def(self, '$x=', $Offset_x$eq$4 = function(value) {
            var self = this;

            return self.$set(value, nil)
          }, $Offset_x$eq$4.$$arity = 1);
          
          Opal.def(self, '$y', $Offset_y$5 = function $$y() {
            var self = this;

            return self.$get().$y()
          }, $Offset_y$5.$$arity = 0);
          
          Opal.def(self, '$y=', $Offset_y$eq$6 = function(value) {
            var self = this;

            return self.$set(nil, value)
          }, $Offset_y$eq$6.$$arity = 1);
          if ($truthy($$($nesting, 'Browser')['$supports?']("Element.getBoundingClientRect"))) {
            
            Opal.def(self, '$get', $Offset_get$7 = function $$get() {
              var self = this, doc = nil, root = nil, win = nil;

              
              doc = self.element.$document();
              root = doc.$root().$to_n();
              win = doc.$window().$to_n();
              
        var box = self["native"].getBoundingClientRect(),
            y   = box.top + (win.pageYOffset || root.scrollTop) - (root.clientTop || 0),
            x   = box.left + (win.pageXOffset || root.scrollLeft) - (root.clientLeft || 0);
      ;
              return $$$($$($nesting, 'Browser'), 'Position').$new(x, y);
            }, $Offset_get$7.$$arity = 0)
          } else {
            
            Opal.def(self, '$get', $Offset_get$8 = function $$get() {
              var self = this, doc = nil, root = nil, win = nil;

              
              doc = self.$document();
              root = doc.$root().$to_n();
              win = doc.$window().$to_n();
              
        var y = (win.pageYOffset || root.scrollTop) - (root.clientTop || 0),
            x = (win.pageXOffset || root.scrollLeft) - (root.clientLeft || 0);
      ;
              return $$$($$($nesting, 'Browser'), 'Position').$new(x, y);
            }, $Offset_get$8.$$arity = 0)
          };
          return (Opal.def(self, '$set', $Offset_set$9 = function $$set($a) {
            var $post_args, value, $b, $c, self = this, position = nil, $writer = nil, offset = nil, top = nil, left = nil, x = nil, y = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            value = $post_args;;
            position = self.element['$style!']()['$[]']("position");
            if (position['$==']("static")) {
              
              $writer = ["position", "relative"];
              $send(self.element.$style(), '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            offset = self.$get();
            top = self.element['$style!']()['$[]']("top").$to_u();
            left = self.element['$style!']()['$[]']("left").$to_u();
            if ($truthy($$$($$($nesting, 'Browser'), 'Position')['$==='](value.$first()))) {
              $b = [value.$first().$x(), value.$first().$y()], (x = $b[0]), (y = $b[1]), $b
            } else if ($truthy($$($nesting, 'Hash')['$==='](value.$first()))) {
              $b = [value.$first()['$[]']("x"), value.$first()['$[]']("y")], (x = $b[0]), (y = $b[1]), $b
            } else {
              $c = value, $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c
            };
            if ($truthy(x)) {
              
              $writer = ["left", $rb_plus($rb_minus(x.$px(), offset.$x()), left)];
              $send(self.element.$style(), '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(y)) {
              
              $writer = ["top", $rb_plus($rb_minus(y.$px(), offset.$y()), top)];
              $send(self.element.$style(), '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
            } else {
              return nil
            };
          }, $Offset_set$9.$$arity = -1), nil) && 'set';
        })($nesting[0], null, $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/scroll"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$to_n', '$include?', '$class', '$first', '$===', '$[]', '$set', '$set_by', '$supports?', '$private', '$+', '$x', '$y', '$new', '$raise', '$position']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Scroll');

          var $nesting = [self].concat($parent_nesting), $Scroll_initialize$1, $Scroll_to$2, $Scroll_by$3, $Scroll_set_by$4, $Scroll_set_by$5, $Scroll_set$6, $Scroll_position$7, $Scroll_set$8, $Scroll_position$9, $Scroll_x$10, $Scroll_y$11, $Scroll_height$12, $Scroll_width$13, $Scroll_into_view$14, $Scroll_into_view$15, $Scroll_into_view$excl$16;

          self.$$prototype["native"] = self.$$prototype.element = self.$$prototype.scrolling_native = nil;
          
          self.$attr_reader("element");
          
          Opal.def(self, '$initialize', $Scroll_initialize$1 = function $$initialize(element) {
            var self = this;

            
            self.element = element;
            self["native"] = element.$to_n();
            self.scrolling_native = self["native"];
            if ($truthy([$$($nesting, 'Document'), $$($nesting, 'Window')]['$include?'](self.element.$class()))) {
              
              if ($truthy((typeof(self.scrolling_native.document) !== "undefined"))) {
                self.scrolling_native = self.scrolling_native.document};
              if ($truthy((typeof(self.scrolling_native.documentElement.scrollTop) !== "undefined"))) {
                return (self.scrolling_native = self.scrolling_native.documentElement)
              } else if ($truthy((typeof(self.scrolling_native.body.scrollTop) !== "undefined"))) {
                return (self.scrolling_native = self.scrolling_native.body)
              } else {
                return nil
              };
            } else {
              return nil
            };
          }, $Scroll_initialize$1.$$arity = 1);
          
          Opal.def(self, '$to', $Scroll_to$2 = function $$to($a) {
            var $post_args, args, $b, $c, self = this, x = nil, y = nil, $case = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            $b = [nil, nil], (x = $b[0]), (y = $b[1]), $b;
            $case = args.$first();
            if ($$($nesting, 'Hash')['$===']($case)) {
            x = args.$first()['$[]']("x");
            y = args.$first()['$[]']("y");}
            else if ("top"['$===']($case)) {y = 0}
            else if ("bottom"['$===']($case)) {y = 99999999}
            else {$c = args, $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c};
            if ($truthy(($truthy($b = x) ? $b : y))) {
              self.$set(x, y)};
            return self;
          }, $Scroll_to$2.$$arity = -1);
          
          Opal.def(self, '$by', $Scroll_by$3 = function $$by($a) {
            var $post_args, args, $b, $c, self = this, $case = nil, x = nil, y = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            $case = args.$first();
            if ($$($nesting, 'Hash')['$===']($case)) {
            x = ($truthy($b = args.$first()['$[]']("x")) ? $b : 0);
            y = ($truthy($b = args.$first()['$[]']("y")) ? $b : 0);}
            else {$c = args, $b = Opal.to_ary($c), (x = ($b[0] == null ? nil : $b[0])), (y = ($b[1] == null ? nil : $b[1])), $c};
            self.$set_by(x, y);
            return self;
          }, $Scroll_by$3.$$arity = -1);
          if ($truthy($$($nesting, 'Browser')['$supports?']("Element.scrollBy"))) {
            self.$private((Opal.def(self, '$set_by', $Scroll_set_by$4 = function $$set_by(x, y) {
              var self = this;

              return self.scrolling_native.scrollBy(x, y)
            }, $Scroll_set_by$4.$$arity = 2), nil) && 'set_by')
          } else {
            self.$private((Opal.def(self, '$set_by', $Scroll_set_by$5 = function $$set_by(x, y) {
              var self = this;

              return self.$set($rb_plus(self.$x(), x), $rb_plus(self.$y(), y))
            }, $Scroll_set_by$5.$$arity = 2), nil) && 'set_by')
          };
          if ($truthy($$($nesting, 'Browser')['$supports?']("Element.scroll"))) {
            
            self.$private((Opal.def(self, '$set', $Scroll_set$6 = function $$set(x, y) {
              var self = this;

              
              
              if (x == null) {
                x = nil;
              };
              
              if (y == null) {
                y = nil;
              };
              if ($truthy(y)) {
                self.scrolling_native.scrollTop  = y};
              if ($truthy(x)) {
                return self.scrolling_native.scrollLeft = x
              } else {
                return nil
              };
            }, $Scroll_set$6.$$arity = -1), nil) && 'set');
            
            Opal.def(self, '$position', $Scroll_position$7 = function $$position() {
              var self = this;

              return $$$($$($nesting, 'Browser'), 'Position').$new(self.scrolling_native.scrollLeft, self.scrolling_native.scrollTop)
            }, $Scroll_position$7.$$arity = 0);
          } else {
            
            self.$private((Opal.def(self, '$set', $Scroll_set$8 = function $$set(x, y) {
              var self = this;

              
              
              if (x == null) {
                x = nil;
              };
              
              if (y == null) {
                y = nil;
              };
              return self.$raise($$($nesting, 'NotImplementedError'), "scroll on element unsupported");
            }, $Scroll_set$8.$$arity = -1), nil) && 'set');
            
            Opal.def(self, '$position', $Scroll_position$9 = function $$position() {
              var self = this;

              return self.$raise($$($nesting, 'NotImplementedError'), "scroll on element unsupported")
            }, $Scroll_position$9.$$arity = 0);
          };
          
          Opal.def(self, '$x', $Scroll_x$10 = function $$x() {
            var self = this;

            return self.$position().$x()
          }, $Scroll_x$10.$$arity = 0);
          
          Opal.def(self, '$y', $Scroll_y$11 = function $$y() {
            var self = this;

            return self.$position().$y()
          }, $Scroll_y$11.$$arity = 0);
          
          Opal.def(self, '$height', $Scroll_height$12 = function $$height() {
            var self = this;

            return self.scrolling_native.scrollHeight
          }, $Scroll_height$12.$$arity = 0);
          
          Opal.def(self, '$width', $Scroll_width$13 = function $$width() {
            var self = this;

            return self.scrolling_native.scrollWidth
          }, $Scroll_width$13.$$arity = 0);
          if ($truthy($$($nesting, 'Browser')['$supports?']("Element.scrollIntoViewIfNeeded"))) {
            
            Opal.def(self, '$into_view', $Scroll_into_view$14 = function $$into_view(align) {
              var self = this;

              
              
              if (align == null) {
                align = true;
              };
              return self.scrolling_native.scrollIntoViewIfNeeded(align);
            }, $Scroll_into_view$14.$$arity = -1)
          } else {
            
            Opal.def(self, '$into_view', $Scroll_into_view$15 = function $$into_view(align) {
              var self = this;

              
              
              if (align == null) {
                align = true;
              };
              return self.$raise($$($nesting, 'NotImplementedError'));
            }, $Scroll_into_view$15.$$arity = -1)
          };
          return (Opal.def(self, '$into_view!', $Scroll_into_view$excl$16 = function(align) {
            var self = this;

            
            
            if (align == null) {
              align = true;
            };
            return self.scrolling_native.scrollIntoView(align);
          }, $Scroll_into_view$excl$16.$$arity = -1), nil) && 'into_view!';
        })($nesting[0], null, $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/size"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$to_n', '$[]=', '$style', '$-']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Size');

          var $nesting = [self].concat($parent_nesting), $Size_initialize$1, $Size_width$2, $Size_width$eq$3, $Size_height$4, $Size_height$eq$5;

          self.$$prototype["native"] = self.$$prototype.element = nil;
          
          self.$attr_reader("element");
          
          Opal.def(self, '$initialize', $Size_initialize$1 = function $$initialize(element, $a) {
            var $post_args, inc, self = this;

            
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            inc = $post_args;;
            self.element = element;
            self["native"] = element.$to_n();
            return (self.include = inc);
          }, $Size_initialize$1.$$arity = -2);
          
          Opal.def(self, '$width', $Size_width$2 = function $$width() {
            var self = this;

            return self["native"].offsetWidth
          }, $Size_width$2.$$arity = 0);
          
          Opal.def(self, '$width=', $Size_width$eq$3 = function(value) {
            var self = this, $writer = nil;

            
            $writer = ["width", value];
            $send(self.element.$style(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }, $Size_width$eq$3.$$arity = 1);
          
          Opal.def(self, '$height', $Size_height$4 = function $$height() {
            var self = this;

            return self["native"].offsetHeight
          }, $Size_height$4.$$arity = 0);
          return (Opal.def(self, '$height=', $Size_height$eq$5 = function(value) {
            var self = this, $writer = nil;

            
            $writer = ["height", value];
            $send(self.element.$style(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }, $Size_height$eq$5.$$arity = 1), nil) && 'height=';
        })($nesting[0], null, $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/button"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Button');

          var $nesting = [self].concat($parent_nesting), $Button_disabled$ques$1, $Button_disabled$eq$2, $Button_autofocus$ques$3, $Button_autofocus$eq$4, $Button_name$5, $Button_name$eq$6;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$disabled?', $Button_disabled$ques$1 = function() {
            var self = this;

            return self["native"].disabled
          }, $Button_disabled$ques$1.$$arity = 0);
          
          Opal.def(self, '$disabled=', $Button_disabled$eq$2 = function(value) {
            var self = this;

            return self["native"].disabled = value
          }, $Button_disabled$eq$2.$$arity = 1);
          
          Opal.def(self, '$autofocus?', $Button_autofocus$ques$3 = function() {
            var self = this;

            return self["native"].autofocus
          }, $Button_autofocus$ques$3.$$arity = 0);
          
          Opal.def(self, '$autofocus=', $Button_autofocus$eq$4 = function(value) {
            var self = this;

            return self["native"].autofocus = value
          }, $Button_autofocus$eq$4.$$arity = 1);
          
          Opal.def(self, '$name', $Button_name$5 = function $$name() {
            var self = this;

            return self["native"].name
          }, $Button_name$5.$$arity = 0);
          return (Opal.def(self, '$name=', $Button_name$eq$6 = function(value) {
            var self = this;

            return self["native"].name = value
          }, $Button_name$eq$6.$$arity = 1), nil) && 'name=';
        })($nesting[0], $$($nesting, 'Element'), $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/image"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Image');

          var $nesting = [self].concat($parent_nesting), $Image_complete$ques$1, $Image_cross$ques$2, $Image_height$3, $Image_width$4;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$complete?', $Image_complete$ques$1 = function() {
            var self = this;

            return self["native"].complete
          }, $Image_complete$ques$1.$$arity = 0);
          
          Opal.def(self, '$cross?', $Image_cross$ques$2 = function() {
            var self = this;

            return self["native"].crossOrigin
          }, $Image_cross$ques$2.$$arity = 0);
          
          Opal.def(self, '$height', $Image_height$3 = function $$height() {
            var self = this;

            return self["native"].naturalHeight
          }, $Image_height$3.$$arity = 0);
          return (Opal.def(self, '$width', $Image_width$4 = function $$width() {
            var self = this;

            return self["native"].naturalWidth
          }, $Image_width$4.$$arity = 0), nil) && 'width';
        })($nesting[0], $$($nesting, 'Element'), $nesting);
        return Opal.const_set($nesting[0], 'Img', $$($nesting, 'Image'));
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/form"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$require', '$create', '$alias_native', '$[]', '$new']);
  
  self.$require("browser/blob");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Form');

          var $nesting = [self].concat($parent_nesting), $Form_form_data$1, $Form_submit$2, $Form_reset$3, $Form_controls$4;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$form_data', $Form_form_data$1 = function $$form_data() {
            var self = this;

            return $$($nesting, 'FormData').$create(self)
          }, $Form_form_data$1.$$arity = 0);
          
          Opal.def(self, '$submit', $Form_submit$2 = function $$submit() {
            var self = this;

            return self["native"].submit()
          }, $Form_submit$2.$$arity = 0);
          
          Opal.def(self, '$reset', $Form_reset$3 = function $$reset() {
            var self = this;

            return self["native"].reset()
          }, $Form_reset$3.$$arity = 0);
          self.$alias_native("action");
          self.$alias_native("action=");
          self.$alias_native("method");
          self.$alias_native("method=");
          self.$alias_native("target");
          self.$alias_native("target=");
          self.$alias_native("name");
          self.$alias_native("name=");
          self.$alias_native("encoding");
          self.$alias_native("encoding=");
          return (Opal.def(self, '$controls', $Form_controls$4 = function $$controls() {
            var self = this;

            return $$($nesting, 'NodeSet')['$[]']($$$($$($nesting, 'Native'), 'Array').$new(self["native"].elements))
          }, $Form_controls$4.$$arity = 0), nil) && 'controls';
        })($nesting[0], $$($nesting, 'Element'), $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/input"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$require', '$map', '$new', '$to_n']);
  
  self.$require("browser/blob");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Input');

          var $nesting = [self].concat($parent_nesting), $Input_value$1, $Input_value$eq$2, $Input_checked$ques$3, $Input_check$excl$4, $Input_uncheck$excl$5, $Input_clear$6, $Input_files$7;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$value', $Input_value$1 = function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          }, $Input_value$1.$$arity = 0);
          
          Opal.def(self, '$value=', $Input_value$eq$2 = function(value) {
            var self = this;

            return self["native"].value = value
          }, $Input_value$eq$2.$$arity = 1);
          
          Opal.def(self, '$checked?', $Input_checked$ques$3 = function() {
            var self = this;

            return self["native"].checked
          }, $Input_checked$ques$3.$$arity = 0);
          
          Opal.def(self, '$check!', $Input_check$excl$4 = function() {
            var self = this;

            return self["native"].checked = 'checked'
          }, $Input_check$excl$4.$$arity = 0);
          
          Opal.def(self, '$uncheck!', $Input_uncheck$excl$5 = function() {
            var self = this;

            return self["native"].checked = ''
          }, $Input_uncheck$excl$5.$$arity = 0);
          
          Opal.def(self, '$clear', $Input_clear$6 = function $$clear() {
            var self = this;

            return self["native"].value = ''
          }, $Input_clear$6.$$arity = 0);
          return (Opal.def(self, '$files', $Input_files$7 = function $$files() {
            var $$8, self = this;

            return $send($$$($$($nesting, 'Native'), 'Array').$new(self["native"].files), 'map', [], ($$8 = function(f){var self = $$8.$$s || this;

            
              
              if (f == null) {
                f = nil;
              };
              return $$($nesting, 'File').$new(f.$to_n());}, $$8.$$s = self, $$8.$$arity = 1, $$8))
          }, $Input_files$7.$$arity = 0), nil) && 'files';
        })($nesting[0], $$($nesting, 'Element'), $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/select"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$[]', '$new', '$DOM', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Select');

          var $nesting = [self].concat($parent_nesting), $Select_value$1, $Select_labels$2, $Select_options$3, $Select_option$4, $Select_index$5;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$value', $Select_value$1 = function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          }, $Select_value$1.$$arity = 0);
          
          Opal.def(self, '$labels', $Select_labels$2 = function $$labels() {
            var self = this;

            return $$($nesting, 'NodeSet')['$[]']($$$($$($nesting, 'Native'), 'Array').$new(self["native"].labels))
          }, $Select_labels$2.$$arity = 0);
          
          Opal.def(self, '$options', $Select_options$3 = function $$options() {
            var self = this;

            return $$($nesting, 'NodeSet')['$[]']($$$($$($nesting, 'Native'), 'Array').$new(self["native"].options))
          }, $Select_options$3.$$arity = 0);
          
          Opal.def(self, '$option', $Select_option$4 = function $$option() {
            var self = this;

            return self.$DOM(self["native"].options[self["native"].selectedIndex])
          }, $Select_option$4.$$arity = 0);
          
          Opal.def(self, '$index', $Select_index$5 = function $$index() {
            var self = this;

            return self["native"].selectedIndex
          }, $Select_index$5.$$arity = 0);
          self.$alias_native("multiple?", "multiple");
          self.$alias_native("required?", "required");
          return self.$alias_native("length");
        })($nesting[0], $$($nesting, 'Element'), $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/template"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  Opal.add_stubs(['$DOM']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Template');

          var $nesting = [self].concat($parent_nesting), $Template_content$1;

          self.$$prototype["native"] = nil;
          return (Opal.def(self, '$content', $Template_content$1 = function $$content() {
            var self = this;

            return self.$DOM(self["native"].content)
          }, $Template_content$1.$$arity = 0), nil) && 'content'
        })($nesting[0], $$($nesting, 'Element'), $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/textarea"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Textarea');

          var $nesting = [self].concat($parent_nesting), $Textarea_value$1, $Textarea_value$eq$2, $Textarea_clear$3;

          self.$$prototype["native"] = nil;
          
          
          Opal.def(self, '$value', $Textarea_value$1 = function $$value() {
            var self = this;

            
      if (self["native"].value == "") {
        return nil;
      }
      else {
        return self["native"].value;
      }
    
          }, $Textarea_value$1.$$arity = 0);
          
          Opal.def(self, '$value=', $Textarea_value$eq$2 = function(value) {
            var self = this;

            return self["native"].value = value
          }, $Textarea_value$eq$2.$$arity = 1);
          return (Opal.def(self, '$clear', $Textarea_clear$3 = function $$clear() {
            var self = this;

            return self["native"].value = ''
          }, $Textarea_clear$3.$$arity = 0), nil) && 'clear';
        })($nesting[0], $$($nesting, 'Element'), $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element/iframe"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$alias_native', '$new', '$DOM', '$send', '$content_window']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Iframe');

          var $nesting = [self].concat($parent_nesting), $Iframe_content_window$1, $Iframe_content_document$2, $Iframe_send$3;

          self.$$prototype["native"] = nil;
          
          self.$alias_native("src");
          self.$alias_native("src=");
          
          Opal.def(self, '$content_window', $Iframe_content_window$1 = function $$content_window() {
            var self = this;

            return $$$($$($nesting, 'Browser'), 'Window').$new(self["native"].contentWindow)
          }, $Iframe_content_window$1.$$arity = 0);
          
          Opal.def(self, '$content_document', $Iframe_content_document$2 = function $$content_document() {
            var self = this;

            return self.$DOM(self["native"].contentDocument || self["native"].contentWindow.document)
          }, $Iframe_content_document$2.$$arity = 0);
          return (Opal.def(self, '$send', $Iframe_send$3 = function $$send(message, options) {
            var self = this;

            
            
            if (options == null) {
              options = $hash2([], {});
            };
            return self.$content_window().$send(message, options);
          }, $Iframe_send$3.$$arity = -2), nil) && 'send';
        })($nesting[0], $$($nesting, 'Element'), $nesting)
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/element"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$create_element', '$==', '$capitalize', '$include?', '$constants', '$new', '$const_get', '$include', '$target', '$DOM', '$supports?', '$loaded?', '$raise', '$[]', '$map', '$xpath', '$get', '$attributes', '$set', '$+', '$class_names', '$empty?', '$join', '$uniq', '$first', '$css', '$each', '$alias_native', '$reject', '$split', '$to_proc', '$===', '$assign', '$height', '$size', '$height=', '$-', '$to_s', '$clear', '$document', '$<<', '$to_a', '$downcase', '$name', '$id', '$offset', '$flatten', '$concat', '$replace', '$apply', '$to_n', '$window', '$width', '$width=']);
  
  self.$require("browser/dom/element/attributes");
  self.$require("browser/dom/element/data");
  self.$require("browser/dom/element/position");
  self.$require("browser/dom/element/offset");
  self.$require("browser/dom/element/scroll");
  self.$require("browser/dom/element/size");
  self.$require("browser/dom/element/button");
  self.$require("browser/dom/element/image");
  self.$require("browser/dom/element/form");
  self.$require("browser/dom/element/input");
  self.$require("browser/dom/element/select");
  self.$require("browser/dom/element/template");
  self.$require("browser/dom/element/textarea");
  self.$require("browser/dom/element/iframe");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Element');

        var $nesting = [self].concat($parent_nesting), $Element_create$1, $Element_new$2, $Element$3, $Element_$eq_tilde$4, $Element_$eq_tilde$5, $Element_$eq_tilde$6, $Element_$eq_tilde$7, $Element_$eq_tilde$8, $Element_$eq_tilde$9, $Element_$eq_tilde$10, $Element_$slash$11, $Element_$$$13, $Element_$$$eq$14, $Element_add_class$15, $Element_at$16, $Element_at_css$17, $Element_at_xpath$19, $Element_attributes$21, $Element_attribute_nodes$22, $Element_class_names$23, $Element_css$24, $Element_css$25, $Element_css$26, $Element_click$27, $Element_data$28, $Element_height$29, $Element_height$eq$30, $Element_id$31, $Element_id$eq$32, $Element_inner_dom$33, $Element_inner_dom$eq$34, $Element_inspect$35, $Element_offset$36, $Element_offset$eq$37, $Element_position$38, $Element_scroll$39, $Element_search$40, $Element_style$42, $Element_style$excl$43, $Element_style$excl$44, $Element_style$excl$45, $Element_remove_attribute$46, $Element_remove_class$47, $Element_size$48, $Element_width$49, $Element_width$eq$50, $Element_window$51, $a, $Element_xpath$52, $Element_xpath$53;

        self.$$prototype["native"] = self.$$prototype.position = self.$$prototype.scroll = nil;
        
        Opal.defs(self, '$create', $Element_create$1 = function $$create($a) {
          var $post_args, args, self = this;
          if ($gvars.document == null) $gvars.document = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send($gvars.document, 'create_element', Opal.to_a(args));
        }, $Element_create$1.$$arity = -1);
        Opal.defs(self, '$new', $Element_new$2 = function(node) {
          var $iter = $Element_new$2.$$p, $yield = $iter || nil, self = this, name = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $Element_new$2.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          if (self['$==']($$($nesting, 'Element'))) {
            
            name = (node.nodeName).$capitalize();
            if ($truthy($$($nesting, 'Element').$constants()['$include?'](name))) {
              return $$($nesting, 'Element').$const_get(name).$new(node)
            } else {
              return $send(self, Opal.find_super_dispatcher(self, 'new', $Element_new$2, false, self.$$class.$$prototype), $zuper, $iter)
            };
          } else {
            return $send(self, Opal.find_super_dispatcher(self, 'new', $Element_new$2, false, self.$$class.$$prototype), $zuper, $iter)
          }
        }, $Element_new$2.$$arity = 1);
        self.$include($$$($$($nesting, 'Event'), 'Target'));
        $send(self, 'target', [], ($Element$3 = function(value){var self = $Element$3.$$s || this;

        
          
          if (value == null) {
            value = nil;
          };
          try {
            return self.$DOM(value)
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'StandardError'), $$$($$($nesting, 'JS'), 'Error')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, $Element$3.$$s = self, $Element$3.$$arity = 1, $Element$3));
        if ($truthy($$($nesting, 'Browser')['$supports?']("Element.matches"))) {
          
          Opal.def(self, '$=~', $Element_$eq_tilde$4 = function(selector) {
            var self = this;

            return self["native"].matches(selector)
          }, $Element_$eq_tilde$4.$$arity = 1)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Element.matches (Opera)"))) {
          
          Opal.def(self, '$=~', $Element_$eq_tilde$5 = function(selector) {
            var self = this;

            return self["native"].oMatchesSelector(selector)
          }, $Element_$eq_tilde$5.$$arity = 1)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Element.matches (Internet Explorer)"))) {
          
          Opal.def(self, '$=~', $Element_$eq_tilde$6 = function(selector) {
            var self = this;

            return self["native"].msMatchesSelector(selector)
          }, $Element_$eq_tilde$6.$$arity = 1)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Element.matches (Firefox)"))) {
          
          Opal.def(self, '$=~', $Element_$eq_tilde$7 = function(selector) {
            var self = this;

            return self["native"].mozMatchesSelector(selector)
          }, $Element_$eq_tilde$7.$$arity = 1)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Element.matches (Chrome)"))) {
          
          Opal.def(self, '$=~', $Element_$eq_tilde$8 = function(selector) {
            var self = this;

            return self["native"].webkitMatchesSelector(selector)
          }, $Element_$eq_tilde$8.$$arity = 1)
        } else if ($truthy($$($nesting, 'Browser')['$loaded?']("Sizzle"))) {
          
          Opal.def(self, '$=~', $Element_$eq_tilde$9 = function(selector) {
            var self = this;

            return Sizzle.matchesSelector(self["native"], selector)
          }, $Element_$eq_tilde$9.$$arity = 1)
        } else {
          
          Opal.def(self, '$=~', $Element_$eq_tilde$10 = function(selector) {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "selector matching unsupported")
          }, $Element_$eq_tilde$10.$$arity = 1)
        };
        
        Opal.def(self, '$/', $Element_$slash$11 = function($a) {
          var $post_args, paths, $$12, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          paths = $post_args;;
          return $$($nesting, 'NodeSet')['$[]']($send(paths, 'map', [], ($$12 = function(path){var self = $$12.$$s || this;

          
            
            if (path == null) {
              path = nil;
            };
            return self.$xpath(path);}, $$12.$$s = self, $$12.$$arity = 1, $$12)));
        }, $Element_$slash$11.$$arity = -1);
        
        Opal.def(self, '$[]', $Element_$$$13 = function(name, options) {
          var self = this;

          
          
          if (options == null) {
            options = $hash2([], {});
          };
          return self.$attributes().$get(name, options);
        }, $Element_$$$13.$$arity = -2);
        
        Opal.def(self, '$[]=', $Element_$$$eq$14 = function(name, value, options) {
          var self = this;

          
          
          if (options == null) {
            options = $hash2([], {});
          };
          return self.$attributes().$set(name, value, options);
        }, $Element_$$$eq$14.$$arity = -3);
        
        Opal.def(self, '$add_class', $Element_add_class$15 = function $$add_class($a) {
          var $post_args, names, self = this, classes = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          names = $post_args;;
          classes = $rb_plus(self.$class_names(), names);
          if ($truthy(classes['$empty?']())) {
          } else {
            self["native"].className = classes.$uniq().$join(" ")
          };
          return self;
        }, $Element_add_class$15.$$arity = -1);
        
        Opal.def(self, '$at', $Element_at$16 = function $$at(path_or_selector) {
          var $a, self = this;

          return ($truthy($a = self.$xpath(path_or_selector).$first()) ? $a : self.$css(path_or_selector).$first())
        }, $Element_at$16.$$arity = 1);
        
        Opal.def(self, '$at_css', $Element_at_css$17 = function $$at_css($a) {
          var $post_args, rules, $$18, self = this, result = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          rules = $post_args;;
          result = nil;
          (function(){var $brk = Opal.new_brk(); try {return $send(rules, 'each', [], ($$18 = function(rule){var self = $$18.$$s || this;

          
            
            if (rule == null) {
              rule = nil;
            };
            if ($truthy((result = self.$css(rule).$first()))) {
              
              Opal.brk(nil, $brk)
            } else {
              return nil
            };}, $$18.$$s = self, $$18.$$brk = $brk, $$18.$$arity = 1, $$18))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          return result;
        }, $Element_at_css$17.$$arity = -1);
        
        Opal.def(self, '$at_xpath', $Element_at_xpath$19 = function $$at_xpath($a) {
          var $post_args, paths, $$20, self = this, result = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          paths = $post_args;;
          result = nil;
          (function(){var $brk = Opal.new_brk(); try {return $send(paths, 'each', [], ($$20 = function(path){var self = $$20.$$s || this;

          
            
            if (path == null) {
              path = nil;
            };
            if ($truthy((result = self.$xpath(path).$first()))) {
              
              Opal.brk(nil, $brk)
            } else {
              return nil
            };}, $$20.$$s = self, $$20.$$brk = $brk, $$20.$$arity = 1, $$20))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          return result;
        }, $Element_at_xpath$19.$$arity = -1);
        Opal.alias(self, "attr", "[]");
        Opal.alias(self, "attribute", "[]");
        
        Opal.def(self, '$attributes', $Element_attributes$21 = function $$attributes(options) {
          var self = this;

          
          
          if (options == null) {
            options = $hash2([], {});
          };
          return $$($nesting, 'Attributes').$new(self, options);
        }, $Element_attributes$21.$$arity = -1);
        
        Opal.def(self, '$attribute_nodes', $Element_attribute_nodes$22 = function $$attribute_nodes() {
          var self = this;

          return $$($nesting, 'NodeSet')['$[]']($$$($$($nesting, 'Native'), 'Array').$new(self["native"].attributes, $hash2(["get"], {"get": "item"})))
        }, $Element_attribute_nodes$22.$$arity = 0);
        self.$alias_native("class_name", "className");
        
        Opal.def(self, '$class_names', $Element_class_names$23 = function $$class_names() {
          var self = this;

          return $send((self["native"].className).$split(/\s+/), 'reject', [], "empty?".$to_proc())
        }, $Element_class_names$23.$$arity = 0);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Query.css"))) {
          
          Opal.def(self, '$css', $Element_css$24 = function $$css(path) {
            var self = this;

            try {
              return $$($nesting, 'NodeSet')['$[]']($$$($$($nesting, 'Native'), 'Array').$new(self["native"].querySelectorAll(path)))
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError'), $$$($$($nesting, 'JS'), 'Error')])) {
                try {
                  return $$($nesting, 'NodeSet')['$[]']()
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            }
          }, $Element_css$24.$$arity = 1)
        } else if ($truthy($$($nesting, 'Browser')['$loaded?']("Sizzle"))) {
          
          Opal.def(self, '$css', $Element_css$25 = function $$css(path) {
            var self = this;

            try {
              return $$($nesting, 'NodeSet')['$[]'](Sizzle(path, self["native"]))
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError'), $$$($$($nesting, 'JS'), 'Error')])) {
                try {
                  return $$($nesting, 'NodeSet')['$[]']()
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            }
          }, $Element_css$25.$$arity = 1)
        } else {
          
          Opal.def(self, '$css', $Element_css$26 = function $$css(selector) {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "query by CSS selector unsupported")
          }, $Element_css$26.$$arity = 1)
        };
        
        Opal.def(self, '$click', $Element_click$27 = function $$click() {
          var self = this;

          
          self["native"].click();
          return self;
        }, $Element_click$27.$$arity = 0);
        
        Opal.def(self, '$data', $Element_data$28 = function $$data(value) {
          var self = this, data = nil;

          
          
          if (value == null) {
            value = nil;
          };
          data = $$($nesting, 'Data').$new(self);
          if ($truthy(value)) {
          } else {
            return data
          };
          if ($truthy($$($nesting, 'Hash')['$==='](value))) {
            data.$assign(value)
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "unknown data type")
          };
          return self;
        }, $Element_data$28.$$arity = -1);
        Opal.alias(self, "get_attribute", "[]");
        Opal.alias(self, "get", "[]");
        
        Opal.def(self, '$height', $Element_height$29 = function $$height() {
          var self = this;

          return self.$size().$height()
        }, $Element_height$29.$$arity = 0);
        
        Opal.def(self, '$height=', $Element_height$eq$30 = function(value) {
          var self = this, $writer = nil;

          
          $writer = [value];
          $send(self.$size(), 'height=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, $Element_height$eq$30.$$arity = 1);
        
        Opal.def(self, '$id', $Element_id$31 = function $$id() {
          var self = this;

          
      var id = self["native"].id;

      if (id === "") {
        return nil;
      }
      else {
        return id;
      }
    
        }, $Element_id$31.$$arity = 0);
        
        Opal.def(self, '$id=', $Element_id$eq$32 = function(value) {
          var self = this;

          return self["native"].id = value.$to_s()
        }, $Element_id$eq$32.$$arity = 1);
        
        Opal.def(self, '$inner_dom', $Element_inner_dom$33 = function $$inner_dom() {
          var $iter = $Element_inner_dom$33.$$p, block = $iter || nil, self = this, doc = nil;

          if ($iter) $Element_inner_dom$33.$$p = null;
          
          
          if ($iter) $Element_inner_dom$33.$$p = null;;
          self.$clear();
          doc = self.$document();
          return self['$<<']($send($$($nesting, 'Builder'), 'new', [doc, self], block.$to_proc()).$to_a());
        }, $Element_inner_dom$33.$$arity = 0);
        
        Opal.def(self, '$inner_dom=', $Element_inner_dom$eq$34 = function(node) {
          var self = this;

          
          self.$clear();
          return self['$<<'](node);
        }, $Element_inner_dom$eq$34.$$arity = 1);
        
        Opal.def(self, '$inspect', $Element_inspect$35 = function $$inspect() {
          var self = this, inspect = nil;

          
          inspect = self.$name().$downcase();
          if ($truthy(self.$id())) {
            inspect = $rb_plus(inspect, $rb_plus($rb_plus(".", self.$id()), "!"))};
          if ($truthy(self.$class_names()['$empty?']())) {
          } else {
            inspect = $rb_plus(inspect, $rb_plus(".", self.$class_names().$join(".")))
          };
          return "" + "#<DOM::Element: " + (inspect) + ">";
        }, $Element_inspect$35.$$arity = 0);
        
        Opal.def(self, '$offset', $Element_offset$36 = function $$offset($a) {
          var $post_args, values, self = this, off = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          values = $post_args;;
          off = $$($nesting, 'Offset').$new(self);
          if ($truthy(values['$empty?']())) {
          } else {
            $send(off, 'set', Opal.to_a(values))
          };
          return off;
        }, $Element_offset$36.$$arity = -1);
        
        Opal.def(self, '$offset=', $Element_offset$eq$37 = function(value) {
          var self = this;

          return $send(self.$offset(), 'set', Opal.to_a(value))
        }, $Element_offset$eq$37.$$arity = 1);
        
        Opal.def(self, '$position', $Element_position$38 = function $$position() {
          var $a, self = this;

          return (self.position = ($truthy($a = self.position) ? $a : $$($nesting, 'Position').$new(self)))
        }, $Element_position$38.$$arity = 0);
        
        Opal.def(self, '$scroll', $Element_scroll$39 = function $$scroll() {
          var $a, self = this;

          return (self.scroll = ($truthy($a = self.scroll) ? $a : $$($nesting, 'Scroll').$new(self)))
        }, $Element_scroll$39.$$arity = 0);
        
        Opal.def(self, '$search', $Element_search$40 = function $$search($a) {
          var $post_args, selectors, $$41, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          selectors = $post_args;;
          return $$($nesting, 'NodeSet').$new($send(selectors, 'map', [], ($$41 = function(selector){var self = $$41.$$s || this;

          
            
            if (selector == null) {
              selector = nil;
            };
            return self.$xpath(selector).$to_a().$concat(self.$css(selector).$to_a());}, $$41.$$s = self, $$41.$$arity = 1, $$41)).$flatten().$uniq());
        }, $Element_search$40.$$arity = -1);
        Opal.alias(self, "set", "[]=");
        Opal.alias(self, "set_attribute", "[]=");
        
        Opal.def(self, '$style', $Element_style$42 = function $$style(data) {
          var $iter = $Element_style$42.$$p, block = $iter || nil, $a, self = this, style = nil;

          if ($iter) $Element_style$42.$$p = null;
          
          
          if ($iter) $Element_style$42.$$p = null;;
          
          if (data == null) {
            data = nil;
          };
          style = $$$($$($nesting, 'CSS'), 'Declaration').$new(self["native"].style);
          if ($truthy(($truthy($a = data) ? $a : block))) {
          } else {
            return style
          };
          if ($truthy($$($nesting, 'String')['$==='](data))) {
            style.$replace(data)
          } else if ($truthy($$($nesting, 'Hash')['$==='](data))) {
            style.$assign(data)
          } else if ($truthy(block)) {
            $send(style, 'apply', [], block.$to_proc())
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "unknown data type")
          };
          return self;
        }, $Element_style$42.$$arity = -1);
        if ($truthy($$($nesting, 'Browser')['$supports?']("CSS.computed"))) {
          
          Opal.def(self, '$style!', $Element_style$excl$43 = function() {
            var self = this;

            return $$$($$($nesting, 'CSS'), 'Declaration').$new(self.$window().$to_n().getComputedStyle(self["native"], null))
          }, $Element_style$excl$43.$$arity = 0)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("CSS.current"))) {
          
          Opal.def(self, '$style!', $Element_style$excl$44 = function() {
            var self = this;

            return $$$($$($nesting, 'CSS'), 'Declaration').$new(self["native"].currentStyle)
          }, $Element_style$excl$44.$$arity = 0)
        } else {
          
          Opal.def(self, '$style!', $Element_style$excl$45 = function() {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "computed style unsupported")
          }, $Element_style$excl$45.$$arity = 0)
        };
        
        Opal.def(self, '$remove_attribute', $Element_remove_attribute$46 = function $$remove_attribute(name) {
          var self = this;

          return self["native"].removeAttribute(name)
        }, $Element_remove_attribute$46.$$arity = 1);
        
        Opal.def(self, '$remove_class', $Element_remove_class$47 = function $$remove_class($a) {
          var $post_args, names, self = this, classes = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          names = $post_args;;
          classes = $rb_minus(self.$class_names(), names);
          if ($truthy(classes['$empty?']())) {
            self["native"].removeAttribute('class')
          } else {
            self["native"].className = classes.$join(" ")
          };
          return self;
        }, $Element_remove_class$47.$$arity = -1);
        
        Opal.def(self, '$size', $Element_size$48 = function $$size($a) {
          var $post_args, inc, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          inc = $post_args;;
          return $send($$($nesting, 'Size'), 'new', [self].concat(Opal.to_a(inc)));
        }, $Element_size$48.$$arity = -1);
        
        Opal.def(self, '$width', $Element_width$49 = function $$width() {
          var self = this;

          return self.$size().$width()
        }, $Element_width$49.$$arity = 0);
        
        Opal.def(self, '$width=', $Element_width$eq$50 = function(value) {
          var self = this, $writer = nil;

          
          $writer = [value];
          $send(self.$size(), 'width=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, $Element_width$eq$50.$$arity = 1);
        
        Opal.def(self, '$window', $Element_window$51 = function $$window() {
          var self = this;

          return self.$document().$window()
        }, $Element_window$51.$$arity = 0);
        if ($truthy(($truthy($a = $$($nesting, 'Browser')['$supports?']("Query.xpath")) ? $a : $$($nesting, 'Browser')['$loaded?']("wicked-good-xpath")))) {
          
          if ($truthy($$($nesting, 'Browser')['$loaded?']("wicked-good-xpath"))) {
            wgxpath.install()};
          return (Opal.def(self, '$xpath', $Element_xpath$52 = function $$xpath(path) {
            var self = this;

            try {
              return $$($nesting, 'NodeSet')['$[]']($$$($$($nesting, 'Native'), 'Array').$new((self["native"].ownerDocument || self["native"]).evaluate(path,
           self["native"], null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null), $hash2(["get", "length"], {"get": "snapshotItem", "length": "snapshotLength"})))
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError'), $$$($$($nesting, 'JS'), 'Error')])) {
                try {
                  return $$($nesting, 'NodeSet')['$[]']()
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            }
          }, $Element_xpath$52.$$arity = 1), nil) && 'xpath';
        } else {
          return (Opal.def(self, '$xpath', $Element_xpath$53 = function $$xpath(path) {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "query by XPath unsupported")
          }, $Element_xpath$53.$$arity = 1), nil) && 'xpath'
        };
      })($nesting[0], $$($nesting, 'Node'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/document"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$DOM', '$first', '$css', '$xpath', '$[]', '$supports?', '$raise', '$ready?', '$call', '$on', '$off', '$convert', '$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Document');

        var $nesting = [self].concat($parent_nesting), $Document_$$$1, $Document_body$2, $Document_create_element$3, $Document_create_text$4, $Document_document$5, $Document_head$6, $Document_inspect$7, $Document_ready$8, $Document_ready$10, $Document_ready$12, $Document_ready$ques$13, $Document_root$14, $Document_root$eq$15, $Document_style_sheets$16, $Document_title$18, $Document_title$eq$19, $Document_window$20, $Document_window$21, $Document_window$22;

        self.$$prototype["native"] = nil;
        
        
        Opal.def(self, '$[]', $Document_$$$1 = function(what) {
          var $a, self = this;

          
          
      var result = self["native"].getElementById(what);

      if (result) {
        return self.$DOM(result);
      }
    ;
          return ($truthy($a = self.$css(what).$first()) ? $a : self.$xpath(what).$first());
        }, $Document_$$$1.$$arity = 1);
        Opal.alias(self, "at", "[]");
        
        Opal.def(self, '$body', $Document_body$2 = function $$body() {
          var self = this;

          return self.$DOM(self["native"].body)
        }, $Document_body$2.$$arity = 0);
        
        Opal.def(self, '$create_element', $Document_create_element$3 = function $$create_element(name, options) {
          var self = this, ns = nil;

          
          
          if (options == null) {
            options = $hash2([], {});
          };
          if ($truthy((ns = options['$[]']("namespace")))) {
            return self.$DOM(self["native"].createElementNS(ns, name))
          } else {
            return self.$DOM(self["native"].createElement(name))
          };
        }, $Document_create_element$3.$$arity = -2);
        
        Opal.def(self, '$create_text', $Document_create_text$4 = function $$create_text(content) {
          var self = this;

          return self.$DOM(self["native"].createTextNode(content))
        }, $Document_create_text$4.$$arity = 1);
        
        Opal.def(self, '$document', $Document_document$5 = function $$document() {
          var self = this;

          return self
        }, $Document_document$5.$$arity = 0);
        
        Opal.def(self, '$head', $Document_head$6 = function $$head() {
          var self = this;

          return self.$DOM(self["native"].getElementsByTagName("head")[0])
        }, $Document_head$6.$$arity = 0);
        
        Opal.def(self, '$inspect', $Document_inspect$7 = function $$inspect() {
          var self = this;

          return "#<DOM::Document>"
        }, $Document_inspect$7.$$arity = 0);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Event.addListener"))) {
          
          Opal.def(self, '$ready', $Document_ready$8 = function $$ready() {
            var $iter = $Document_ready$8.$$p, block = $iter || nil, $$9, self = this;

            if ($iter) $Document_ready$8.$$p = null;
            
            
            if ($iter) $Document_ready$8.$$p = null;;
            if ($truthy(block)) {
            } else {
              self.$raise($$($nesting, 'ArgumentError'), "no block given")
            };
            if ($truthy(self['$ready?']())) {
              return block.$call()};
            return $send(self, 'on', ["dom:load"], ($$9 = function(e){var self = $$9.$$s || this;

            
              
              if (e == null) {
                e = nil;
              };
              e.$off();
              return block.$call();}, $$9.$$s = self, $$9.$$arity = 1, $$9));
          }, $Document_ready$8.$$arity = 0)
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Event.attach"))) {
          
          Opal.def(self, '$ready', $Document_ready$10 = function $$ready() {
            var $iter = $Document_ready$10.$$p, block = $iter || nil, $$11, self = this;

            if ($iter) $Document_ready$10.$$p = null;
            
            
            if ($iter) $Document_ready$10.$$p = null;;
            if ($truthy(block)) {
            } else {
              self.$raise($$($nesting, 'ArgumentError'), "no block given")
            };
            if ($truthy(self['$ready?']())) {
              return block.$call()};
            return $send(self, 'on', ["ready:state:change"], ($$11 = function(e){var self = $$11.$$s || this;

            
              
              if (e == null) {
                e = nil;
              };
              if ($truthy(self['$ready?']())) {
                
                e.$off();
                return block.$call();
              } else {
                return nil
              };}, $$11.$$s = self, $$11.$$arity = 1, $$11));
          }, $Document_ready$10.$$arity = 0)
        } else {
          
          Opal.def(self, '$ready', $Document_ready$12 = function $$ready() {
            var $iter = $Document_ready$12.$$p, block = $iter || nil, self = this;

            if ($iter) $Document_ready$12.$$p = null;
            
            
            if ($iter) $Document_ready$12.$$p = null;;
            return self.$raise($$($nesting, 'NotImplementedError'), "document ready unsupported");
          }, $Document_ready$12.$$arity = 0)
        };
        
        Opal.def(self, '$ready?', $Document_ready$ques$13 = function() {
          var self = this;

          return self["native"].readyState === "complete" || self["native"].readyState === "interactive"
        }, $Document_ready$ques$13.$$arity = 0);
        
        Opal.def(self, '$root', $Document_root$14 = function $$root() {
          var self = this;

          return self.$DOM(self["native"].documentElement)
        }, $Document_root$14.$$arity = 0);
        
        Opal.def(self, '$root=', $Document_root$eq$15 = function(element) {
          var self = this;

          return self["native"].documentElement = $$($nesting, 'Native').$convert(element)
        }, $Document_root$eq$15.$$arity = 1);
        
        Opal.def(self, '$style_sheets', $Document_style_sheets$16 = function $$style_sheets() {
          var $$17, self = this;

          return $send($$$($$($nesting, 'Native'), 'Array'), 'new', [self["native"].styleSheets], ($$17 = function(e){var self = $$17.$$s || this;

          
            
            if (e == null) {
              e = nil;
            };
            return $$$($$($nesting, 'CSS'), 'StyleSheet').$new(e);}, $$17.$$s = self, $$17.$$arity = 1, $$17))
        }, $Document_style_sheets$16.$$arity = 0);
        
        Opal.def(self, '$title', $Document_title$18 = function $$title() {
          var self = this;

          return self["native"].title
        }, $Document_title$18.$$arity = 0);
        
        Opal.def(self, '$title=', $Document_title$eq$19 = function(value) {
          var self = this;

          return self["native"].title = value
        }, $Document_title$eq$19.$$arity = 1);
        if ($truthy($$($nesting, 'Browser')['$supports?']("Document.view"))) {
          return (Opal.def(self, '$window', $Document_window$20 = function $$window() {
            var self = this;

            return $$($nesting, 'Window').$new(self["native"].defaultView)
          }, $Document_window$20.$$arity = 0), nil) && 'window'
        } else if ($truthy($$($nesting, 'Browser')['$supports?']("Document.window"))) {
          return (Opal.def(self, '$window', $Document_window$21 = function $$window() {
            var self = this;

            return $$($nesting, 'Window').$new(self["native"].parentWindow)
          }, $Document_window$21.$$arity = 0), nil) && 'window'
        } else {
          return (Opal.def(self, '$window', $Document_window$22 = function $$window() {
            var self = this;

            return self.$raise($$($nesting, 'NotImplementedError'), "window from document unsupported")
          }, $Document_window$22.$$arity = 0), nil) && 'window'
        };
      })($nesting[0], $$($nesting, 'Element'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/document_fragment"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DocumentFragment');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Element'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/builder"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$<<', '$[]=', '$to_h', '$-', '$[]', '$each', '$===', '$call', '$raise', '$attr_reader', '$new', '$to_proc', '$map', '$build', '$for', '$create_text', '$document', '$create_element', '$merge!', '$attributes', '$add_class', '$on', '$inner_html=']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Utils');

    var $nesting = [self].concat($parent_nesting), $Utils_heredoc$1;

    Opal.defs(self, '$heredoc', $Utils_heredoc$1 = function $$heredoc(string) {
      var self = this;

      return string
    }, $Utils_heredoc$1.$$arity = 1)
  })($$($nesting, 'Paggio'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Element');

    var $nesting = [self].concat($parent_nesting), $Element_on$2;

    self.$$prototype.on = nil;
    return (Opal.def(self, '$on', $Element_on$2 = function $$on($a) {
      var $iter = $Element_on$2.$$p, block = $iter || nil, $post_args, args, $b, self = this;

      if ($iter) $Element_on$2.$$p = null;
      
      
      if ($iter) $Element_on$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return (self.on = ($truthy($b = self.on) ? $b : []))['$<<']([args, block]);
    }, $Element_on$2.$$arity = -1), nil) && 'on'
  })($$$($$($nesting, 'Paggio'), 'HTML'), $$($nesting, 'BasicObject'), $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting), $DOM$10, $DOM$11, $DOM$15;

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Builder');

        var $nesting = [self].concat($parent_nesting), $Builder_to_h$3, $Builder_for$4, $Builder_build$5, $Builder_initialize$7, $Builder_to_a$9;

        self.$$prototype.builder = self.$$prototype.roots = nil;
        
        Opal.defs(self, '$to_h', $Builder_to_h$3 = function $$to_h() {
          var $a, self = this;
          if (self.builders == null) self.builders = nil;

          return (self.builders = ($truthy($a = self.builders) ? $a : $hash2([], {})))
        }, $Builder_to_h$3.$$arity = 0);
        Opal.defs(self, '$for', $Builder_for$4 = function(klass) {
          var $iter = $Builder_for$4.$$p, block = $iter || nil, self = this, $writer = nil;

          if ($iter) $Builder_for$4.$$p = null;
          
          
          if ($iter) $Builder_for$4.$$p = null;;
          if ($truthy(block)) {
            
            $writer = [klass, block];
            $send(self.$to_h(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          } else {
            return self.$to_h()['$[]'](klass)
          };
        }, $Builder_for$4.$$arity = 1);
        Opal.defs(self, '$build', $Builder_build$5 = function $$build(builder, item) {try {

          var $$6, self = this;

          
          $send(self.$to_h(), 'each', [], ($$6 = function(klass, block){var self = $$6.$$s || this;

          
            
            if (klass == null) {
              klass = nil;
            };
            
            if (block == null) {
              block = nil;
            };
            if ($truthy(klass['$==='](item))) {
              Opal.ret(block.$call(builder, item))
            } else {
              return nil
            };}, $$6.$$s = self, $$6.$$arity = 2, $$6));
          return self.$raise($$($nesting, 'ArgumentError'), "" + "cannot build unknown item " + (item));
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, $Builder_build$5.$$arity = 2);
        self.$attr_reader("document", "element");
        
        Opal.def(self, '$initialize', $Builder_initialize$7 = function $$initialize(document) {
          var $iter = $Builder_initialize$7.$$p, block = $iter || nil, $$8, self = this;

          if ($iter) $Builder_initialize$7.$$p = null;
          
          
          if ($iter) $Builder_initialize$7.$$p = null;;
          self.document = document;
          self.builder = $send($$$($$($nesting, 'Paggio'), 'HTML'), 'new', [], block.$to_proc());
          return (self.roots = $send(self.builder.$each(), 'map', [], ($$8 = function(e){var self = $$8.$$s || this;

          
            
            if (e == null) {
              e = nil;
            };
            return $$($nesting, 'Builder').$build(self, e);}, $$8.$$s = self, $$8.$$arity = 1, $$8)));
        }, $Builder_initialize$7.$$arity = 1);
        return (Opal.def(self, '$to_a', $Builder_to_a$9 = function $$to_a() {
          var self = this;

          return self.roots
        }, $Builder_to_a$9.$$arity = 0), nil) && 'to_a';
      })($nesting[0], null, $nesting);
      $send($$($nesting, 'Builder'), 'for', [$$($nesting, 'String')], ($DOM$10 = function(b, item){var self = $DOM$10.$$s || this;

      
        
        if (b == null) {
          b = nil;
        };
        
        if (item == null) {
          item = nil;
        };
        return b.$document().$create_text(item);}, $DOM$10.$$s = self, $DOM$10.$$arity = 2, $DOM$10));
      $send($$($nesting, 'Builder'), 'for', [$$$($$$($$($nesting, 'Paggio'), 'HTML'), 'Element')], ($DOM$11 = function(b, item){var self = $DOM$11.$$s || this, $$12, $$13, $$14, dom = nil, on = nil, inner = nil, $writer = nil;

      
        
        if (b == null) {
          b = nil;
        };
        
        if (item == null) {
          item = nil;
        };
        dom = b.$document().$create_element(item.name);
        if ($truthy($$($nesting, 'Hash')['$==='](item.attributes))) {
          dom.$attributes()['$merge!'](item.attributes)};
        $send((item.class_names), 'each', [], ($$12 = function(value){var self = $$12.$$s || this;

        
          
          if (value == null) {
            value = nil;
          };
          return dom.$add_class(value);}, $$12.$$s = self, $$12.$$arity = 1, $$12));
        if ($truthy((on = item.on || nil))) {
          $send(on, 'each', [], ($$13 = function(args, block){var self = $$13.$$s || this;

          
            
            if (args == null) {
              args = nil;
            };
            
            if (block == null) {
              block = nil;
            };
            return $send(dom, 'on', Opal.to_a(args), block.$to_proc());}, $$13.$$s = self, $$13.$$arity = 2, $$13))};
        if ($truthy((inner = item.inner_html || nil))) {
          
          $writer = [inner];
          $send(dom, 'inner_html=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        } else {
          $send(item, 'each', [], ($$14 = function(child){var self = $$14.$$s || this;

          
            
            if (child == null) {
              child = nil;
            };
            return dom['$<<']($$($nesting, 'Builder').$build(b, child));}, $$14.$$s = self, $$14.$$arity = 1, $$14))
        };
        return dom;}, $DOM$11.$$s = self, $DOM$11.$$arity = 2, $DOM$11));
      $send($$($nesting, 'Builder'), 'for', [$$$($$($nesting, 'DOM'), 'Node')], ($DOM$15 = function(b, item){var self = $DOM$15.$$s || this;

      
        
        if (b == null) {
          b = nil;
        };
        
        if (item == null) {
          item = nil;
        };
        return item;}, $DOM$15.$$s = self, $DOM$15.$$arity = 2, $DOM$15));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom/mutation_observer"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$supports?', '$include', '$===', '$==', '$type', '$new', '$[]', '$DOM', '$alias_native', '$call', '$map', '$convert', '$private', '$Native', '$[]=', '$-', '$to_n']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'DOM');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MutationObserver');

        var $nesting = [self].concat($parent_nesting), $MutationObserver_supported$ques$1, $MutationObserver_initialize$9, $MutationObserver_observe$11, $MutationObserver_take$12, $MutationObserver_disconnect$14, $MutationObserver_convert$15;

        self.$$prototype["native"] = nil;
        
        Opal.defs(self, '$supported?', $MutationObserver_supported$ques$1 = function() {
          var self = this;

          return $$($nesting, 'Browser')['$supports?']("MutationObserver")
        }, $MutationObserver_supported$ques$1.$$arity = 0);
        self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Record');

          var $nesting = [self].concat($parent_nesting), $Record_type$2, $Record_attribute$ques$3, $Record_tree$ques$4, $Record_cdata$ques$5, $Record_added$6, $Record_removed$7, $Record_target$8;

          self.$$prototype["native"] = nil;
          
          self.$include($$$($$($nesting, 'Browser'), 'NativeCachedWrapper'));
          
          Opal.def(self, '$type', $Record_type$2 = function $$type() {
            var self = this, $case = nil;

            return (function() {$case = self["native"].type;
            if ("attributes"['$===']($case)) {return "attribute"}
            else if ("childList"['$===']($case)) {return "tree"}
            else if ("characterData"['$===']($case)) {return "cdata"}
            else { return nil }})()
          }, $Record_type$2.$$arity = 0);
          
          Opal.def(self, '$attribute?', $Record_attribute$ques$3 = function() {
            var self = this;

            return self.$type()['$==']("attribute")
          }, $Record_attribute$ques$3.$$arity = 0);
          
          Opal.def(self, '$tree?', $Record_tree$ques$4 = function() {
            var self = this;

            return self.$type()['$==']("tree")
          }, $Record_tree$ques$4.$$arity = 0);
          
          Opal.def(self, '$cdata?', $Record_cdata$ques$5 = function() {
            var self = this;

            return self.$type()['$==']("cdata")
          }, $Record_cdata$ques$5.$$arity = 0);
          
          Opal.def(self, '$added', $Record_added$6 = function $$added() {
            var self = this, array = nil;

            
            array = (function() {if ($truthy(self["native"].addedNodes != null)) {
              return $$$($$($nesting, 'Native'), 'Array').$new(self["native"].addedNodes)
            } else {
              return []
            }; return nil; })();
            return $$($nesting, 'NodeSet')['$[]'](array);
          }, $Record_added$6.$$arity = 0);
          
          Opal.def(self, '$removed', $Record_removed$7 = function $$removed() {
            var self = this, array = nil;

            
            array = (function() {if ($truthy(self["native"].removedNodes != null)) {
              return $$$($$($nesting, 'Native'), 'Array').$new(self["native"].removedNodes)
            } else {
              return []
            }; return nil; })();
            return $$($nesting, 'NodeSet')['$[]'](array);
          }, $Record_removed$7.$$arity = 0);
          
          Opal.def(self, '$target', $Record_target$8 = function $$target() {
            var self = this;

            return self.$DOM(self["native"].target)
          }, $Record_target$8.$$arity = 0);
          self.$alias_native("old", "oldValue");
          self.$alias_native("name", "attributeName");
          return self.$alias_native("namespace", "attributeNamespace");
        })($nesting[0], null, $nesting);
        
        Opal.def(self, '$initialize', $MutationObserver_initialize$9 = function $$initialize() {
          var $iter = $MutationObserver_initialize$9.$$p, block = $iter || nil, $$10, self = this;

          if ($iter) $MutationObserver_initialize$9.$$p = null;
          
          
          if ($iter) $MutationObserver_initialize$9.$$p = null;;
          
      var func = function(records) {
        return block.$call($send((records), 'map', [], ($$10 = function(r){var self = $$10.$$s || this;

          
            
            if (r == null) {
              r = nil;
            };
            return $$$($$$($$$($$($nesting, 'Browser'), 'DOM'), 'MutationObserver'), 'Record').$new(r);}, $$10.$$s = self, $$10.$$arity = 1, $$10)));
      }
    ;
          return $send(self, Opal.find_super_dispatcher(self, 'initialize', $MutationObserver_initialize$9, false), [new window.MutationObserver(func)], null);
        }, $MutationObserver_initialize$9.$$arity = 0);
        
        Opal.def(self, '$observe', $MutationObserver_observe$11 = function $$observe(target, options) {
          var self = this;

          
          
          if (options == null) {
            options = nil;
          };
          if ($truthy(options)) {
          } else {
            options = $hash2(["children", "tree", "attributes", "cdata"], {"children": true, "tree": true, "attributes": "old", "cdata": "old"})
          };
          self["native"].observe($$($nesting, 'Native').$convert(target), self.$convert(options));
          return self;
        }, $MutationObserver_observe$11.$$arity = -2);
        
        Opal.def(self, '$take', $MutationObserver_take$12 = function $$take() {
          var $$13, self = this;

          return $send((self["native"].takeRecords()), 'map', [], ($$13 = function(r){var self = $$13.$$s || this;

          
            
            if (r == null) {
              r = nil;
            };
            return $$($nesting, 'Record').$new(r);}, $$13.$$s = self, $$13.$$arity = 1, $$13))
        }, $MutationObserver_take$12.$$arity = 0);
        
        Opal.def(self, '$disconnect', $MutationObserver_disconnect$14 = function $$disconnect() {
          var self = this;

          return self["native"].disconnect()
        }, $MutationObserver_disconnect$14.$$arity = 0);
        self.$private();
        return (Opal.def(self, '$convert', $MutationObserver_convert$15 = function $$convert(hash) {
          var self = this, options = nil, $writer = nil, attrs = nil, filter = nil, cdata = nil;

          
          options = self.$Native({});
          if ($truthy(hash['$[]']("children"))) {
            
            $writer = ["childList", true];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy(hash['$[]']("tree"))) {
            
            $writer = ["subtree", true];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy((attrs = hash['$[]']("attributes")))) {
            
            
            $writer = ["attributes", true];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if (attrs['$==']("old")) {
              
              $writer = ["attributeOldValue", true];
              $send(options, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};};
          if ($truthy((filter = hash['$[]']("filter")))) {
            
            $writer = ["attributeFilter", filter];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy((cdata = hash['$[]']("cdata")))) {
            
            
            $writer = ["characterData", true];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if (cdata['$==']("old")) {
              
              $writer = ["characterDataOldValue", true];
              $send(options, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};};
          return options.$to_n();
        }, $MutationObserver_convert$15.$$arity = 1), nil) && 'convert';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/dom"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send, $klass = Opal.klass;
  if ($gvars.window == null) $gvars.window = nil;

  Opal.add_stubs(['$require', '$DOM', '$shift', '$to_a', '$new', '$to_proc', '$==', '$length', '$first', '$native?', '$===', '$try_convert', '$raise', '$document']);
  
  self.$require("browser/dom/node_set");
  self.$require("browser/dom/node");
  self.$require("browser/dom/attribute");
  self.$require("browser/dom/character_data");
  self.$require("browser/dom/text");
  self.$require("browser/dom/cdata");
  self.$require("browser/dom/comment");
  self.$require("browser/dom/element");
  self.$require("browser/dom/document");
  self.$require("browser/dom/document_fragment");
  self.$require("browser/dom/builder");
  self.$require("browser/dom/mutation_observer");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_XML$1, $Kernel_DOM$2;

    
    
    Opal.def(self, '$XML', $Kernel_XML$1 = function $$XML(what) {
      var self = this;

      
      
      var doc;

      if (window.DOMParser) {
        doc = new DOMParser().parseFromString(what, 'text/xml');
      }
      else {
        doc       = new ActiveXObject('Microsoft.XMLDOM');
        doc.async = 'false';
        doc.loadXML(what);
      }
    ;
      return self.$DOM(doc);
    }, $Kernel_XML$1.$$arity = 1);
    
    Opal.def(self, '$DOM', $Kernel_DOM$2 = function $$DOM($a) {
      var $iter = $Kernel_DOM$2.$$p, block = $iter || nil, $post_args, args, $b, self = this, document = nil, roots = nil, what = nil;
      if ($gvars.document == null) $gvars.document = nil;

      if ($iter) $Kernel_DOM$2.$$p = null;
      
      
      if ($iter) $Kernel_DOM$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
        
        document = ($truthy($b = args.$shift()) ? $b : $gvars.document);
        roots = $send($$$($$$($$($nesting, 'Browser'), 'DOM'), 'Builder'), 'new', [document], block.$to_proc()).$to_a();
        if (roots.$length()['$=='](1)) {
          return roots.$first()
        } else {
          return $$$($$$($$($nesting, 'Browser'), 'DOM'), 'NodeSet').$new(roots)
        };
      } else {
        
        what = args.$shift();
        document = ($truthy($b = args.$shift()) ? $b : $gvars.document);
        if ($truthy(self['$native?'](what))) {
          return $$$($$$($$($nesting, 'Browser'), 'DOM'), 'Node').$new(what)
        } else if ($truthy($$$($$$($$($nesting, 'Browser'), 'DOM'), 'Node')['$==='](what))) {
          return what
        } else if ($truthy($$($nesting, 'String')['$==='](what))) {
          
          var doc = $$($nesting, 'Native').$try_convert(document).createElement('div');
          doc.innerHTML = what;

          return self.$DOM(doc.childNodes.length == 1 ? doc.childNodes[0] : doc);
        
        } else {
          return self.$raise($$($nesting, 'ArgumentError'), "argument not DOM convertible")
        };
      };
    }, $Kernel_DOM$2.$$arity = -1);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Window');

      var $nesting = [self].concat($parent_nesting), $Window_document$3;

      self.$$prototype["native"] = nil;
      return (Opal.def(self, '$document', $Window_document$3 = function $$document() {
        var self = this;

        return self.$DOM(self["native"].document)
      }, $Window_document$3.$$arity = 0), nil) && 'document'
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
  return ($gvars.document = $gvars.window.$document());
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/css/declaration"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs(['$include', '$new', '$each', '$[]=', '$-', '$to_proc', '$important', '$name', '$value', '$to_s', '$enum_for', '$[]', '$alias_native', '$end_with?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Declaration');

        var $nesting = [self].concat($parent_nesting), $Declaration_rule$1, $Declaration_assign$2, $Declaration_replace$4, $Declaration_apply$5, $Declaration_delete$7, $Declaration_$$$8, $Declaration_$$$eq$9, $Declaration_important$ques$10, $Declaration_each$11, $Declaration_method_missing$12;

        self.$$prototype["native"] = nil;
        
        self.$include($$$($$($nesting, 'Browser'), 'NativeCachedWrapper'));
        self.$include($$($nesting, 'Enumerable'));
        
        Opal.def(self, '$rule', $Declaration_rule$1 = function $$rule() {
          var self = this;

          if ($truthy((typeof(self["native"].parentRule) !== "undefined"))) {
            return $$($nesting, 'Rule').$new(self["native"].parentRule)
          } else {
            return nil
          }
        }, $Declaration_rule$1.$$arity = 0);
        
        Opal.def(self, '$assign', $Declaration_assign$2 = function $$assign(data) {
          var $$3, self = this;

          
          $send(data, 'each', [], ($$3 = function(name, value){var self = $$3.$$s || this, $writer = nil;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (value == null) {
              value = nil;
            };
            $writer = [name, value];
            $send(self, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $$3.$$s = self, $$3.$$arity = 2, $$3));
          return self;
        }, $Declaration_assign$2.$$arity = 1);
        
        Opal.def(self, '$replace', $Declaration_replace$4 = function $$replace(string) {
          var self = this;

          return self["native"].cssText = string
        }, $Declaration_replace$4.$$arity = 1);
        
        Opal.def(self, '$apply', $Declaration_apply$5 = function $$apply() {
          var $iter = $Declaration_apply$5.$$p, block = $iter || nil, $$6, self = this;

          if ($iter) $Declaration_apply$5.$$p = null;
          
          
          if ($iter) $Declaration_apply$5.$$p = null;;
          return $send($send($$$($$$($$($nesting, 'Paggio'), 'CSS'), 'Definition'), 'new', [], block.$to_proc()), 'each', [], ($$6 = function(style){var self = $$6.$$s || this;
            if (self["native"] == null) self["native"] = nil;

          
            
            if (style == null) {
              style = nil;
            };
            if ($truthy(style.$important())) {
              return self["native"].setProperty(style.$name(), style.$value(), "important")
            } else {
              return self["native"].setProperty(style.$name(), style.$value(), "")
            };}, $$6.$$s = self, $$6.$$arity = 1, $$6));
        }, $Declaration_apply$5.$$arity = 0);
        
        Opal.def(self, '$delete', $Declaration_delete$7 = function(name) {
          var self = this;

          return self["native"].removeProperty(name)
        }, $Declaration_delete$7.$$arity = 1);
        
        Opal.def(self, '$[]', $Declaration_$$$8 = function(name) {
          var self = this;

          
      var result = self["native"].getPropertyValue(name);

      if (result == null || result === "") {
        return nil;
      }

      return result;
    
        }, $Declaration_$$$8.$$arity = 1);
        
        Opal.def(self, '$[]=', $Declaration_$$$eq$9 = function(name, value) {
          var self = this;

          return self["native"].setProperty(name, value.$to_s(), "")
        }, $Declaration_$$$eq$9.$$arity = 2);
        
        Opal.def(self, '$important?', $Declaration_important$ques$10 = function(name) {
          var self = this;

          return self["native"].getPropertyPriority(name) == "important"
        }, $Declaration_important$ques$10.$$arity = 1);
        
        Opal.def(self, '$each', $Declaration_each$11 = function $$each() {
          var $iter = $Declaration_each$11.$$p, block = $iter || nil, self = this;

          if ($iter) $Declaration_each$11.$$p = null;
          
          
          if ($iter) $Declaration_each$11.$$p = null;;
          if ((block !== nil)) {
          } else {
            return self.$enum_for("each")
          };
          
      for (var i = 0, length = self["native"].length; i < length; i++) {
        var name  = self["native"].item(i);

        Opal.yieldX(block, [name, self['$[]'](name)])
      }
    ;
          return self;
        }, $Declaration_each$11.$$arity = 0);
        self.$alias_native("length");
        self.$alias_native("to_s", "cssText");
        return (Opal.def(self, '$method_missing', $Declaration_method_missing$12 = function $$method_missing(name, value) {
          var self = this, $writer = nil;

          
          
          if (value == null) {
            value = nil;
          };
          if ($truthy(name['$end_with?']("="))) {
            
            $writer = [name['$[]']($range(0, -2, false)), value];
            $send(self, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          } else {
            return self['$[]'](name)
          };
        }, $Declaration_method_missing$12.$$arity = -2), nil) && 'method_missing';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/css/style_sheet"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$is_a?', '$to_n', '$alias_native', '$new', '$DOM', '$===', '$join', '$map', '$insert', '$length', '$find', '$rules', '$log', '$==', '$id', '$__send__', '$to_proc']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StyleSheet');

        var $nesting = [self].concat($parent_nesting), $StyleSheet_initialize$1, $StyleSheet_media$2, $StyleSheet_owner$3, $StyleSheet_parent$4, $StyleSheet_rules$5, $StyleSheet_delete$7, $StyleSheet_insert$8, $StyleSheet_rule$9, $StyleSheet_$$$11, $StyleSheet_method_missing$13;

        self.$$prototype["native"] = nil;
        
        self.$include($$$($$($nesting, 'Browser'), 'NativeCachedWrapper'));
        
        Opal.def(self, '$initialize', $StyleSheet_initialize$1 = function $$initialize(what) {
          var $iter = $StyleSheet_initialize$1.$$p, $yield = $iter || nil, self = this;

          if ($iter) $StyleSheet_initialize$1.$$p = null;
          if ($truthy(what['$is_a?']($$$($$($nesting, 'DOM'), 'Element')))) {
            return $send(self, Opal.find_super_dispatcher(self, 'initialize', $StyleSheet_initialize$1, false), [what.$to_n().sheet], null)
          } else {
            return $send(self, Opal.find_super_dispatcher(self, 'initialize', $StyleSheet_initialize$1, false), [what], null)
          }
        }, $StyleSheet_initialize$1.$$arity = 1);
        self.$alias_native("disabled?", "disabled");
        self.$alias_native("href");
        self.$alias_native("title");
        self.$alias_native("type");
        
        Opal.def(self, '$media', $StyleSheet_media$2 = function $$media() {
          var self = this;

          if ($truthy(self["native"].media != null)) {
            return $$($nesting, 'Media').$new(self["native"].media)
          } else {
            return nil
          }
        }, $StyleSheet_media$2.$$arity = 0);
        
        Opal.def(self, '$owner', $StyleSheet_owner$3 = function $$owner() {
          var self = this;

          return self.$DOM(self["native"].ownerNode)
        }, $StyleSheet_owner$3.$$arity = 0);
        
        Opal.def(self, '$parent', $StyleSheet_parent$4 = function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentStyleSheet != null)) {
            return $$($nesting, 'Sheet').$new(self["native"].parentStyleSheet)
          } else {
            return nil
          }
        }, $StyleSheet_parent$4.$$arity = 0);
        
        Opal.def(self, '$rules', $StyleSheet_rules$5 = function $$rules() {
          var $$6, self = this;

          return $send($$$($$($nesting, 'Native'), 'Array'), 'new', [self["native"].cssRules], ($$6 = function(e){var self = $$6.$$s || this;

          
            
            if (e == null) {
              e = nil;
            };
            return $$($nesting, 'Rule').$new(e);}, $$6.$$s = self, $$6.$$arity = 1, $$6))
        }, $StyleSheet_rules$5.$$arity = 0);
        
        Opal.def(self, '$delete', $StyleSheet_delete$7 = function(index) {
          var self = this;

          return self["native"].deleteRule(index)
        }, $StyleSheet_delete$7.$$arity = 1);
        
        Opal.def(self, '$insert', $StyleSheet_insert$8 = function $$insert(index, rule) {
          var self = this;

          return self["native"].insertRule(rule, index)
        }, $StyleSheet_insert$8.$$arity = 2);
        
        Opal.def(self, '$rule', $StyleSheet_rule$9 = function $$rule(selector, body) {
          var $$10, self = this;

          
          if ($truthy($$($nesting, 'String')['$==='](selector))) {
          } else {
            selector = selector.$join(", ")
          };
          if ($truthy($$($nesting, 'String')['$==='](body))) {
          } else {
            body = $send(body, 'map', [], ($$10 = function(name, value){var self = $$10.$$s || this;

            
              
              if (name == null) {
                name = nil;
              };
              
              if (value == null) {
                value = nil;
              };
              return "" + (name) + ": " + (value) + ";";}, $$10.$$s = self, $$10.$$arity = 2, $$10)).$join("\n")
          };
          return self.$insert(self.$length(), "" + (selector) + " { " + (body) + " }");
        }, $StyleSheet_rule$9.$$arity = 2);
        
        Opal.def(self, '$[]', $StyleSheet_$$$11 = function(id) {
          var $$12, self = this;

          return $send(self.$rules(), 'find', [], ($$12 = function(r){var self = $$12.$$s || this;

          
            
            if (r == null) {
              r = nil;
            };
            self.$log(r);
            return r.$id()['$=='](id);}, $$12.$$s = self, $$12.$$arity = 1, $$12))
        }, $StyleSheet_$$$11.$$arity = 1);
        
        Opal.def(self, '$method_missing', $StyleSheet_method_missing$13 = function $$method_missing($a) {
          var $iter = $StyleSheet_method_missing$13.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $StyleSheet_method_missing$13.$$p = null;
          
          
          if ($iter) $StyleSheet_method_missing$13.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self.$rules(), '__send__', Opal.to_a(args), block.$to_proc());
        }, $StyleSheet_method_missing$13.$$arity = -1);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Media');

          var $nesting = [self].concat($parent_nesting), $Media_push$14, $Media_delete$15;

          self.$$prototype["native"] = nil;
          
          self.$alias_native("text", "mediaText");
          self.$alias_native("to_s", "mediaText");
          
          Opal.def(self, '$push', $Media_push$14 = function $$push(medium) {
            var self = this;

            
            self["native"].appendMedium(medium);
            return self;
          }, $Media_push$14.$$arity = 1);
          return (Opal.def(self, '$delete', $Media_delete$15 = function(medium) {
            var self = this;

            return self["native"].deleteMedium(medium)
          }, $Media_delete$15.$$arity = 1), nil) && 'delete';
        })($nesting[0], $$$($$($nesting, 'Native'), 'Array'), $nesting);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/css/rule"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$==', '$[]', '$new', '$raise', '$alias_native']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rule');

        var $nesting = [self].concat($parent_nesting), $Rule_new$1, $Rule_parent$2, $Rule_style_sheet$3;

        self.$$prototype["native"] = nil;
        
        self.$include($$$($$($nesting, 'Browser'), 'NativeCachedWrapper'));
        Opal.const_set($nesting[0], 'STYLE_RULE', 1);
        Opal.const_set($nesting[0], 'CHARSET_RULE', 2);
        Opal.const_set($nesting[0], 'IMPORT_RULE', 3);
        Opal.const_set($nesting[0], 'MEDIA_RULE', 4);
        Opal.const_set($nesting[0], 'FONT_FACE_RULE', 5);
        Opal.const_set($nesting[0], 'PAGE_RULE', 6);
        Opal.const_set($nesting[0], 'KEYFRAMES_RULE', 7);
        Opal.const_set($nesting[0], 'KEYFRAME_RULE', 8);
        Opal.const_set($nesting[0], 'NAMESPACE_RULE', 10);
        Opal.const_set($nesting[0], 'COUNTER_STYLE_RULE', 11);
        Opal.const_set($nesting[0], 'SUPPORTS_RULE', 12);
        Opal.const_set($nesting[0], 'DOCUMENT_RULE', 13);
        Opal.const_set($nesting[0], 'FONT_FEATURE_VALUES_RULE', 14);
        Opal.const_set($nesting[0], 'VIEWPORT_RULE', 15);
        Opal.const_set($nesting[0], 'REGION_STYLE_RULE', 16);
        Opal.defs(self, '$new', $Rule_new$1 = function(rule) {
          var $a, $iter = $Rule_new$1.$$p, $yield = $iter || nil, self = this, klass = nil;
          if (self.classes == null) self.classes = nil;

          if ($iter) $Rule_new$1.$$p = null;
          if (self['$==']($$($nesting, 'Rule'))) {
            
            self.classes = ($truthy($a = self.classes) ? $a : [nil, $$($nesting, 'Style')]);
            if ($truthy((klass = self.classes['$[]'](rule.type)))) {
              return klass.$new(rule)
            } else {
              return self.$raise($$($nesting, 'ArgumentError'), "cannot instantiate a non derived Rule object")
            };
          } else {
            return $send(self, Opal.find_super_dispatcher(self, 'new', $Rule_new$1, false, self.$$class.$$prototype), [rule], null)
          }
        }, $Rule_new$1.$$arity = 1);
        self.$alias_native("text", "cssText");
        self.$alias_native("to_s", "cssText");
        
        Opal.def(self, '$parent', $Rule_parent$2 = function $$parent() {
          var self = this;

          if ($truthy(self["native"].parentRule != null)) {
            return $$($nesting, 'Rule').$new(self["native"].parentRule)
          } else {
            return nil
          }
        }, $Rule_parent$2.$$arity = 0);
        return (Opal.def(self, '$style_sheet', $Rule_style_sheet$3 = function $$style_sheet() {
          var self = this;

          if ($truthy(self["native"].parentStyleSheet != null)) {
            return $$($nesting, 'StyleSheet').$new(self["native"].parentStyleSheet)
          } else {
            return nil
          }
        }, $Rule_style_sheet$3.$$arity = 0), nil) && 'style_sheet';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/css/rule/style"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$alias_native', '$new', '$__send__', '$declaration', '$to_proc']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Browser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'CSS');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rule');

        var $nesting = [self].concat($parent_nesting);

        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'Style');

          var $nesting = [self].concat($parent_nesting), $Style_declaration$1, $Style_method_missing$2;

          self.$$prototype["native"] = nil;
          
          self.$alias_native("selector", "selectorText");
          self.$alias_native("id", "selectorText");
          
          Opal.def(self, '$declaration', $Style_declaration$1 = function $$declaration() {
            var self = this;

            return $$($nesting, 'Declaration').$new(self["native"].style)
          }, $Style_declaration$1.$$arity = 0);
          return (Opal.def(self, '$method_missing', $Style_method_missing$2 = function $$method_missing($a) {
            var $iter = $Style_method_missing$2.$$p, block = $iter || nil, $post_args, args, self = this;

            if ($iter) $Style_method_missing$2.$$p = null;
            
            
            if ($iter) $Style_method_missing$2.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            return $send(self.$declaration(), '__send__', Opal.to_a(args), block.$to_proc());
          }, $Style_method_missing$2.$$arity = -1), nil) && 'method_missing';
        })($nesting[0], $$($nesting, 'Rule'), $nesting)
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["browser/css"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send;

  Opal.add_stubs(['$require', '$>', '$length', '$pop', '$create_element', '$[]=', '$-', '$css', '$to_proc', '$inner_text=', '$join']);
  
  self.$require("browser/css/declaration");
  self.$require("browser/css/style_sheet");
  self.$require("browser/css/rule");
  self.$require("browser/css/rule/style");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_CSS$1;

    
    Opal.def(self, '$CSS', $Kernel_CSS$1 = function $$CSS($a) {
      var $iter = $Kernel_CSS$1.$$p, block = $iter || nil, $post_args, args, $b, $c, self = this, document = nil, style = nil, $writer = nil;
      if ($gvars.document == null) $gvars.document = nil;

      if ($iter) $Kernel_CSS$1.$$p = null;
      
      
      if ($iter) $Kernel_CSS$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      document = ($truthy($b = (function() {if ($truthy(($truthy($c = $rb_gt(args.$length(), 1)) ? $c : (block !== nil)))) {
        return args.$pop()
      } else {
        return nil
      }; return nil; })()) ? $b : $gvars.document);
      style = document.$create_element("style");
      
      $writer = ["type", "text/css"];
      $send(style, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      if ($truthy(block)) {
        
        $writer = [$send($$($nesting, 'Paggio'), 'css', [], block.$to_proc())];
        $send(style, 'inner_text=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [args.$join("")];
        $send(style, 'inner_text=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return style;
    }, $Kernel_CSS$1.$$arity = -1)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.0.3 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("native");
  self.$require("paggio");
  self.$require("browser/version");
  self.$require("browser/utils");
  self.$require("browser/form_data");
  self.$require("browser/support");
  self.$require("browser/event");
  self.$require("browser/window");
  self.$require("browser/dom");
  return self.$require("browser/css");
})(Opal);

/* Generated by Opal 1.0.3 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$exit']);
  return $$($nesting, 'Kernel').$exit()
})(Opal);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAvLyBAbm90ZVxuICAvLyAgIEEgZmV3IGNvbnZlbnRpb25zIGZvciB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZpbGU6XG4gIC8vICAgMS4gQWx3YXlzIHVzZSBcIi8vXCIgKGluIGNvbnRyYXN0IHdpdGggXCIvKiovXCIpXG4gIC8vICAgMi4gVGhlIHN5bnRheCB1c2VkIGlzIFlhcmRvYyAoeWFyZG9jLm9yZyksIHdoaWNoIGlzIGludGVuZGVkIGZvciBSdWJ5IChzZSBiZWxvdylcbiAgLy8gICAzLiBgQHBhcmFtYCBhbmQgYEByZXR1cm5gIHR5cGVzIHNob3VsZCBiZSBwcmVjZWRlZCBieSBgSlMuYCB3aGVuIHJlZmVycmluZyB0b1xuICAvLyAgICAgIEphdmFTY3JpcHQgY29uc3RydWN0b3JzIChlLmcuIGBKUy5GdW5jdGlvbmApIG90aGVyd2lzZSBSdWJ5IGlzIGFzc3VtZWQuXG4gIC8vICAgNC4gYG5pbGAgYW5kIGBudWxsYCBiZWluZyB1bmFtYmlndW91cyByZWZlciB0byB0aGUgcmVzcGVjdGl2ZVxuICAvLyAgICAgIG9iamVjdHMvdmFsdWVzIGluIFJ1YnkgYW5kIEphdmFTY3JpcHRcbiAgLy8gICA1LiBUaGlzIGlzIHN0aWxsIFdJUCA6KSBzbyBwbGVhc2UgZ2l2ZSBmZWVkYmFjayBhbmQgc3VnZ2VzdGlvbnMgb24gaG93XG4gIC8vICAgICAgdG8gaW1wcm92ZSBvciBmb3IgYWx0ZXJuYXRpdmUgc29sdXRpb25zXG4gIC8vXG4gIC8vICAgVGhlIHdheSB0aGUgY29kZSBpcyBkaWdlc3RlZCBiZWZvcmUgZ29pbmcgdGhyb3VnaCBZYXJkb2MgaXMgYSBzZWNyZXQga2VwdFxuICAvLyAgIGluIHRoZSBkb2NzIHJlcG8gKGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL2RvY3MvdHJlZS9tYXN0ZXIpLlxuXG4gIHZhciBnbG9iYWxfb2JqZWN0ID0gdGhpcywgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWwpICE9PSAndW5kZWZpbmVkJykgeyBnbG9iYWxfb2JqZWN0ID0gZ2xvYmFsOyB9XG4gIGlmICh0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IHdpbmRvdzsgfVxuXG4gIC8vIFNldHVwIGEgZHVtbXkgY29uc29sZSBvYmplY3QgaWYgbWlzc2luZ1xuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuY29uc29sZSkgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc29sZSA9IGdsb2JhbF9vYmplY3QuY29uc29sZTtcbiAgfSBlbHNlIGlmIChnbG9iYWxfb2JqZWN0LmNvbnNvbGUgPT0gbnVsbCkge1xuICAgIGNvbnNvbGUgPSBnbG9iYWxfb2JqZWN0LmNvbnNvbGUgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlID0ge307XG4gIH1cblxuICBpZiAoISgnbG9nJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uICgpIHt9OyB9XG4gIGlmICghKCd3YXJuJyBpbiBjb25zb2xlKSkgeyBjb25zb2xlLndhcm4gPSBjb25zb2xlLmxvZzsgfVxuXG4gIGlmICh0eXBlb2YodGhpcy5PcGFsKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ09wYWwgYWxyZWFkeSBsb2FkZWQuIExvYWRpbmcgdHdpY2UgY2FuIGNhdXNlIHRyb3VibGVzLCBwbGVhc2UgZml4IHlvdXIgc2V0dXAuJyk7XG4gICAgcmV0dXJuIHRoaXMuT3BhbDtcbiAgfVxuXG4gIHZhciBuaWw7XG5cbiAgLy8gVGhlIGFjdHVhbCBjbGFzcyBmb3IgQmFzaWNPYmplY3RcbiAgdmFyIEJhc2ljT2JqZWN0O1xuXG4gIC8vIFRoZSBhY3R1YWwgT2JqZWN0IGNsYXNzLlxuICAvLyBUaGUgbGVhZGluZyB1bmRlcnNjb3JlIGlzIHRvIGF2b2lkIGNvbmZ1c2lvbiB3aXRoIHdpbmRvdy5PYmplY3QoKVxuICB2YXIgX09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE1vZHVsZSBjbGFzc1xuICB2YXIgTW9kdWxlO1xuXG4gIC8vIFRoZSBhY3R1YWwgQ2xhc3MgY2xhc3NcbiAgdmFyIENsYXNzO1xuXG4gIC8vIFRoZSBPcGFsIG9iamVjdCB0aGF0IGlzIGV4cG9zZWQgZ2xvYmFsbHlcbiAgdmFyIE9wYWwgPSB0aGlzLk9wYWwgPSB7fTtcblxuICAvLyBUaGlzIGlzIGEgdXNlZnVsIHJlZmVyZW5jZSB0byBnbG9iYWwgb2JqZWN0IGluc2lkZSBydWJ5IGZpbGVzXG4gIE9wYWwuZ2xvYmFsID0gZ2xvYmFsX29iamVjdDtcbiAgZ2xvYmFsX29iamVjdC5PcGFsID0gT3BhbDtcblxuICAvLyBDb25maWd1cmUgcnVudGltZSBiZWhhdmlvciB3aXRoIHJlZ2FyZHMgdG8gcmVxdWlyZSBhbmQgdW5zdXBwb3J0ZWQgZmVhcnVyZXNcbiAgT3BhbC5jb25maWcgPSB7XG4gICAgbWlzc2luZ19yZXF1aXJlX3NldmVyaXR5OiAnZXJyb3InLCAgICAgICAgLy8gZXJyb3IsIHdhcm5pbmcsIGlnbm9yZVxuICAgIHVuc3VwcG9ydGVkX2ZlYXR1cmVzX3NldmVyaXR5OiAnd2FybmluZycsIC8vIGVycm9yLCB3YXJuaW5nLCBpZ25vcmVcbiAgICBlbmFibGVfc3RhY2tfdHJhY2U6IHRydWUgICAgICAgICAgICAgICAgICAvLyB0cnVlLCBmYWxzZVxuICB9O1xuXG4gIC8vIE1pbmlmeSBjb21tb24gZnVuY3Rpb24gY2FsbHNcbiAgdmFyICRoYXNPd24gICAgICAgPSBPYmplY3QuaGFzT3duUHJvcGVydHk7XG4gIHZhciAkYmluZCAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG4gIHZhciAkc2V0UHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuICB2YXIgJHNsaWNlICAgICAgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgdmFyICRzcGxpY2UgICAgICAgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xuXG4gIC8vIE5pbCBvYmplY3QgaWQgaXMgYWx3YXlzIDRcbiAgdmFyIG5pbF9pZCA9IDQ7XG5cbiAgLy8gR2VuZXJhdGVzIGV2ZW4gc2VxdWVudGlhbCBudW1iZXJzIGdyZWF0ZXIgdGhhbiA0XG4gIC8vIChuaWxfaWQpIHRvIHNlcnZlIGFzIHVuaXF1ZSBpZHMgZm9yIHJ1Ynkgb2JqZWN0c1xuICB2YXIgdW5pcXVlX2lkID0gbmlsX2lkO1xuXG4gIC8vIFJldHVybiBuZXh0IHVuaXF1ZSBpZFxuICBPcGFsLnVpZCA9IGZ1bmN0aW9uKCkge1xuICAgIHVuaXF1ZV9pZCArPSAyO1xuICAgIHJldHVybiB1bmlxdWVfaWQ7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgb3IgYXNzaWduIHRoZSBpZCBvZiBhbiBvYmplY3RcbiAgT3BhbC5pZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouJCRpc19udW1iZXIpIHJldHVybiAob2JqICogMikrMTtcbiAgICBpZiAob2JqLiQkaWQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iai4kJGlkO1xuICAgIH1cbiAgICAkZGVmaW5lUHJvcGVydHkob2JqLCAnJCRpZCcsIE9wYWwudWlkKCkpO1xuICAgIHJldHVybiBvYmouJCRpZDtcbiAgfTtcblxuICAvLyBHbG9iYWxzIHRhYmxlXG4gIE9wYWwuZ3ZhcnMgPSB7fTtcblxuICAvLyBFeGl0IGZ1bmN0aW9uLCB0aGlzIHNob3VsZCBiZSByZXBsYWNlZCBieSBwbGF0Zm9ybSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuICAvLyAoU2VlIG5vZGVqcyBhbmQgY2hyb21lIGZvciBleGFtcGxlcylcbiAgT3BhbC5leGl0ID0gZnVuY3Rpb24oc3RhdHVzKSB7IGlmIChPcGFsLmd2YXJzLkRFQlVHKSBjb25zb2xlLmxvZygnRXhpdGVkIHdpdGggc3RhdHVzICcrc3RhdHVzKTsgfTtcblxuICAvLyBrZWVwcyB0cmFjayBvZiBleGNlcHRpb25zIGZvciAkIVxuICBPcGFsLmV4Y2VwdGlvbnMgPSBbXTtcblxuICAvLyBAcHJpdmF0ZVxuICAvLyBQb3BzIGFuIGV4Y2VwdGlvbiBmcm9tIHRoZSBzdGFjayBhbmQgdXBkYXRlcyBgJCFgLlxuICBPcGFsLnBvcF9leGNlcHRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBPcGFsLmd2YXJzW1wiIVwiXSA9IE9wYWwuZXhjZXB0aW9ucy5wb3AoKSB8fCBuaWw7XG4gIH07XG5cbiAgLy8gSW5zcGVjdCBhbnkga2luZCBvZiBvYmplY3QsIGluY2x1ZGluZyBub24gUnVieSBvbmVzXG4gIE9wYWwuaW5zcGVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBlbHNlIGlmICghb2JqLiQkY2xhc3MpIHtcbiAgICAgIHJldHVybiBvYmoudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gb2JqLiRpbnNwZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIGluaXRpYWxWYWx1ZSkge1xuICAgIGlmICh0eXBlb2Yob2JqZWN0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvcjpcbiAgICAgIC8vICAgcyA9IFwic3RyaW5nXCJcbiAgICAgIC8vICAgZGVmIHMubTsgZW5kXG4gICAgICAvLyBTdHJpbmcgY2xhc3MgaXMgdGhlIG9ubHkgY2xhc3MgdGhhdDpcbiAgICAgIC8vICsgY29tcGlsZXMgdG8gSlMgcHJpbWl0aXZlXG4gICAgICAvLyArIGFsbG93cyBtZXRob2QgZGVmaW5pdGlvbiBkaXJlY3RseSBvbiBpbnN0YW5jZXNcbiAgICAgIC8vIG51bWJlcnMsIHRydWUsIGZhbHNlIGFuZCBuaWwgZG8gbm90IHN1cHBvcnQgaXQuXG4gICAgICBvYmplY3RbbmFtZV0gPSBpbml0aWFsVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwuZGVmaW5lUHJvcGVydHkgPSAkZGVmaW5lUHJvcGVydHk7XG5cbiAgT3BhbC5zbGljZSA9ICRzbGljZTtcblxuXG4gIC8vIFRydXRoXG4gIC8vIC0tLS0tXG5cbiAgT3BhbC50cnV0aHkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCAhPT0gbmlsICYmIHZhbCAhPSBudWxsICYmICghdmFsLiQkaXNfYm9vbGVhbiB8fCB2YWwgPT0gdHJ1ZSkpO1xuICB9O1xuXG4gIE9wYWwuZmFsc3kgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCA9PT0gbmlsIHx8IHZhbCA9PSBudWxsIHx8ICh2YWwuJCRpc19ib29sZWFuICYmIHZhbCA9PSBmYWxzZSkpXG4gIH07XG5cblxuICAvLyBDb25zdGFudHNcbiAgLy8gLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAvLyAtIFRoZSBSYWlscyBhdXRvbG9hZGluZyBndWlkZSAoaHR0cDovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvdjUuMC9hdXRvbG9hZGluZ19hbmRfcmVsb2FkaW5nX2NvbnN0YW50cy5odG1sKVxuICAvLyAtIEBDb25yYWRJcndpbidzIDIwMTIgcG9zdCBvbiDigJxFdmVyeXRoaW5nIHlvdSBldmVyIHdhbnRlZCB0byBrbm93IGFib3V0IGNvbnN0YW50IGxvb2t1cCBpbiBSdWJ54oCdIChodHRwOi8vY2lydy5pbi9ibG9nL2NvbnN0YW50LWxvb2t1cC5odG1sKVxuICAvL1xuICAvLyBMZWdlbmQgb2YgTVJJIGNvbmNlcHRzL25hbWVzOlxuICAvLyAtIGNvbnN0YW50IHJlZmVyZW5jZSAoY3JlZik6IHRoZSBtb2R1bGUvY2xhc3MgdGhhdCBhY3RzIGFzIGEgbmFtZXNwYWNlXG4gIC8vIC0gbmVzdGluZzogdGhlIG5hbWVzcGFjZXMgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2NvcGUsIGUuZy4gbmVzdGluZyBpbnNpZGVcbiAgLy8gICAgICAgICAgICBgbW9kdWxlIEE7IG1vZHVsZSBCOjpDOyBlbmQ7IGVuZGAgaXMgYFtCOjpDLCBBXWBcblxuICAvLyBHZXQgdGhlIGNvbnN0YW50IGluIHRoZSBzY29wZSBvZiB0aGUgY3VycmVudCBjcmVmXG4gIGZ1bmN0aW9uIGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZikgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIG5lc3RpbmcgYXJyYXkgbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIHJlc3VsdCwgY29uc3RhbnQ7XG5cbiAgICBpZiAobmVzdGluZy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIC8vIElmIHRoZSBuZXN0aW5nIGlzIG5vdCBlbXB0eSB0aGUgY29uc3RhbnQgaXMgbG9va2VkIHVwIGluIGl0cyBlbGVtZW50c1xuICAgIC8vIGFuZCBpbiBvcmRlci4gVGhlIGFuY2VzdG9ycyBvZiB0aG9zZSBlbGVtZW50cyBhcmUgaWdub3JlZC5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IG5lc3RpbmcubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3RhbnQgPSBuZXN0aW5nW2ldLiQkY29uc3RbbmFtZV07XG4gICAgICBpZiAoY29uc3RhbnQgIT0gbnVsbCkgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIGFuY2VzdG9ycyBjaGFpbiBsb29raW5nIGZvciB0aGUgY29uc3RhbnRcbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSB7XG4gICAgdmFyIGksIGlpLCByZXN1bHQsIGFuY2VzdG9ycztcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKGNyZWYpO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWYgKGFuY2VzdG9yc1tpXS4kJGNvbnN0ICYmICRoYXNPd24uY2FsbChhbmNlc3RvcnNbaV0uJCRjb25zdCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgT2JqZWN0J3MgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudCxcbiAgLy8gYnV0IG9ubHkgaWYgY3JlZiBpcyBtaXNzaW5nIG9yIGEgbW9kdWxlLlxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfT2JqZWN0KGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYuJCRpc19tb2R1bGUpIHtcbiAgICAgIHJldHVybiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKF9PYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgY29uc3RfbWlzc2luZyBpZiBub3RoaW5nIGVsc2Ugd29ya2VkXG4gIGZ1bmN0aW9uIGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgaWYgKCFza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiAoY3JlZiB8fCBfT2JqZWN0KS4kY29uc3RfbWlzc2luZyhuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQganVzdCBpbiB0aGUgY3VycmVudCBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYFxuICBPcGFsLmNvbnN0X2dldF9sb2NhbCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAoIWNyZWYuJCRpc19tb2R1bGUgJiYgIWNyZWYuJCRpc19jbGFzcykge1xuICAgICAgdGhyb3cgbmV3IE9wYWwuVHlwZUVycm9yKGNyZWYudG9TdHJpbmcoKSArIFwiIGlzIG5vdCBhIGNsYXNzL21vZHVsZVwiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKTsgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXN1bHQgPSBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZyk7IGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgcmVsYXRpdmUgdG8gYSBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGVcbiAgLy8gY29uc3RhbnQgaXMgcHJlZml4ZWQgYnkgYDo6YCkuXG4gIE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQsIGNhY2hlLCBjYWNoZWQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICghY3JlZi4kJGlzX21vZHVsZSAmJiAhY3JlZi4kJGlzX2NsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgT3BhbC5UeXBlRXJyb3IoY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIGlmICgoY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjcmVmLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKTtcbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB0b3AgbGV2ZWwgY29uc3RhbnQgY2FjaGUgZ2VuZXJhdGlvbiBjb3VudGVyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGluIHRoZSBvcGVuIHVzaW5nIHRoZSBjdXJyZW50IG5lc3RpbmcgYW5kIHRoZSBuZWFyZXN0XG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlID0gZnVuY3Rpb24obmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIGNyZWYgPSBuZXN0aW5nWzBdLCByZXN1bHQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiwgY2FjaGUsIGNhY2hlZDtcblxuICAgIGlmICgoY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkpICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XG5cbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgY29uc3RhbnQgb24gYSBjcmVmIGFuZCBvcHBvcnR1bmlzdGljYWxseSBzZXQgdGhlIG5hbWUgb2ZcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXG4gIE9wYWwuY29uc3Rfc2V0ID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKHZhbHVlLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGlmICh2YWx1ZS4kJG5hbWUgPT0gbnVsbCB8fCB2YWx1ZS4kJG5hbWUgPT09IG5pbCkgdmFsdWUuJCRuYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZS4kJGJhc2VfbW9kdWxlID09IG51bGwpIHZhbHVlLiQkYmFzZV9tb2R1bGUgPSBjcmVmO1xuICAgIH1cblxuICAgIGNyZWYuJCRjb25zdCA9IChjcmVmLiQkY29uc3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY3JlZi4kJGNvbnN0W25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAgIC8vIEBleGFtcGxlXG4gICAgLy8gICBPcGFsLiQkLlJlZ2V4cC4kJC5JR05PUkVDQVNFXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgLy8gRXhwb3NlIHRvcCBsZXZlbCBjb25zdGFudHMgb250byB0aGUgT3BhbCBvYmplY3RcbiAgICBpZiAoY3JlZiA9PT0gX09iamVjdCkgT3BhbFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gTmFtZSBuZXcgY2xhc3MgZGlyZWN0bHkgb250byBjdXJyZW50IHNjb3BlIChPcGFsLkZvby5CYXogPSBrbGFzcylcbiAgICAkZGVmaW5lUHJvcGVydHkoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIEdldCBhbGwgdGhlIGNvbnN0YW50cyByZWFjaGFibGUgZnJvbSBhIGdpdmVuIGNyZWYsIGJ5IGRlZmF1bHQgd2lsbCBpbmNsdWRlXG4gIC8vIGluaGVyaXRlZCBjb25zdGFudHMuXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xuICAgIGlmIChpbmhlcml0ID09IG51bGwpIGluaGVyaXQgPSB0cnVlO1xuXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgbW9kdWxlX2NvbnN0YW50cywgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcblxuICAgIGlmIChpbmhlcml0KSBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoT3BhbC5PYmplY3QpKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuXG4gICAgICAvLyBEb24gbm90IHNob3cgT2JqZWN0cyBjb25zdGFudHMgdW5sZXNzIHdlJ3JlIHF1ZXJ5aW5nIE9iamVjdCBpdHNlbGZcbiAgICAgIGlmIChjcmVmICE9PSBfT2JqZWN0ICYmIG1vZHVsZSA9PSBfT2JqZWN0KSBicmVhaztcblxuICAgICAgZm9yIChjb25zdGFudCBpbiBtb2R1bGUuJCRjb25zdCkge1xuICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgfTtcblxuICAvLyBSZW1vdmUgYSBjb25zdGFudCBmcm9tIGEgY3JlZi5cbiAgT3BhbC5jb25zdF9yZW1vdmUgPSBmdW5jdGlvbihjcmVmLCBuYW1lKSB7XG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG5cbiAgICBpZiAoY3JlZi4kJGNvbnN0W25hbWVdICE9IG51bGwpIHtcbiAgICAgIHZhciBvbGQgPSBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICBkZWxldGUgY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgcmV0dXJuIG9sZDtcbiAgICB9XG5cbiAgICBpZiAoY3JlZi4kJGF1dG9sb2FkICE9IG51bGwgJiYgY3JlZi4kJGF1dG9sb2FkW25hbWVdICE9IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkYXV0b2xvYWRbbmFtZV07XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cblxuICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJjb25zdGFudCBcIitjcmVmK1wiOjpcIitjcmVmLiRuYW1lKCkrXCIgbm90IGRlZmluZWRcIik7XG4gIH07XG5cblxuICAvLyBNb2R1bGVzICYgQ2xhc3Nlc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEEgYGNsYXNzIEZvbzsgZW5kYCBleHByZXNzaW9uIGluIHJ1YnkgaXMgY29tcGlsZWQgdG8gY2FsbCB0aGlzIHJ1bnRpbWVcbiAgLy8gbWV0aG9kIHdoaWNoIGVpdGhlciByZXR1cm5zIGFuIGV4aXN0aW5nIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lLCBvciBjcmVhdGVzXG4gIC8vIGEgbmV3IGNsYXNzIGluIHRoZSBnaXZlbiBgYmFzZWAgc2NvcGUuXG4gIC8vXG4gIC8vIElmIGEgY29uc3RhbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMsIHRoZW4gd2UgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXRcbiAgLy8gaXQgaXMgYSBjbGFzcyBhbmQgYWxzbyB0aGF0IHRoZSBzdXBlcmNsYXNzZXMgbWF0Y2guIElmIGVpdGhlciBvZiB0aGVzZVxuICAvLyBmYWlsLCB0aGVuIHdlIHJhaXNlIGEgYFR5cGVFcnJvcmAuIE5vdGUsIGBzdXBlcmNsYXNzYCBtYXkgYmUgbnVsbCBpZiBvbmVcbiAgLy8gd2FzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHJ1YnkgY29kZS5cbiAgLy9cbiAgLy8gV2UgcGFzcyBhIGNvbnN0cnVjdG9yIHRvIHRoaXMgbWV0aG9kIG9mIHRoZSBmb3JtIGBmdW5jdGlvbiBDbGFzc05hbWUoKSB7fWBcbiAgLy8gc2ltcGx5IHNvIHRoYXQgY2xhc3NlcyBzaG93IHVwIHdpdGggbmljZWx5IGZvcm1hdHRlZCBuYW1lcyBpbnNpZGUgZGVidWdnZXJzXG4gIC8vIGluIHRoZSB3ZWIgYnJvd3NlciAob3Igbm9kZS9zcHJvY2tldHMpLlxuICAvL1xuICAvLyBUaGUgYHNjb3BlYCBpcyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgd2hlcmUgdGhlIGNsYXNzIGlzIGJlaW5nIGNyZWF0ZWRcbiAgLy8gZnJvbS4gV2UgdXNlIHRoaXMgdG8gZ2V0IHRoZSBzY29wZSBmb3Igd2hlcmUgdGhlIGNsYXNzIHNob3VsZCBiZSBjcmVhdGVkLlxuICAvLyBJZiBgc2NvcGVgIGlzIGFuIG9iamVjdCAobm90IGEgY2xhc3MvbW9kdWxlKSwgd2Ugc2ltcGxlIGdldCBpdHMgY2xhc3MgYW5kXG4gIC8vIHVzZSB0aGF0IGFzIHRoZSBzY29wZSBpbnN0ZWFkLlxuICAvL1xuICAvLyBAcGFyYW0gc2NvcGUgICAgICAgIFtPYmplY3RdIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIEBwYXJhbSBzdXBlcmNsYXNzICBbQ2xhc3MsbnVsbF0gc3VwZXJjbGFzcyBvZiB0aGUgbmV3IGNsYXNzIChtYXkgYmUgbnVsbClcbiAgLy8gQHBhcmFtIGlkICAgICAgICAgIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBiZSBjcmVhdGVkXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIGZ1bmN0aW9uIHRvIHVzZSBhcyBjb25zdHJ1Y3RvclxuICAvL1xuICAvLyBAcmV0dXJuIG5ldyBbQ2xhc3NdICBvciBleGlzdGluZyBydWJ5IGNsYXNzXG4gIC8vXG4gIE9wYWwuYWxsb2NhdGVfY2xhc3MgPSBmdW5jdGlvbihuYW1lLCBzdXBlcmNsYXNzKSB7XG4gICAgdmFyIGtsYXNzLCBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzdXBlcmNsYXNzICE9IG51bGwgJiYgc3VwZXJjbGFzcy4kJGJyaWRnZSkge1xuICAgICAgLy8gSW5oZXJpdGFuY2UgZnJvbSBicmlkZ2VkIGNsYXNzZXMgcmVxdWlyZXNcbiAgICAgIC8vIGNhbGxpbmcgb3JpZ2luYWwgSlMgY29uc3RydWN0b3JzXG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBzZWxmID0gbmV3ICgkYmluZC5hcHBseShzdXBlcmNsYXNzLiQkY29uc3RydWN0b3IsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xuXG4gICAgICAgIC8vIGFuZCByZXBsYWNpbmcgYSBfX3Byb3RvX18gbWFudWFsbHlcbiAgICAgICAgJHNldFByb3RvdHlwZShzZWxmLCBrbGFzcy4kJHByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCAnOjonK25hbWUpO1xuICAgIH1cblxuICAgIGtsYXNzID0gY29uc3RydWN0b3I7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGNvbnN0cnVjdG9yJywgY29uc3RydWN0b3IpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkaXNfY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRzdXBlcicsIHN1cGVyY2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGFuY2VzdG9ycycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuXG4gICAgLy8gQnkgZGVmYXVsdCBpZiB0aGVyZSBhcmUgbm8gc2luZ2xldG9uIGNsYXNzIG1ldGhvZHNcbiAgICAvLyBfX3Byb3RvX18gaXMgQ2xhc3MucHJvdG90eXBlXG4gICAgLy8gTGF0ZXIgc2luZ2xldG9uIG1ldGhvZHMgZ2VuZXJhdGUgYSBzaW5nbGV0b25fY2xhc3NcbiAgICAvLyBhbmQgaW5qZWN0IGl0IGludG8gYW5jZXN0b3JzIGNoYWluXG4gICAgaWYgKE9wYWwuQ2xhc3MpIHtcbiAgICAgICRzZXRQcm90b3R5cGUoa2xhc3MsIE9wYWwuQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsKSB7XG4gICAgICAkc2V0UHJvdG90eXBlKGtsYXNzLiQkcHJvdG90eXBlLCBzdXBlcmNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgaWYgKHN1cGVyY2xhc3MuJCRtZXRhKSB7XG4gICAgICAgIC8vIElmIHN1cGVyY2xhc3MgaGFzIG1ldGFjbGFzcyB0aGVuIHdlIGhhdmUgZXhwbGljaXRlbHkgaW5oZXJpdCBpdC5cbiAgICAgICAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3Moa2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpIHtcbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgY2xhc3MgaW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgICB2YXIga2xhc3MgPSBjb25zdF9nZXRfbmFtZShzY29wZSwgbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgY2xhc3MgZXhpc3RzIGluIHRoZSBzY29wZSwgdGhlbiB3ZSBtdXN0IHVzZSB0aGF0XG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGV4aXN0aW5nIGNvbnN0YW50IGlzIGEgY2xhc3MsIG9yIHJhaXNlIGVycm9yXG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgY2xhc3NcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBpZiAoa2xhc3MuJCRzdXBlciAhPT0gc3VwZXJjbGFzcykge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcInN1cGVyY2xhc3MgbWlzbWF0Y2ggZm9yIGNsYXNzIFwiICsga2xhc3MuJCRuYW1lKTtcbiAgICB9XG4gIH1cblxuICBPcGFsLmtsYXNzID0gZnVuY3Rpb24oc2NvcGUsIHN1cGVyY2xhc3MsIG5hbWUpIHtcbiAgICB2YXIgYnJpZGdlZDtcblxuICAgIGlmIChzY29wZSA9PSBudWxsKSB7XG4gICAgICAvLyBHbG9iYWwgc2NvcGVcbiAgICAgIHNjb3BlID0gX09iamVjdDtcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xuICAgICAgLy8gU2NvcGUgaXMgYW4gb2JqZWN0LCB1c2UgaXRzIGNsYXNzXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHN1cGVyY2xhc3MgaXMgbm90IGFuIE9wYWwtZ2VuZXJhdGVkIGNsYXNzIHRoZW4gd2UncmUgYnJpZGdpbmcgYSBuYXRpdmUgSlMgY2xhc3NcbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsICYmICFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIGJyaWRnZWQgPSBzdXBlcmNsYXNzO1xuICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIGtsYXNzID0gZmluZF9leGlzdGluZ19jbGFzcyhzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAoa2xhc3MpIHtcbiAgICAgIGlmIChzdXBlcmNsYXNzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBleGlzdGluZyBjbGFzcyBoYXMgc2FtZSBzdXBlcmNsYXNzXG4gICAgICAgIGVuc3VyZVN1cGVyY2xhc3NNYXRjaChrbGFzcywgc3VwZXJjbGFzcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuXG4gICAgLy8gQ2xhc3MgZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZSB3aXRoIGdpdmVuIHN1cGVyY2xhc3MuLi5cblxuICAgIC8vIE5vdCBzcGVjaWZ5aW5nIGEgc3VwZXJjbGFzcyBtZWFucyB3ZSBjYW4gYXNzdW1lIGl0IHRvIGJlIE9iamVjdFxuICAgIGlmIChzdXBlcmNsYXNzID09IG51bGwpIHtcbiAgICAgIHN1cGVyY2xhc3MgPSBfT2JqZWN0O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgY2xhc3Mgb2JqZWN0IChpbnN0YW5jZSBvZiBDbGFzcylcbiAgICBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmFtZSwgc3VwZXJjbGFzcyk7XG4gICAgT3BhbC5jb25zdF9zZXQoc2NvcGUsIG5hbWUsIGtsYXNzKTtcblxuICAgIC8vIENhbGwgLmluaGVyaXRlZCgpIGhvb2sgd2l0aCBuZXcgY2xhc3Mgb24gdGhlIHN1cGVyY2xhc3NcbiAgICBpZiAoc3VwZXJjbGFzcy4kaW5oZXJpdGVkKSB7XG4gICAgICBzdXBlcmNsYXNzLiRpbmhlcml0ZWQoa2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChicmlkZ2VkKSB7XG4gICAgICBPcGFsLmJyaWRnZShicmlkZ2VkLCBrbGFzcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtsYXNzO1xuICB9O1xuXG4gIC8vIERlZmluZSBuZXcgbW9kdWxlIChvciByZXR1cm4gZXhpc3RpbmcgbW9kdWxlKS4gVGhlIGdpdmVuIGBzY29wZWAgaXMgYmFzaWNhbGx5XG4gIC8vIHRoZSBjdXJyZW50IGBzZWxmYCB2YWx1ZSB0aGUgYG1vZHVsZWAgc3RhdGVtZW50IHdhcyBkZWZpbmVkIGluLiBJZiB0aGlzIGlzXG4gIC8vIGEgcnVieSBtb2R1bGUgb3IgY2xhc3MsIHRoZW4gaXQgaXMgdXNlZCwgb3RoZXJ3aXNlIGlmIHRoZSBzY29wZSBpcyBhIHJ1YnlcbiAgLy8gb2JqZWN0IHRoZW4gdGhhdCBvYmplY3RzIHJlYWwgcnVieSBjbGFzcyBpcyB1c2VkIChlLmcuIGlmIHRoZSBzY29wZSBpcyB0aGVcbiAgLy8gbWFpbiBvYmplY3QsIHRoZW4gdGhlIHRvcCBsZXZlbCBgT2JqZWN0YCBjbGFzcyBpcyB1c2VkIGFzIHRoZSBzY29wZSkuXG4gIC8vXG4gIC8vIElmIGEgbW9kdWxlIG9mIHRoZSBnaXZlbiBuYW1lIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgc2NvcGUsIHRoZW4gdGhhdFxuICAvLyBpbnN0YW5jZSBpcyBqdXN0IHJldHVybmVkLlxuICAvL1xuICAvLyBJZiB0aGVyZSBpcyBhIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBzY29wZSwgdGhlbiBhbiBlcnJvciBpc1xuICAvLyBnZW5lcmF0ZWQgaW5zdGVhZCAoY2Fubm90IGhhdmUgYSBjbGFzcyBhbmQgbW9kdWxlIG9mIHNhbWUgbmFtZSBpbiBzYW1lIHNjb3BlKS5cbiAgLy9cbiAgLy8gT3RoZXJ3aXNlLCBhIG5ldyBtb2R1bGUgaXMgY3JlYXRlZCBpbiB0aGUgc2NvcGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgYW5kIHRoYXRcbiAgLy8gbmV3IGluc3RhbmNlIGlzIHJldHVybmVkIGJhY2sgKHRvIGJlIHJlZmVyZW5jZWQgYXQgcnVudGltZSkuXG4gIC8vXG4gIC8vIEBwYXJhbSAgc2NvcGUgW01vZHVsZSwgQ2xhc3NdIGNsYXNzIG9yIG1vZHVsZSB0aGlzIGRlZmluaXRpb24gaXMgaW5zaWRlXG4gIC8vIEBwYXJhbSAgaWQgICBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgbmV3IChvciBleGlzdGluZykgbW9kdWxlXG4gIC8vXG4gIC8vIEByZXR1cm4gW01vZHVsZV1cbiAgT3BhbC5hbGxvY2F0ZV9tb2R1bGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gZnVuY3Rpb24oKXt9O1xuICAgIGlmIChuYW1lKSB7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdkaXNwbGF5TmFtZScsIG5hbWUrJy4kJGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKG5hbWUpXG4gICAgICAkZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdkaXNwbGF5TmFtZScsIG5hbWUrJy5jb25zdHJ1Y3RvcicpO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkbmFtZScsIG5hbWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJHByb3RvdHlwZScsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkY29uc3QnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaXNfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaXNfYV9tb2R1bGUnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRjdmFycycsIHt9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRpY2xhc3NlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRvd25fcHJlcGVuZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkYW5jZXN0b3JzJywgW21vZHVsZV0pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG5cbiAgICAkc2V0UHJvdG90eXBlKG1vZHVsZSwgT3BhbC5Nb2R1bGUucHJvdG90eXBlKTtcblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZF9leGlzdGluZ19tb2R1bGUoc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuICAgIGlmIChtb2R1bGUgPT0gbnVsbCAmJiBzY29wZSA9PT0gX09iamVjdCkgbW9kdWxlID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhfT2JqZWN0LCBuYW1lKTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIGlmICghbW9kdWxlLiQkaXNfbW9kdWxlICYmIG1vZHVsZSAhPT0gX09iamVjdCkge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KG5hbWUgKyBcIiBpcyBub3QgYSBtb2R1bGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuXG4gIE9wYWwubW9kdWxlID0gZnVuY3Rpb24oc2NvcGUsIG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlO1xuXG4gICAgaWYgKHNjb3BlID09IG51bGwpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICBtb2R1bGUgPSBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cblxuICAgIC8vIE1vZHVsZSBkb2VzbnQgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgICBtb2R1bGUgPSBPcGFsLmFsbG9jYXRlX21vZHVsZShuYW1lKTtcbiAgICBPcGFsLmNvbnN0X3NldChzY29wZSwgbmFtZSwgbW9kdWxlKTtcblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIHRoZSBwYXNzZWQgb2JqZWN0LlxuICAvL1xuICAvLyBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGFscmVkeSBoYXMgYSBzaW5nbGV0b24gY2xhc3MsIHRoZW4gaXQgd2lsbCBiZSBzdG9yZWQgb25cbiAgLy8gdGhlIG9iamVjdCBhcyB0aGUgYCQkbWV0YWAgcHJvcGVydHkuIElmIHRoaXMgZXhpc3RzLCB0aGVuIGl0IGlzIHNpbXBseVxuICAvLyByZXR1cm5lZCBiYWNrLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IHNpbmdsZXRvbiBvYmplY3QgZm9yIHRoZSBjbGFzcyBvciBvYmplY3QgaXMgY3JlYXRlZCwgc2V0IG9uXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIHRoZSBydWJ5IG9iamVjdFxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XG4gIE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LiQkbWV0YTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX21vZHVsZScpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldGluX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcbiAgLy8gd2l0aCB0aGVpciBzaW5nbGV0b24gY2xhc3MgYWxyZWFkeSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBpbmhlcml0aW5nXG4gIC8vIGZyb20gdGhlaXIgc3VwZXJjbGFzcyBvYmplY3QgKHVwIHRvIGBDbGFzc2AgaXRzZWxmKS5cbiAgLy9cbiAgLy8gTk9URTogQWN0dWFsbHkgaW4gTVJJIGEgY2xhc3MnIHNpbmdsZXRvbiBjbGFzcyBpbmhlcml0cyBmcm9tIGl0c1xuICAvLyBzdXBlcmNsYXNzJyBzaW5nbGV0b24gY2xhc3Mgd2hpY2ggaW4gdHVybiBpbmhlcml0cyBmcm9tIENsYXNzLlxuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgW0NsYXNzXVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBzdXBlcmNsYXNzLCBtZXRhO1xuXG4gICAgaWYgKGtsYXNzLiQkbWV0YSkge1xuICAgICAgcmV0dXJuIGtsYXNzLiQkbWV0YTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2luZ2xldG9uX2NsYXNzIHN1cGVyY2xhc3MgaXMgdGhlIHNpbmdsZXRvbl9jbGFzcyBvZiBpdHMgc3VwZXJjbGFzcztcbiAgICAvLyBidXQgQmFzaWNPYmplY3QgaGFzIG5vIHN1cGVyY2xhc3MgKGl0cyBgJCRzdXBlcmAgaXMgbnVsbCksIHRodXMgd2VcbiAgICAvLyBmYWxsYmFjayBvbiBgQ2xhc3NgLlxuICAgIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcblxuICAgIG1ldGEgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG51bGwsIHN1cGVyY2xhc3MsIGZ1bmN0aW9uKCl7fSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1ldGEsICckJHNpbmdsZXRvbl9vZicsIGtsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG1ldGEnLCBtZXRhKTtcbiAgICAkc2V0UHJvdG90eXBlKGtsYXNzLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICAvLyBSZXN0b3JpbmcgQ2xhc3NOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjbGFzcycsIE9wYWwuQ2xhc3MpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldGluX2NsYXNzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgaWYgKG1vZC4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBtb2QuJCRtZXRhO1xuICAgIH1cblxuICAgIHZhciBtZXRhID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhudWxsLCBPcGFsLk1vZHVsZSwgZnVuY3Rpb24oKXt9KTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgJHNldFByb3RvdHlwZShtb2QsIG1ldGEuJCRwcm90b3R5cGUpO1xuICAgIC8vIFJlc3RvcmluZyBNb2R1bGVOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KG1vZCwgJyQkY2xhc3MnLCBPcGFsLk1vZHVsZSk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfTtcblxuICAvLyBCdWlsZCB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciBhIFJ1YnkgKG5vbiBjbGFzcykgT2JqZWN0LlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdXG4gIC8vIEByZXR1cm4gW0NsYXNzXVxuICBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgc3VwZXJjbGFzcyA9IG9iamVjdC4kJGNsYXNzLFxuICAgICAgICBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzLCBmdW5jdGlvbigpe30pO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsICckJG1ldGEnLCBrbGFzcyk7XG5cbiAgICAkc2V0UHJvdG90eXBlKG9iamVjdCwgb2JqZWN0LiQkbWV0YS4kJHByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgT3BhbC5pc19tZXRob2QgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChwcm9wWzBdID09PSAnJCcgJiYgcHJvcFsxXSAhPT0gJyQnKTtcbiAgfTtcblxuICBPcGFsLmluc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgZXhjbHVkZSA9IFtdLCByZXN1bHRzID0gW10sIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgICAgIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC4kJHN0dWIgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGUucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViICYmIHJlc3VsdHMuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaikpO1xuICB9O1xuXG4gIE9wYWwub3duX21ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSk7XG4gIH07XG5cbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG1vZCA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopO1xuICAgIHZhciBzaW5nbGV0b25fbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kKTtcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xuICAgIHJldHVybiBzaW5nbGV0b25fbWV0aG9kcy5jb25jYXQoaW5zdGFuY2VfbWV0aG9kcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcGFpcnMgb2YgbmFtZXMvdmFsdWVzXG4gIC8vIGZvciBhbGwgY2xhc3MgdmFyaWFibGVzIGRlZmluZWQgaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHJldHVybiBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGlmICgkaGFzT3duLmNhbGwoYW5jZXN0b3IuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgYW5jZXN0b3IuJCRjdmFyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kdWxlLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcbiAgICByZXR1cm4gcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX2luY2x1ZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICAgIC8vIHN1cGVyY2xhc3NcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgIH1cbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX3ByZXBlbmRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8vIFRoZSBhY3R1YWwgaW5jbHVzaW9uIG9mIGEgbW9kdWxlIGludG8gYSBjbGFzcy5cbiAgLy9cbiAgLy8gIyMgQ2xhc3MgYCQkcGFyZW50YCBhbmQgYGljbGFzc2BcbiAgLy9cbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXG4gIC8vIHVzZWQgdG8gcmVzb2x2ZSB0aGUgbmV4dCBjbGFzcyBmb3IgYSBzdXBlciBjYWxsLiBBIG5vcm1hbCBjbGFzcyB3b3VsZFxuICAvLyBoYXZlIHRoaXMgcG9pbnQgdG8gaXRzIHN1cGVyY2xhc3MuIEhvd2V2ZXIsIGlmIGEgY2xhc3MgaW5jbHVkZXMgYSBtb2R1bGVcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxuICAvLyBhbHNvIGhhdmUgdG8gdGhlbiBwb2ludCBpdHMgYCQkcGFyZW50YCB0byB0aGUgYWN0dWFsIHN1cGVyY2xhc3MuIFdlXG4gIC8vIGNhbm5vdCBtb2RpZnkgbW9kdWxlcyBsaWtlIHRoaXMsIGJlY2F1c2UgaXQgbWlnaHQgYmUgaW5jbHVkZWQgaW4gbW9yZVxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXG4gIC8vIGAkJHBhcmVudGAgd2hpY2ggY2FuIHRoZW4gcG9pbnQgdG8gdGhlIHN1cGVyY2xhc3MuIFRoZSBgaWNsYXNzYCBhY3RzIGFzXG4gIC8vIGEgcHJveHkgdG8gdGhlIGFjdHVhbCBtb2R1bGUsIHNvIHRoZSBgc3VwZXJgIGNoYWluIGNhbiB0aGVuIHNlYXJjaCBpdCBmb3JcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXSB0aGUgbW9kdWxlIHRvIGluY2x1ZGVcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xuICAvLyBAcmV0dXJuIFtudWxsXVxuICBPcGFsLmFwcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgaW5jbHVkZXIpIHtcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsICckJGluY2x1ZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuICAgIHZhciBpbmNsdWRlcl9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhpbmNsdWRlciksXG4gICAgICAgIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGluY2x1ZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIGluY2x1ZGVcblxuICAgICAgLy8gaW5jbHVkZXIgLT4gY2hhaW4uZmlyc3QgLT4gLi4uY2hhaW4uLi4gLT4gY2hhaW4ubGFzdCAtPiBpbmNsdWRlci5wYXJlbnRcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGhhcyBiZWVuIGFscmVhZHkgaW5jbHVkZWQsXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHB1dCBpdCBpbnRvIHRoZSBhbmNlc3RvcnMgY2hhaW4gYWdhaW4sXG4gICAgICAvLyBidXQgdGhpcyBtb2R1bGUgbWF5IGhhdmUgbmV3IGluY2x1ZGVkIG1vZHVsZXMuXG4gICAgICAvLyBJZiBpdCdzIHRydWUgd2UgbmVlZCB0byBjb3B5IHRoZW0uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHNpbXBsZXN0IHdheSBpcyB0byByZXBsYWNlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnByZXZpb3MgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXMgLi4uXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIHRvXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5yZWdlbmVyYXRlZCBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlc1xuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBhcmUgbm8gaW50ZXJtZWRpYXRlIGNsYXNzZXMgYmV0d2VlbiBgcGFyZW50YCBhbmQgYG5leHQgYW5jZXN0b3JgLlxuICAgICAgLy8gSXQgZG9lc24ndCBicmVhayBhbnkgcHJvdG90eXBlcyBvZiBvdGhlciBvYmplY3RzIGFzIHdlIGRvbid0IGNoYW5nZSBjbGFzcyByZWZlcmVuY2VzLlxuXG4gICAgICB2YXIgcHJvdG8gPSBpbmNsdWRlci4kJHByb3RvdHlwZSwgcGFyZW50ID0gcHJvdG8sIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcblxuICAgICAgd2hpbGUgKG1vZHVsZV9pY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSb290KG1vZHVsZV9pY2xhc3MpICYmIG1vZHVsZV9pY2xhc3MuJCRtb2R1bGUgPT09IG1vZHVsZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gbW9kdWxlX2ljbGFzcztcbiAgICAgICAgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHRfYW5jZXN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlX2ljbGFzcyk7XG5cbiAgICAgIC8vIHNraXAgbm9uLXJvb3QgaWNsYXNzZXMgKHRoYXQgd2VyZSByZWN1cnNpdmVseSBpbmNsdWRlZClcbiAgICAgIHdoaWxlIChuZXh0X2FuY2VzdG9yLmhhc093blByb3BlcnR5KCckJGljbGFzcycpICYmICFpc1Jvb3QobmV4dF9hbmNlc3RvcikpIHtcbiAgICAgICAgbmV4dF9hbmNlc3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXh0X2FuY2VzdG9yKTtcbiAgICAgIH1cblxuICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICBlbmRfY2hhaW5fb24gPSBuZXh0X2FuY2VzdG9yO1xuICAgIH1cblxuICAgICRzZXRQcm90b3R5cGUoc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0UHJvdG90eXBlKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25faW5jbHVkZWRfbW9kdWxlcyBjYWNoZVxuICAgIGluY2x1ZGVyLiQkb3duX2luY2x1ZGVkX21vZHVsZXMgPSBvd25faW5jbHVkZWRfbW9kdWxlcyhpbmNsdWRlcik7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgfTtcblxuICBPcGFsLnByZXBlbmRfZmVhdHVyZXMgPSBmdW5jdGlvbihtb2R1bGUsIHByZXBlbmRlcikge1xuICAgIC8vIEhlcmUgd2UgY2hhbmdlIHRoZSBhbmNlc3RvcnMgY2hhaW4gZnJvbVxuICAgIC8vXG4gICAgLy8gICBwcmVwZW5kZXJcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICAvL1xuICAgIC8vIHRvOlxuICAgIC8vXG4gICAgLy8gZHVtbXkocHJlcGVuZGVyKVxuICAgIC8vICAgICAgfFxuICAgIC8vICBpY2xhc3MobW9kdWxlKVxuICAgIC8vICAgICAgfFxuICAgIC8vIGljbGFzcyhwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gICAgcGFyZW50XG4gICAgdmFyIG1vZHVsZV9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpO1xuICAgIHZhciBpY2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKG1vZHVsZV9hbmNlc3RvcnMuaW5kZXhPZihwcmVwZW5kZXIpICE9PSAtMSkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoJ2N5Y2xpYyBwcmVwZW5kIGRldGVjdGVkJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1vZHVsZV9hbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IG1vZHVsZV9hbmNlc3RvcnNbaV0sIGljbGFzcyA9IGNyZWF0ZV9pY2xhc3MoYW5jZXN0b3IpO1xuICAgICAgJGRlZmluZVByb3BlcnR5KGljbGFzcywgJyQkcHJlcGVuZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBkdW1teV9wcmVwZW5kZXIgPSBwcmVwZW5kZXIuJCRwcm90b3R5cGUsXG4gICAgICAgIHByZXZpb3VzX3BhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpLFxuICAgICAgICBwcmVwZW5kZXJfaWNsYXNzLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGR1bW15X3ByZXBlbmRlci5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGFscmVhZHkgaGFzIHNvbWUgcHJlcGVuZGVkIG1vZHVsZXNcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBtYWtlIGl0IFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGR1bW15X3ByZXBlbmRlci4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNYWtpbmcgdGhlIG1vZHVsZSBcImR1bW15XCJcbiAgICAgIHByZXBlbmRlcl9pY2xhc3MgPSBjcmVhdGVfZHVtbXlfaWNsYXNzKHByZXBlbmRlcik7XG4gICAgICBmbHVzaF9tZXRob2RzX2luKHByZXBlbmRlcik7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoZHVtbXlfcHJlcGVuZGVyLCAnJCRkdW1teScsIHRydWUpO1xuICAgICAgJGRlZmluZVByb3BlcnR5KGR1bW15X3ByZXBlbmRlciwgJyQkZGVmaW5lX21ldGhvZHNfb24nLCBwcmVwZW5kZXJfaWNsYXNzKTtcblxuICAgICAgLy8gQ29udmVydGluZ1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgLy8gdG9cbiAgICAgIC8vICAgZHVtbXkocHJlcGVuZGVyKSAtPiBpY2xhc3MocHJlcGVuZGVyKSAtPiBwcmV2aW91c19wYXJlbnRcbiAgICAgICRzZXRQcm90b3R5cGUoZHVtbXlfcHJlcGVuZGVyLCBwcmVwZW5kZXJfaWNsYXNzKTtcbiAgICAgICRzZXRQcm90b3R5cGUocHJlcGVuZGVyX2ljbGFzcywgcHJldmlvdXNfcGFyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgcHJlcGVuZGVyX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHByZXBlbmRlcik7XG5cbiAgICBpZiAocHJlcGVuZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIHByZXBlbmRcblxuICAgICAgc3RhcnRfY2hhaW5fYWZ0ZXIgPSBkdW1teV9wcmVwZW5kZXI7XG5cbiAgICAgIC8vIG5leHQgJCRyb290IG9yIHByZXBlbmRlcl9pY2xhc3Mgb3Igbm9uLSQkaWNsYXNzXG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZHVtbXlfcHJlcGVuZGVyKTtcbiAgICAgIHdoaWxlIChlbmRfY2hhaW5fb24gIT0gbnVsbCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZW5kX2NoYWluX29uLmhhc093blByb3BlcnR5KCckJHJvb3QnKSB8fFxuICAgICAgICAgIGVuZF9jaGFpbl9vbiA9PT0gcHJlcGVuZGVyX2ljbGFzcyB8fFxuICAgICAgICAgICFlbmRfY2hhaW5fb24uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZW5kX2NoYWluX29uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5SdW50aW1lRXJyb3IuJG5ldyhcIlByZXBlbmRpbmcgYSBtb2R1bGUgbXVsdGlwbGUgdGltZXMgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG5cbiAgICAkc2V0UHJvdG90eXBlKHN0YXJ0X2NoYWluX2FmdGVyLCBjaGFpbi5maXJzdCk7XG4gICAgJHNldFByb3RvdHlwZShjaGFpbi5sYXN0LCBlbmRfY2hhaW5fb24pO1xuXG4gICAgLy8gcmVjYWxjdWxhdGUgb3duX3ByZXBlbmRlZF9tb2R1bGVzIGNhY2hlXG4gICAgcHJlcGVuZGVyLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzID0gb3duX3ByZXBlbmRlZF9tb2R1bGVzKHByZXBlbmRlcik7XG5cbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgfTtcblxuICBmdW5jdGlvbiBmbHVzaF9tZXRob2RzX2luKG1vZHVsZSkge1xuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZSxcbiAgICAgICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKHByb3ApKSB7XG4gICAgICAgIGRlbGV0ZSBwcm90b1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVfaWNsYXNzKG1vZHVsZSkge1xuICAgIHZhciBpY2xhc3MgPSBjcmVhdGVfZHVtbXlfaWNsYXNzKG1vZHVsZSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBtb2R1bGUuJCRpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGljbGFzcztcbiAgfVxuXG4gIC8vIER1bW15IGljbGFzcyBkb2Vzbid0IHJlY2VpdmUgdXBkYXRlcyB3aGVuIHRoZSBtb2R1bGUgZ2V0cyBhIG5ldyBtZXRob2QuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKSB7XG4gICAgdmFyIGljbGFzcyA9IHt9LFxuICAgICAgICBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCBwcm9wLCBwcm90b1twcm9wXSk7XG4gICAgfVxuXG4gICAgJGRlZmluZVByb3BlcnR5KGljbGFzcywgJyQkaWNsYXNzJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGljbGFzcywgJyQkbW9kdWxlJywgbW9kdWxlKTtcblxuICAgIHJldHVybiBpY2xhc3M7XG4gIH1cblxuICBmdW5jdGlvbiBjaGFpbl9pY2xhc3NlcyhpY2xhc3Nlcykge1xuICAgIHZhciBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGgsIGZpcnN0ID0gaWNsYXNzZXNbMF07XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoZmlyc3QsICckJHJvb3QnLCB0cnVlKTtcblxuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7IGZpcnN0OiBmaXJzdCwgbGFzdDogZmlyc3QgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXMgPSBmaXJzdDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaWNsYXNzZXNbaV07XG4gICAgICAkc2V0UHJvdG90eXBlKHByZXZpb3VzLCBjdXJyZW50KTtcbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cblxuICAgIHJldHVybiB7IGZpcnN0OiBpY2xhc3Nlc1swXSwgbGFzdDogaWNsYXNzZXNbbGVuZ3RoIC0gMV0gfTtcbiAgfVxuXG4gIC8vIEZvciBwZXJmb3JtYW5jZSwgc29tZSBjb3JlIFJ1YnkgY2xhc3NlcyBhcmUgdG9sbC1mcmVlIGJyaWRnZWQgdG8gdGhlaXJcbiAgLy8gbmF0aXZlIEphdmFTY3JpcHQgY291bnRlcnBhcnRzIChlLmcuIGEgUnVieSBBcnJheSBpcyBhIEphdmFTY3JpcHQgQXJyYXkpLlxuICAvL1xuICAvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldHVwIGEgbmF0aXZlIGNvbnN0cnVjdG9yIChlLmcuIEFycmF5KSwgdG8gaGF2ZVxuICAvLyBpdHMgcHJvdG90eXBlIGFjdCBsaWtlIGEgbm9ybWFsIFJ1YnkgY2xhc3MuIEZpcnN0bHksIGEgbmV3IFJ1YnkgY2xhc3MgaXNcbiAgLy8gY3JlYXRlZCB1c2luZyB0aGUgbmF0aXZlIGNvbnN0cnVjdG9yIHNvIHRoYXQgaXRzIHByb3RvdHlwZSBpcyBzZXQgYXMgdGhlXG4gIC8vIHRhcmdldCBmb3IgdGhlIG5ldyBjbGFzcy4gTm90ZTogYWxsIGJyaWRnZWQgY2xhc3NlcyBhcmUgc2V0IHRvIGluaGVyaXRcbiAgLy8gZnJvbSBPYmplY3QuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgIE9wYWwuYnJpZGdlKHNlbGYsIEZ1bmN0aW9uKTtcbiAgLy9cbiAgLy8gQHBhcmFtIGtsYXNzICAgICAgIFtDbGFzc10gdGhlIFJ1YnkgY2xhc3MgdG8gYnJpZGdlXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIG5hdGl2ZSBKYXZhU2NyaXB0IGNvbnN0cnVjdG9yIHRvIHVzZVxuICAvLyBAcmV0dXJuIFtDbGFzc10gcmV0dXJucyB0aGUgcGFzc2VkIFJ1YnkgY2xhc3NcbiAgLy9cbiAgT3BhbC5icmlkZ2UgPSBmdW5jdGlvbihuYXRpdmVfa2xhc3MsIGtsYXNzKSB7XG4gICAgaWYgKG5hdGl2ZV9rbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRicmlkZ2UnKSkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJhbHJlYWR5IGJyaWRnZWRcIik7XG4gICAgfVxuXG4gICAgdmFyIGtsYXNzX3RvX2luamVjdCwga2xhc3NfcmVmZXJlbmNlO1xuXG4gICAga2xhc3NfdG9faW5qZWN0ID0ga2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdDtcbiAgICBrbGFzc19yZWZlcmVuY2UgPSBrbGFzcztcbiAgICB2YXIgb3JpZ2luYWxfcHJvdG90eXBlID0ga2xhc3MuJCRwcm90b3R5cGU7XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBhIEpTIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUgY2hhaW4gbGlrZTpcbiAgICAvLyAtIGNvbnN0cnVjdG9yXG4gICAgLy8gICAtIHN1cGVyXG4gICAgLy9cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZG8gaXMgdG8gaW5qZWN0IG91ciBjbGFzcyAod2l0aCBpdHMgcHJvdG90eXBlIGNoYWluKVxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XG4gICAgLy8gaW50byBKUyBTdHJpbmcgd2UgZ2V0OlxuICAgIC8vXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcbiAgICAvLyAgIC0gT3BhbC5PYmplY3RcbiAgICAvLyAgICAgLSBPcGFsLktlcm5lbFxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxuICAgIC8vICAgICAgICAgLSBzdXBlciAod2luZG93Lk9iamVjdClcbiAgICAvLyAgICAgICAgICAgLSBudWxsXG4gICAgLy9cbiAgICAkZGVmaW5lUHJvcGVydHkobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldFByb3RvdHlwZShuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgbmF0aXZlX2tsYXNzLnByb3RvdHlwZSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkYnJpZGdlJywgdHJ1ZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvdG9Ub01vZHVsZShwcm90bykge1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkbW9kdWxlO1xuICAgIH0gZWxzZSBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkY2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3duX2FuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICByZXR1cm4gbW9kdWxlLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzLmNvbmNhdChbbW9kdWxlXSkuY29uY2F0KG1vZHVsZS4kJG93bl9pbmNsdWRlZF9tb2R1bGVzKTtcbiAgfVxuXG4gIC8vIFRoZSBBcnJheSBvZiBhbmNlc3RvcnMgZm9yIGEgZ2l2ZW4gbW9kdWxlL2NsYXNzXG4gIE9wYWwuYW5jZXN0b3JzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHsgcmV0dXJuIFtdOyB9XG5cbiAgICBpZiAobW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPT09IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbikge1xuICAgICAgcmV0dXJuIG1vZHVsZS4kJGFuY2VzdG9ycztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sIGksIG1vZHMsIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIG1vZHMgPSBvd25fYW5jZXN0b3JzKG1vZHVsZSksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChtb2R1bGUuJCRzdXBlcikge1xuICAgICAgZm9yIChpID0gMCwgbW9kcyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhbXCIkZm9vXCIsIFwiJGJhclwiLCBcIiRiYXo9XCJdKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3R1YiA9IHN0dWJzW2ldLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICB2YXIgbWV0aG9kX21pc3Npbmdfc3R1YiA9IE9wYWwuc3R1Yl9mb3Ioc3R1Yik7XG4gICAgJGRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgc3R1YiwgbWV0aG9kX21pc3Npbmdfc3R1Yik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgdGhlIG1ldGhvZF9taXNzaW5nIHN0dWIgZm9yIGEgZ2l2ZW4gbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIEBwYXJhbSBtZXRob2RfbmFtZSBbU3RyaW5nXSBUaGUganMtbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHN0dWIgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5zdHViX2ZvciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XG4gICAgZnVuY3Rpb24gbWV0aG9kX21pc3Npbmdfc3R1YigpIHtcbiAgICAgIC8vIENvcHkgYW55IGdpdmVuIGJsb2NrIG9udG8gdGhlIG1ldGhvZF9taXNzaW5nIGRpc3BhdGNoZXJcbiAgICAgIHRoaXMuJG1ldGhvZF9taXNzaW5nLiQkcCA9IG1ldGhvZF9taXNzaW5nX3N0dWIuJCRwO1xuXG4gICAgICAvLyBTZXQgYmxvY2sgcHJvcGVydHkgdG8gbnVsbCByZWFkeSBmb3IgdGhlIG5leHQgY2FsbCAoc3RvcCBmYWxzZS1wb3NpdGl2ZXMpXG4gICAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkcCA9IG51bGw7XG5cbiAgICAgIC8vIGNhbGwgbWV0aG9kIG1pc3Npbmcgd2l0aCBjb3JyZWN0IGFyZ3MgKHJlbW92ZSAnJCcgcHJlZml4IG9uIG1ldGhvZCBuYW1lKVxuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3VtZW50c1tpXTsgfVxuXG4gICAgICByZXR1cm4gdGhpcy4kbWV0aG9kX21pc3NpbmcuYXBwbHkodGhpcywgW21ldGhvZF9uYW1lLnNsaWNlKDEpXS5jb25jYXQoYXJnc19hcnkpKTtcbiAgICB9XG5cbiAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkc3R1YiA9IHRydWU7XG5cbiAgICByZXR1cm4gbWV0aG9kX21pc3Npbmdfc3R1YjtcbiAgfTtcblxuXG4gIC8vIE1ldGhvZHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIG1ldGhvZHNcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIG93bmVyIG9mIHRoZSBtZXRob2QgK21ldGgrXG4gIC8vIEBwYXJhbSBtZXRoIFtTdHJpbmddIG1ldGhvZCBuYW1lIHRoYXQgZ290IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmFjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgb2JqZWN0LCBtZXRoKSB7XG4gICAgdmFyIGluc3BlY3QgPSAnJztcbiAgICBpZiAob2JqZWN0LiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGluc3BlY3QgKz0gb2JqZWN0LiQkbmFtZSArICcuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJGNsYXNzLiQkbmFtZSArICcjJztcbiAgICB9XG4gICAgaW5zcGVjdCArPSBtZXRoO1xuXG4gICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoJ1snICsgaW5zcGVjdCArICddIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMoJyArIGFjdHVhbCArICcgZm9yICcgKyBleHBlY3RlZCArICcpJyk7XG4gIH07XG5cbiAgLy8gQXJpdHkgY291bnQgZXJyb3IgZGlzcGF0Y2hlciBmb3IgYmxvY2tzXG4gIC8vXG4gIC8vIEBwYXJhbSBhY3R1YWwgW0ZpeG51bV0gbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiB0byBibG9ja1xuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gY29udGV4dCBbT2JqZWN0XSBjb250ZXh0IG9mIHRoZSBibG9jayBkZWZpbml0aW9uXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cbiAgT3BhbC5ibG9ja19hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zcGVjdCA9IFwiYGJsb2NrIGluIFwiICsgY29udGV4dCArIFwiJ1wiO1xuXG4gICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoaW5zcGVjdCArICc6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCcgKyBhY3R1YWwgKyAnIGZvciAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIFN1cGVyIGRpc3BhdGNoZXJcbiAgT3BhbC5maW5kX3N1cGVyX2Rpc3BhdGNoZXIgPSBmdW5jdGlvbihvYmosIG1pZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjaywgZGVmcykge1xuICAgIHZhciBqc2lkID0gJyQnICsgbWlkLCBhbmNlc3RvcnMsIHN1cGVyX21ldGhvZDtcblxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvYmouJCRtZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob2JqLiQkY2xhc3MpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50X2luZGV4ID0gYW5jZXN0b3JzLmluZGV4T2YoY3VycmVudF9mdW5jLiQkb3duZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV0sXG4gICAgICAgICAgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcblxuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoanNpZCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW2pzaWRdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHN1cGVyX21ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRlZmNoZWNrICYmIHN1cGVyX21ldGhvZCA9PSBudWxsICYmIE9wYWwuS2VybmVsLiRtZXRob2RfbWlzc2luZyA9PT0gb2JqLiRtZXRob2RfbWlzc2luZykge1xuICAgICAgLy8gbWV0aG9kX21pc3NpbmcgaGFzbid0IGJlZW4gZXhwbGljaXRseSBkZWZpbmVkXG4gICAgICB0aHJvdyBPcGFsLk5vTWV0aG9kRXJyb3IuJG5ldygnc3VwZXI6IG5vIHN1cGVyY2xhc3MgbWV0aG9kIGAnK21pZCtcIicgZm9yIFwiK29iaiwgbWlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXJfbWV0aG9kO1xuICB9O1xuXG4gIC8vIEl0ZXIgZGlzcGF0Y2hlciBmb3Igc3VwZXIgaW4gYSBibG9ja1xuICBPcGFsLmZpbmRfaXRlcl9zdXBlcl9kaXNwYXRjaGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiaW1wbGljaXQgYXJndW1lbnQgcGFzc2luZyBvZiBzdXBlciBmcm9tIG1ldGhvZCBkZWZpbmVkIGJ5IGRlZmluZV9tZXRob2QoKSBpcyBub3Qgc3VwcG9ydGVkLiBTcGVjaWZ5IGFsbCBhcmd1bWVudHMgZXhwbGljaXRseVwiKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudF9mdW5jLiQkZGVmKSB7XG4gICAgICBjYWxsX2pzaWQgPSBjdXJyZW50X2Z1bmMuJCRqc2lkO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlcihvYmosIGNhbGxfanNpZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjayk7XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZXR1cm4gYXMgYW4gZXhwcmVzc2lvbi4gU29tZXRpbWVzLCB3ZSBjYW4ndCBzaW1wbHkgcmV0dXJuIGZyb21cbiAgLy8gYSBqYXZhc2NyaXB0IGZ1bmN0aW9uIGFzIGlmIHdlIHdlcmUgYSBtZXRob2QsIGFzIHRoZSByZXR1cm4gaXMgdXNlZCBhc1xuICAvLyBhbiBleHByZXNzaW9uLCBvciBldmVuIGluc2lkZSBhIGJsb2NrIHdoaWNoIG11c3QgXCJyZXR1cm5cIiB0byB0aGUgb3V0ZXJcbiAgLy8gbWV0aG9kLiBUaGlzIGhlbHBlciBzaW1wbHkgdGhyb3dzIGFuIGVycm9yIHdoaWNoIGlzIHRoZW4gY2F1Z2h0IGJ5IHRoZVxuICAvLyBtZXRob2QuIFRoaXMgYXBwcm9hY2ggaXMgZXhwZW5zaXZlLCBzbyBpdCBpcyBvbmx5IHVzZWQgd2hlbiBhYnNvbHV0ZWx5XG4gIC8vIG5lZWRlZC5cbiAgLy9cbiAgT3BhbC5yZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBPcGFsLnJldHVybmVyLiR2ID0gdmFsO1xuICAgIHRocm93IE9wYWwucmV0dXJuZXI7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBicmVhayBvdXQgb2YgYSBibG9jay5cbiAgT3BhbC5icmsgPSBmdW5jdGlvbih2YWwsIGJyZWFrZXIpIHtcbiAgICBicmVha2VyLiR2ID0gdmFsO1xuICAgIHRocm93IGJyZWFrZXI7XG4gIH07XG5cbiAgLy8gQnVpbGRzIGEgbmV3IHVuaXF1ZSBicmVha2VyLCB0aGlzIGlzIHRvIGF2b2lkIG11bHRpcGxlIG5lc3RlZCBicmVha3MgdG8gZ2V0XG4gIC8vIGluIHRoZSB3YXkgb2YgZWFjaCBvdGhlci5cbiAgT3BhbC5uZXdfYnJrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigndW5leHBlY3RlZCBicmVhaycpO1xuICB9O1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzO1xuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgIGFyZyA9IE9wYWwudG9fYXJ5KGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKChibG9jay5sZW5ndGggPiAxIHx8IChoYXNfdHJhaWxpbmdfY29tbWEgJiYgYmxvY2subGVuZ3RoID09PSAxKSkgJiYgYXJnLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGZvciA+IDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZFggPSBmdW5jdGlvbihibG9jaywgYXJncykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzX2FyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXG4gIC8vIGJlIGEgdmFsdWUsIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gIE9wYWwucmVzY3VlID0gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYW5kaWRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPcGFsLnJlc2N1ZShleGNlcHRpb24sIGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZSA9PT0gT3BhbC5KUy5FcnJvcikge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlWyckPT09J10oZXhjZXB0aW9uKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE9wYWwuaXNfYSA9IGZ1bmN0aW9uKG9iamVjdCwga2xhc3MpIHtcbiAgICBpZiAoa2xhc3MgIT0gbnVsbCAmJiBvYmplY3QuJCRtZXRhID09PSBrbGFzcyB8fCBvYmplY3QuJCRjbGFzcyA9PT0ga2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuJCRpc19udW1iZXIgJiYga2xhc3MuJCRpc19udW1iZXJfY2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpLCBsZW5ndGgsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG9iamVjdC4kJGlzX2NsYXNzID8gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iamVjdCkgOiAob2JqZWN0LiQkbWV0YSB8fCBvYmplY3QuJCRjbGFzcykpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBrbGFzcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gSGVscGVycyBmb3IgZXh0cmFjdGluZyBrd3NwbGF0c1xuICAvLyBVc2VkIGZvcjogeyAqKmggfVxuICBPcGFsLnRvX2hhc2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBoYXNoID0gdmFsdWUuJHRvX2hhc2goKTtcbiAgICAgIGlmIChoYXNoLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEhhc2ggKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2hhc2ggZ2l2ZXMgXCIgKyBoYXNoLiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIgaW50byBIYXNoXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBpbXBsZW1lbnRpbmcgbXVsdGlwbGUgYXNzaWdubWVudFxuICAvLyBPdXIgY29kZSBmb3IgZXh0cmFjdGluZyB0aGUgdmFsdWVzIGFuZCBhc3NpZ25pbmcgdGhlbSBvbmx5IHdvcmtzIGlmIHRoZVxuICAvLyByZXR1cm4gdmFsdWUgaXMgYSBKUyBhcnJheS5cbiAgLy8gU28gaWYgd2UgZ2V0IGFuIEFycmF5IHN1YmNsYXNzLCBleHRyYWN0IHRoZSB3cmFwcGVkIEpTIGFycmF5IGZyb20gaXRcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9IHNvbWV0aGluZyAobm8gc3BsYXQpXG4gIE9wYWwudG9fYXJ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2FyeScsIHRydWUpKSB7XG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2FyeSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hcnkgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSAqc29tZXRoaW5nICh3aXRoIHNwbGF0KVxuICBPcGFsLnRvX2EgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAvLyBBIHNwbGF0dGVkIGFycmF5IG11c3QgYmUgY29waWVkXG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19hJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hIGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgZm9yIGV4dHJhY3Rpbmcga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gIC8vIEpTIGZ1bmN0aW9uLiBJZiBwcm92aWRlZCArYXJndW1lbnRzKyBsaXN0IGRvZXNuJ3QgaGF2ZSBhIEhhc2hcbiAgLy8gYXMgYSBsYXN0IGl0ZW0sIHJldHVybnMgYSBibGFuayBIYXNoLlxuICAvL1xuICAvLyBAcGFyYW0gcGFyYW1ldGVycyBbQXJyYXldXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwuZXh0cmFjdF9rd2FyZ3MgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIGt3YXJncyA9IHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoa3dhcmdzICE9IG51bGwgJiYga3dhcmdzWyckcmVzcG9uZF90bz8nXSgndG9faGFzaCcsIHRydWUpKSB7XG4gICAgICAkc3BsaWNlLmNhbGwocGFyYW1ldGVycywgcGFyYW1ldGVycy5sZW5ndGggLSAxLCAxKTtcbiAgICAgIHJldHVybiBrd2FyZ3MuJHRvX2hhc2goKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5oYXNoMihbXSwge30pO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIHRvIGdldCBhIGxpc3Qgb2YgcmVzdCBrZXl3b3JkIGFyZ3VtZW50cy4gTWV0aG9kIHRha2VzIHRoZSBnaXZlblxuICAvLyBrZXl3b3JkIGFyZ3MsIGkuZS4gdGhlIGhhc2ggbGl0ZXJhbCBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjb250YWluaW5nIGFsbFxuICAvLyBrZXl3b3JkIGFyZ3VlbW50cyBwYXNzZWQgdG8gbWV0aG9kLCBhcyB3ZWxsIGFzIHRoZSB1c2VkIGFyZ3Mgd2hpY2ggYXJlXG4gIC8vIHRoZSBuYW1lcyBvZiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgYXJndW1lbnRzIGRlZmluZWQuIFRoaXMgbWV0aG9kIHRoZW5cbiAgLy8ganVzdCByZXR1cm5zIGFsbCBrZXkvdmFsdWUgcGFpcnMgd2hpY2ggaGF2ZSBub3QgYmVlbiB1c2VkLCBpbiBhIG5ld1xuICAvLyBoYXNoIGxpdGVyYWwuXG4gIC8vXG4gIC8vIEBwYXJhbSBnaXZlbl9hcmdzIFtIYXNoXSBhbGwga3dhcmdzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gdXNlZF9hcmdzIFtPYmplY3Q8U3RyaW5nOiB0cnVlPl0gYWxsIGtleXMgdXNlZCBhcyBuYW1lZCBrd2FyZ3NcbiAgLy8gQHJldHVybiBbSGFzaF1cbiAgLy9cbiAgT3BhbC5rd3Jlc3RhcmdzID0gZnVuY3Rpb24oZ2l2ZW5fYXJncywgdXNlZF9hcmdzKSB7XG4gICAgdmFyIGtleXMgICAgICA9IFtdLFxuICAgICAgICBtYXAgICAgICAgPSB7fSxcbiAgICAgICAga2V5ICAgICAgICAgICAsXG4gICAgICAgIGdpdmVuX21hcCA9IGdpdmVuX2FyZ3MuJCRzbWFwO1xuXG4gICAgZm9yIChrZXkgaW4gZ2l2ZW5fbWFwKSB7XG4gICAgICBpZiAoIXVzZWRfYXJnc1trZXldKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBtYXBba2V5XSA9IGdpdmVuX21hcFtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmhhc2gyKGtleXMsIG1hcCk7XG4gIH07XG5cbiAgLy8gQ2FsbHMgcGFzc2VkIG1ldGhvZCBvbiBhIHJ1Ynkgb2JqZWN0IHdpdGggYXJndW1lbnRzIGFuZCBibG9jazpcbiAgLy9cbiAgLy8gQ2FuIHRha2UgYSBtZXRob2Qgb3IgYSBtZXRob2QgbmFtZS5cbiAgLy9cbiAgLy8gMS4gV2hlbiBtZXRob2QgbmFtZSBnZXRzIHBhc3NlZCBpdCBpbnZva2VzIGl0IGJ5IGl0cyBuYW1lXG4gIC8vICAgIGFuZCBjYWxscyAnbWV0aG9kX21pc3NpbmcnIHdoZW4gb2JqZWN0IGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZC5cbiAgLy8gICAgVXNlZCBpbnRlcm5hbGx5IGJ5IE9wYWwgdG8gaW52b2tlIG1ldGhvZCB0aGF0IHRha2VzIGEgYmxvY2sgb3IgYSBzcGxhdC5cbiAgLy8gMi4gV2hlbiBtZXRob2QgKGkuZS4gbWV0aG9kIGJvZHkpIGdldHMgcGFzc2VkLCBpdCBkb2Vzbid0IHRyaWdnZXIgJ21ldGhvZF9taXNzaW5nJ1xuICAvLyAgICBiZWNhdXNlIGl0IGRvZXNuJ3Qga25vdyB0aGUgbmFtZSBvZiB0aGUgYWN0dWFsIG1ldGhvZC5cbiAgLy8gICAgVXNlZCBpbnRlcm5hbGx5IGJ5IE9wYWwgdG8gaW52b2tlICdzdXBlcicuXG4gIC8vXG4gIC8vIEBleGFtcGxlXG4gIC8vICAgdmFyIG15X2FycmF5ID0gWzEsIDIsIDMsIDRdXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCAnbGVuZ3RoJykgICAgICAgICAgICAgICAgICAgICMgPT4gNFxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgbXlfYXJyYXkuJGxlbmd0aCkgICAgICAgICAgICAjID0+IDRcbiAgLy9cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksICdyZXZlcnNlIScpICAgICAgICAgICAgICAgICAgIyA9PiBbNCwgMywgMiwgMV1cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksIG15X2FycmF5WyckcmV2ZXJzZSEnXScpICAgICAgIyA9PiBbNCwgMywgMiwgMV1cbiAgLy9cbiAgLy8gQHBhcmFtIHJlY3YgW09iamVjdF0gcnVieSBvYmplY3RcbiAgLy8gQHBhcmFtIG1ldGhvZCBbRnVuY3Rpb24sIFN0cmluZ10gbWV0aG9kIGJvZHkgb3IgbmFtZSBvZiB0aGUgbWV0aG9kXG4gIC8vIEBwYXJhbSBhcmdzIFtBcnJheV0gYXJndW1lbnRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsXG4gIC8vIEBwYXJhbSBibG9jayBbRnVuY3Rpb25dIHJ1YnkgYmxvY2tcbiAgLy8gQHJldHVybiBbT2JqZWN0XSByZXR1cm5pbmcgdmFsdWUgb2YgdGhlIG1ldGhvZCBjYWxsXG4gIE9wYWwuc2VuZCA9IGZ1bmN0aW9uKHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2spIHtcbiAgICB2YXIgYm9keSA9ICh0eXBlb2YobWV0aG9kKSA9PT0gJ3N0cmluZycpID8gcmVjdlsnJCcrbWV0aG9kXSA6IG1ldGhvZDtcblxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm9keS4kJHAgPSBibG9jaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBib2R5LmFwcGx5KHJlY3YsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiByZWN2LiRtZXRob2RfbWlzc2luZy5hcHBseShyZWN2LCBbbWV0aG9kXS5jb25jYXQoYXJncykpO1xuICB9O1xuXG4gIE9wYWwubGFtYmRhID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgICBibG9jay4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9O1xuXG4gIC8vIFVzZWQgdG8gZGVmaW5lIG1ldGhvZHMgb24gYW4gb2JqZWN0LiBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCwgdXNlZCBieSB0aGVcbiAgLy8gY29tcGlsZWQgc291cmNlIHRvIGRlZmluZSBtZXRob2RzIG9uIHNwZWNpYWwgY2FzZSBvYmplY3RzIHdoZW4gdGhlIGNvbXBpbGVyXG4gIC8vIGNhbiBub3QgZGV0ZXJtaW5lIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QsIG9yIHRoZSBvYmplY3QgaXMgYSBNb2R1bGVcbiAgLy8gaW5zdGFuY2UuIFRoaXMgY2FuIGdldCBjYWxsZWQgYnkgYE1vZHVsZSNkZWZpbmVfbWV0aG9kYCBhcyB3ZWxsLlxuICAvL1xuICAvLyAjIyBNb2R1bGVzXG4gIC8vXG4gIC8vIEFueSBtZXRob2QgZGVmaW5lZCBvbiBhIG1vZHVsZSB3aWxsIGNvbWUgdGhyb3VnaCB0aGlzIHJ1bnRpbWUgaGVscGVyLlxuICAvLyBUaGUgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBtb2R1bGUgYm9keSwgYW5kIHRoZSBvd25lciBvZiB0aGUgbWV0aG9kIGlzXG4gIC8vIHNldCB0byBiZSB0aGUgbW9kdWxlIGl0c2VsZi4gVGhpcyBpcyB1c2VkIGxhdGVyIHdoZW4gY2hvb3Npbmcgd2hpY2hcbiAgLy8gbWV0aG9kIHNob3VsZCBzaG93IG9uIGEgY2xhc3MgaWYgbW9yZSB0aGFuIDEgaW5jbHVkZWQgbW9kdWxlcyBkZWZpbmVcbiAgLy8gdGhlIHNhbWUgbWV0aG9kLiBGaW5hbGx5LCBpZiB0aGUgbW9kdWxlIGlzIGluIGBtb2R1bGVfZnVuY3Rpb25gIG1vZGUsXG4gIC8vIHRoZW4gdGhlIG1ldGhvZCBpcyBhbHNvIGRlZmluZWQgb250byB0aGUgbW9kdWxlIGl0c2VsZi5cbiAgLy9cbiAgLy8gIyMgQ2xhc3Nlc1xuICAvL1xuICAvLyBUaGlzIGhlbHBlciB3aWxsIG9ubHkgYmUgY2FsbGVkIGZvciBjbGFzc2VzIHdoZW4gYSBtZXRob2QgaXMgYmVpbmdcbiAgLy8gZGVmaW5lZCBpbmRpcmVjdGx5OyBlaXRoZXIgdGhyb3VnaCBgTW9kdWxlI2RlZmluZV9tZXRob2RgLCBvciBieSBhXG4gIC8vIGxpdGVyYWwgYGRlZmAgbWV0aG9kIGluc2lkZSBhbiBgaW5zdGFuY2VfZXZhbGAgb3IgYGNsYXNzX2V2YWxgIGJvZHkuIEluXG4gIC8vIGVpdGhlciBjYXNlLCB0aGUgbWV0aG9kIGlzIHNpbXBseSBhZGRlZCB0byB0aGUgY2xhc3MnIHByb3RvdHlwZS4gQSBzcGVjaWFsXG4gIC8vIGV4Y2VwdGlvbiBleGlzdHMgZm9yIGBCYXNpY09iamVjdGAgYW5kIGBPYmplY3RgLiBUaGVzZSB0d28gY2xhc3NlcyBhcmVcbiAgLy8gc3BlY2lhbCBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgaW4gdG9sbC1mcmVlIGJyaWRnZWQgY2xhc3Nlcy4gSW4gZWFjaCBvZlxuICAvLyB0aGVzZSB0d28gY2FzZXMsIGV4dHJhIHdvcmsgaXMgcmVxdWlyZWQgdG8gZGVmaW5lIHRoZSBtZXRob2RzIG9uIHRvbGwtZnJlZVxuICAvLyBicmlkZ2VkIGNsYXNzJyBwcm90b3R5cGVzIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE9iamVjdHNcbiAgLy9cbiAgLy8gSWYgYSBzaW1wbGUgcnVieSBvYmplY3QgaXMgdGhlIG9iamVjdCwgdGhlbiB0aGUgbWV0aG9kIGlzIHNpbXBseSBqdXN0XG4gIC8vIGRlZmluZWQgb24gdGhlIG9iamVjdCBhcyBhIHNpbmdsZXRvbiBtZXRob2QuIFRoaXMgd291bGQgYmUgdGhlIGNhc2Ugd2hlblxuICAvLyBhIG1ldGhvZCBpcyBkZWZpbmVkIGluc2lkZSBhbiBgaW5zdGFuY2VfZXZhbGAgYmxvY2suXG4gIC8vXG4gIC8vIEBwYXJhbSBvYmogIFtPYmplY3QsIENsYXNzXSB0aGUgYWN0dWFsIG9iaiB0byBkZWZpbmUgbWV0aG9kIGZvclxuICAvLyBAcGFyYW0ganNpZCBbU3RyaW5nXSB0aGUgSmF2YVNjcmlwdCBmcmllbmRseSBtZXRob2QgbmFtZSAoZS5nLiAnJGZvbycpXG4gIC8vIEBwYXJhbSBib2R5IFtKUy5GdW5jdGlvbl0gdGhlIGxpdGVyYWwgSmF2YVNjcmlwdCBmdW5jdGlvbiB1c2VkIGFzIG1ldGhvZFxuICAvLyBAcmV0dXJuIFtudWxsXVxuICAvL1xuICBPcGFsLmRlZiA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBtZXRob2QgZGVmaW5pdGlvbiBpbiB0aGVcbiAgICAvLyB0b3AtbGV2ZWwgbmFtZXNwYWNlXG4gICAgaWYgKG9iaiA9PT0gT3BhbC50b3ApIHtcbiAgICAgIE9wYWwuZGVmbihPcGFsLk9iamVjdCwganNpZCwgYm9keSlcbiAgICB9XG4gICAgLy8gaWYgaW5zdGFuY2VfZXZhbCBpcyBpbnZva2VkIG9uIGEgbW9kdWxlL2NsYXNzLCBpdCBzZXRzIGluc3RfZXZhbF9tb2RcbiAgICBlbHNlIGlmICghb2JqLiQkZXZhbCAmJiBvYmouJCRpc19hX21vZHVsZSkge1xuICAgICAgT3BhbC5kZWZuKG9iaiwganNpZCwgYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgT3BhbC5kZWZzKG9iaiwganNpZCwgYm9keSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERlZmluZSBtZXRob2Qgb24gYSBtb2R1bGUgb3IgY2xhc3MgKHNlZSBPcGFsLmRlZikuXG4gIE9wYWwuZGVmbiA9IGZ1bmN0aW9uKG1vZHVsZSwganNpZCwgYm9keSkge1xuICAgIGJvZHkuZGlzcGxheU5hbWUgPSBqc2lkO1xuICAgIGJvZHkuJCRvd25lciA9IG1vZHVsZTtcblxuICAgIHZhciBwcm90byA9IG1vZHVsZS4kJHByb3RvdHlwZTtcbiAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgIH1cbiAgICAkZGVmaW5lUHJvcGVydHkocHJvdG8sIGpzaWQsIGJvZHkpO1xuXG4gICAgaWYgKG1vZHVsZS4kJGlzX21vZHVsZSkge1xuICAgICAgaWYgKG1vZHVsZS4kJG1vZHVsZV9mdW5jdGlvbikge1xuICAgICAgICBPcGFsLmRlZnMobW9kdWxlLCBqc2lkLCBib2R5KVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWNsYXNzZXMgPSBtb2R1bGUuJCRpY2xhc3NlcywgbGVuZ3RoID0gaWNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGljbGFzcyA9IGljbGFzc2VzW2ldO1xuICAgICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCBqc2lkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2luZ2xldG9uX29mID0gbW9kdWxlLiQkc2luZ2xldG9uX29mO1xuICAgIGlmIChtb2R1bGUuJG1ldGhvZF9hZGRlZCAmJiAhbW9kdWxlLiRtZXRob2RfYWRkZWQuJCRzdHViICYmICFzaW5nbGV0b25fb2YpIHtcbiAgICAgIG1vZHVsZS4kbWV0aG9kX2FkZGVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2luZ2xldG9uX29mICYmIHNpbmdsZXRvbl9vZi4kc2luZ2xldG9uX21ldGhvZF9hZGRlZCAmJiAhc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkLiQkc3R1Yikge1xuICAgICAgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIGEgc2luZ2xldG9uIG1ldGhvZCBvbiB0aGUgZ2l2ZW4gb2JqZWN0IChzZWUgT3BhbC5kZWYpLlxuICBPcGFsLmRlZnMgPSBmdW5jdGlvbihvYmosIGpzaWQsIGJvZHkpIHtcbiAgICBpZiAob2JqLiQkaXNfc3RyaW5nIHx8IG9iai4kJGlzX251bWJlcikge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcImNhbid0IGRlZmluZSBzaW5nbGV0b25cIik7XG4gICAgfVxuICAgIE9wYWwuZGVmbihPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwganNpZCwgYm9keSlcbiAgfTtcblxuICAvLyBDYWxsZWQgZnJvbSAjcmVtb3ZlX21ldGhvZC5cbiAgT3BhbC5yZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCEkaGFzT3duLmNhbGwob2JqLiQkcHJvdG90eXBlLCBqc2lkKSkge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb2JqLiQkcHJvdG90eXBlW2pzaWRdO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xuICAgIHJldHVybiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKTtcbiAgfVxuXG4gIE9wYWwuYWxpYXMgPSBmdW5jdGlvbihvYmosIG5hbWUsIG9sZCkge1xuICAgIHZhciBpZCAgICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBvbGRfaWQgPSAnJCcgKyBvbGQsXG4gICAgICAgIGJvZHkgICA9IG9iai4kJHByb3RvdHlwZVsnJCcgKyBvbGRdLFxuICAgICAgICBhbGlhcztcblxuICAgIC8vIFdoZW4gcnVubmluZyBpbnNpZGUgI2luc3RhbmNlX2V2YWwgdGhlIGFsaWFzIHJlZmVycyB0byBjbGFzcyBtZXRob2RzLlxuICAgIGlmIChvYmouJCRldmFsKSB7XG4gICAgICByZXR1cm4gT3BhbC5hbGlhcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwgbmFtZSwgb2xkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBvYmouJCRzdXBlcjtcblxuICAgICAgd2hpbGUgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiICYmIGFuY2VzdG9yKSB7XG4gICAgICAgIGJvZHkgICAgID0gYW5jZXN0b3Jbb2xkX2lkXTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci4kJHN1cGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpICYmIG9iai4kJGlzX21vZHVsZSkge1xuICAgICAgICAvLyB0cnkgdG8gbG9vayBpbnRvIE9iamVjdFxuICAgICAgICBib2R5ID0gT3BhbC5PYmplY3QuJCRwcm90b3R5cGVbb2xkX2lkXVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBcIiArIG9sZCArIFwiJyBmb3IgY2xhc3MgYFwiICsgb2JqLiRuYW1lKCkgKyBcIidcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYm9keSBpcyBpdHNlbGYgYW4gYWxpYXMgdXNlIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgLy8gdG8ga2VlcCB0aGUgbWF4IGRlcHRoIGF0IDEuXG4gICAgaWYgKGJvZHkuJCRhbGlhc19vZikgYm9keSA9IGJvZHkuJCRhbGlhc19vZjtcblxuICAgIC8vIFdlIG5lZWQgYSB3cmFwcGVyIGJlY2F1c2Ugb3RoZXJ3aXNlIHByb3BlcnRpZXNcbiAgICAvLyB3b3VsZCBiZSBvdnJld3JpdHRlbiBvbiB0aGUgb3JpZ2luYWwgYm9keS5cbiAgICBhbGlhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsb2NrID0gYWxpYXMuJCRwLCBhcmdzLCBpLCBpaTtcblxuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT0gbnVsbCkgeyBhbGlhcy4kJHAgPSBudWxsIH1cblxuICAgICAgcmV0dXJuIE9wYWwuc2VuZCh0aGlzLCBib2R5LCBhcmdzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIFRyeSB0byBtYWtlIHRoZSBicm93c2VyIHBpY2sgdGhlIHJpZ2h0IG5hbWVcbiAgICBhbGlhcy5kaXNwbGF5TmFtZSAgICAgICA9IG5hbWU7XG4gICAgYWxpYXMubGVuZ3RoICAgICAgICAgICAgPSBib2R5Lmxlbmd0aDtcbiAgICBhbGlhcy4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eTtcbiAgICBhbGlhcy4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIGFsaWFzLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgICAgICA9IGJvZHk7XG4gICAgYWxpYXMuJCRhbGlhc19uYW1lICAgICAgPSBuYW1lO1xuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGFsaWFzKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19uYXRpdmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIG5hdGl2ZV9uYW1lKSB7XG4gICAgdmFyIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW25hdGl2ZV9uYW1lXTtcblxuICAgIGlmICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiB8fCBib2R5LiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBuYXRpdmUgbWV0aG9kIGBcIiArIG5hdGl2ZV9uYW1lICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBib2R5KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cblxuICAvLyBIYXNoZXNcbiAgLy8gLS0tLS0tXG5cbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC4kJHNtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IFtdO1xuICB9O1xuXG4gIE9wYWwuaGFzaF9jbG9uZSA9IGZ1bmN0aW9uKGZyb21faGFzaCwgdG9faGFzaCkge1xuICAgIHRvX2hhc2guJCRub25lID0gZnJvbV9oYXNoLiQkbm9uZTtcbiAgICB0b19oYXNoLiQkcHJvYyA9IGZyb21faGFzaC4kJHByb2M7XG5cbiAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IGZyb21faGFzaC4kJGtleXMsIHNtYXAgPSBmcm9tX2hhc2guJCRzbWFwLCBsZW4gPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICB9XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9wdXQgPSBmdW5jdGlvbihoYXNoLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgaGFzaC4kJGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgaGFzaC4kJHNtYXBba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0LCBsYXN0X2J1Y2tldDtcbiAgICBrZXlfaGFzaCA9IGhhc2guJCRieV9pZGVudGl0eSA/IE9wYWwuaWQoa2V5KSA6IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICBidWNrZXQgPSB7a2V5OiBrZXksIGtleV9oYXNoOiBrZXlfaGFzaCwgdmFsdWU6IHZhbHVlfTtcbiAgICAgIGhhc2guJCRrZXlzLnB1c2goYnVja2V0KTtcbiAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gYnVja2V0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJ1Y2tldC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICBidWNrZXQgPSB7a2V5OiBrZXksIGtleV9oYXNoOiBrZXlfaGFzaCwgdmFsdWU6IHZhbHVlfTtcbiAgICAgIGhhc2guJCRrZXlzLnB1c2goYnVja2V0KTtcbiAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQ7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9nZXQgPSBmdW5jdGlvbihoYXNoLCBrZXkpIHtcbiAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICBpZiAoJGhhc093bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0O1xuICAgIGtleV9oYXNoID0gaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoJGhhc093bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgICByZXR1cm4gYnVja2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZGVsZXRlID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgdmFyIGksIGtleXMgPSBoYXNoLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIHZhbHVlO1xuXG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGtleXNbaV0gPT09IGtleSkge1xuICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaGFzaC4kJHNtYXBba2V5XTtcbiAgICAgIGRlbGV0ZSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCA9IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdLCBsYXN0X2J1Y2tldDtcblxuICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgIHZhbHVlID0gYnVja2V0LnZhbHVlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXlzW2ldID09PSBidWNrZXQpIHtcbiAgICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RfYnVja2V0ICYmIGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgICAgZGVsZXRlIGxhc3RfYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9yZWhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGhhc2guJCRrZXlzLmxlbmd0aCwga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICBpZiAoaGFzaC4kJGtleXNbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGtleV9oYXNoID0gaGFzaC4kJGtleXNbaV0ua2V5LiRoYXNoKCk7XG5cbiAgICAgIGlmIChrZXlfaGFzaCA9PT0gaGFzaC4kJGtleXNbaV0ua2V5X2hhc2gpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdO1xuICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PT0gaGFzaC4kJGtleXNbaV0pIHtcbiAgICAgICAgICBpZiAobGFzdF9idWNrZXQgJiYgYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXN0X2J1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChidWNrZXQubmV4dCkge1xuICAgICAgICAgICAgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF0gPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaGFzaC4kJGtleXNbaV0ua2V5X2hhc2ggPSBrZXlfaGFzaDtcblxuICAgICAgaWYgKCEkaGFzT3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gaGFzaC4kJGtleXNbaV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChidWNrZXQgPT09IGhhc2guJCRrZXlzW2ldKSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGhhc2guJCRrZXlzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJndW1lbnRzX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MsIGhhc2gsIGksIGxlbmd0aCwga2V5LCB2YWx1ZTtcblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcbiAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXS4kJGlzX2FycmF5KSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJnc1tpXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcInZhbHVlIG5vdCBvZiBsZW5ndGggMjogXCIgKyBhcmdzW2ldLiRpbnNwZWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gYXJnc1tpXVswXTtcbiAgICAgICAgdmFsdWUgPSBhcmdzW2ldWzFdO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yIChrZXkgaW4gYXJncykge1xuICAgICAgICBpZiAoJGhhc093bi5jYWxsKGFyZ3MsIGtleSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcIm9kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHNfbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBBIGZhc3RlciBIYXNoIGNyZWF0b3IgZm9yIGhhc2hlcyB0aGF0IGp1c3QgdXNlIHN5bWJvbHMgYW5kXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcbiAgLy8gY29tcGlsZSB0aW1lLCBzbyB0aGV5IGFyZSBqdXN0IGFkZGVkIGhlcmUgYnkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICBPcGFsLmhhc2gyID0gZnVuY3Rpb24oa2V5cywgc21hcCkge1xuICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgaGFzaC4kJHNtYXAgPSBzbWFwO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IGtleXM7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgcmFuZ2UgaW5zdGFuY2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCB2YWx1ZXMsIGFuZCB3aGV0aGVyIHRoZVxuICAvLyByYW5nZSBleGNsdWRlcyB0aGUgbGFzdCB2YWx1ZS5cbiAgLy9cbiAgT3BhbC5yYW5nZSA9IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBleGMpIHtcbiAgICB2YXIgcmFuZ2UgICAgICAgICA9IG5ldyBPcGFsLlJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmJlZ2luICAgPSBmaXJzdDtcbiAgICAgICAgcmFuZ2UuZW5kICAgICA9IGxhc3Q7XG4gICAgICAgIHJhbmdlLmV4Y2wgICAgPSBleGM7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBpdmFyIG5hbWUgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgLy8gTW9zdGx5IGFkZHMgYSB0cmFpbGluZyAkIHRvIHJlc2VydmVkIG5hbWVzLlxuICAvL1xuICBPcGFsLml2YXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgIG5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICBuYW1lID09PSBcImRpc3BsYXlOYW1lXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX2NvdW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fbm9TdWNoTWV0aG9kX19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcGFyZW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8XG5cbiAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICBuYW1lID09PSBcImhhc093blByb3BlcnR5XCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJ2YWx1ZU9mXCJcbiAgICAgICApXG4gICAge1xuICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuXG4gIC8vIFJlZ2V4cHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEVzY2FwZSBSZWdleHAgc3BlY2lhbCBjaGFycyBsZXR0aW5nIHRoZSByZXN1bHRpbmcgc3RyaW5nIGJlIHVzZWQgdG8gYnVpbGRcbiAgLy8gYSBuZXcgUmVnZXhwLlxuICAvL1xuICBPcGFsLmVzY2FwZV9yZWdleHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLVtcXF1cXC97fSgpKis/Ll4kXFxcXHwgXSkvZywgJ1xcXFwkMScpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxuXS9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xccl0vZywgJ1xcXFxyJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXGZdL2csICdcXFxcZicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx0XS9nLCAnXFxcXHQnKTtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgcmV0dXJuIHBhdHRlcm47IC8vIFJlZ0V4cCBhbHJlYWR5IGhhcyB0aGUgZ2xvYmFsIGZsYWdcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uJCRnID09IG51bGwpIHtcbiAgICAgIHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4ubXVsdGlsaW5lID8gJ2dtJyA6ICdnJykgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybi4kJGcubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuLiQkZztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgbXVsdGlsaW5lIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnbSBvciAkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChwYXR0ZXJuLm11bHRpbGluZSkge1xuICAgICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBhbmQgbXVsdGlsaW5lIGZsYWdcbiAgICAgIH1cbiAgICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgJCRnIGF0dHJpYnV0ZSBiZWNhdXNlIHRoZSBSZWdleHAgaXMgYWxyZWFkeSBtdWx0aWxpbmVcbiAgICAgIGlmIChwYXR0ZXJuLiQkZyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJuLiQkZ20gIT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZ20gPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgfVxuICAgIHJlc3VsdC5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJlcXVpcmUgc3lzdGVtXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgT3BhbC5tb2R1bGVzICAgICAgICAgPSB7fTtcbiAgT3BhbC5sb2FkZWRfZmVhdHVyZXMgPSBbJ2NvcmVsaWIvcnVudGltZSddO1xuICBPcGFsLmN1cnJlbnRfZGlyICAgICA9ICcuJztcbiAgT3BhbC5yZXF1aXJlX3RhYmxlICAgPSB7J2NvcmVsaWIvcnVudGltZSc6IHRydWV9O1xuXG4gIE9wYWwubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHZhciBwYXJ0cywgcGFydCwgbmV3X3BhcnRzID0gW10sIFNFUEFSQVRPUiA9ICcvJztcblxuICAgIGlmIChPcGFsLmN1cnJlbnRfZGlyICE9PSAnLicpIHtcbiAgICAgIHBhdGggPSBPcGFsLmN1cnJlbnRfZGlyLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhdGg7XG4gICAgfVxuXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLlxcLy8sICcnKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC4ocmJ8b3BhbHxqcykkLywgJycpO1xuICAgIHBhcnRzID0gcGF0aC5zcGxpdChTRVBBUkFUT1IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSBjb250aW51ZTtcbiAgICAgIChwYXJ0ID09PSAnLi4nKSA/IG5ld19wYXJ0cy5wb3AoKSA6IG5ld19wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld19wYXJ0cy5qb2luKFNFUEFSQVRPUik7XG4gIH07XG5cbiAgT3BhbC5sb2FkZWQgPSBmdW5jdGlvbihwYXRocykge1xuICAgIHZhciBpLCBsLCBwYXRoO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGhzW2ldKTtcblxuICAgICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5sb2FkZWRfZmVhdHVyZXMucHVzaChwYXRoKTtcbiAgICAgIE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwubG9hZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XG5cbiAgICBPcGFsLmxvYWRlZChbcGF0aF0pO1xuXG4gICAgdmFyIG1vZHVsZSA9IE9wYWwubW9kdWxlc1twYXRoXTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIG1vZHVsZShPcGFsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2V2ZXJpdHkgPSBPcGFsLmNvbmZpZy5taXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk7XG4gICAgICB2YXIgbWVzc2FnZSAgPSAnY2Fubm90IGxvYWQgc3VjaCBmaWxlIC0tICcgKyBwYXRoO1xuXG4gICAgICBpZiAoc2V2ZXJpdHkgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBpZiAoT3BhbC5Mb2FkRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBPcGFsLkxvYWRFcnJvci4kbmV3KG1lc3NhZ2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbWVzc2FnZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZXZlcml0eSA9PT0gXCJ3YXJuaW5nXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBMb2FkRXJyb3I6ICcgKyBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBPcGFsLnJlcXVpcmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmxvYWQocGF0aCk7XG4gIH07XG5cblxuICAvLyBJbml0aWFsaXphdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiAkQmFzaWNPYmplY3QoKSB7fVxuICBmdW5jdGlvbiAkT2JqZWN0KCkge31cbiAgZnVuY3Rpb24gJE1vZHVsZSgpIHt9XG4gIGZ1bmN0aW9uICRDbGFzcygpIHt9XG5cbiAgT3BhbC5CYXNpY09iamVjdCA9IEJhc2ljT2JqZWN0ID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnQmFzaWNPYmplY3QnLCBudWxsLCAkQmFzaWNPYmplY3QpO1xuICBPcGFsLk9iamVjdCAgICAgID0gX09iamVjdCAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdPYmplY3QnLCBPcGFsLkJhc2ljT2JqZWN0LCAkT2JqZWN0KTtcbiAgT3BhbC5Nb2R1bGUgICAgICA9IE1vZHVsZSAgICAgID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnTW9kdWxlJywgT3BhbC5PYmplY3QsICRNb2R1bGUpO1xuICBPcGFsLkNsYXNzICAgICAgID0gQ2xhc3MgICAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdDbGFzcycsIE9wYWwuTW9kdWxlLCAkQ2xhc3MpO1xuXG4gICRzZXRQcm90b3R5cGUoT3BhbC5CYXNpY09iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRQcm90b3R5cGUoT3BhbC5PYmplY3QsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0UHJvdG90eXBlKE9wYWwuTW9kdWxlLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldFByb3RvdHlwZShPcGFsLkNsYXNzLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAvLyBCYXNpY09iamVjdCBjYW4gcmVhY2ggaXRzZWxmLCBhdm9pZCBjb25zdF9zZXQgdG8gc2tpcCB0aGUgJCRiYXNlX21vZHVsZSBsb2dpY1xuICBCYXNpY09iamVjdC4kJGNvbnN0W1wiQmFzaWNPYmplY3RcIl0gPSBCYXNpY09iamVjdDtcblxuICAvLyBBc3NpZ24gYmFzaWMgY29uc3RhbnRzXG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiQmFzaWNPYmplY3RcIiwgIEJhc2ljT2JqZWN0KTtcbiAgT3BhbC5jb25zdF9zZXQoX09iamVjdCwgXCJPYmplY3RcIiwgICAgICAgX09iamVjdCk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiTW9kdWxlXCIsICAgICAgIE1vZHVsZSk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiQ2xhc3NcIiwgICAgICAgIENsYXNzKTtcblxuICAvLyBGaXggYm9vdGVkIGNsYXNzZXMgdG8gaGF2ZSBjb3JyZWN0IC5jbGFzcyB2YWx1ZVxuICBCYXNpY09iamVjdC4kJGNsYXNzID0gQ2xhc3M7XG4gIF9PYmplY3QuJCRjbGFzcyAgICAgPSBDbGFzcztcbiAgTW9kdWxlLiQkY2xhc3MgICAgICA9IENsYXNzO1xuICBDbGFzcy4kJGNsYXNzICAgICAgID0gQ2xhc3M7XG5cbiAgLy8gRm9yd2FyZCAudG9TdHJpbmcoKSB0byAjdG9fc1xuICAkZGVmaW5lUHJvcGVydHkoX09iamVjdC4kJHByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvX3MgPSB0aGlzLiR0b19zKCk7XG4gICAgaWYgKHRvX3MuJCRpc19zdHJpbmcgJiYgdHlwZW9mKHRvX3MpID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gYSBzdHJpbmcgY3JlYXRlZCB1c2luZyBuZXcgU3RyaW5nKCdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRvX3MudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9fcztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ha2UgS2VybmVsI3JlcXVpcmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGFzIGl0J3MgbmVlZGVkIHRvIHJlcXVpcmUgYWxsIHRoZVxuICAvLyBvdGhlciBjb3JlbGliIGZpbGVzLlxuICAkZGVmaW5lUHJvcGVydHkoX09iamVjdC4kJHByb3RvdHlwZSwgJyRyZXF1aXJlJywgT3BhbC5yZXF1aXJlKTtcblxuICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAvLyBAZXhhbXBsZVxuICAvLyAgIE9wYWwuJCQuUmVnZXhwLiQkLklHTk9SRUNBU0VcbiAgT3BhbC4kJCA9IF9PYmplY3QuJCQ7XG5cbiAgLy8gSW5zdGFudGlhdGUgdGhlIG1haW4gb2JqZWN0XG4gIE9wYWwudG9wID0gbmV3IF9PYmplY3QoKTtcbiAgT3BhbC50b3AuJHRvX3MgPSBPcGFsLnRvcC4kaW5zcGVjdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ21haW4nIH07XG5cblxuICAvLyBOaWxcbiAgZnVuY3Rpb24gJE5pbENsYXNzKCkge31cbiAgT3BhbC5OaWxDbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ05pbENsYXNzJywgT3BhbC5PYmplY3QsICROaWxDbGFzcyk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsICdOaWxDbGFzcycsIE9wYWwuTmlsQ2xhc3MpO1xuICBuaWwgPSBPcGFsLm5pbCA9IG5ldyBPcGFsLk5pbENsYXNzKCk7XG4gIG5pbC4kJGlkID0gbmlsX2lkO1xuICBuaWwuY2FsbCA9IG5pbC5hcHBseSA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoJ25vIGJsb2NrIGdpdmVuJyk7IH07XG5cbiAgLy8gRXJyb3JzXG4gIE9wYWwuYnJlYWtlciAgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJlYWsgKG9sZCknKTtcbiAgT3BhbC5yZXR1cm5lciA9IG5ldyBFcnJvcigndW5leHBlY3RlZCByZXR1cm4nKTtcbiAgVHlwZUVycm9yLiQkc3VwZXIgPSBFcnJvcjtcbn0pLmNhbGwodGhpcyk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3J1bnRpbWUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUU7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRDtBQUNIO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDVTtBQUNBO0FBQ0E7QUFDQTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDEzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBPcGFsXG4gIGRlZiBzZWxmLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpXG4gICAgYE9wYWwuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QgPSBuaWwsIGNvZXJjZWQgPSBuaWwpXG4gICAgaWYgbWV0aG9kICYmIGNvZXJjZWRcbiAgICAgIFR5cGVFcnJvci5uZXcgXCJjYW4ndCBjb252ZXJ0ICN7b2JqZWN0LmNsYXNzfSBpbnRvICN7dHlwZX0gKCN7b2JqZWN0LmNsYXNzfSMje21ldGhvZH0gZ2l2ZXMgI3tjb2VyY2VkLmNsYXNzfSlcIlxuICAgIGVsc2VcbiAgICAgIFR5cGVFcnJvci5uZXcgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7b2JqZWN0LmNsYXNzfSBpbnRvICN7dHlwZX1cIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5jb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QpXG4gICAgcmV0dXJuIG9iamVjdCBpZiB0eXBlID09PSBvYmplY3RcblxuICAgIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICByYWlzZSB0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSlcbiAgICBlbmRcblxuICAgIG9iamVjdC5fX3NlbmRfXyBtZXRob2RcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvIShvYmplY3QsIHR5cGUsIG1ldGhvZClcbiAgICBjb2VyY2VkID0gY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90bz8ob2JqZWN0LCB0eXBlLCBtZXRob2QpXG4gICAgcmV0dXJuIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG5cbiAgICBjb2VyY2VkID0gY29lcmNlX3RvKG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuXG4gICAgcmV0dXJuIGlmIGNvZXJjZWQubmlsP1xuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIHR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlLCBtZXRob2QsIGNvZXJjZWQpXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuICAgIHJldHVybiBvYmplY3QgaWYgdHlwZSA9PT0gb2JqZWN0XG5cbiAgICBpZiBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICBvYmplY3QuX19zZW5kX18gbWV0aG9kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbXBhcmUoYSwgYilcbiAgICBjb21wYXJlID0gYSA8PT4gYlxuXG4gICAgaWYgYGNvbXBhcmUgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2EuY2xhc3N9IHdpdGggI3tiLmNsYXNzfSBmYWlsZWRcIlxuICAgIGVuZFxuXG4gICAgY29tcGFyZVxuICBlbmRcblxuICBkZWYgc2VsZi5kZXN0cnVjdHVyZShhcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cblxuICAgICAgICByZXR1cm4gYXJnc19hcnk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yZXNwb25kX3RvPyhvYmosIG1ldGhvZCwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iai5yZXNwb25kX3RvPyhtZXRob2QsIGluY2x1ZGVfYWxsKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbnNwZWN0X29iaihvYmopXG4gICAgYE9wYWwuaW5zcGVjdChvYmopYFxuICBlbmRcblxuICBkZWYgc2VsZi5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgdW5sZXNzIGAvXkBbYS16QS1aX11bYS16QS1aMC05X10qPyQvLnRlc3QobmFtZSlgXG4gICAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwiJyN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGBuYW1lLmxlbmd0aCA8IDMgfHwgbmFtZS5zbGljZSgwLDIpICE9PSAnQEAnYFxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcImAje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICBjb25zdF9uYW1lID0gT3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGNvbnN0X25hbWVbMF0gIT0gY29uc3RfbmFtZVswXS51cGNhc2VcbiAgICAgIHJhaXNlIE5hbWVFcnJvciwgXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7Y29uc3RfbmFtZX1cIlxuICAgIGVuZFxuXG4gICAgY29uc3RfbmFtZVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gICMgTWFyayBzb21lIG1ldGhvZHMgYXMgcHJpc3RpbmUgaW4gb3JkZXIgdG8gYXBwbHkgb3B0aW1pemF0aW9ucyB3aGVuIHRoZXlcbiAgIyBhcmUgc3RpbGwgaW4gdGhlaXIgb3JpZ2luYWwgZm9ybS4gVGhpcyBjb3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0b1xuICAjIHRoZSBgT3BhbC5kZWYoKWAgSlMgQVBJLCBidXQgZm9yIG5vdyBpdCB3aWxsIHN0YXkgbWFudWFsLlxuICAjXG4gICMgQGV4YW1wbGVcbiAgI1xuICAjICAgT3BhbC5wcmlzdGluZSBBcnJheSwgOmFsbG9jYXRlLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuICAjXG4gICMgICBjbGFzcyBBcnJheVxuICAjICAgICBkZWYgZHVwXG4gICMgICAgICAgJXh7XG4gICMgICAgICAgICBpZiAoXG4gICMgICAgICAgICAgIHNlbGYuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxuICAjICAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lXG4gICMgICAgICAgICApIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAjICAgICAgIH1cbiAgI1xuICAjICAgICAgIHN1cGVyXG4gICMgICAgIGVuZFxuICAjICAgZW5kXG4gICNcbiAgIyBAcGFyYW0gb3duZXJfY2xhc3MgW0NsYXNzXSB0aGUgY2xhc3Mgb3duaW5nIHRoZSBtZXRob2RzXG4gICMgQHBhcmFtIG1ldGhvZF9uYW1lcyBbQXJyYXk8U3ltYm9sPl0gdGhlIGxpc3Qgb2YgbWV0aG9kcyBuYW1lcyB0byBtYXJrXG4gICMgQHJldHVybiBbbmlsXVxuICBkZWYgc2VsZi5wcmlzdGluZShvd25lcl9jbGFzcywgKm1ldGhvZF9uYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBtZXRob2RfbmFtZSwgbWV0aG9kO1xuICAgICAgZm9yICh2YXIgaSA9IG1ldGhvZF9uYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZXRob2RfbmFtZSA9IG1ldGhvZF9uYW1lc1tpXTtcbiAgICAgICAgbWV0aG9kID0gb3duZXJfY2xhc3MuJCRwcm90b3R5cGVbJyQnK21ldGhvZF9uYW1lXTtcblxuICAgICAgICBpZiAobWV0aG9kICYmICFtZXRob2QuJCRzdHViKSB7XG4gICAgICAgICAgbWV0aG9kLiQkcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImJyaWRnZSIsInNlbGYiLCJ0eXBlX2Vycm9yIiwibWV0aG9kIiwiY29lcmNlZCIsIm5ldyIsIm9iamVjdCIsImNsYXNzIiwidHlwZSIsImNvZXJjZV90byIsIj09PSIsInJlc3BvbmRfdG8/IiwicmFpc2UiLCJfX3NlbmRfXyIsImNvZXJjZV90byEiLCJjb2VyY2VfdG8/IiwibmlsPyIsInRyeV9jb252ZXJ0IiwiY29tcGFyZSIsImEiLCI8PT4iLCJiIiwiZGVzdHJ1Y3R1cmUiLCJvYmoiLCJpbmNsdWRlX2FsbCIsImluc3BlY3Rfb2JqIiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJuYW1lIiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjb25zdF9uYW1lISIsImNvbnN0X25hbWUiLCJbXSIsIjAiLCIhPSIsInVwY2FzZSIsInByaXN0aW5l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bkIsRUF5SkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXpKRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQXlKaUMsTUFBQSwwQkF6SmpDO0FBQUE7QUEySkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQXBLQTtBQUFBLE1BcUtJLE9BQUEsR0FyS0o7QUF5SkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQXZKQTtBQURGcEMsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tb2R1bGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTW9kdWxlXG4gIGRlZiBzZWxmLmFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgbW9kdWxlID0gT3BhbC5hbGxvY2F0ZV9tb2R1bGUobmlsLCBmdW5jdGlvbigpe30pO1xuICAgICAgLy8gTGluayB0aGUgcHJvdG90eXBlIG9mIE1vZHVsZSBzdWJjbGFzc2VzXG4gICAgICBpZiAoc2VsZiAhPT0gT3BhbC5Nb2R1bGUpIE9iamVjdC5zZXRQcm90b3R5cGVPZihtb2R1bGUsIHNlbGYuJCRwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICBtb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuICBlbmRcblxuICBkZWYgPT09KG9iamVjdClcbiAgICByZXR1cm4gZmFsc2UgaWYgYG9iamVjdCA9PSBudWxsYFxuXG4gICAgYE9wYWwuaXNfYShvYmplY3QsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICB1bmxlc3MgTW9kdWxlID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnY29tcGFyZWQgd2l0aCBub24gY2xhc3MvbW9kdWxlJ1xuICAgIGVuZFxuXG4gICAgIyBjbGFzcyBjYW5ub3QgYmUgYSBkZXNjZW5kYW50IG9mIGl0c2VsZlxuICAgICV4e1xuICAgICAgdmFyIHdvcmtpbmcgPSBzZWxmLFxuICAgICAgICAgIGFuY2VzdG9ycyxcbiAgICAgICAgICBpLCBsZW5ndGg7XG5cbiAgICAgIGlmICh3b3JraW5nID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvdGhlciksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmIDwgb3RoZXJcbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgIG90aGVyIDwgc2VsZlxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmID4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgTW9kdWxlID09PSBvdGhlclxuICAgICAgcmV0dXJuIG5pbFxuICAgIGVuZFxuXG4gICAgbHQgPSBzZWxmIDwgb3RoZXJcbiAgICByZXR1cm4gbmlsIGlmIGx0Lm5pbD9cbiAgICBsdCA/IC0xIDogMVxuICBlbmRcblxuICBkZWYgYWxpYXNfbWV0aG9kKG5ld25hbWUsIG9sZG5hbWUpXG4gICAgYE9wYWwuYWxpYXMoc2VsZiwgbmV3bmFtZSwgb2xkbmFtZSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19uYXRpdmUobWlkLCBqc2lkID0gbWlkKVxuICAgIGBPcGFsLmFsaWFzX25hdGl2ZShzZWxmLCBtaWQsIGpzaWQpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYW5jZXN0b3JzXG4gICAgYE9wYWwuYW5jZXN0b3JzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYXBwZW5kX2ZlYXR1cmVzKGluY2x1ZGVyKVxuICAgIGBPcGFsLmFwcGVuZF9mZWF0dXJlcyhzZWxmLCBpbmNsdWRlcilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYXR0cl9hY2Nlc3NvcigqbmFtZXMpXG4gICAgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgZW5kXG5cbiAgYWxpYXMgYXR0ciBhdHRyX2FjY2Vzc29yXG5cbiAgZGVmIGF0dHJfcmVhZGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUsXG4gICAgICAgICAgICBpdmFyID0gT3BhbC5pdmFyKG5hbWUpO1xuXG4gICAgICAgIC8vIHRoZSBjbG9zdXJlIGhlcmUgaXMgbmVlZGVkIGJlY2F1c2UgbmFtZSB3aWxsIGNoYW5nZSBhdCB0aGUgbmV4dFxuICAgICAgICAvLyBjeWNsZSwgSSB3aXNoIHdlIGNvdWxkIHVzZSBsZXQuXG4gICAgICAgIHZhciBib2R5ID0gKGZ1bmN0aW9uKGl2YXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpdmFyXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaXZhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoaXZhcik7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkocHJvdG8sIGl2YXIsIG5pbCk7XG5cbiAgICAgICAgYm9keS4kJHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgYm9keS4kJGFyaXR5ID0gMDtcblxuICAgICAgICBPcGFsLmRlZm4oc2VsZiwgaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgYXR0cl93cml0ZXIoKm5hbWVzKVxuICAgICV4e1xuICAgICAgdmFyIHByb3RvID0gc2VsZi4kJHByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV0sXG4gICAgICAgICAgICBpZCAgID0gJyQnICsgbmFtZSArICc9JyxcbiAgICAgICAgICAgIGl2YXIgPSBPcGFsLml2YXIobmFtZSk7XG5cbiAgICAgICAgLy8gdGhlIGNsb3N1cmUgaGVyZSBpcyBuZWVkZWQgYmVjYXVzZSBuYW1lIHdpbGwgY2hhbmdlIGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIGN5Y2xlLCBJIHdpc2ggd2UgY291bGQgdXNlIGxldC5cbiAgICAgICAgdmFyIGJvZHkgPSAoZnVuY3Rpb24oaXZhcil7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tpdmFyXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoaXZhcik7XG5cbiAgICAgICAgYm9keS4kJHBhcmFtZXRlcnMgPSBbWydyZXEnXV07XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDE7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkocHJvdG8sIGl2YXIsIG5pbCk7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF1dG9sb2FkKGNvbnN0LCBwYXRoKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRhdXRvbG9hZCA9PSBudWxsKSBzZWxmLiQkYXV0b2xvYWQgPSB7fTtcbiAgICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICAgICAgc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XSA9ICN7cGF0aH07XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlc1xuICAgIGBPYmplY3Qua2V5cyhPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZilbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmluaXRpYWxpemVkIGNsYXNzIHZhcmlhYmxlICN7bmFtZX0gaW4gI3tzZWxmfVwiLCBuYW1lKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikuaGFzT3duUHJvcGVydHkobmFtZSlgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY2xhc3NfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAoT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICBkZWxldGUgc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvciwgXCJjYW5ub3QgcmVtb3ZlICN7bmFtZX0gZm9yICN7c2VsZn1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdGFudHMoaW5oZXJpdCA9IHRydWUpXG4gICAgYE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdGFudHMoaW5oZXJpdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIG5lc3RpbmcgPSAoc2VsZi4kJG5lc3RpbmcgfHwgW10pLmNvbmNhdChPcGFsLk9iamVjdCksXG4gICAgICAgICAgICBjb25zdGFudCwgY29uc3RhbnRzID0ge30sXG4gICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgZm9yIChjb25zdGFudCBpbiBuZXN0aW5nW2ldLiQkY29uc3QpIHtcbiAgICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLmNvbnN0YW50cyhzZWxmLCBpbmhlcml0KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubmVzdGluZ1xuICAgIGBzZWxmLiQkbmVzdGluZyB8fCBbXWBcbiAgZW5kXG5cbiAgIyBjaGVjayBmb3IgY29uc3RhbnQgd2l0aGluIGN1cnJlbnQgc2NvcGVcbiAgIyBpZiBpbmhlcml0IGlzIHRydWUgb3Igc2VsZiBpcyBPYmplY3QsIHdpbGwgYWxzbyBjaGVjayBhbmNlc3RvcnNcbiAgZGVmIGNvbnN0X2RlZmluZWQ/KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbc2VsZl0sIG1vZHVsZV9jb25zdGFudHMsIGksIGlpO1xuXG4gICAgICAvLyBBZGQgdXAgYW5jZXN0b3JzIGlmIGluaGVyaXQgaXMgdHJ1ZVxuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KE9wYWwuYW5jZXN0b3JzKHNlbGYpKTtcblxuICAgICAgICAvLyBBZGQgT2JqZWN0J3MgYW5jZXN0b3JzIGlmIGl0J3MgYSBtb2R1bGUg4oCTIG1vZHVsZXMgaGF2ZSBubyBhbmNlc3RvcnMgb3RoZXJ3aXNlXG4gICAgICAgIGlmIChzZWxmLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFtPcGFsLk9iamVjdF0pLmNvbmNhdChPcGFsLmFuY2VzdG9ycyhPcGFsLk9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG4gICAgICAgIGlmIChtb2R1bGUuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X2dldChuYW1lLCBpbmhlcml0ID0gdHJ1ZSlcbiAgICBuYW1lID0gT3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAobmFtZS5pbmRleE9mKCc6OicpID09PSAwICYmIG5hbWUgIT09ICc6Oicpe1xuICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgbmFtZS5pbmRleE9mKCc6OicpICE9IC0xICYmIG5hbWUgIT0gJzo6J2BcbiAgICAgIHJldHVybiBuYW1lLnNwbGl0KCc6OicpLmluamVjdChzZWxmKSB7IHxvLCBjfCBvLmNvbnN0X2dldChjKSB9XG4gICAgZW5kXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgIHJldHVybiAkJChbc2VsZl0sIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RfZ2V0X2xvY2FsKHNlbGYsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X21pc3NpbmcobmFtZSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBzZWxmLiQkYXV0b2xvYWRbbmFtZV07XG5cbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICBzZWxmLiRyZXF1aXJlKGZpbGUpO1xuXG4gICAgICAgICAgcmV0dXJuICN7Y29uc3RfZ2V0IG5hbWV9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVsbF9jb25zdF9uYW1lID0gc2VsZiA9PSBPYmplY3QgPyBuYW1lIDogXCIje3NlbGZ9Ojoje25hbWV9XCJcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmluaXRpYWxpemVkIGNvbnN0YW50ICN7ZnVsbF9jb25zdF9uYW1lfVwiLCBuYW1lKVxuICBlbmRcblxuICBkZWYgY29uc3Rfc2V0KG5hbWUsIHZhbHVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICBpZiBuYW1lICF+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQIHx8IG5hbWUuc3RhcnRfd2l0aD8oJzo6JylcbiAgICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIGBPcGFsLmNvbnN0X3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG5cbiAgICB2YWx1ZVxuICBlbmRcblxuICBkZWYgcHVibGljX2NvbnN0YW50KGNvbnN0X25hbWUpXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBtZXRob2QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBhIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGJsb2NrIHx8PSBjYXNlIG1ldGhvZFxuICAgICAgICAgICAgICB3aGVuIFByb2NcbiAgICAgICAgICAgICAgICBtZXRob2RcblxuICAgICAgICAgICAgICB3aGVuIE1ldGhvZFxuICAgICAgICAgICAgICAgIGAje21ldGhvZC50b19wcm9jfS4kJHVuYm91bmRgXG5cbiAgICAgICAgICAgICAgd2hlbiBVbmJvdW5kTWV0aG9kXG4gICAgICAgICAgICAgICAgLT4oKmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kID0gbWV0aG9kLmJpbmQoc2VsZilcbiAgICAgICAgICAgICAgICAgIGJvdW5kLmNhbGwoKmFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Jsb2NrLmNsYXNzfSAoZXhwZWN0ZWQgUHJvYy9NZXRob2QpXCJcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBpZCA9ICckJyArIG5hbWU7XG5cbiAgICAgIGJsb2NrLiQkanNpZCAgICAgICAgPSBuYW1lO1xuICAgICAgYmxvY2suJCRzICAgICAgICAgICA9IG51bGw7XG4gICAgICBibG9jay4kJGRlZiAgICAgICAgID0gYmxvY2s7XG4gICAgICBibG9jay4kJGRlZmluZV9tZXRoID0gdHJ1ZTtcblxuICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBibG9jayk7XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwucmRlZihzZWxmLCBcIiRcIiArIG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3M/XG4gICAgYCEhc2VsZi4kJGlzX3NpbmdsZXRvbmBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUoKm1vZHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5pbmNsdWRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZF9tb2R1bGVzXG4gICAgYE9wYWwuaW5jbHVkZWRfbW9kdWxlcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1vZClcbiAgICAleHtcbiAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpaSwgbW9kMiwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kMiA9IGFuY2VzdG9yc1tpXTtcbiAgICAgICAgaWYgKG1vZDIgPT09IG1vZCAmJiBtb2QyICE9PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX21ldGhvZChuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGggPSBzZWxmLiQkcHJvdG90eXBlWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgI3tuYW1lfScgZm9yIGNsYXNzIGAje3NlbGYubmFtZX0nXCIsIG5hbWUpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7VW5ib3VuZE1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGZ9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kcyhpbmNsdWRlX3N1cGVyID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgje09wYWwudHJ1dGh5PyhpbmNsdWRlX3N1cGVyKX0pIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuaW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZF9vYmplY3Qob2JqZWN0KVxuICBlbmRcblxuICBkZWYgbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfcmVtb3ZlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2V2YWwoKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcbiAgICAgIEtlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gT3BhbC5jb21waWxlIHN0cmluZywgY29tcGlsaW5nX29wdGlvbnNcbiAgICAgIGJsb2NrID0gS2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7XG4gICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbChjb21waWxlZCk7XG4gICAgICAgICAgfSkoc2VsZilcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICBLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3Muc2l6ZX0gZm9yIDApXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcblxcbiAgTk9URTpJZiB5b3Ugd2FudCB0byBlbmFibGUgcGFzc2luZyBhIFN0cmluZyBhcmd1bWVudCBwbGVhc2UgYWRkIFxcXCJyZXF1aXJlICdvcGFsLXBhcnNlcidcXFwiIHRvIHlvdXIgc2NyaXB0XFxuXCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIG9sZCA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBbc2VsZl0pO1xuICAgICAgYmxvY2suJCRzID0gb2xkO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgY2xhc3NfZXZhbCBtb2R1bGVfZXZhbFxuXG4gIGRlZiBtb2R1bGVfZXhlYygqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJ31cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGNsYXNzX2V4ZWMgbW9kdWxlX2V4ZWNcblxuICBkZWYgbWV0aG9kX2RlZmluZWQ/KG1ldGhvZClcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZi4kJHByb3RvdHlwZVsnJCcgKyBtZXRob2RdO1xuICAgICAgcmV0dXJuICghIWJvZHkpICYmICFib2R5LiQkc3R1YjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZnVuY3Rpb24oKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aCA9IG1ldGhvZHNbaV0sXG4gICAgICAgICAgICAgIGlkICAgPSAnJCcgKyBtZXRoLFxuICAgICAgICAgICAgICBmdW5jID0gc2VsZi4kJHByb3RvdHlwZVtpZF07XG5cbiAgICAgICAgICBPcGFsLmRlZnMoc2VsZiwgaWQsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkZnVsbF9uYW1lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGJhc2UgPSBzZWxmO1xuXG4gICAgICB3aGlsZSAoYmFzZSkge1xuICAgICAgICAvLyBHaXZlIHVwIGlmIGFueSBvZiB0aGUgYW5jZXN0b3JzIGlzIHVubmFtZWRcbiAgICAgICAgaWYgKGJhc2UuJCRuYW1lID09PSBuaWwgfHwgYmFzZS4kJG5hbWUgPT0gbnVsbCkgcmV0dXJuIG5pbDtcblxuICAgICAgICByZXN1bHQudW5zaGlmdChiYXNlLiQkbmFtZSk7XG5cbiAgICAgICAgYmFzZSA9IGJhc2UuJCRiYXNlX21vZHVsZTtcblxuICAgICAgICBpZiAoYmFzZSA9PT0gT3BhbC5PYmplY3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZSA9IHJlc3VsdC5qb2luKCc6OicpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByZXBlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICBpZiAobW9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMCwgZXhwZWN0ZWQgMSspJ31cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLnByZXBlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kX2ZlYXR1cmVzKHByZXBlbmRlcilcbiAgICAleHtcbiAgICAgIGlmICghc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7c2VsZi5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIE9wYWwucHJlcGVuZF9mZWF0dXJlcyhzZWxmLCBwcmVwZW5kZXIpXG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByZXBlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY29uc3QobmFtZSlcbiAgICBgT3BhbC5jb25zdF9yZW1vdmUoc2VsZiwgbmFtZSlgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgYE9wYWwuTW9kdWxlLiRuYW1lLmNhbGwoc2VsZilgIHx8IFwiIzwje2BzZWxmLiQkaXNfbW9kdWxlID8gJ01vZHVsZScgOiAnQ2xhc3MnYH06MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgZGVmIHVuZGVmX21ldGhvZCgqbmFtZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC51ZGVmKHNlbGYsIFwiJFwiICsgbmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIGNvbnN0cyA9IGNvbnN0YW50c1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBuYW1lICE9PSAnY29uc3RydWN0b3InICYmICEje2NvbnN0cy5pbmNsdWRlPyhgbmFtZWApfSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdAJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHN1cGVyXG4gICAgY29weS5jb3B5X2NsYXNzX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9jb25zdGFudHMoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3B5X2NsYXNzX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXIuJCRjdmFycykge1xuICAgICAgICBzZWxmLiQkY3ZhcnNbbmFtZV0gPSBvdGhlci4kJGN2YXJzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfY29uc3RhbnRzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIG5hbWUsIG90aGVyX2NvbnN0YW50cyA9IG90aGVyLiQkY29uc3Q7XG5cbiAgICAgIGZvciAobmFtZSBpbiBvdGhlcl9jb25zdGFudHMpIHtcbiAgICAgICAgT3BhbC5jb25zdF9zZXQoc2VsZiwgbmFtZSwgb3RoZXJfY29uc3RhbnRzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJhbGxvY2F0ZSIsInNlbGYiLCJpbml0aWFsaXplIiwiYmxvY2tfZ2l2ZW4/IiwibW9kdWxlX2V2YWwiLCJibG9jayIsIj09PSIsIjwiLCJvdGhlciIsInJhaXNlIiwiPD0iLCJlcXVhbD8iLCI+IiwiPj0iLCI8PT4iLCJsdCIsIm5pbD8iLCItMSIsIjEiLCJhbGlhc19tZXRob2QiLCJhbGlhc19uYXRpdmUiLCJtaWQiLCJhbmNlc3RvcnMiLCJhcHBlbmRfZmVhdHVyZXMiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJuYW1lcyIsImF0dHJfd3JpdGVyIiwiYXV0b2xvYWQiLCJjb25zdCQiLCJwYXRoIiwiY2xhc3NfdmFyaWFibGVzIiwiY2xhc3NfdmFyaWFibGVfZ2V0IiwibmFtZSIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwibmV3IiwiY2xhc3NfdmFyaWFibGVfc2V0IiwiY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8iLCJyZW1vdmVfY2xhc3NfdmFyaWFibGUiLCJjb25zdGFudHMiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwiY29uc3RfZ2V0IiwiaW5qZWN0Iiwic3BsaXQiLCJvIiwiYyIsImNvbnN0X21pc3NpbmciLCJmdWxsX2NvbnN0X25hbWUiLCI9PSIsImNvbnN0X3NldCIsIiF+Iiwic3RhcnRfd2l0aD8iLCJ2YWx1ZSIsInB1YmxpY19jb25zdGFudCIsImRlZmluZV9tZXRob2QiLCJtZXRob2QiLCJ0b19wcm9jIiwiYm91bmQiLCJiaW5kIiwiY2FsbCIsImFyZ3MiLCJyZW1vdmVfbWV0aG9kIiwic2luZ2xldG9uX2NsYXNzPyIsImluY2x1ZGUiLCJpbmNsdWRlZCIsImluY2x1ZGVkX21vZHVsZXMiLCJpbmNsdWRlPyIsImluc3RhbmNlX21ldGhvZCIsImluc3RhbmNlX21ldGhvZHMiLCJ0cnV0aHk/IiwiaW5jbHVkZV9zdXBlciIsImV4dGVuZGVkIiwiZXh0ZW5kX29iamVjdCIsIm1ldGhvZF9hZGRlZCIsIm1ldGhvZF9yZW1vdmVkIiwibWV0aG9kX3VuZGVmaW5lZCIsIjMiLCJjb3Zlcj8iLCJzaXplIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYW55PyIsIm1vZHVsZV9leGVjIiwibWV0aG9kX2RlZmluZWQ/IiwibW9kdWxlX2Z1bmN0aW9uIiwicHJlcGVuZCIsInByZXBlbmRfZmVhdHVyZXMiLCJwcmVwZW5kZWQiLCJyZW1vdmVfY29uc3QiLCJ0b19zIiwiX19pZF9fIiwiMTYiLCJ1bmRlZl9tZXRob2QiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJjb25zdHMiLCJkdXAiLCJjb3B5IiwiY29weV9jbGFzc192YXJpYWJsZXMiLCJjb3B5X2NvbnN0YW50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsZUFBQUEscUJBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQUFBO0FBQUE7QUFTQUUsSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBWEY7QUFXaUIsTUFBQSwyQ0FYakI7QUFBQSxNQVlJLElB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LHdDQUFBQSxrQ0FBQUEsZ0NBQXlCLEtBQXpCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUxFQSxJQUFBQSxDQUFBQSw2Q0FBQUEsQ0E1b0JBO0FBQUEsSUFvcEJBLE9BQUFDLENBQUFBLGtDQUFBQSw0QkFBQUEsMEJBQW1CLEtBQW5CQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVBFQSxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQUEsMEJBcHBCQTtBQURGOUcsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNTI2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jbGFzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL21vZHVsZSdcblxuY2xhc3MgQ2xhc3NcbiAgZGVmIHNlbGYubmV3KHN1cGVyY2xhc3MgPSBPYmplY3QsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3VwZXJjbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MpO1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgICN7YGtsYXNzYC5jbGFzc19ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/fVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmhlcml0ZWQoY2xzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3JpZ2luYWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG9yaWdpbmFsKVxuICAgICV4e1xuICAgICAgc2VsZi4kJG5hbWUgPSBudWxsO1xuICAgICAgc2VsZi4kJGZ1bGxfbmFtZSA9IG51bGw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV3KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqZWN0ID0gI3thbGxvY2F0ZX07XG4gICAgICBPcGFsLnNlbmQob2JqZWN0LCBvYmplY3QuJGluaXRpYWxpemUsIGFyZ3MsIGJsb2NrKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VwZXJjbGFzc1xuICAgIGBzZWxmLiQkc3VwZXIgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICV4e1xuICAgICAgdmFyIHNpbmdsZXRvbl9vZiA9IHNlbGYuJCRzaW5nbGV0b25fb2Y7XG5cbiAgICAgIGlmIChzaW5nbGV0b25fb2YgJiYgKHNpbmdsZXRvbl9vZi4kJGlzX2FfbW9kdWxlKSkge1xuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6I3tgc2luZ2xldG9uX29mYC5uYW1lfT5cIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGV0b24gY2xhc3MgY3JlYXRlZCBmcm9tIGFuIG9iamVjdFxuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6Izwje2BzaW5nbGV0b25fb2YuJCRjbGFzc2AubmFtZX06MHgje2BPcGFsLmlkKHNpbmdsZXRvbl9vZilgLnRvX3MoMTYpfT4+XCJ9O1xuICAgICAgfVxuICAgICAgcmV0dXJuICN7c3VwZXIoKX07XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsIm5ldyIsInNlbGYiLCJibG9ja19naXZlbj8iLCJjbGFzc19ldmFsIiwiYmxvY2siLCJhbGxvY2F0ZSIsImluaGVyaXRlZCIsImluaXRpYWxpemVfZHVwIiwiaW5pdGlhbGl6ZV9jb3B5Iiwib3JpZ2luYWwiLCJzdXBlcmNsYXNzIiwidG9fcyIsIm5hbWUiLCIxNiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUFDLFVBQUlDLElBQUpELFVBQUFBLGVBQUFBLFNBQWEsVUFBYkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBSkY7QUFJb0MsTUFBQSxtQ0FKcEM7QUFBQTtBQUllLE1BQUE7QUFBQSxNQUFBLGVBQWEsc0JBQWI7QUFBQSxNQUFBLENBSmY7QUFBQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBUSxhQUFBLElBQThCRSxlQUE5QjtBQUFBLFFBQUEsT0FBQUMsTUFBQSxDQUFDLEtBQUQsQ0FBQUEsY0FBQUEsRUFBQUEsRUFBQUEsRUFBb0JDLGdCQUFwQkQ7QUFBQSxNQUFBO0FBQUE7QUFBQSxNQUFBLENBQUE7QUFDUjtBQUNBLElBZEE7QUFJRUgsSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUE7QUFBQTtBQWFBSyxJQUFBQSw0QkFBQUEsb0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUxFQSxJQUFBQSxDQUFBQSwrQkFBQUEsQ0FiQTtBQUFBO0FBcUJBQyxJQUFBQSw2QkFBQUEscUJBQUFBLHFCQUFjLEdBQWRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQXpCRixPQUFBO0FBeUJFQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FyQkE7QUFBQTtBQXdCQUMsSUFBQUEsa0NBQUFBLDBCQUFBQSwwQkFBbUIsUUFBbkJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLFVBQUFDLGlCQUFBQSxDQUFnQkMsUUFBaEJELENBQUE7QUFBQTtBQUVKO0FBQ0E7QUFDQSxJQUpJO0FBREZELElBQUFBLENBQUFBLHFDQUFBQSxDQXhCQTtBQUFBO0FBZ0NBUCxJQUFBQSx1QkFBQUEsZUFBQUEsU0FwQ0YsRUFvQ0VBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQXBDRjtBQW9DaUIsTUFBQSxtQ0FwQ2pCO0FBQUE7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFvQ1UsTUFBQSxrQkFwQ1Y7QUFBQTtBQXNDQSx1QkFBcUJLLFVBQUFBLENBQUFBLENBQVM7QUFDOUI7QUFDQTtBQUNBLElBekNBO0FBb0NFTCxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FoQ0E7QUFBQTtBQXdDQVUsSUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxtQkFBRDtBQURGQSxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0F4Q0E7QUFBQSxJQTRDQSxPQUFBQyxDQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFFRjs7QUFFQTtBQUNBLGVBQWlCLEVBQUEsR0FBQSxVQUFBLEdBQUEsQ0FBVyxDQUFDLFlBQUQsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0FBWCxDQUFBLEdBQUEsR0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZUFBaUIsRUFBQSxHQUFBLFlBQUEsR0FBQSxDQUFhLENBQUMsb0JBQUQsQ0FBQUEsTUFBQUEsQ0FBQUEsQ0FBYixDQUFBLEdBQUEsS0FBQSxHQUFBLENBQThDLENBQUMscUJBQUQsQ0FBQUQsTUFBQUEsQ0FBNkJFLEVBQTdCRixDQUE5QyxDQUFBLEdBQUEsSUFBbUY7QUFDcEc7QUFDQSxhQUFlLFVBQUEsRUFBQSw4REFBQSxFQUFBLEVBQUEsTUFBQSxDQUFRO0FBQ3ZCO0FBWkVBLElBQUFBLENBQUFBLDJCQUFBQSxDQUFBQSxnQkE1Q0E7QUFERlosRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2MzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jhc2ljX29iamVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBCYXNpY09iamVjdFxuICBkZWYgaW5pdGlhbGl6ZSgqKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYHNlbGYgPT09IG90aGVyYFxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuXG4gIGRlZiBfX2lkX19cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGlkO1xuICAgICAgfVxuICAgICAgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLCAnJCRpZCcsIE9wYWwudWlkKCkpO1xuICAgICAgcmV0dXJuIHNlbGYuJCRpZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBfX3NlbmRfXyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgZnVuYyA9IHNlbGZbJyQnICsgc3ltYm9sXVxuXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGZ1bmMuJCRwID0gYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kbWV0aG9kX21pc3NpbmcuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRtZXRob2RfbWlzc2luZy5hcHBseShzZWxmLCBbc3ltYm9sXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICFcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgIT0ob3RoZXIpXG4gICAgIShzZWxmID09IG90aGVyKVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXZhbCgqYXJncywgJmJsb2NrKVxuICAgIGlmIGJsb2NrLm5pbD8gJiYgYCEhT3BhbC5jb21waWxlYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gOjpPcGFsLmNvbXBpbGUgc3RyaW5nLCBjb21waWxpbmdfb3B0aW9uc1xuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIGRvXG4gICAgICAgICV4e1xuICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGV2YWwoY29tcGlsZWQpO1xuICAgICAgICAgIH0pKHNlbGYpXG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgLy8gTmVlZCB0byBwYXNzICQkZXZhbCBzbyB0aGF0IG1ldGhvZCBkZWZpbml0aW9ucyBrbm93IGlmIHRoaXMgaXNcbiAgICAgIC8vIGJlaW5nIGRvbmUgb24gYSBjbGFzcy9tb2R1bGUuIENhbm5vdCBiZSBjb21waWxlciBkcml2ZW4gc2luY2VcbiAgICAgIC8vIHNlbmQoOmluc3RhbmNlX2V2YWwpIG5lZWRzIHRvIHdvcmsuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgfVxuXG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXhlYygqYXJncywgJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgY2xhc3NcbiAgICBgc2VsZi4kJGNsYXNzYFxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3Npbmcoc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgIG1lc3NhZ2UgPSBpZiBgc2VsZi4kaW5zcGVjdCAmJiAhc2VsZi4kaW5zcGVjdC4kJHN0dWJgXG4gICAgICAgICAgICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3R9OiN7YHNlbGYuJCRjbGFzc2B9XCJcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIFwidW5kZWZpbmVkIG1ldGhvZCBgI3tzeW1ib2x9JyBmb3IgI3tgc2VsZi4kJGNsYXNzYH1cIlxuICAgICAgICAgICAgICBlbmRcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcobWVzc2FnZSwgc3ltYm9sKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiaW5pdGlhbGl6ZSIsIj09IiwiZXFsPyIsInNlbGYiLCJvdGhlciIsIl9faWRfXyIsIl9fc2VuZF9fIiwiISIsIiE9IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwibmlsPyIsIjEiLCIzIiwiY292ZXI/IiwiYXJncyIsInNpemUiLCJyYWlzZSIsInN0cmluZyIsImZpbGUiLCJfbGluZW5vIiwiZGVmYXVsdF9ldmFsX29wdGlvbnMiLCJjb21waWxpbmdfb3B0aW9ucyIsIl9fT1BBTF9DT01QSUxFUl9DT05GSUdfXyIsIm1lcmdlIiwiY29tcGlsZWQiLCJjb21waWxlIiwicHJvYyIsImFueT8iLCJpbnN0YW5jZV9leGVjIiwic2luZ2xldG9uX21ldGhvZF9hZGRlZCIsInNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCIsInNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkIiwibWV0aG9kX21pc3NpbmciLCJtZXNzYWdlIiwic3ltYm9sIiwiaW5zcGVjdCIsIm5ldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFBQUMsSUFBQUEsOEJBQUFBLDRCQUFBQSxzQkFGRixFQUVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFGRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxPQUFBLEdBQUE7QUFFRUEsSUFBQUEsQ0FBQUEsd0NBQUFBLENBQUE7QUFBQTtBQUdBQyxJQUFBQSxzQkFBQUEsd0JBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxjQUFEO0FBREZBLElBQUFBLENBQUFBLG1DQUFBQSxDQUhBO0FBQUE7QUFPQUMsSUFBQUEsd0JBQUFBLDBCQUFBQSxTQUFTLEtBQVRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFDLElBQUFGLE9BQUFBLENBQVFHLEtBQVJIO0FBREZDLElBQUFBLENBQUFBLHFDQUFBQSxDQVBBO0FBQUEsSUFXQSxpQkFBTSxRQUFOLEVBQWEsSUFBYixDQVhBO0FBQUE7QUFhQUcsSUFBQUEsMEJBQUFBLHdCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEVBLElBQUFBLENBQUFBLG1DQUFBQSxDQWJBO0FBQUE7QUF1QkFDLElBQUFBLDRCQUFBQSwwQkFBQUEsb0JBQWEsTUFBRCxFQXpCZCxFQXlCRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBekJGO0FBeUI4QixNQUFBLDhDQXpC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QUFBO0FBNkk2QixNQUFBLGtCQTdJN0I7QUFBQSxNQThJSUMsVUFBVSxhQUFBLElBQUEsUUFBSSxzQ0FBSixDQUFBO0FBQUEsUUFDRSxPQUFBLEVBQUEsR0FBQSxvQkFBQSxHQUFBLENBQXFCQyxNQUFyQixDQUFBLEdBQUEsUUFBQSxHQUFBLEtBQW9DQyxTQUFBQSxDQUFBQSxDQUFwQyxDQUFBLEdBQUEsR0FBQSxHQUFBLENBQWdELFlBQWhEO0FBREYsTUFBQTtBQUFBLFFBR0UsT0FBQSxFQUFBLEdBQUEsb0JBQUEsR0FBQSxDQUFxQkQsTUFBckIsQ0FBQSxHQUFBLFFBQUEsR0FBQSxDQUFxQyxZQUFyQztBQUhGLE1BQUEsQ0FBQSxrQkE5SWQ7QUFBQSxNQW9KSSxPQUFBLElBQUEsSUFBQSxXQUFBbEIsT0FBQUEsQ0FBZSxJQUFBLElBQUEsa0JBQUFvQixLQUFBQSxDQUFvQkgsU0FBU0MsTUFBN0JFLENBQWZwQixDQXBKSjtBQTZJRWdCLElBQUFBLENBQUFBLDZDQUFBQSxDQUFBQSwwQkEzSUE7QUFERmxDLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mzg3OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIva2VybmVsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBLZXJuZWxcbiAgZGVmIG1ldGhvZF9taXNzaW5nKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICByYWlzZSBOb01ldGhvZEVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7aW5zcGVjdH1cIiwgc3ltYm9sLCBhcmdzKVxuICBlbmRcblxuICBkZWYgPX4ob2JqKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiAhfihvYmopXG4gICAgIShzZWxmID1+IG9iailcbiAgZW5kXG5cbiAgZGVmID09PShvdGhlcilcbiAgICBvYmplY3RfaWQgPT0gb3RoZXIub2JqZWN0X2lkIHx8IHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICAleHtcbiAgICAgIC8vIHNldCBndWFyZCBmb3IgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICBzZWxmLiQkY29tcGFyYWJsZSA9IHRydWU7XG5cbiAgICAgIHZhciB4ID0gI3tzZWxmID09IG90aGVyfTtcblxuICAgICAgaWYgKHggJiYgeCAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZChuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGggPSBzZWxmWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgI3tuYW1lfScgZm9yIGNsYXNzIGAje3NlbGYuY2xhc3N9J1wiLCBuYW1lKX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje01ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGYuY2xhc3N9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kcyhhbGwgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGFsbCl9KSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5vd25fbWV0aG9kcyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwdWJsaWNfbWV0aG9kcyhhbGwgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGFsbCl9KSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5yZWNlaXZlcl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEFycmF5KG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBjb2VyY2VkO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hKX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIHJldHVybiBbb2JqZWN0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdF9leGl0KCZibG9jaylcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG4gICAgJF9fYXRfZXhpdF9fIDw8IGJsb2NrXG4gIGVuZFxuXG4gICMgT3BhbCBkb2VzIG5vdCBzdXBwb3J0ICNjYWxsZXIsIGJ1dCB3ZSBzdHViIGl0IGFzIGFuIGVtcHR5IGFycmF5IHRvIG5vdFxuICAjIGJyZWFrIGRlcGVuZGFudCBsaWJzXG4gIGRlZiBjYWxsZXIoKmFyZ3MpXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvdGhlciksIGksIGlpLCBuYW1lO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBrZXlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGtleXNbaV07XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29weV9zaW5nbGV0b25fbWV0aG9kcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBpLCBuYW1lLCBuYW1lcywgbGVuZ3RoO1xuXG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICAgIHZhciBvdGhlcl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob3RoZXIpO1xuICAgICAgICB2YXIgc2VsZl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZik7XG4gICAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QobmFtZSkpIHtcbiAgICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdID0gb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QgPSBPYmplY3QuYXNzaWduKHt9LCBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihcbiAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyKSwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICckJyAmJiBuYW1lLmNoYXJBdCgxKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2Nsb25lKG90aGVyKVxuICAgIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHNpbmdsZXRvbl9jbGFzcy5kZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHNlbGYuY2xhc3MuYWxsb2NhdGVcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICBFbnVtZXJhdG9yLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcblxuICBkZWYgZXF1YWw/KG90aGVyKVxuICAgIGBzZWxmID09PSBvdGhlcmBcbiAgZW5kXG5cbiAgZGVmIGV4aXQoc3RhdHVzID0gdHJ1ZSlcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG5cbiAgICB1bnRpbCAkX19hdF9leGl0X18uZW1wdHk/XG4gICAgICBibG9jayA9ICRfX2F0X2V4aXRfXy5wb3BcbiAgICAgIGJsb2NrLmNhbGxcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHN0YXR1cy4kJGlzX2Jvb2xlYW4pIHtcbiAgICAgICAgc3RhdHVzID0gc3RhdHVzID8gMCA6IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAje09wYWwuY29lcmNlX3RvKHN0YXR1cywgSW50ZWdlciwgOnRvX2ludCl9XG4gICAgICB9XG5cbiAgICAgIE9wYWwuZXhpdChzdGF0dXMpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIHZhciBzaW5nbGV0b24gPSAje3NpbmdsZXRvbl9jbGFzc307XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAuYXBwZW5kX2ZlYXR1cmVzIGBzaW5nbGV0b25gfTtcbiAgICAgICAgI3tgbW9kYC5leHRlbmRfb2JqZWN0IHNlbGZ9O1xuICAgICAgICAje2Btb2RgLmV4dGVuZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBfX2lkX19cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICB0b19zXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgJXh7XG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MgJiYgIWtsYXNzLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2xhc3MgPT09IGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZiwgbmFtZS5zdWJzdHIoMSkpYFxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgdmFyIGl2YXIgPSBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldO1xuXG4gICAgICByZXR1cm4gaXZhciA9PSBudWxsID8gbmlsIDogaXZhcjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gT3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICB2YXIga2V5ID0gT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKSxcbiAgICAgICAgICB2YWw7XG4gICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhbCA9IHNlbGZba2V5XTtcbiAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSBOYW1lRXJyb3IsIFwiaW5zdGFuY2UgdmFyaWFibGUgI3tuYW1lfSBub3QgZGVmaW5lZFwiXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaXZhcjtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUuY2hhckF0KDApICE9PSAnJCcpIHtcbiAgICAgICAgICBpZiAobmFtZS5zdWJzdHIoLTEpID09PSAnJCcpIHtcbiAgICAgICAgICAgIGl2YXIgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl2YXIgPSBuYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCgnQCcgKyBpdmFyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEludGVnZXIodmFsdWUsIGJhc2UgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc3RyLCBiYXNlX2RpZ2l0cztcblxuICAgICAgaWYgKCF2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnYmFzZSBzcGVjaWZpZWQgZm9yIG5vbiBzdHJpbmcgdmFsdWUnfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBuaWwgaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5IHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgI3tyYWlzZSBGbG9hdERvbWFpbkVycm9yLCB2YWx1ZX1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/KDp0b19pbnQpfSkge1xuICAgICAgICAgIGkgPSAje3ZhbHVlLnRvX2ludH07XG4gICAgICAgICAgaWYgKGkgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje09wYWwuY29lcmNlX3RvISh2YWx1ZSwgSW50ZWdlciwgOnRvX2kpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSBcIjBcIikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYXNlID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2UgPSAje09wYWwuY29lcmNlX3RvKGBiYXNlYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoYmFzZSA9PT0gMSB8fCBiYXNlIDwgMCB8fCBiYXNlID4gMzYpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJ9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgJyQxJyk7XG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pLywgZnVuY3Rpb24gKF8sIGhlYWQsIGZsYWcpIHtcbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAyKSB7XG4gICAgICAgICAgICBiYXNlID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSA4KSB7XG4gICAgICAgICAgICBiYXNlID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDEwKSB7XG4gICAgICAgICAgICBiYXNlID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAxNikge1xuICAgICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH0pO1xuXG4gICAgICBiYXNlID0gKGJhc2UgPT09IDAgPyAxMCA6IGJhc2UpO1xuXG4gICAgICBiYXNlX2RpZ2l0cyA9ICcwLScgKyAoYmFzZSA8PSAxMCA/IGJhc2UgLSAxIDogJzlhLScgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgKGJhc2UgLSAxMSkpKTtcblxuICAgICAgaWYgKCEobmV3IFJlZ0V4cCgnXlxcXFxzKlsrLV0/WycgKyBiYXNlX2RpZ2l0cyArICddK1xcXFxzKiQnKSkudGVzdChzdHIpKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgaSA9IHBhcnNlSW50KHN0ciwgYmFzZSk7XG5cbiAgICAgIGlmIChpc05hTihpKSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEZsb2F0KHZhbHVlKVxuICAgICV4e1xuICAgICAgdmFyIHN0cjtcblxuICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBuaWwgaW50byBGbG9hdFwifVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcblxuICAgICAgICAvL1NwZWNpYWwgY2FzZSBmb3IgaGV4IHN0cmluZ3Mgb25seTpcbiAgICAgICAgaWYgKC9eXFxzKlstK10/MFt4WF1bMC05YS1mQS1GXStcXHMqJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuICN7SW50ZWdlcihgc3RyYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEvXlxccypbLStdP1swLTldKlxcLj9bMC05XSsoW2VFXVstK10/WzAtOV0rKT9cXHMqJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEZsb2F0KCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje09wYWwuY29lcmNlX3RvISh2YWx1ZSwgRmxvYXQsIDp0b19mKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgSGFzaChhcmcpXG4gICAgcmV0dXJuIHt9IGlmIGFyZy5uaWw/IHx8IGFyZyA9PSBbXVxuICAgIHJldHVybiBhcmcgaWYgSGFzaCA9PT0gYXJnXG4gICAgT3BhbC5jb2VyY2VfdG8hKGFyZywgSGFzaCwgOnRvX2hhc2gpXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICAleHtcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcyAmJiAha2xhc3MuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdjbGFzcyBvciBtb2R1bGUgcmVxdWlyZWQnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9wYWwuaXNfYShzZWxmLCBrbGFzcyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaXRzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBraW5kX29mPyBpc19hP1xuXG4gIGRlZiBsYW1iZGEoJmJsb2NrKVxuICAgIGBPcGFsLmxhbWJkYShibG9jaylgXG4gIGVuZFxuXG4gIGRlZiBsb2FkKGZpbGUpXG4gICAgZmlsZSA9IE9wYWwuY29lcmNlX3RvIShmaWxlLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYE9wYWwubG9hZCgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgZGVmIGxvb3BcbiAgICByZXR1cm4gZW51bV9mb3IoOmxvb3ApIHsgRmxvYXQ6OklORklOSVRZIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgdHJ1ZVxuICAgICAgYmVnaW5cbiAgICAgICAgeWllbGRcbiAgICAgIHJlc2N1ZSBTdG9wSXRlcmF0aW9uID0+IGVcbiAgICAgICAgcmV0dXJuIGUucmVzdWx0XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmIHByaW50ZigqYXJncylcbiAgICBpZiBhcmdzLmFueT9cbiAgICAgIHByaW50IGZvcm1hdCgqYXJncylcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHJvYygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGBibG9jay4kJGlzX2xhbWJkYSA9IGZhbHNlYFxuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBwdXRzKCpzdHJzKVxuICAgICRzdGRvdXQucHV0cygqc3RycylcbiAgZW5kXG5cbiAgZGVmIHAoKmFyZ3MpXG4gICAgYXJncy5lYWNoIHsgfG9ianwgJHN0ZG91dC5wdXRzIG9iai5pbnNwZWN0IH1cblxuICAgIGFyZ3MubGVuZ3RoIDw9IDEgPyBhcmdzWzBdIDogYXJnc1xuICBlbmRcblxuICBkZWYgcHJpbnQoKnN0cnMpXG4gICAgJHN0ZG91dC5wcmludCgqc3RycylcbiAgZW5kXG5cbiAgZGVmIHdhcm4oKnN0cnMpXG4gICAgJHN0ZGVyci5wdXRzKCpzdHJzKSB1bmxlc3MgJFZFUkJPU0UubmlsPyB8fCBzdHJzLmVtcHR5P1xuICBlbmRcblxuICBkZWYgcmFpc2UoZXhjZXB0aW9uID0gdW5kZWZpbmVkLCBzdHJpbmcgPSBuaWwsIF9iYWNrdHJhY2UgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwgJiYgI3skIX0gIT09IG5pbCkge1xuICAgICAgICB0aHJvdyAjeyQhfTtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBleGNlcHRpb24gPSAje1J1bnRpbWVFcnJvci5uZXd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7UnVudGltZUVycm9yLm5ldyBleGNlcHRpb259O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgI3tleGNlcHRpb24ucmVzcG9uZF90bz8oOmV4Y2VwdGlvbil9KSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tleGNlcHRpb24uaXNfYT8oRXhjZXB0aW9uKX0pIHtcbiAgICAgICAgLy8gZXhjZXB0aW9uIGlzIGZpbmVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBleGNlcHRpb24gPSAje1R5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgT3BhbC5leGNlcHRpb25zLnB1c2goI3skIX0pO1xuICAgICAgfVxuXG4gICAgICAjeyQhfSA9IGV4Y2VwdGlvbjtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmFpbCByYWlzZVxuXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tSYW5kb206OkRFRkFVTFQucmFuZH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCAlIDEgIT09IDApIHtcbiAgICAgICAgICBtYXggPSBtYXguJHRvX2koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgICBtYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgUmFuZG9tOjpERUZBVUxULnJhbmQobWF4KVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICByZXR1cm4gdHJ1ZSBpZiByZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsKVxuXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGZbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHJlcXVpcmUoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgcmVxdWlyZV9yZWxhdGl2ZShmaWxlKVxuICAgIE9wYWwudHJ5X2NvbnZlcnQhKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gRmlsZS5leHBhbmRfcGF0aCBGaWxlLmpvaW4oYE9wYWwuY3VycmVudF9maWxlYCwgJy4uJywgZmlsZSlcblxuICAgIGBPcGFsLnJlcXVpcmUoI3tmaWxlfSlgXG4gIGVuZFxuXG4gICMgYHBhdGhgIHNob3VsZCBiZSB0aGUgZnVsbCBwYXRoIHRvIGJlIGZvdW5kIGluIHJlZ2lzdGVyZWQgbW9kdWxlcyAoYE9wYWwubW9kdWxlc2ApXG4gIGRlZiByZXF1aXJlX3RyZWUocGF0aClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcGF0aCA9ICN7RmlsZS5leHBhbmRfcGF0aChwYXRoKX1cbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIGlmIChwYXRoID09PSAnLicpIHBhdGggPSAnJztcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgIGlmICgje2BuYW1lYC5zdGFydF93aXRoPyhwYXRoKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgT3BhbC5yZXF1aXJlKG5hbWUpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNlbmQgICAgICAgIF9fc2VuZF9fXG4gIGFsaWFzIHB1YmxpY19zZW5kIF9fc2VuZF9fXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBzbGVlcChzZWNvbmRzID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IE5pbENsYXNzIGludG8gdGltZSBpbnRlcnZhbFwifVxuICAgICAgfVxuICAgICAgaWYgKCFzZWNvbmRzLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWNvbmRzLmNsYXNzfSBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cbiAgICAgIH1cbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0aW1lIGludGVydmFsIG11c3QgYmUgcG9zaXRpdmUnfVxuICAgICAgfVxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCl9XG5cbiAgICAgIHZhciB0ID0gZ2V0X3RpbWUoKTtcbiAgICAgIHdoaWxlIChnZXRfdGltZSgpIC0gdCA8PSBzZWNvbmRzICogMTAwMCk7XG4gICAgICByZXR1cm4gc2Vjb25kcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcmFuZChzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIFJhbmRvbS5zcmFuZChzZWVkKVxuICBlbmRcblxuICBkZWYgU3RyaW5nKHN0cilcbiAgICBPcGFsLmNvZXJjZV90bz8oc3RyLCBTdHJpbmcsIDp0b19zdHIpIHx8XG4gICAgICBPcGFsLmNvZXJjZV90byEoc3RyLCBTdHJpbmcsIDp0b19zKVxuICBlbmRcblxuICBkZWYgdGFwKCZibG9jaylcbiAgICB5aWVsZCBzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBkZWYgY2F0Y2goc3ltKVxuICAgIHlpZWxkXG4gIHJlc2N1ZSBVbmNhdWdodFRocm93RXJyb3IgPT4gZVxuICAgIHJldHVybiBlLmFyZyBpZiBlLnN5bSA9PSBzeW1cbiAgICByYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3coKmFyZ3MpXG4gICAgcmFpc2UgVW5jYXVnaHRUaHJvd0Vycm9yLCBhcmdzXG4gIGVuZFxuXG4gICMgYmFzaWMgaW1wbGVtZW50YXRpb24gb2Ygb3BlbiwgZGVsZWdhdGUgdG8gRmlsZS5vcGVuXG4gIGRlZiBvcGVuKCphcmdzLCAmYmxvY2spXG4gICAgRmlsZS5vcGVuKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB5aWVsZF9zZWxmXG4gICAgcmV0dXJuIGVudW1fZm9yKDp5aWVsZF9zZWxmKSB7IDEgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgeWllbGQgc2VsZlxuICBlbmRcbmVuZFxuXG5jbGFzcyBPYmplY3RcbiAgaW5jbHVkZSBLZXJuZWxcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm1ldGhvZF9taXNzaW5nIiwicmFpc2UiLCJuZXciLCJzeW1ib2wiLCJpbnNwZWN0IiwiYXJncyIsIj1+IiwiIX4iLCJzZWxmIiwib2JqIiwiISIsIj09PSIsIm9iamVjdF9pZCIsIj09Iiwib3RoZXIiLCI8PT4iLCJtZXRob2QiLCJuYW1lIiwiY2xhc3MiLCJtZXRob2RzIiwidHJ1dGh5PyIsImFsbCIsInB1YmxpY19tZXRob2RzIiwiQXJyYXkiLCJjb2VyY2VfdG8/Iiwib2JqZWN0IiwiYXRfZXhpdCIsIiRfX2F0X2V4aXRfXyIsIjw8IiwiYmxvY2siLCJjYWxsZXIiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJjbG9uZSIsImNvcHkiLCJhbGxvY2F0ZSIsImluaXRpYWxpemVfY2xvbmUiLCJpbml0aWFsaXplX2NvcHkiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImRlZmluZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3MiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiZm9yIiwiZXF1YWw/IiwiZXhpdCIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJjb2VyY2VfdG8iLCJzdGF0dXMiLCJleHRlbmQiLCJhcHBlbmRfZmVhdHVyZXMiLCJleHRlbmRfb2JqZWN0IiwiZXh0ZW5kZWQiLCJoYXNoIiwiX19pZF9fIiwidG9fcyIsImluc3RhbmNlX29mPyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJyZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJJbnRlZ2VyIiwidmFsdWUiLCJyZXNwb25kX3RvPyIsInRvX2ludCIsImNvZXJjZV90byEiLCJiYXNlIiwiRmxvYXQiLCJIYXNoIiwiYXJnIiwibmlsPyIsImlzX2E/IiwiaXRzZWxmIiwibGFtYmRhIiwibG9hZCIsImZpbGUiLCJsb29wIiwiYmxvY2tfZ2l2ZW4/IiwiZSIsInJlc3VsdCIsInByaW50ZiIsImFueT8iLCJwcmludCIsImZvcm1hdCIsInByb2MiLCJwdXRzIiwiJHN0ZG91dCIsInN0cnMiLCJwIiwiZWFjaCIsIjw9IiwibGVuZ3RoIiwiMSIsIltdIiwiMCIsIndhcm4iLCIkVkVSQk9TRSIsIiRzdGRlcnIiLCIkISIsImV4Y2VwdGlvbiIsInN0cmluZyIsInJhbmQiLCJtYXgiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiaW5jbHVkZV9hbGwiLCJyZXF1aXJlIiwicmVxdWlyZV9yZWxhdGl2ZSIsInRyeV9jb252ZXJ0ISIsImV4cGFuZF9wYXRoIiwiam9pbiIsInJlcXVpcmVfdHJlZSIsInBhdGgiLCJzdGFydF93aXRoPyIsInNsZWVwIiwic2Vjb25kcyIsInNyYW5kIiwibmV3X3NlZWQiLCJzZWVkIiwiU3RyaW5nIiwic3RyIiwidGFwIiwidG9fcHJvYyIsIjE2IiwiY2F0Y2giLCJzeW0iLCJ0aHJvdyIsIm9wZW4iLCJ5aWVsZF9zZWxmIiwiaW5jbHVkZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQUFDLElBQUFBLGtDQUFBQSwyQkFBQUEsMEJBQW1CLE1BQUQsRUFGcEIsRUFFRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBRkY7QUFFb0MsTUFBQSwrQ0FGcEM7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQUU2QixNQUFBLGtCQUY3QjtBQUFBLE1BR0ksV0FBQUMsT0FBQUEsQ0FBTSw2QkFBQUMsS0FBQUEsQ0FBa0IsRUFBQSxHQUFBLG9CQUFBLEdBQUEsQ0FBcUJDLE1BQXJCLENBQUEsR0FBQSxRQUFBLEdBQUEsS0FBb0NDLFNBQUFBLENBQUFBLENBQXBDLEdBQStDRCxRQUFRRSxJQUF6RUgsQ0FBTkQsQ0FISjtBQUVFRCxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQTtBQUFBO0FBSUFNLElBQUFBLHNCQUFBQSxzQkFBQUEsU0FBTyxHQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLGlDQUFBQSxDQUpBO0FBQUE7QUFRQUMsSUFBQUEsc0JBQUFBLHdCQUFBQSxTQUFPLEdBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUVDLElBQUFGLE9BQUFBLENBQVFHLEdBQVJILENBQUZJLE1BQUFBLENBQUFBO0FBREZILElBQUFBLENBQUFBLG1DQUFBQSxDQVJBO0FBQUE7QUFZQUksSUFBQUEsdUJBQUFBLHNCQUFBQSxTQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsa0JBQUFDLFdBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWFDLEtBQUFGLFdBQUFBLENBQUFBLENB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QUEsRUFBQTs7QUFBQSxRQXdxQm1DLE9BQUFzRCxDQXhxQm5DLG1CQUFBLGtCQUFBLE1Bd3FCV3REO0FBQVAsTUFBQSxDQUFBO0FBQUEsTUFDQSxPQUFBLG9CQUFNbkMsSUFBTixDQUFBLENBREE7QUFERjRILElBQUFBLENBQUFBLG1DQUFBQSxDQXJxQkE7QUFERnJJLEVBQUFBLEdBQUFBLFdBQUFBLFdBQUE7QUFBQSxFQTRxQkEsT0FBQW1CO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxXQUFBbUgsU0FBQUEsQ0FBUSxzQkFBUkE7QUFERm5ILEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBNXFCQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ5MDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEV4Y2VwdGlvbiA8IGBFcnJvcmBcbiAgIyBgdmFyIEtlcm5lbCRyYWlzZSA9ICN7S2VybmVsfS4kcmFpc2VgXG4gIGB2YXIgc3RhY2tfdHJhY2VfbGltaXRgXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIG1lc3NhZ2UgICA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbDtcbiAgICAgIHZhciBlcnJvciAgICAgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgICAgZXJyb3IubmFtZSAgICA9IHNlbGYuJCRuYW1lO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICBPcGFsLnNlbmQoZXJyb3IsIGVycm9yLiRpbml0aWFsaXplLCBhcmdzKTtcblxuICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoKSB3aWxsIHVzZSAubmFtZSBhbmQgLnRvU3RyaW5nIHRvIGJ1aWxkIHRoZVxuICAgICAgLy8gZmlyc3QgbGluZSBvZiB0aGUgc3RhY2sgdHJhY2Ugc28gaXQgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGVycm9yXG4gICAgICAvLyBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12Ni54L2RvY3MvYXBpL2Vycm9ycy5odG1sXG4gICAgICBpZiAoT3BhbC5jb25maWcuZW5hYmxlX3N0YWNrX3RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgS2VybmVsLnJhaXNlIHdpbGwgY3V0IHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoYXQgcG9pbnQgYWJvdmVcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrX3RyYWNlX2xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgZW5kXG4gIGBzdGFja190cmFjZV9saW1pdCA9IHNlbGYuJG5ld2BcblxuICBkZWYgc2VsZi5leGNlcHRpb24oKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAjIHVzaW5nIHNlbGYubWVzc2FnZSBha2EgQG1lc3NhZ2UgdG8gcmV0YWluIGNvbXBhdGliaWxpdHkgd2l0aCBuYXRpdmUgZXhjZXB0aW9uJ3MgbWVzc2FnZSBwcm9wZXJ0eVxuICAgIGBzZWxmLm1lc3NhZ2UgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWxgXG4gIGVuZFxuXG4gIGRlZiBiYWNrdHJhY2VcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xuICAgICAgICAvLyBuaWwgaXMgYSB2YWxpZCBiYWNrdHJhY2VcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja3RyYWNlID0gc2VsZi5zdGFjaztcblxuICAgICAgaWYgKHR5cGVvZihiYWNrdHJhY2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYmFja3RyYWNlLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDAsIDE1KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm4gYmFja3RyYWNlLnNsaWNlKDAsIDE1KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbihzdHIgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc3RyID09PSBuaWwgfHwgc2VsZiA9PT0gc3RyKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gI3tjbG9uZX07XG4gICAgICBjbG9uZWQubWVzc2FnZSA9IHN0cjtcbiAgICAgIGNsb25lZC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBub3QgdXNpbmcgYWxpYXMgbWVzc2FnZSB0b19zIGJlY2F1c2UgeW91IG5lZWQgdG8gYmUgYWJsZSB0byBvdmVycmlkZSB0b19zIGFuZCBoYXZlIG1lc3NhZ2UgdXNlIG92ZXJyaWRkZW4gbWV0aG9kLCB3b24ndCB3b3JrIHdpdGggYWxpYXNcbiAgZGVmIG1lc3NhZ2VcbiAgICB0b19zXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgYXNfc3RyID0gdG9fc1xuICAgIGFzX3N0ci5lbXB0eT8gPyBzZWxmLmNsYXNzLnRvX3MgOiBcIiM8I3tzZWxmLmNsYXNzLnRvX3N9OiAje3RvX3N9PlwiXG4gIGVuZFxuXG4gIGRlZiBzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSlcbiAgICAleHtcbiAgICAgIHZhciB2YWxpZCA9IHRydWUsIGksIGlpO1xuXG4gICAgICBpZiAoYmFja3RyYWNlID09PSBuaWwpIHtcbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBuaWw7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gW2JhY2t0cmFjZV07XG4gICAgICAgIHNlbGYuc3RhY2sgPSBiYWNrdHJhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFja3RyYWNlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJhY2t0cmFjZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJhY2t0cmFjZVtpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2JhY2t0cmFjZSBtdXN0IGJlIEFycmF5IG9mIFN0cmluZyd9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcbiAgICAgICAgc2VsZi5zdGFjayA9IGJhY2t0cmFjZS5qb2luKCdcXG4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhY2t0cmFjZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICAoQG1lc3NhZ2UgJiYgQG1lc3NhZ2UudG9fcykgfHwgc2VsZi5jbGFzcy50b19zXG4gIGVuZFxuZW5kXG5cbiMga2VlcCB0aGUgaW5kZW50YXRpb24sIGl0IG1ha2VzIHRoZSBleGNlcHRpb24gaGllcmFyY2h5IGNsZWFyXG5jbGFzcyBTY3JpcHRFcnJvciAgICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBTeW50YXhFcnJvciAgICAgICAgIDwgU2NyaXB0RXJyb3I7IGVuZFxuY2xhc3MgTG9hZEVycm9yICAgICAgICAgICA8IFNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIE5vdEltcGxlbWVudGVkRXJyb3IgPCBTY3JpcHRFcnJvcjsgZW5kXG5cbmNsYXNzIFN5c3RlbUV4aXQgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIE5vTWVtb3J5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNpZ25hbEV4Y2VwdGlvbiAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIEludGVycnVwdCAgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNlY3VyaXR5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcblxuY2xhc3MgU3RhbmRhcmRFcnJvciAgICAgPCBFeGNlcHRpb247IGVuZFxuY2xhc3MgRW5jb2RpbmdFcnJvciAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgWmVyb0RpdmlzaW9uRXJyb3IgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTmFtZUVycm9yICAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTm9NZXRob2RFcnJvciAgICAgICAgIDwgTmFtZUVycm9yOyBlbmRcbmNsYXNzIFJ1bnRpbWVFcnJvciAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEZyb3plbkVycm9yICAgICAgICAgICA8IFJ1bnRpbWVFcnJvcjsgZW5kXG5jbGFzcyBMb2NhbEp1bXBFcnJvciAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBUeXBlRXJyb3IgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBBcmd1bWVudEVycm9yICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBJbmRleEVycm9yICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBTdG9wSXRlcmF0aW9uICAgICAgICAgPCBJbmRleEVycm9yOyBlbmRcbmNsYXNzIEtleUVycm9yICAgICAgICAgICAgICA8IEluZGV4RXJyb3I7IGVuZFxuY2xhc3MgUmFuZ2VFcnJvciAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgRmxvYXREb21haW5FcnJvciAgICAgIDwgUmFuZ2VFcnJvcjsgZW5kXG5jbGFzcyBJT0Vycm9yICAgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBTeXN0ZW1DYWxsRXJyb3IgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5cbm1vZHVsZSBFcnJub1xuICBjbGFzcyBFSU5WQUwgICAgICAgICAgICAgIDwgU3lzdGVtQ2FsbEVycm9yXG4gICAgZGVmIHNlbGYubmV3KG5hbWUgPSBuaWwpXG4gICAgICBtZXNzYWdlID0gJ0ludmFsaWQgYXJndW1lbnQnXG4gICAgICBtZXNzYWdlICs9IFwiIC0gI3tuYW1lfVwiIGlmIG5hbWVcbiAgICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFVuY2F1Z2h0VGhyb3dFcnJvciA8IEFyZ3VtZW50RXJyb3JcbiAgYXR0cl9yZWFkZXIgOnN5bSwgOmFyZ1xuXG4gIGRlZiBpbml0aWFsaXplKGFyZ3MpXG4gICAgQHN5bSA9IGFyZ3NbMF1cbiAgICBAYXJnID0gYXJnc1sxXSBpZiBhcmdzLmxlbmd0aCA+IDFcblxuICAgIHN1cGVyKFwidW5jYXVnaHQgdGhyb3cgI3tAc3ltLmluc3BlY3R9XCIpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5hbWVFcnJvclxuICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwpXG4gICAgc3VwZXIgbWVzc2FnZVxuICAgIEBuYW1lID0gbmFtZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOb01ldGhvZEVycm9yXG4gIGF0dHJfcmVhZGVyIDphcmdzXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbCwgYXJncyA9IFtdKVxuICAgIHN1cGVyIG1lc3NhZ2UsIG5hbWVcbiAgICBAYXJncyA9IGFyZ3NcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RvcEl0ZXJhdGlvblxuICBhdHRyX3JlYWRlciA6cmVzdWx0XG5lbmRcblxuY2xhc3MgS2V5RXJyb3JcbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgcmVjZWl2ZXI6IG5pbCwga2V5OiBuaWwpXG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBrZXkgPSBrZXlcbiAgZW5kXG5cbiAgZGVmIHJlY2VpdmVyXG4gICAgQHJlY2VpdmVyIHx8IHJhaXNlKEFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBpcyBhdmFpbGFibGUnKVxuICBlbmRcblxuICBkZWYga2V5XG4gICAgQGtleSB8fCByYWlzZShBcmd1bWVudEVycm9yLCAnbm8ga2V5IGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBKU1xuICBjbGFzcyBFcnJvclxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwibmV3Iiwic2VsZiIsImV4Y2VwdGlvbiIsImFyZ3MiLCJpbml0aWFsaXplIiwiYmFja3RyYWNlIiwiY2xvbmUiLCJtZXNzYWdlIiwidG9fcyIsImluc3BlY3QiLCJhc19zdHIiLCJlbXB0eT8iLCJzZXRfYmFja3RyYWNlIiwicmFpc2UiLCJAbWVzc2FnZSIsIm1vZHVsZSIsIm5hbWUiLCIrIiwiYXR0cl9yZWFkZXIiLCJAc3ltIiwiW10iLCIwIiwiPiIsImxlbmd0aCIsIjEiLCJAYXJnIiwiQG5hbWUiLCJAYXJncyIsIkByZWNlaXZlciIsInJlY2VpdmVyIiwiQGtleSIsImtleSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUVFLElBQUMscUJBQUQ7QUFBQSxJQUVBQyxVQUFJQyxJQUFK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LE9BQUFnQjtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0VoQjtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQUFBLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBREZnQixFQUFBQSxHQUFBQSxXQUFBQSxXQS9NQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU0MTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbnN0YW50cy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJSVUJZX1BMQVRGT1JNICAgICAgID0gJ29wYWwnXG5SVUJZX0VOR0lORSAgICAgICAgID0gJ29wYWwnXG5SVUJZX1ZFUlNJT04gICAgICAgID0gJzIuNS43J1xuUlVCWV9FTkdJTkVfVkVSU0lPTiA9ICcxLjAuMydcblJVQllfUkVMRUFTRV9EQVRFICAgPSAnMjAyMC0wMi0wMSdcblJVQllfUEFUQ0hMRVZFTCAgICAgPSAwXG5SVUJZX1JFVklTSU9OICAgICAgID0gMFxuUlVCWV9DT1BZUklHSFQgICAgICA9ICdvcGFsIC0gQ29weXJpZ2h0IChDKSAyMDEzLTIwMjAgQWRhbSBCZXlub24gYW5kIHRoZSBPcGFsIGNvbnRyaWJ1dG9ycydcblJVQllfREVTQ1JJUFRJT04gICAgPSBcIm9wYWwgI3tSVUJZX0VOR0lORV9WRVJTSU9OfSAoI3tSVUJZX1JFTEVBU0VfREFURX0gcmV2aXNpb24gI3tSVUJZX1JFVklTSU9OfSlcIlxuIl0sIm5hbWVzIjpbIjAiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsRUFBQSw2Q0FBc0IsTUFBdEIsQ0FBQTtBQUFBLEVBQ0EsMkNBQXNCLE1BQXRCLENBREE7QUFBQSxFQUVBLDRDQUFzQixPQUF0QixDQUZBO0FBQUEsRUFHQSxtREFBc0IsT0FBdEIsQ0FIQTtBQUFBLEVBSUEsaURBQXNCLFlBQXRCLENBSkE7QUFBQSxFQUtBLCtDQUFzQkEsQ0FBdEIsQ0FMQTtBQUFBLEVBTUEsNkNBQXNCQSxDQUF0QixDQU5BO0FBQUEsRUFPQSw4Q0FBc0Isc0VBQXRCLENBUEE7QUFBQSxFQVFBLE9BQUEsZ0RBQXNCLEVBQUEsR0FBQSxPQUFBLEdBQUEsQ0FBUSxtQ0FBUixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQWdDLGlDQUFoQyxDQUFBLEdBQUEsWUFBQSxHQUFBLENBQThELDZCQUE5RCxDQUFBLEdBQUEsR0FBdEIsQ0FSQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU0MzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9ydW50aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9oZWxwZXJzJ1xucmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5yZXF1aXJlICdjb3JlbGliL2NsYXNzJ1xucmVxdWlyZSAnY29yZWxpYi9iYXNpY19vYmplY3QnXG5yZXF1aXJlICdjb3JlbGliL2tlcm5lbCdcbnJlcXVpcmUgJ2NvcmVsaWIvZXJyb3InXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29uc3RhbnRzJ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsaUJBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQURBO0FBQUEsTUFFQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FGQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsZUFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEsc0JBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUxBO0FBQUEsTUFNQUEsU0FBQUEsQ0FBUSxlQUFSQSxDQU5BO0FBQUEsRUFRQSxXQUFBQSxTQUFBQSxDQUFRLG1CQUFSQSxDQVJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6NTQ0NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5pbENsYXNzXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkbWV0YSA9ICN7c2VsZn1gXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgIVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgPT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICduaWwnXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgTmlsQ2xhc3NcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbXVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIGBPcGFsLmhhc2goKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2YgdG9faVxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4Lm5ldygwLCAwKVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoKmFyZ3MpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciBpZiBhcmdzLmxlbmd0aCA+IDFcbiAgICBSYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIFJhdGlvbmFsKDAsIDEpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBbXVxuICBlbmRcbmVuZFxuXG5OSUwgPSBuaWxcbiJdLCJuYW1lcyI6WyJjbGFzcyIsInNlbGYiLCJhbGxvY2F0ZSIsInJhaXNlIiwibmFtZSIsIiEiLCImIiwifCIsIl4iLCI9PSIsImR1cCIsImNsb25lIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19hIiwidG9faCIsInRvX2kiLCIwIiwidG9fcyIsInRvX2MiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIlJhdGlvbmFsIiwidG9fciIsImluc3RhbmNlX3ZhcmlhYmxlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsMEJBQTRCQyxJQUE3QjtBQUFBLElBRUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUMsTUFBQUEsNEJBQUFBLGNBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxXQUFBQyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSwwQkFBQSxHQUFBLEtBQTJCQyxNQUFBQSxDQUFBQSxDQUEzQixDQUFqQkQ7QUFERkQsTUFBQUEsQ0FBQUEseUJBQUFBLENBQUE7QUFBQTs7QUFJQSxNQUFBLHNCQUFNLEtBQU47aUJBSkE7QUFERixJQUFBLDRCQUFTRCxJQUFULFlBRkE7QUFBQTtBQVVBSSxJQUFBQSxxQkFBQUEsb0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBVkE7QUFBQTtBQWNBQyxJQUFBQSxxQkFBQUEsZ0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFB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Q0EzRUo7QUFBQSxNQTRFSSxXQUFBd0IsVUFBQUEsQ0FBU1QsR0FBR1EsQ0FBWkMsQ0E1RUo7QUEwRUVMLElBQUFBLENBQUFBLHVDQUFBQSxDQXhFQTtBQUFBO0FBNkVBTSxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBRCxVQUFBQSxDQUFTVCxHQUFHUSxDQUFaQztBQURGQyxJQUFBQSxDQUFBQSwrQkFBQUEsQ0E3RUE7QUFBQSxJQWlGQSxPQUFBQyxDQUFBQSxzQ0FBQUEsa0NBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLDZDQUFBQSxDQUFBQSw4QkFqRkE7QUFERjdCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBQUE7QUFBQSxFQXVGQSxPQUFBLG1DQUFNLEdBQU4sQ0F2RkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1NjA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9ib29sZWFuLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJvb2xlYW4gPCBgQm9vbGVhbmBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYm9vbGVhbicsIHRydWUpYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRtZXRhJywgI3tzZWxmfSlgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudmFsdWVPZigpID8gMiA6IDBgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgIVxuICAgIGBzZWxmICE9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbCkgOiBmYWxzZWBcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gdHJ1ZSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciA9PT0gZmFsc2UgfHwgb3RoZXIgPT09IG5pbCkgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID09PSBvdGhlci52YWx1ZU9mKClgXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIEJvb2xlYW5cbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuVHJ1ZUNsYXNzICA9IEJvb2xlYW5cbkZhbHNlQ2xhc3MgPSBCb29sZWFuXG5cblRSVUUgID0gdHJ1ZVxuRkFMU0UgPSBmYWxzZVxuIl0sIm5hbWVzIjpbImNsYXNzIiwic2VsZiIsImFsbG9jYXRlIiwicmFpc2UiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJ8IiwiXiIsIj09Iiwic2luZ2xldG9uX2NsYXNzIiwidG9fcyIsImR1cCIsImNsb25lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQywyREFB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ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBhcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIENvbXBhcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHdoYXQpIHtcbiAgICAgIGlmIChPcGFsLmlzX2Eod2hhdCwgT3BhbC5JbnRlZ2VyKSkgeyByZXR1cm4gd2hhdDsgfVxuXG4gICAgICBpZiAoI3tgd2hhdGAgPiAwfSkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKCN7YHdoYXRgIDwgMH0pIHsgcmV0dXJuIC0xOyB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsX2NvbXBhcmlzb24obGhzLCByaHMpIHtcbiAgICAgIHZhciBjbGFzc19uYW1lO1xuICAgICAgI3tcbiAgICAgICAgY2FzZSBgcmhzYFxuICAgICAgICB3aGVuIG5pbCwgdHJ1ZSwgZmFsc2UsIEludGVnZXIsIEZsb2F0XG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJGluc3BlY3QoKWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGBjbGFzc19uYW1lID0gcmhzLiQkY2xhc3NgXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgbGhzYC5jbGFzc30gd2l0aCAje2BjbGFzc19uYW1lYH0gZmFpbGVkXCJ9XG4gICAgfVxuICB9XG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiB0cnVlIGlmIGVxdWFsPyhvdGhlcilcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGZbXCIkPD0+XCJdID09IE9wYWwuS2VybmVsW1wiJDw9PlwiXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIGlmIChzZWxmLiQkY29tcGFyYWJsZSkge1xuICAgICAgICBkZWxldGUgc2VsZi4kJGNvbXBhcmFibGU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcblxuICAgIGBub3JtYWxpemUoY21wKSA9PSAwYFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuICAgICAgYGZhaWxfY29tcGFyaXNvbihzZWxmLCBvdGhlcilgXG4gICAgZW5kXG5cbiAgICBgbm9ybWFsaXplKGNtcCkgPiAwYFxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcbiAgICAgIGBmYWlsX2NvbXBhcmlzb24oc2VsZiwgb3RoZXIpYFxuICAgIGVuZFxuXG4gICAgYG5vcm1hbGl6ZShjbXApID49IDBgXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIHVubGVzcyBjbXAgPSAoc2VsZiA8PT4gb3RoZXIpXG4gICAgICBgZmFpbF9jb21wYXJpc29uKHNlbGYsIG90aGVyKWBcbiAgICBlbmRcblxuICAgIGBub3JtYWxpemUoY21wKSA8IDBgXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuICAgICAgYGZhaWxfY29tcGFyaXNvbihzZWxmLCBvdGhlcilgXG4gICAgZW5kXG5cbiAgICBgbm9ybWFsaXplKGNtcCkgPD0gMGBcbiAgZW5kXG5cbiAgZGVmIGJldHdlZW4/KG1pbiwgbWF4KVxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmIDwgbWluXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNlbGYgPiBtYXhcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBjbGFtcChtaW4sIG1heClcbiAgICBjbXAgPSBtaW4gPD0+IG1heFxuXG4gICAgdW5sZXNzIGNtcFxuICAgICAgYGZhaWxfY29tcGFyaXNvbihtaW4sIG1heClgXG4gICAgZW5kXG5cbiAgICBpZiBgbm9ybWFsaXplKGNtcCkgPiAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ21pbiBhcmd1bWVudCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggYXJndW1lbnQnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gbWluIGlmIGBub3JtYWxpemUoI3tzZWxmIDw9PiBtaW59KSA8IDBgXG4gICAgcmV0dXJuIG1heCBpZiBgbm9ybWFsaXplKCN7c2VsZiA8PT4gbWF4fSkgPiAwYFxuICAgIHNlbGZcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCI+IiwiMCIsIjwiLCJyYWlzZSIsImNsYXNzIiwiPT0iLCJlcXVhbD8iLCJvdGhlciIsImNtcCIsInNlbGYiLCI8PT4iLCI+PSIsIjw9IiwiYmV0d2Vlbj8iLCJtaW4iLCJtYXgiLCJjbGFtcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFDRjtBQUNBOztBQUVBLFVBQVlDLE9BQUMsSUFBREEsRUFBU0MsQ0FBVEQsQ0FBVztBQUN2QixVQUFZRSxPQUFDLElBQURBLEVBQVNELENBQVRDLENBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFDUSxhQUFBLFFBQU0sR0FBTjtBQUFBLElBQ0EsSUFBSyxrQkFBTCxJQUFVLG1CQUFWLElBQWdCLG9CQUFoQixJQUF1QixzQ0FBdkIsSUFBZ0Msb0NBQWhDLEdBQ0UsT0FBQywyQkFBRCxDQURGO0FBREEsSUFBQSxNQUlFLE9BQUMsd0JBQUQsQ0FKRixDQUFBO0FBT1IsVUFBUUMsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsZ0JBQUEsR0FBQSxDQUFpQixDQUFDLEdBQUQsQ0FBQUMsT0FBQUEsQ0FBQUEsQ0FBakIsQ0FBQSxHQUFBLFFBQUEsR0FBQSxDQUFzQyxVQUF0QyxDQUFBLEdBQUEsU0FBckJEO0FBQ1I7QUFDQSxFQXJCRTtBQUFBO0FBdUJBRSxJQUFBQSxz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UUFBZSxVQUFZTSxJQUFBQyxRQUFBQSxDQUFTSSxHQUFUSixDQUFhLEtBQXhDLENBQUE7QUFBQSxRQUFBLE9BQU9JLEdBQVAsQ0FWQTtBQUFBLE1BV0EsSUFBQSxRQUFlLFVBQVlMLElBQUFDLFFBQUFBLENBQVNLLEdBQVRMLENBQWEsS0FBeEMsQ0FBQTtBQUFBLFFBQUEsT0FBT0ssR0FBUCxDQVhBO0FBQUEsTUFZQSxPQUFBTixJQVpBO0FBREZPLElBQUFBLENBQUFBLGlDQUFBQSxDQWpGQTtBQURGakIsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1ODUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yZWdleHAucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUmVnZXhwRXJyb3IgPCBTdGFuZGFyZEVycm9yOyBlbmRcblxuY2xhc3MgUmVnZXhwIDwgYFJlZ0V4cGBcbiAgSUdOT1JFQ0FTRSA9IDFcbiAgRVhURU5ERUQgPSAyXG4gIE1VTFRJTElORSA9IDRcblxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19yZWdleHAnLCB0cnVlKWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICBhbGxvY2F0ZWQgPSBzdXBlclxuICAgICAgYCN7YWxsb2NhdGVkfS51bmluaXRpYWxpemVkID0gdHJ1ZWBcbiAgICAgIGFsbG9jYXRlZFxuICAgIGVuZFxuXG4gICAgZGVmIGVzY2FwZShzdHJpbmcpXG4gICAgICBgT3BhbC5lc2NhcGVfcmVnZXhwKHN0cmluZylgXG4gICAgZW5kXG5cbiAgICBkZWYgbGFzdF9tYXRjaChuID0gbmlsKVxuICAgICAgaWYgbi5uaWw/XG4gICAgICAgICR+XG4gICAgICBlbHNlXG4gICAgICAgICR+W25dXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIHF1b3RlIGVzY2FwZVxuXG4gICAgZGVmIHVuaW9uKCpwYXJ0cylcbiAgICAgICV4e1xuICAgICAgICB2YXIgaXNfZmlyc3RfcGFydF9hcnJheSwgcXVvdGVkX3ZhbGlkYXRlZCwgcGFydCwgb3B0aW9ucywgZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAvKD8hKS87XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGZhc3QgaWYgdGhlcmUncyBvbmx5IG9uZSBlbGVtZW50XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3ZlciB0aGUgMiBhcnJheXMgcGFzc2VkIGFzIGFyZ3VtZW50cyBjYXNlXG4gICAgICAgIGlzX2ZpcnN0X3BhcnRfYXJyYXkgPSBwYXJ0c1swXS4kJGlzX2FycmF5O1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBpc19maXJzdF9wYXJ0X2FycmF5KSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIEFycmF5IGludG8gU3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgICAvLyBkZWFsIHdpdGggc3BsYXQgaXNzdWVzIChyZWxhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvaXNzdWVzLzg1OClcbiAgICAgICAgaWYgKGlzX2ZpcnN0X3BhcnRfYXJyYXkpIHtcbiAgICAgICAgICBwYXJ0cyA9IHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHF1b3RlZF92YWxpZGF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKHBhcnQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGApfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHBhcnQuJCRpc19yZWdleHApIHtcbiAgICAgICAgICAgIGVhY2hfcGFydF9vcHRpb25zID0gI3tgcGFydGAub3B0aW9uc307XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucyAhPSBlYWNoX3BhcnRfb3B0aW9ucykge1xuICAgICAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0FsbCBleHByZXNzaW9ucyBtdXN0IHVzZSB0aGUgc2FtZSBvcHRpb25zJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSBlYWNoX3BhcnRfb3B0aW9ucztcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgnKCcrcGFydC5zb3VyY2UrJyknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goI3tlc2NhcGUoYHBhcnRgLnRvX3N0cil9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICMgVGFrZSBhZHZhbnRhZ2Ugb2YgbG9naWMgdGhhdCBjYW4gcGFyc2Ugb3B0aW9ucyBmcm9tIEpTIFJlZ2V4XG4gICAgICBuZXcoYHF1b3RlZF92YWxpZGF0ZWRgLmpvaW4oJ3wnKSwgYG9wdGlvbnNgKVxuICAgIGVuZFxuXG4gICAgZGVmIG5ldyhyZWdleHAsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKHJlZ2V4cC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdleHAgPSAje09wYWwuY29lcmNlX3RvIShyZWdleHAsIFN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIGlmIChyZWdleHAuY2hhckF0KHJlZ2V4cC5sZW5ndGggLSAxKSA9PT0gJ1xcXFwnICYmIHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDIpICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAje3JhaXNlIFJlZ2V4cEVycm9yLCBcInRvbyBzaG9ydCBlc2NhcGUgc2VxdWVuY2U6IC8je3JlZ2V4cH0vXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICN7IW9wdGlvbnN9KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSAnJztcbiAgICAgICAgICBpZiAoI3tJR05PUkVDQVNFfSAmIG9wdGlvbnMpIHsgdGVtcCArPSAnaSc7IH1cbiAgICAgICAgICBpZiAoI3tNVUxUSUxJTkV9ICAmIG9wdGlvbnMpIHsgdGVtcCArPSAnbSc7IH1cbiAgICAgICAgICBvcHRpb25zID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gJ2knO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiA9PT0oc3RyaW5nKVxuICAgIGAje21hdGNoKE9wYWwuY29lcmNlX3RvPyhzdHJpbmcsIFN0cmluZywgOnRvX3N0cikpfSAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgPX4oc3RyaW5nKVxuICAgIG1hdGNoKHN0cmluZykgJiYgJH4uYmVnaW4oMClcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgIyBVc2UgYSByZWdleHAgdG8gZXh0cmFjdCB0aGUgcmVndWxhciBleHByZXNzaW9uIGFuZCB0aGUgb3B0aW9uYWwgbW9kZSBtb2RpZmllcnMgZnJvbSB0aGUgc3RyaW5nLlxuICAgICMgSW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZXNjYXBlIGFueSBmcm9udCBzbGFzaCAobm90IGFscmVhZHkgZXNjYXBlZCkgd2l0aCBhIGJhY2tzbGFzaC5cbiAgICAleHtcbiAgICAgIHZhciByZWdleHBfZm9ybWF0ID0gL15cXC8oLiopXFwvKFteXFwvXSopJC87XG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4cF9mb3JtYXQuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm4gPSBtYXRjaGVzWzFdO1xuICAgICAgICB2YXIgcmVnZXhwX2ZsYWdzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgdmFyIGNoYXJzID0gcmVnZXhwX3BhdHRlcm4uc3BsaXQoJycpO1xuICAgICAgICB2YXIgY2hhcnNfbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudF9jaGFyID0gY2hhcnNbaV07XG4gICAgICAgICAgaWYgKCFjaGFyX2VzY2FwZWQgJiYgY3VycmVudF9jaGFyID09ICcvJykge1xuICAgICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9IHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQuY29uY2F0KCdcXFxcJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdChjdXJyZW50X2NoYXIpO1xuICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoY2hhcl9lc2NhcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IG92ZXIgZXNjYXBlXG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLycgKyByZWdleHBfcGF0dGVybl9lc2NhcGVkICsgJy8nICsgcmVnZXhwX2ZsYWdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHN0cmluZywgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIHZhciBtID0gc2VsZi5leGVjKCN7T3BhbC5jb2VyY2VfdG8oc3RyaW5nLCBTdHJpbmcsIDp0b19zdHIpfSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHNlbGZgLCBgbWApfTtcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICN7T3BhbC5jb2VyY2VfdG8ocG9zLCBJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICN7T3BhbC5jb2VyY2VfdG8oc3RyaW5nLCBTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zICs9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdsb2JhbCBSZWdFeHAgbWFpbnRhaW5zIHN0YXRlLCBzbyBub3QgdXNpbmcgc2VsZi90aGlzXG4gICAgICB2YXIgbWQsIHJlID0gT3BhbC5nbG9iYWxfcmVnZXhwKHNlbGYpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtZCA9IHJlLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgaWYgKG1kID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZC5pbmRleCA+PSBwb3MpIHtcbiAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgcmVgLCBgbWRgKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG1kLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8oc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbmlsID8gZmFsc2UgOiBzZWxmLnRlc3QoI3tPcGFsLmNvZXJjZV90byhzdHJpbmcsIFN0cmluZywgOnRvX3N0cil9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gI3tPcGFsLmNvZXJjZV90byhwb3MsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gI3tPcGFsLmNvZXJjZV90byhzdHJpbmcsIFN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG1kID09PSBudWxsIHx8IG1kLmluZGV4IDwgcG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIH5cbiAgICBzZWxmID1+ICRfXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VcbiAgICBgc2VsZi5zb3VyY2VgXG4gIGVuZFxuXG4gIGRlZiBvcHRpb25zXG4gICAgIyBGbGFncyB3b3VsZCBiZSBuaWNlIHRvIHVzZSB3aXRoIHRoaXMsIGJ1dCBzdGlsbCBleHBlcmltZW50YWwgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvZmxhZ3NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIC8vIHNob3VsZCBiZSBzdXBwb3J0ZWQgaW4gSUU2IGFjY29yZGluZyB0byBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5LzdmNXoyNnc0KHY9dnMuOTQpLmFzcHhcbiAgICAgIGlmIChzZWxmLm11bHRpbGluZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tNVUxUSUxJTkV9O1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuaWdub3JlQ2FzZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tJR05PUkVDQVNFfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FzZWZvbGQ/XG4gICAgYHNlbGYuaWdub3JlQ2FzZWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBzb3VyY2VcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWdleHAsIG1hdGNoX2dyb3VwcylcbiAgICAkfiAgICAgICAgICA9IHNlbGZcbiAgICBAcmVnZXhwICAgICA9IHJlZ2V4cFxuICAgIEBiZWdpbiAgICAgID0gYG1hdGNoX2dyb3Vwcy5pbmRleGBcbiAgICBAc3RyaW5nICAgICA9IGBtYXRjaF9ncm91cHMuaW5wdXRgXG4gICAgQHByZV9tYXRjaCAgPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKDAsIG1hdGNoX2dyb3Vwcy5pbmRleClgXG4gICAgQHBvc3RfbWF0Y2ggPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKG1hdGNoX2dyb3Vwcy5pbmRleCArIG1hdGNoX2dyb3Vwc1swXS5sZW5ndGgpYFxuICAgIEBtYXRjaGVzICAgID0gW11cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1hdGNoX2dyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBtYXRjaF9ncm91cHNbaV07XG5cbiAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKG5pbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXSgqYXJncylcbiAgICBAbWF0Y2hlc1sqYXJnc11cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI29mZnNldCBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBbc2VsZi5iZWdpbiwgc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgTWF0Y2hEYXRhID09PSBvdGhlclxuXG4gICAgYHNlbGYuc3RyaW5nID09IG90aGVyLnN0cmluZ2AgJiZcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxuICAgICAgYHNlbGYucHJlX21hdGNoID09IG90aGVyLnByZV9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLnBvc3RfbWF0Y2ggPT0gb3RoZXIucG9zdF9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjYmVnaW4gb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlbmQobilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FwdHVyZXNcbiAgICBgI3tAbWF0Y2hlc30uc2xpY2UoMSlgXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBcIiBcIiArIGkgKyBcIjpcIiArICN7YCN7QG1hdGNoZXN9W2ldYC5pbnNwZWN0fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BtYXRjaGVzfS5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHRvX2FcbiAgICBAbWF0Y2hlc1xuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAje0BtYXRjaGVzfVswXWBcbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBpLCBhLCBpbmRleCwgdmFsdWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19yYW5nZSkge1xuICAgICAgICAgIGEgPSAje2BhcmdzW2ldYC50b19hfTtcbiAgICAgICAgICBhLnVuc2hpZnQoaSwgMSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShhcmdzLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gI3tPcGFsLmNvZXJjZV90byEoYGFyZ3NbaV1gLCBJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9ICN7QG1hdGNoZXN9Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuaWwpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLnB1c2goI3tAbWF0Y2hlc31baW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIxIiwiMiIsIjQiLCJhbGxvY2F0ZSIsImFsbG9jYXRlZCIsImVzY2FwZSIsImxhc3RfbWF0Y2giLCJuIiwibmlsPyIsIiR+IiwiW10iLCJ1bmlvbiIsInJhaXNlIiwib3B0aW9ucyIsInRvX3N0ciIsIm5ldyIsImpvaW4iLCJjb2VyY2VfdG8hIiwicmVnZXhwIiwiISIsInNlbGYiLCI9PSIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsInN0cmluZyIsIj1+IiwiYmVnaW4iLCIwIiwiaW5zcGVjdCIsImNvZXJjZV90byIsInBvcyIsIm1hdGNoPyIsIn4iLCIkXyIsInNvdXJjZSIsImNhc2Vmb2xkPyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkByZWdleHAiLCJAYmVnaW4iLCJAc3RyaW5nIiwiQHByZV9tYXRjaCIsIkBwb3N0X21hdGNoIiwiQG1hdGNoZXMiLCJhcmdzIiwib2Zmc2V0Iiwib3RoZXIiLCJlbmQiLCJjYXB0dXJlcyIsImxlbmd0aCIsInRvX2EiLCJ0b19zIiwidmFsdWVzX2F0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBLEVBQUFBLEdBQUFBLFdBQUFBLEVBQW9CLDZCQUFwQkEsV0FBQTtBQUFBLEVBRUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBLDBDQUFhQyxDQUFiLENBQUE7QUFBQSxJQUNBLHdDQUFXQyxDQUFYLENBREE7QUFBQSxJQUVBLHlDQUFZQyxDQUFaLENBRkE7QUFBQSxJQUlDLDBEQUpEO0FBQUEsSUFNQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFlBQVksVUFBQSxFQUFBLGdFQUFBLFFBQUEsT0FBQSxDQUFaO0FBQUEsUUFDR0EsU0FBVSxxQkFEYjtBQUFBLFFBRUEsT0FBQUEsU0FGQTtBQURGRCxNQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQTtBQUFBO0FBTUFFLE1BQUFBLDBCQUFBQSxZQUFBQSxrQkFBVyxNQUFYQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFDLDBCQUFEO0FBREZB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QSxPQUFBQyxDQUFBQSw2QkFBQUEsMEJBQUFBLHFCQXZYRixFQXVYRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBdlhGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBdVhnQixNQUFBLGtCQXZYaEI7QUFBQTtBQXlYQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWdCLENBQUMsT0FBRCxDQUFBRixNQUFBQSxDQUFBQSxDQUFlO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxnQkFBa0Isb0JBQUFsQyxlQUFBQSxDQUFpQixTQUFVLHlCQUFTLFFBQXBDQSxDQUE2Qzs7QUFFL0Q7QUFDQSxtQkFBcUIyQixZQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQXNCQSxZQUFTO0FBQy9COztBQUVBO0FBQ0EsSUFqWkE7QUF1WEVTLElBQUFBLENBQUFBLHNDQUFBQSxDQUFBQSxxQkFsR0E7QUFERnRELEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBblJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6NjM2MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RyaW5nLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xuXG5jbGFzcyBTdHJpbmcgPCBgU3RyaW5nYFxuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICAleHtcbiAgICBPcGFsLmRlZmluZVByb3BlcnR5KCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGlzX3N0cmluZycsIHRydWUpO1xuXG4gICAgT3BhbC5kZWZpbmVQcm9wZXJ0eSgje3NlbGZ9LiQkcHJvdG90eXBlLCAnJCRjYXN0JywgZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIga2xhc3MgPSB0aGlzLiQkY2xhc3M7XG4gICAgICBpZiAoa2xhc3MuJCRjb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IGtsYXNzLiQkY29uc3RydWN0b3Ioc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlZiBfX2lkX19cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQod2hhdClcbiAgICBPcGFsLmNvZXJjZV90bz8od2hhdCwgU3RyaW5nLCA6dG9fc3RyKVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXcoc3RyID0gJycpXG4gICAgc3RyID0gT3BhbC5jb2VyY2VfdG8oc3RyLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYG5ldyBzZWxmLiQkY29uc3RydWN0b3Ioc3RyKWBcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoc3RyID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnTXV0YWJsZSBzdHJpbmdzIGFyZSBub3Qgc3VwcG9ydGVkIGluIE9wYWwuJ1xuICBlbmRcblxuICBkZWYgJShkYXRhKVxuICAgIGlmIEFycmF5ID09PSBkYXRhXG4gICAgICBmb3JtYXQoc2VsZiwgKmRhdGEpXG4gICAgZWxzZVxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKGNvdW50KVxuICAgICV4e1xuICAgICAgY291bnQgPSAje09wYWwuY29lcmNlX3RvKGBjb3VudGAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcmd1bWVudCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QoJycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b1N0cmluZygpO1xuXG4gICAgICAvLyBBbGwgY3JlZGl0IGZvciB0aGUgYml0LXR3aWRkbGluZyBtYWdpYyBjb2RlIGJlbG93IGdvZXMgdG8gTW96aWxsYVxuICAgICAgLy8gcG9seWZpbGwgaW1wbGVtZW50YXRpb24gb2YgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoKSBwb3N0ZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBlYXRcblxuICAgICAgaWYgKHN0cmluZy5sZW5ndGggKiBjb3VudCA+PSAxIDw8IDI4KSB7XG4gICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgJ211bHRpcGx5IGNvdW50IG11c3Qgbm90IG92ZXJmbG93IG1heGltdW0gc3RyaW5nIHNpemUnfVxuICAgICAgfVxuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoY291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgPj4+PSAxO1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8gb3RoZXIsIFN0cmluZywgOnRvX3N0clxuXG4gICAgYHNlbGYgKyAje290aGVyLnRvX3N9YFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcbiAgICAgIG90aGVyID0gb3RoZXIudG9fc3RyLnRvX3NcblxuICAgICAgYHNlbGYgPiBvdGhlciA/IDEgOiAoc2VsZiA8IG90aGVyID8gLTEgOiAwKWBcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgdmFyIGNtcCA9ICN7b3RoZXIgPD0+IHNlbGZ9O1xuXG4gICAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNtcCA+IDAgPyAtMSA6IChjbXAgPCAwID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICByZXR1cm4gc2VsZi50b1N0cmluZygpID09PSBvdGhlci50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKCN7T3BhbC5yZXNwb25kX3RvPyBgb3RoZXJgLCA6dG9fc3RyfSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgPT09ID09XG5cbiAgZGVmID1+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndHlwZSBtaXNtYXRjaDogU3RyaW5nIGdpdmVuJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje290aGVyID1+IHNlbGZ9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLCBleGNsdWRlO1xuXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICBleGNsdWRlID0gaW5kZXguZXhjbDtcbiAgICAgICAgbGVuZ3RoICA9ICN7T3BhbC5jb2VyY2VfdG8oYGluZGV4LmVuZGAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaW5kZXggICA9ICN7T3BhbC5jb2VyY2VfdG8oYGluZGV4LmJlZ2luYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhpbmRleCkgPiBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gaW5kZXg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc3Vic3RyKGluZGV4LCBsZW5ndGgpKTtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3J9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihpbmRleCkgIT09IC0xID8gc2VsZi4kJGNhc3QoaW5kZXgpIDogbmlsO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZWxmLm1hdGNoKGluZGV4KTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgaW5kZXhgLCBgbWF0Y2hgKX1cblxuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gI3tPcGFsLmNvZXJjZV90byhgbGVuZ3RoYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwICYmIC1sZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbbGVuZ3RoICs9IG1hdGNoLmxlbmd0aF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFtsZW5ndGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaW5kZXggPSAje09wYWwuY29lcmNlX3RvKGBpbmRleGAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIDEpKTtcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoID0gI3tPcGFsLmNvZXJjZV90byhgbGVuZ3RoYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgYnl0ZXNsaWNlIFtdXG5cbiAgZGVmIGJcbiAgICBmb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGNhcGl0YWxpemVcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNlbGYuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpYFxuICBlbmRcblxuICBkZWYgY2FzZWNtcChvdGhlcilcbiAgICByZXR1cm4gbmlsIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8ob3RoZXIsIFN0cmluZywgOnRvX3N0cikudG9fc1xuICAgICV4e1xuICAgICAgdmFyIGFzY2lpX29ubHkgPSAvXltcXHgwMC1cXHg3Rl0qJC87XG4gICAgICBpZiAoYXNjaWlfb25seS50ZXN0KHNlbGYpICYmIGFzY2lpX29ubHkudGVzdChvdGhlcikpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgb3RoZXIgPSBvdGhlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmIDw9PiBvdGhlclxuICBlbmRcblxuICBkZWYgY2FzZWNtcD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgY21wID0gI3tjYXNlY21wKG90aGVyKX07XG4gICAgICBpZiAoY21wID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbXAgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2VudGVyKHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gT3BhbC5jb2VyY2VfdG8od2lkdGgsIEludGVnZXIsIDp0b19pbnQpXG4gICAgcGFkc3RyID0gT3BhbC5jb2VyY2VfdG8ocGFkc3RyLCBTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qocmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaGFycygmYmxvY2spXG4gICAgcmV0dXJuIGVhY2hfY2hhci50b19hIHVubGVzcyBibG9ja1xuXG4gICAgZWFjaF9jaGFyKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGNob21wKHNlcGFyYXRvciA9ICQvKVxuICAgIHJldHVybiBzZWxmIGlmIGBzZXBhcmF0b3IgPT09IG5pbCB8fCBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIHNlcGFyYXRvciA9IE9wYWwuY29lcmNlX3RvIShzZXBhcmF0b3IsIFN0cmluZywgOnRvX3N0cikudG9fc1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvXFxyP1xcbj8kLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VwYXJhdG9yID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYucmVwbGFjZSgvKFxccj9cXG4pKyQvLCAnJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmLmxlbmd0aCA+PSBzZXBhcmF0b3IubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0YWlsID0gc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoLCBzZXBhcmF0b3IubGVuZ3RoKTtcblxuICAgICAgICBpZiAodGFpbCA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgc2VsZi5sZW5ndGggLSBzZXBhcmF0b3IubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2hvcFxuICAgICV4e1xuICAgICAgdmFyIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCByZXN1bHQ7XG5cbiAgICAgIGlmIChsZW5ndGggPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gXCJcXG5cIiAmJiBzZWxmLmNoYXJBdChsZW5ndGggLSAyKSA9PT0gXCJcXHJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBsZW5ndGggLSAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaHJcbiAgICBgc2VsZi5jaGFyQXQoMClgXG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgIGNvcHkgPSBgc2VsZi5zbGljZSgpYFxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgc2VsZi5zbGljZSgpYFxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3VudCgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfcHJlZml4KHByZWZpeClcbiAgICAleHtcbiAgICAgIGlmICghcHJlZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7cHJlZml4ID0gT3BhbC5jb2VyY2VfdG8ocHJlZml4LCBTdHJpbmcsIDp0b19zdHIpfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zbGljZSgwLCBwcmVmaXgubGVuZ3RoKSA9PT0gcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnNsaWNlKHByZWZpeC5sZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9zdWZmaXgoc3VmZml4KVxuICAgICV4e1xuICAgICAgaWYgKCFzdWZmaXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tzdWZmaXggPSBPcGFsLmNvZXJjZV90byhzdWZmaXgsIFN0cmluZywgOnRvX3N0cil9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zbGljZSgwLCBzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRvd25jYXNlXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYudG9Mb3dlckNhc2UoKSlgXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jaGFyKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLmNoYXJBdChpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9saW5lKHNlcGFyYXRvciA9ICQvLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2xpbmUsIHNlcGFyYXRvciB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IG5pbCkge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZik7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHNlcGFyYXRvciA9ICN7T3BhbC5jb2VyY2VfdG8oYHNlcGFyYXRvcmAsIFN0cmluZywgOnRvX3N0cil9XG5cbiAgICAgIHZhciBhLCBpLCBuLCBsZW5ndGgsIGNob21wZWQsIHRyYWlsaW5nLCBzcGxpdHRlZDtcblxuICAgICAgaWYgKHNlcGFyYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yIChhID0gc2VsZi5zcGxpdCgvKFxcbnsyLH0pLyksIGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoYVtpXSB8fCBhW2kgKyAxXSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gKGFbaV0gfHwgXCJcIikgKyAoYVtpICsgMV0gfHwgXCJcIik7XG4gICAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3QodmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgY2hvbXBlZCAgPSAje2Nob21wKHNlcGFyYXRvcil9O1xuICAgICAgdHJhaWxpbmcgPSBzZWxmLmxlbmd0aCAhPSBjaG9tcGVkLmxlbmd0aDtcbiAgICAgIHNwbGl0dGVkID0gY2hvbXBlZC5zcGxpdChzZXBhcmF0b3IpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzcGxpdHRlZC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEgfHwgdHJhaWxpbmcpIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3Qoc3BsaXR0ZWRbaV0gKyBzZXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3Qoc3BsaXR0ZWRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVuZF93aXRoPygqc3VmZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3VmZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1ZmZpeCA9ICN7T3BhbC5jb2VyY2VfdG8oYHN1ZmZpeGVzW2ldYCwgU3RyaW5nLCA6dG9fc3RyKS50b19zfTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PT1cblxuICBkZWYgZ3N1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6Z3N1YiwgcGF0dGVybn07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJywgbWF0Y2hfZGF0YSA9IG5pbCwgaW5kZXggPSAwLCBtYXRjaCwgX3JlcGxhY2VtZW50O1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAje09wYWwuY29lcmNlX3RvKGBwYXR0ZXJuYCwgU3RyaW5nLCA6dG9fc3RyKX07XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0SW5kZXg7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJlc3VsdCArPSBzZWxmLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoX2RhdGEgPSAje01hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhc3RJbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IGJsb2NrKG1hdGNoWzBdKTtcbiAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IGxhc3RJbmRleDsgLy8gc2F2ZSBhbmQgcmVzdG9yZSBsYXN0SW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKCFyZXBsYWNlbWVudC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAje09wYWwuY29lcmNlX3RvKGByZXBsYWNlbWVudGAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChfcmVwbGFjZW1lbnQgKyBzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCArIDEpKVxuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQpXG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgaGV4XG4gICAgdG9faSAxNlxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7b3RoZXIgPSBPcGFsLmNvZXJjZV90byhvdGhlciwgU3RyaW5nLCA6dG9fc3RyKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2Yob3RoZXIpICE9PSAtMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByZWdleDtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAje09wYWwuY29lcmNlX3RvKGBvZmZzZXRgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VhcmNoLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHJlZ2V4ID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZWFyY2gpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICN7JH4gPSBuaWx9O1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF0Y2guaW5kZXggPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgcmVnZXhgLCBgbWF0Y2hgKX1cbiAgICAgICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2ggPSAje09wYWwuY29lcmNlX3RvKGBzZWFyY2hgLCBTdHJpbmcsIDp0b19zdHIpfTtcbiAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDAgJiYgb2Zmc2V0ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbmlsIDogaW5kZXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxcdTAwN0YtXFx1MDA5RlxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgICAgbWV0YSA9IHtcbiAgICAgICAgICAgICdcXHUwMDA3JzogJ1xcXFxhJyxcbiAgICAgICAgICAgICdcXHUwMDFiJzogJ1xcXFxlJyxcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXFx2JzogJ1xcXFx2JyxcbiAgICAgICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXNjYXBlZCA9IHNlbGYucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChjaHIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRhW2Nocl0gfHwgJ1xcXFx1JyArICgnMDAwMCcgKyBjaHIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTQpO1xuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1xcI1tcXCRcXEBcXHtdL2csICdcXFxcJCYnKSArICdcIic7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW50ZXJuXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmIGxpbmVzKHNlcGFyYXRvciA9ICQvLCAmYmxvY2spXG4gICAgZSA9IGVhY2hfbGluZShzZXBhcmF0b3IsICZibG9jaylcbiAgICBibG9jayA/IHNlbGYgOiBlLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGxqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gT3BhbC5jb2VyY2VfdG8od2lkdGgsIEludGVnZXIsIDp0b19pbnQpXG4gICAgcGFkc3RyID0gT3BhbC5jb2VyY2VfdG8ocGFkc3RyLCBTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBpbmRleCAgPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBcIlwiO1xuXG4gICAgICB3aWR0aCAtPSBzZWxmLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCB3aWR0aCkge1xuICAgICAgICByZXN1bHQgKz0gcGFkc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZiArIHJlc3VsdC5zbGljZSgwLCB3aWR0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15cXHMqLywgJycpYFxuICBlbmRcblxuICBkZWYgYXNjaWlfb25seT9cbiAgICAjIG5vbi1BU0NJSS1jb21wYXRpYmxlIGVuY29kaW5nIG11c3QgcmV0dXJuIGZhbHNlXG4gICAgIyBOT1RFOiBFbmNvZGluZzo6VVRGXzE2TEUgaXMgYWxzbyBub24tQVNDSUktY29tcGF0aWJsZSBlbmNvZGluZyxcbiAgICAjIGJ1dCBzaW5jZSB0aGUgZGVmYXVsdCBlbmNvZGluZyBpbiBKYXZhU2NyaXB0IGlzIFVURl8xNkxFLFxuICAgICMgd2UgY2Fubm90IHJldHVybiBmYWxzZSBvdGhlcndpc2UgdGhlIGZvbGxvd2luZyB3aWxsIChpbmNvcnJlY3RseSkgcmV0dXJuIGZhbHNlOiBcImhlbGxvXCIuYXNjaWlfb25seT9cbiAgICAjIEluIG90aGVyIHdvcmRzLCB3ZSBjYW5ub3QgdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuOlxuICAgICMgLSBcImhlbGxvXCIuZm9yY2VfZW5jb2RpbmcoXCJVVEYtMTZMRVwiKVxuICAgICMgLSBcImhlbGxvXCJcbiAgICAjIFRoZSBwcm9ibGVtIGlzIHRoYXQgXCJhc2NpaV9vbmx5XCIgc2hvdWxkIHJldHVybiBmYWxzZSBpbiB0aGUgZmlyc3QgY2FzZSBhbmQgdHJ1ZSBpbiB0aGUgc2Vjb25kIGNhc2UuXG4gICAgaWYgZW5jb2RpbmcgPT0gRW5jb2Rpbmc6OlVURl8xNkJFXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICBlbmRcbiAgICBgL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBtYXRjaChwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IFJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgUmVnZXhwID09PSBwYXR0ZXJuXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2goc2VsZiwgcG9zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8ocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkKVxuICAgIGlmIFN0cmluZyA9PT0gcGF0dGVybiB8fCBwYXR0ZXJuLnJlc3BvbmRfdG8/KDp0b19zdHIpXG4gICAgICBwYXR0ZXJuID0gUmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyBSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxuICAgIGVuZFxuXG4gICAgcGF0dGVybi5tYXRjaD8oc2VsZiwgcG9zKVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgICV4e1xuICAgICAgdmFyIGkgPSBzZWxmLmxlbmd0aDtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdCgnJyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZjtcbiAgICAgIHZhciBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID0gc2VsZi5zZWFyY2goL1thLXpBLVowLTldLyk7XG4gICAgICB2YXIgY2FycnkgPSBmYWxzZTtcbiAgICAgIHZhciBjb2RlO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb2RlID0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDY1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gOTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpICsgMSk7XG4gICAgICAgIGlmIChjYXJyeSAmJiAoaSA9PT0gMCB8fCBpID09PSBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4KSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXJyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZixcbiAgICAgICAgICByYWRpeCA9IDg7XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvaSwgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4Jykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICBgc2VsZi5jaGFyQ29kZUF0KDApYFxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBzZXAuZXhlYyhzZWxmKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGBzZXBgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICN7T3BhbC5jb2VyY2VfdG8oYHNlcGAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBpID0gc2VsZi5pbmRleE9mKHNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gW3NlbGYsICcnLCAnJ107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNlbGYuc2xpY2UoMCwgaSksXG4gICAgICAgIHNlbGYuc2xpY2UoaSwgaSArIHNlcC5sZW5ndGgpLFxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKVxuICAgICAgXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKWBcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gI3tPcGFsLmNvZXJjZV90byhgb2Zmc2V0YCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwgfHwgX20uaW5kZXggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaCA9ICN7T3BhbC5jb2VyY2VfdG8oYHNlYXJjaGAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZWFyY2gsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpID09PSAtMSA/IG5pbCA6IGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBPcGFsLmNvZXJjZV90byh3aWR0aCwgSW50ZWdlciwgOnRvX2ludClcbiAgICBwYWRzdHIgPSBPcGFsLmNvZXJjZV90byhwYWRzdHIsIFN0cmluZywgOnRvX3N0cikudG9fc1xuXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGNoYXJzICAgICA9IE1hdGguZmxvb3Iod2lkdGggLSBzZWxmLmxlbmd0aCksXG4gICAgICAgICAgcGF0dGVybnMgID0gTWF0aC5mbG9vcihjaGFycyAvIHBhZHN0ci5sZW5ndGgpLFxuICAgICAgICAgIHJlc3VsdCAgICA9IEFycmF5KHBhdHRlcm5zICsgMSkuam9pbihwYWRzdHIpLFxuICAgICAgICAgIHJlbWFpbmluZyA9IGNoYXJzIC0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCArIHBhZHN0ci5zbGljZSgwLCByZW1haW5pbmcpICsgc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcnBhcnRpdGlvbihzZXApXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChzZXAuJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IG51bGw7XG4gICAgICAgIHIgPSBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHNlcCk7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgc2VwID0gbVswXTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAje09wYWwuY29lcmNlX3RvKGBzZXBgLCBTdHJpbmcsIDp0b19zdHIpfTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbJycsICcnLCBzZWxmXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZi5zbGljZSgwLCBpKSxcbiAgICAgICAgc2VsZi5zbGljZShpLCBpICsgc2VwLmxlbmd0aCksXG4gICAgICAgIHNlbGYuc2xpY2UoaSArIHNlcC5sZW5ndGgpXG4gICAgICBdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc2NhbihwYXR0ZXJuLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgbWF0Y2hfZGF0YSA9IG5pbCxcbiAgICAgICAgICBtYXRjaDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gI3tPcGFsLmNvZXJjZV90byhgcGF0dGVybmAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpKSAhPSBudWxsKSB7XG4gICAgICAgIG1hdGNoX2RhdGEgPSAje01hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcbiAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IHJlc3VsdC5wdXNoKG1hdGNoWzBdKSA6IHJlc3VsdC5wdXNoKCN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2gubGVuZ3RoID09IDEgPyBibG9jayhtYXRjaFswXSkgOiBibG9jay5jYWxsKHNlbGYsICN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4ubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cblxuICAgICAgcmV0dXJuIChibG9jayAhPT0gbmlsID8gc2VsZiA6IHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGFsaWFzIHNsaWNlIFtdXG5cbiAgZGVmIHNwbGl0KHBhdHRlcm4gPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXQgPSAje09wYWwuY29lcmNlX3RvIShsaW1pdCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAobGltaXQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gW3NlbGZdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQgfHwgcGF0dGVybiA9PT0gbmlsKSB7XG4gICAgICAgIHBhdHRlcm4gPSAjeyQ7IHx8ICcgJ307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGksIGlpO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAje09wYWwuY29lcmNlX3RvKHBhdHRlcm4sIFN0cmluZywgOnRvX3N0cikudG9fc307XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnICcpIHtcbiAgICAgICAgICBwYXR0ZXJuID0gL1xccysvZ207XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL15cXHMrLywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gc3RyaW5nLnNwbGl0KHBhdHRlcm4pO1xuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSAmJiByZXN1bHRbMF0gPT09IHN0cmluZykge1xuICAgICAgICByZXR1cm4gW3NlbGYuJCRjYXN0KHJlc3VsdFswXSldO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKGkgPSByZXN1bHQuaW5kZXhPZih1bmRlZmluZWQpKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShpLCAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FzdFJlc3VsdCgpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGYuJCRjYXN0KHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgICAgIHdoaWxlIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICAgIHJlc3VsdC5sZW5ndGggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XG5cbiAgICAgIGlmIChsaW1pdCA8IDApIHtcbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoWzBdID09PSAnJyAmJiBwYXR0ZXJuLnNvdXJjZS5pbmRleE9mKCcoPz0nKSA9PT0gLTEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG1hdGNoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgcmVzdWx0LnNsaWNlKGxpbWl0IC0gMSkuam9pbignJykpO1xuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICBpZiAoaSArIDEgPT09IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgc3RyaW5nLnNsaWNlKGluZGV4KSk7XG4gICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYucmVwbGFjZSgvKC4pXFwxKy9nLCAnJDEnKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyBjaGFyX2NsYXNzICsgJylcXFxcMSsnLCAnZycpLCAnJDEnKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RhcnRfd2l0aD8oKnByZWZpeGVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSAje09wYWwuY29lcmNlX3RvKGBwcmVmaXhlc1tpXWAsIFN0cmluZywgOnRvX3N0cikudG9fc307XG5cbiAgICAgICAgaWYgKHNlbGYuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvW1xcc1xcdTAwMDBdKiQvLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzdWIocGF0dGVybiwgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghcGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gI3tPcGFsLmNvZXJjZV90byhgcGF0dGVybmAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0LCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcblxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgIHJlc3VsdCA9IHNlbGYudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgxIGZvciAyKSd9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgYmxvY2sobWF0Y2hbMF0pICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9ICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gI3tPcGFsLmNvZXJjZV90byhgcmVwbGFjZW1lbnRgLCBTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvKFtcXFxcXSspKFswLTkrJmAnXSkvZywgZnVuY3Rpb24gKG9yaWdpbmFsLCBzbGFzaGVzLCBjb21tYW5kKSB7XG4gICAgICAgICAgICBpZiAoc2xhc2hlcy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgY2FzZSBcIiZcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFswXTtcbiAgICAgICAgICAgIGNhc2UgXCJgXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgZGVmYXVsdDogIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgKG1hdGNoW2NvbW1hbmRdIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudCArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3VjYyBuZXh0XG5cbiAgZGVmIHN1bShuID0gMTYpXG4gICAgJXh7XG4gICAgICBuID0gI3tPcGFsLmNvZXJjZV90byhgbmAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHNlbGYuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0ICYgKE1hdGgucG93KDIsIG4pIC0gMSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3dhcGNhc2VcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLnJlcGxhY2UoLyhbYS16XSspfChbQS1aXSspL2csIGZ1bmN0aW9uKCQwLCQxLCQyKSB7XG4gICAgICAgIHJldHVybiAkMSA/ICQwLnRvVXBwZXJDYXNlKCkgOiAkMC50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxmLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c2VsZi5jbGFzcy5uZXcgYHN0cmB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGbG9hdChzZWxmLnJlcGxhY2UoL18vZywgJycpKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkgfHwgcmVzdWx0ID09IEluZmluaXR5IHx8IHJlc3VsdCA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19pKGJhc2UgPSAxMClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHJhZGl4ID0gI3tPcGFsLmNvZXJjZV90byhgYmFzZWAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgaWYgKHJhZGl4ID09PSAxIHx8IHJhZGl4IDwgMCB8fCByYWRpeCA+IDM2KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YHJhZGl4YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykoLispJC8sIGZ1bmN0aW9uIChvcmlnaW5hbCwgaGVhZCwgZmxhZywgdGFpbCkge1xuICAgICAgICBzd2l0Y2ggKHRhaWwuY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgxKSA9PT0gJ3gnICYmIGZsYWcgPT09ICcweCcgJiYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDIpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSA4KSB7XG4gICAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxMCkge1xuICAgICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSB7XG4gICAgICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBtZXRob2RfbmFtZSA9ICckJyArIGBzZWxmLnZhbHVlT2YoKWBcblxuICAgIHByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAleHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgZ2l2ZW4nfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3YgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChyZWN2ID09IG51bGwpIHJlY3YgPSBuaWw7XG5cbiAgICAgICAgdmFyIGJvZHkgPSByZWN2WyN7bWV0aG9kX25hbWV9XTtcblxuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdi4kbWV0aG9kX21pc3NpbmcuYXBwbHkocmVjdiwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYm9keS4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBib2R5LmNhbGwocmVjdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBhbGlhcyB0b19zdHIgdG9fc1xuXG4gIGFsaWFzIHRvX3N5bSBpbnRlcm5cblxuICBkZWYgdHIoZnJvbSwgdG8pXG4gICAgZnJvbSA9IE9wYWwuY29lcmNlX3RvKGZyb20sIFN0cmluZywgOnRvX3N0cikudG9fc1xuICAgIHRvID0gT3BhbC5jb2VyY2VfdG8odG8sIFN0cmluZywgOnRvX3N0cikudG9fc1xuICAgICV4e1xuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDAgfHwgZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJvbV9jaGFycyA9IGZyb21fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRvX2xlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdG9fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgICAgICB2YXIgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gdG9fY2hhcnNbaV07XG4gICAgICAgICAgICBpZiAobGFzdF90byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxhc3RfdG8gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF90by5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b19jaGFycyA9IHRvX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgICAgIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IGZyb21fbGVuZ3RoIC0gdG9fbGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoX2RpZmYgPiAwKSB7XG4gICAgICAgICAgdmFyIHBhZF9jaGFyID0gKHRvX2xlbmd0aCA+IDAgPyB0b19jaGFyc1t0b19sZW5ndGggLSAxXSA6ICcnKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoX2RpZmY7IGkrKykge1xuICAgICAgICAgICAgdG9fY2hhcnMucHVzaChwYWRfY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdG9fY2hhcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5ld19zdHIgPSAnJ1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF07XG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgbmV3X3N0ciArPSAoc3ViID09IG51bGwgPyBnbG9iYWxfc3ViIDogY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiAhPSBudWxsID8gc3ViIDogY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QobmV3X3N0cik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJfcyhmcm9tLCB0bylcbiAgICBmcm9tID0gT3BhbC5jb2VyY2VfdG8oZnJvbSwgU3RyaW5nLCA6dG9fc3RyKS50b19zXG4gICAgdG8gPSBPcGFsLmNvZXJjZV90byh0bywgU3RyaW5nLCA6dG9fc3RyKS50b19zXG4gICAgJXh7XG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3X3N0ciA9ICcnXG4gICAgICB2YXIgbGFzdF9zdWJzdGl0dXRlID0gbnVsbFxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBpZiAoc3ViID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IGdsb2JhbF9zdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChzdWIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsIHx8IGxhc3Rfc3Vic3RpdHV0ZSAhPT0gc3ViKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBzdWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QobmV3X3N0cik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXBjYXNlXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYudG9VcHBlckNhc2UoKSlgXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsIGV4Y2wgPSBmYWxzZSwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6dXB0bywgc3RvcCwgZXhjbCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgc3RvcCA9IE9wYWwuY29lcmNlX3RvKHN0b3AsIFN0cmluZywgOnRvX3N0cilcbiAgICAleHtcbiAgICAgIHZhciBhLCBiLCBzID0gc2VsZi50b1N0cmluZygpO1xuXG4gICAgICBpZiAocy5sZW5ndGggPT09IDEgJiYgc3RvcC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICBhID0gcy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBiID0gc3RvcC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHMsIDEwKS50b1N0cmluZygpID09PSBzICYmIHBhcnNlSW50KHN0b3AsIDEwKS50b1N0cmluZygpID09PSBzdG9wKSB7XG5cbiAgICAgICAgYSA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHN0b3AsIDEwKTtcblxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgYSA9PT0gYikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2soYS50b1N0cmluZygpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHdoaWxlIChzLmxlbmd0aCA8PSBzdG9wLmxlbmd0aCAmJiBzIDw9IHN0b3ApIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBzID09PSBzdG9wKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhzKTtcblxuICAgICAgICAgIHMgPSAje2BzYC5zdWNjfTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cykge1xuICAgICAgZnVuY3Rpb24gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChzZXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgaSwgbGVuID0gc2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJfY2hhcixcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoLFxuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20sXG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byxcbiAgICAgICAgICAgIGNoYXJfY29kZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY3Vycl9jaGFyID0gc2V0LmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoY3Vycl9jaGFyID09PSAnLScgJiYgaSA+IDAgJiYgaSA8IChsZW4gLSAxKSAmJiAhc2tpcF9uZXh0X2Rhc2gpIHtcbiAgICAgICAgICAgIGNoYXJfY29kZV9mcm9tID0gc2V0LmNoYXJDb2RlQXQoaSAtIDEpO1xuICAgICAgICAgICAgY2hhcl9jb2RlX3VwdG8gPSBzZXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhcl9jb2RlX2Zyb20gPiBjaGFyX2NvZGVfdXB0bykge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgY2hhcl9jb2RlX2Zyb21gfS0je2BjaGFyX2NvZGVfdXB0b2B9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNoYXJfY29kZSA9IGNoYXJfY29kZV9mcm9tICsgMTsgY2hhcl9jb2RlIDwgY2hhcl9jb2RlX3VwdG8gKyAxOyBjaGFyX2NvZGUrKykge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyX2NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2ggPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IChjdXJyX2NoYXIgPT09ICdcXFxcJyk7XG4gICAgICAgICAgICByZXN1bHQgKz0gY3Vycl9jaGFyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0QSwgc2V0Qikge1xuICAgICAgICBpZiAoc2V0QS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc2V0QjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXRBLmxlbmd0aCxcbiAgICAgICAgICAgIGNocjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hyID0gc2V0QS5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKHNldEIuaW5kZXhPZihjaHIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGxlbiwgc2V0LCBuZWcsIGNociwgdG1wLFxuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSAnJyxcbiAgICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gJyc7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc2V0ID0gI3tPcGFsLmNvZXJjZV90byhgc2V0c1tpXWAsIFN0cmluZywgOnRvX3N0cil9O1xuICAgICAgICBuZWcgPSAoc2V0LmNoYXJBdCgwKSA9PT0gJ14nICYmIHNldC5sZW5ndGggPiAxKTtcbiAgICAgICAgc2V0ID0gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChuZWcgPyBzZXQuc2xpY2UoMSkgOiBzZXQpO1xuICAgICAgICBpZiAobmVnKSB7XG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihuZWdfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24ocG9zX2ludGVyc2VjdGlvbiwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwICYmIG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zX2ludGVyc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNociA9IHBvc19pbnRlcnNlY3Rpb24uY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChuZWdfaW50ZXJzZWN0aW9uLmluZGV4T2YoY2hyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRtcCArPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSB0bXA7XG4gICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1snICsgI3tSZWdleHAuZXNjYXBlKGBwb3NfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnW14nICsgI3tSZWdleHAuZXNjYXBlKGBuZWdfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IHVuZGVmaW5lZClcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemVkPyhmb3JtID0gdW5kZWZpbmVkKVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIHVucGFjayhmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgdW5wYWNrMShmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjazEsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL3VucGFjaycuXCJcbiAgZW5kXG5lbmRcblxuU3ltYm9sID0gU3RyaW5nXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsInNlbGYiLCJfX2lkX18iLCJ0cnlfY29udmVydCIsImNvZXJjZV90bz8iLCJ3aGF0IiwibmV3Iiwic3RyIiwiY29lcmNlX3RvIiwiaW5pdGlhbGl6ZSIsInJhaXNlIiwiJSIsIj09PSIsImRhdGEiLCJmb3JtYXQiLCIqIiwiKyIsIm90aGVyIiwidG9fcyIsIjw9PiIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwiPT0iLCI9fiIsIltdIiwiJH4iLCJiIiwiZm9yY2VfZW5jb2RpbmciLCJjYXBpdGFsaXplIiwiY2FzZWNtcCIsImNhc2VjbXA/IiwiY2VudGVyIiwid2lkdGgiLCJwYWRzdHIiLCJlbXB0eT8iLCJsanVzdCIsIi8iLCIyIiwiY2VpbCIsInJqdXN0IiwiZmxvb3IiLCJjaGFycyIsImJsb2NrIiwiZWFjaF9jaGFyIiwidG9fYSIsImNob21wIiwiJC8iLCJzZXBhcmF0b3IiLCJjb2VyY2VfdG8hIiwiY2hvcCIsImNociIsImNsb25lIiwiY29weSIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJjb3VudCIsImRlbGV0ZSIsImRlbGV0ZV9wcmVmaXgiLCJwcmVmaXgiLCJkZWxldGVfc3VmZml4Iiwic3VmZml4IiwiZG93bmNhc2UiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInNpemUiLCJlYWNoX2xpbmUiLCJlbmRfd2l0aD8iLCJnc3ViIiwicGF0dGVybiIsImhhc2giLCJoZXgiLCJ0b19pIiwiMTYiLCJpbmNsdWRlPyIsImluZGV4IiwiaW5zcGVjdCIsImludGVybiIsImxpbmVzIiwiZSIsImxlbmd0aCIsImxzdHJpcCIsImFzY2lpX29ubHk/IiwiZW5jb2RpbmciLCJtYXRjaCIsInBvcyIsIm1hdGNoPyIsIm5leHQiLCJvY3QiLCJvcmQiLCJwYXJ0aXRpb24iLCJyZXZlcnNlIiwicmluZGV4IiwicnBhcnRpdGlvbiIsInJzdHJpcCIsInNjYW4iLCJjYXB0dXJlcyIsInNwbGl0IiwibGltaXQiLCIkOyIsInNxdWVlemUiLCJzdGFydF93aXRoPyIsInN0cmlwIiwic3ViIiwic3VtIiwic3dhcGNhc2UiLCJ0b19mIiwiMTAiLCJ0b19wcm9jIiwibWV0aG9kX25hbWUiLCJwcm9jIiwidHIiLCJmcm9tIiwidG8iLCJ0cl9zIiwidXBjYXNlIiwidXB0byIsInN0b3AiLCJleGNsIiwic3VjYyIsImVzY2FwZSIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIl9sb2FkIiwiYXJncyIsInVuaWNvZGVfbm9ybWFsaXplIiwidW5pY29kZV9ub3JtYWxpemVkPyIsInVucGFjayIsInVucGFjazEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQURBO0FBQUEsRUFHQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQTtBQUdGLHdCQUEwQkMsSUFBSzs7QUFFL0Isd0JBQTBCQSxJQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFiRTtBQUFBO0FBZUFDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsZUFBRDtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FmQTtBQUFBLElBbUJBLGlCQUFNLFdBQU4sRUFBZ0IsUUFBaEIsQ0FuQkE7QUFBQSxJQXFCQUMsVUFBSUYsSUFBSkUsa0JBQUFBLHdCQUFBQSx1QkFBcUIsSUFBckJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsb0JBQUFDLGVBQUFBLENBQWdCQyxNQUFNLHdCQUFRLFFBQTlCRDtBQURGRCxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0FyQkE7QUFBQSxJQXlCQUcsVUFB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TkE7QUFERnNILElBQUFBLENBQUFBLGdDQUFBQSxDQUFBQSxtQkF0eURBO0FBREZqSSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFnQixNQUFoQkEsV0FIQTtBQUFBLEVBK3lEQSxPQUFBLHNDQUFTLHNCQUFULENBL3lEQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjg0OTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEVudW1lcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBbbmlsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZGVmIGFsbD8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSB1bmxlc3MgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gdHJ1ZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGNodW5rKCZibG9jaylcbiAgICByZXR1cm4gdG9fZW51bSg6Y2h1bmspIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBuaWwsIGFjY3VtdWxhdGUgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiByZWxlYXNlQWNjdW11bGF0ZSgpIHtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHByZXZpb3VzYCwgYGFjY3VtdWxhdGVgKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5pbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBuaWwgfHwgcHJldmlvdXMgPT09IGtleSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2h1bmtfd2hpbGUoJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2xpY2Vfd2hlbiB7IHxiZWZvcmUsIGFmdGVyfCAhKHlpZWxkIGJlZm9yZSwgYWZ0ZXIpIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3RfY29uY2F0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBtYXAgeyB8aXRlbXwgeWllbGQgaXRlbSB9LmZsYXR0ZW4oMSlcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJlc3VsdCA9IDBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBvYmplY3QgIT0gbnVsbGBcbiAgICAgIGJsb2NrID0gcHJvYyBkbyB8KmFyZ3N8XG4gICAgICAgIE9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqZWN0XG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9jay5uaWw/XG4gICAgICBibG9jayA9IHByb2MgeyB0cnVlIH1cbiAgICBlbmRcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgYHJlc3VsdCsrYCBpZiBgT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpYFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cbiAgICAgICAgaWYgbi5uaWw/XG4gICAgICAgICAgcmVzcG9uZF90bz8oOnNpemUpID8gRmxvYXQ6OklORklOSVRZIDogbmlsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICAgbiA+IDAgPyBlbnVtZXJhdG9yX3NpemUgKiBuIDogMFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgbiA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgIHJldHVybiBpZiBgbiA8PSAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGFsbCA9IFtdLCBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSBuaWwpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbGwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIGFsbFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG4gPiAxKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYWxsLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRldGVjdChpZm5vbmUgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmRldGVjdCwgaWZub25lIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgICBpZiB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKGlmbm9uZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YoaWZub25lKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpZm5vbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaWZub25lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBkcm9wKG51bWJlcilcbiAgICBudW1iZXIgPSBPcGFsLmNvZXJjZV90byBudW1iZXIsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGBudW1iZXIgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ICA9IFtdLFxuICAgICAgICAgIGN1cnJlbnQgPSAwO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobnVtYmVyIDw9IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50Kys7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKClcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkcm9wX3doaWxlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmRyb3Bfd2hpbGUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ICAgPSBbXSxcbiAgICAgICAgICBkcm9wcGluZyA9IHRydWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIGlmIChkcm9wcGluZykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICBpZiAoI3tPcGFsLmZhbHN5PyhgdmFsdWVgKX0pIHtcbiAgICAgICAgICAgIGRyb3BwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29ucyhuLCAmYmxvY2spXG4gICAgaWYgYGFyZ3VtZW50cy5sZW5ndGggIT0gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAxKVwiXG4gICAgZW5kXG5cbiAgICBuID0gT3BhbC50cnlfY29udmVydCBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2l6ZSdcbiAgICBlbmRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb25zLCBuKSBkb1xuICAgICAgICBlbnVtX3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgICAgaWYgZW51bV9zaXplLm5pbD9cbiAgICAgICAgICBuaWxcbiAgICAgICAgZWxzaWYgZW51bV9zaXplID09IDAgfHwgZW51bV9zaXplIDwgblxuICAgICAgICAgIDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW1fc2l6ZSAtIG4gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBidWZmZXIgPSBbXSwgcmVzdWx0ID0gbmlsO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBidWZmZXIucHVzaChlbGVtZW50KTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiBuKSB7XG4gICAgICAgICAgYnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbikge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBidWZmZXIuc2xpY2UoMCwgbikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2VudHJ5KCpkYXRhLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIHRvX2VudW0oOmVhY2hfZW50cnksICpkYXRhKSB7IGVudW1lcmF0b3Jfc2l6ZSB9XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGRhdGEpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX3NsaWNlKG4sICZibG9jaylcbiAgICBuID0gT3BhbC5jb2VyY2VfdG8gbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIHNsaWNlIHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfc2xpY2UsIG4pIHsgcmVzcG9uZF90bz8oOnNpemUpID8gKHNpemUgLyBuKS5jZWlsIDogbmlsIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHNsaWNlID0gW11cblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzbGljZSk7XG4gICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgLy8gb3VyIFwibGFzdFwiIGdyb3VwLCBpZiBzbWFsbGVyIHRoYW4gbiB0aGVuIHdvbid0IGhhdmUgYmVlbiB5aWVsZGVkXG4gICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZWFjaF93aXRoX2luZGV4KCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgsICphcmdzKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIGJsb2NrKHBhcmFtLCBpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9vYmplY3Qob2JqZWN0LCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfb2JqZWN0LCBvYmplY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgb2JqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JqZWN0XG4gIGVuZFxuXG4gIGRlZiBlbnRyaWVzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmluZCBkZXRlY3RcblxuICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmluZF9hbGwpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgje09wYWwudHJ1dGh5PyhgdmFsdWVgKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaW5kX2luZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gMFxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKSA9PSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZmlyc3QobnVtYmVyID0gdW5kZWZpbmVkKVxuICAgIGlmIGBudW1iZXIgPT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfHZhbHVlfFxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IFtdXG4gICAgICBudW1iZXIgPSBPcGFsLmNvZXJjZV90byBudW1iZXIsIEludGVnZXIsIDp0b19pbnRcblxuICAgICAgaWYgYG51bWJlciA8IDBgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbnVtYmVyID09IDBgXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnQgPSAwXG5cbiAgICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgICBgcmVzdWx0LnB1c2goI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSlgXG5cbiAgICAgICAgaWYgYG51bWJlciA8PSArK2N1cnJlbnRgXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcblxuICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IHVubGVzcyBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IGlmIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JvdXBfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Z3JvdXBfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaGFzaCA9IHt9XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICN7KGhhc2hbYHZhbHVlYF0gfHw9IFtdKSA8PCBgcGFyYW1gfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvYmopXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9ialxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBbcmVzdWx0LCB2YWx1ZV0pO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCEje1N5bWJvbCA9PT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiI3tvYmplY3QuaW5zcGVjdH0gaXMgbm90IGEgU3ltYm9sXCJ9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN5bSAgICA9IG9iamVjdDtcbiAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLl9fc2VuZF9fIHN5bSwgYHZhbHVlYH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGF6eVxuICAgIEVudW1lcmF0b3I6OkxhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVudW1lcmF0b3Jfc2l6ZVxuICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IHNpemUgOiBuaWxcbiAgZW5kXG5cbiAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA9PT0gbmlsKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgW2l0ZW0sIHJlc3VsdF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICN7YGl0ZW1gIDw9PiBgcmVzdWx0YH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbiA9IE9wYWwuY29lcmNlX3RvKG4sIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxuICBlbmRcblxuICBkZWYgbWF4X2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1heF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG5cbiAgZGVmIG1pbigmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBibG9jayhwYXJhbSwgcmVzdWx0KTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoI3tPcGFsLmNvbXBhcmUoYHBhcmFtYCwgYHJlc3VsdGApfSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWluX2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbl9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPCAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWlubWF4KCZibG9jaylcbiAgICBibG9jayB8fD0gcHJvYyB7IHxhLCBifCBhIDw9PiBiIH1cblxuICAgICV4e1xuICAgICAgdmFyIG1pbiA9IG5pbCwgbWF4ID0gbmlsLCBmaXJzdF90aW1lID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgaWYgKGZpcnN0X3RpbWUpIHtcbiAgICAgICAgICBtaW4gPSBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIGZpcnN0X3RpbWUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWluX2NtcCA9ICN7YmxvY2suY2FsbChgbWluYCwgYGVsZW1lbnRgKX07XG5cbiAgICAgICAgICBpZiAobWluX2NtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9XG4gICAgICAgICAgfSBlbHNlIGlmIChtaW5fY21wID4gMCkge1xuICAgICAgICAgICAgbWluID0gZWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWF4X2NtcCA9ICN7YmxvY2suY2FsbChgbWF4YCwgYGVsZW1lbnRgKX07XG5cbiAgICAgICAgICBpZiAobWF4X2NtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXhfY21wIDwgMCkge1xuICAgICAgICAgICAgbWF4ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXhfYnkoJmJsb2NrKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgZGVmIG5vbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpdGVtID0gT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBvbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBjb3VudCA9IDBcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICAgICAgY291bnQgKz0gMVxuICAgICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBuZXh0IHVubGVzcyBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjb3VudCA9PSAxXG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cGFydGl0aW9uKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHRydXRoeSA9IFtdLCBmYWxzeSA9IFtdLCByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgje09wYWwudHJ1dGh5PyhgdmFsdWVgKX0pIHtcbiAgICAgICAgICB0cnV0aHkucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmFsc3kucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHJlZHVjZSBpbmplY3RcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCN7T3BhbC5mYWxzeT8oYHZhbHVlYCl9KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmV2ZXJzZV9lYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJldmVyc2VfZWFjaCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBPcGFsLnlpZWxkWChibG9jaywgcmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxuXG4gIGRlZiBzbGljZV9iZWZvcmUocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdib3RoIHBhdHRlcm4gYW5kIGJsb2NrIGFyZSBnaXZlbidcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGV4cGVjdGVkIDEpXCJcbiAgICBlbmRcblxuICAgIEVudW1lcmF0b3IubmV3IGRvIHxlfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGB2YWx1ZWApfSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCAje3BhdHRlcm4uZHVwfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGB2YWx1ZWApfSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgje09wYWwudHJ1dGh5PyhgdmFsdWVgKX0gJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNsaWNlX2FmdGVyKHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYm90aCBwYXR0ZXJuIGFuZCBibG9jayBhcmUgZ2l2ZW4nXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDFgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgYmxvY2sgPSBwcm9jIHsgfGV8IHBhdHRlcm4gPT09IGUgfVxuICAgIGVuZFxuXG4gICAgRW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGU7XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICBlbmRfY2h1bmsgPSBPcGFsLnlpZWxkMShibG9jaywgZWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGBlbmRfY2h1bmtgKX0pIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKGFjY3VtdWxhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2Vfd2hlbigmYmxvY2spXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEpJyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBuaWwsIGxhc3RfYWZ0ZXIgPSBuaWw7XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbXMgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgYmVmb3JlID0gcGFyYW1zWzBdLFxuICAgICAgICAgICAgICBhZnRlciA9IHBhcmFtc1sxXSxcbiAgICAgICAgICAgICAgbWF0Y2ggPSBPcGFsLnlpZWxkWChibG9jaywgW2JlZm9yZSwgYWZ0ZXJdKTtcblxuICAgICAgICAgIGxhc3RfYWZ0ZXIgPSBhZnRlcjtcblxuICAgICAgICAgIGlmIChzbGljZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgje09wYWwudHJ1dGh5PyhgbWF0Y2hgKX0pIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zKDIpO1xuXG4gICAgICAgIGlmIChzbGljZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2xpY2UucHVzaChsYXN0X2FmdGVyKTtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICBhcnkgPSB0b19hXG4gICAgYmxvY2sgPSAtPihhLCBiKSB7IGEgPD0+IGIgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc29ydF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGR1cCA9IG1hcCBkb1xuICAgICAgYXJnID0gT3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYClcbiAgICAgIFt5aWVsZChhcmcpLCBhcmddXG4gICAgZW5kXG4gICAgZHVwLnNvcnQhIHsgfGEsIGJ8IGBhWzBdYCA8PT4gYGJbMF1gIH1cbiAgICBkdXAubWFwISB7IHxpfCBgaVsxXWAgfVxuICBlbmRcblxuICBkZWYgc3VtKGluaXRpYWwgPSAwKVxuICAgIHJlc3VsdCA9IGluaXRpYWxcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaXRlbSA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgT3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgICAgICAgIGVuZFxuICAgICAgcmVzdWx0ICs9IGl0ZW1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdGFrZShudW0pXG4gICAgZmlyc3QobnVtKVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp0YWtlX3doaWxlIHVubGVzcyBibG9ja1xuXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHVubGVzcyB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgZW5kXG5cbiAgICAgIGByZXN1bHQucHVzaCh2YWx1ZSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICBoYXNoID0ge31cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHByb2R1Y2VkID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICAgICAgeWllbGQodmFsdWUpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdW5sZXNzIGhhc2gua2V5Pyhwcm9kdWNlZClcbiAgICAgICAgaGFzaFtwcm9kdWNlZF0gPSB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBoYXNoLnZhbHVlc1xuICBlbmRcblxuICBhbGlhcyB0b19hIGVudHJpZXNcblxuICBkZWYgemlwKCpvdGhlcnMsICZibG9jaylcbiAgICB0b19hLnppcCgqb3RoZXJzKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImFsbD8iLCJlYWNoIiwiY29tcGFyYWJsZSIsInB1YmxpY19zZW5kIiwicGF0dGVybiIsImJsb2NrX2dpdmVuPyIsInZhbHVlIiwiZGVzdHJ1Y3R1cmUiLCJhbnk/IiwiY2h1bmsiLCJ0b19lbnVtIiwiZW51bWVyYXRvcl9zaXplIiwibmV3IiwieWllbGRlciIsInlpZWxkIiwiY2h1bmtfd2hpbGUiLCJyYWlzZSIsInNsaWNlX3doZW4iLCJiZWZvcmUiLCJhZnRlciIsIiEiLCJjb2xsZWN0IiwiZW51bV9mb3IiLCJjb2xsZWN0X2NvbmNhdCIsIm1hcCIsIml0ZW0iLCJmbGF0dGVuIiwiMSIsImNvdW50IiwicmVzdWx0IiwiMCIsIndhcm4iLCJibG9jayIsInByb2MiLCJhcmdzIiwiPT0iLCJvYmplY3QiLCJuaWw/IiwiY3ljbGUiLCJuIiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiPiIsIioiLCJkZXRlY3QiLCJpZm5vbmUiLCJkcm9wIiwibnVtYmVyIiwiY29lcmNlX3RvIiwiZHJvcF93aGlsZSIsImZhbHN5PyIsImVhY2hfY29ucyIsInRyeV9jb252ZXJ0IiwiZW51bV9zaXplIiwiPCIsIisiLCItIiwiZWFjaF9lbnRyeSIsImRhdGEiLCJlYWNoX3NsaWNlIiwiLyIsInNpemUiLCJjZWlsIiwiZWFjaF93aXRoX2luZGV4Iiwic2VsZiIsImVhY2hfd2l0aF9vYmplY3QiLCJlbnRyaWVzIiwiZmluZF9hbGwiLCJ0cnV0aHk/IiwiZmluZF9pbmRleCIsImluZGV4IiwiZmlyc3QiLCJjdXJyZW50IiwiZ3JlcCIsImNtcCIsIl9fc2VuZF9fIiwibGVuZ3RoIiwiPD0iLCJbXSIsInB1c2giLCJncmVwX3YiLCJncm91cF9ieSIsImhhc2giLCIkd3JpdGVyIiwiW109IiwiPDwiLCJpbmNsdWRlPyIsIm9iaiIsImluamVjdCIsIj09PSIsImluc3BlY3QiLCJzeW0iLCJsYXp5IiwiZW51bSQiLCJtYXgiLCI8PT4iLCJzb3J0IiwicmV2ZXJzZSIsIm1heF9ieSIsIm1pbiIsImNvbXBhcmUiLCJtaW5fYnkiLCJtaW5tYXgiLCJhIiwiYiIsImNhbGwiLCJtaW5tYXhfYnkiLCJub25lPyIsIm9uZT8iLCJwYXJ0aXRpb24iLCJyZWplY3QiLCJyZXZlcnNlX2VhY2giLCJzbGljZV9iZWZvcmUiLCJlIiwiZHVwIiwic2xpY2VfYWZ0ZXIiLCJhcnkiLCJ0b19hIiwic29ydF9ieSIsImFyZyIsInNvcnQhIiwibWFwISIsInN1bSIsImluaXRpYWwiLCJ0YWtlIiwibnVtIiwidGFrZV93aGlsZSIsInVuaXEiLCJwcm9kdWNlZCIsImtleT8iLCJ2YWx1ZXMiLCJ6aXAiLCJvdGhlcnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQVpFO0FBQUE7QUFjQUMsSUFBQUEsd0JBQUFBLHlCQUFBQSxTQUFTLE9BQVRBLEdBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFB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ImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyBFbnVtZXJhdG9yXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfZW51bWVyYXRvciA9IHRydWVgXG5cbiAgZGVmIHNlbGYuZm9yKG9iamVjdCwgbWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gI3thbGxvY2F0ZX07XG5cbiAgICAgIG9iai5vYmplY3QgPSBvYmplY3Q7XG4gICAgICBvYmouc2l6ZSAgID0gYmxvY2s7XG4gICAgICBvYmoubWV0aG9kID0gbWV0aG9kO1xuICAgICAgb2JqLmFyZ3MgICA9IGFyZ3M7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqLCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIEBvYmplY3QgPSBHZW5lcmF0b3IubmV3KCZibG9jaylcbiAgICAgIEBtZXRob2QgPSA6ZWFjaFxuICAgICAgQGFyZ3MgICA9IFtdXG4gICAgICBAc2l6ZSAgID0gYGFyZ3VtZW50c1swXSB8fCBuaWxgXG5cbiAgICAgIGlmIEBzaXplXG4gICAgICAgIEBzaXplID0gT3BhbC5jb2VyY2VfdG8gQHNpemUsIEludGVnZXIsIDp0b19pbnRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEBvYmplY3QgPSBgYXJndW1lbnRzWzBdYFxuICAgICAgQG1ldGhvZCA9IGBhcmd1bWVudHNbMV0gfHwgXCJlYWNoXCJgXG4gICAgICBAYXJncyAgID0gYCRzbGljZS5jYWxsKGFyZ3VtZW50cywgMilgXG4gICAgICBAc2l6ZSAgID0gbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgaWYgYmxvY2submlsPyAmJiBhcmdzLmVtcHR5P1xuXG4gICAgYXJncyA9IEBhcmdzICsgYXJnc1xuXG4gICAgcmV0dXJuIHNlbGYuY2xhc3MubmV3KEBvYmplY3QsIEBtZXRob2QsICphcmdzKSBpZiBibG9jay5uaWw/XG5cbiAgICBAb2JqZWN0Ll9fc2VuZF9fKEBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgUHJvYyA9PT0gQHNpemUgPyBAc2l6ZS5jYWxsKCpAYXJncykgOiBAc2l6ZVxuICBlbmRcblxuICBkZWYgd2l0aF9pbmRleChvZmZzZXQgPSAwLCAmYmxvY2spXG4gICAgb2Zmc2V0ID0gaWYgb2Zmc2V0XG4gICAgICAgICAgICAgICBPcGFsLmNvZXJjZV90byBvZmZzZXQsIEludGVnZXIsIDp0b19pbnRcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gZW51bV9mb3IoOndpdGhfaW5kZXgsIG9mZnNldCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsIGluZGV4ID0gb2Zmc2V0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGVhY2goKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHdpdGhfb2JqZWN0IGVhY2hfd2l0aF9vYmplY3RcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9OiAje0BvYmplY3QuaW5zcGVjdH06I3tAbWV0aG9kfVwiXG5cbiAgICBpZiBAYXJncy5hbnk/XG4gICAgICByZXN1bHQgKz0gXCIoI3tAYXJncy5pbnNwZWN0W1JhbmdlLm5ldygxLCAtMildfSlcIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJz4nXG4gIGVuZFxuXG4gIGNsYXNzIEdlbmVyYXRvclxuICAgIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgeWllbGRlciA9IFlpZWxkZXIubmV3KCZibG9jaylcblxuICAgICAgJXh7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgT3BhbC55aWVsZFgoI3tAYmxvY2t9LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgICAgcmV0dXJuICRicmVha2VyLiR2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgWWllbGRlclxuICAgIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgeWllbGQoKnZhbHVlcylcbiAgICAgICV4e1xuICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWCgje0BibG9ja30sIHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgIHRocm93ICRicmVha2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIDw8KCp2YWx1ZXMpXG4gICAgICBzZWxmLnlpZWxkKCp2YWx1ZXMpXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgTGF6eSA8IHNlbGZcbiAgICBjbGFzcyBTdG9wTGF6eUVycm9yIDwgRXhjZXB0aW9uOyBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKG9iamVjdCwgc2l6ZSA9IG5pbCwgJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG5ldyB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgQGVudW1lcmF0b3IgPSBvYmplY3RcblxuICAgICAgc3VwZXIgc2l6ZSBkbyB8eWllbGRlciwgKmVhY2hfYXJnc3xcbiAgICAgICAgb2JqZWN0LmVhY2goKmVhY2hfYXJncykgZG8gfCphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgICBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIHJlc2N1ZSBFeGNlcHRpb25cbiAgICAgICAgbmlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZvcmNlIHRvX2FcblxuICAgIGRlZiBsYXp5XG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG1hcCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XG4gICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAje09wYWwudHJ5X2NvbnZlcnQgYHZhbHVlYCwgQXJyYXksIDp0b19hcnl9O1xuXG4gICAgICAgICAgICBpZiAoYXJyYXkgPT09IG5pbCkge1xuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcChuKVxuICAgICAgbiA9IE9wYWwuY29lcmNlX3RvIG4sIEludGVnZXIsIDp0b19pbnRcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnRfc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgc2V0X3NpemUgICAgID0gaWYgSW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGRyb3BwZWQgPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiBkcm9wcGVkIDwgblxuICAgICAgICAgIGRyb3BwZWQgKz0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkcm9wX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IGRyb3Bfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIHN1Y2NlZWRpbmcgPSB0cnVlXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAoI3tPcGFsLmZhbHN5PyhgdmFsdWVgKX0pIHtcbiAgICAgICAgICAgICAgc3VjY2VlZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgICBzZWxmLmNsYXNzLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgZW5kXG5cbiAgICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgc2VsZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGB2YWx1ZWApfSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG5cbiAgICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgICBpZiBibG9ja1xuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoI3tPcGFsLnRydXRoeT8oYHZhbHVlYCl9KSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSlgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoI3tPcGFsLnRydXRoeT8oYHZhbHVlYCl9KSB7XG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgcGFyYW1gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gICAgYWxpYXMgc2VsZWN0IGZpbmRfYWxsXG5cbiAgICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHJlamVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje09wYWwuZmFsc3k/KGB2YWx1ZWApfSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlKG4pXG4gICAgICBuID0gT3BhbC5jb2VyY2VfdG8gbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiBJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdGFrZW4gPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiB0YWtlbiA8IG5cbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICAgIHRha2VuICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJhaXNlIFN0b3BMYXp5RXJyb3JcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHRha2Vfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoI3tPcGFsLnRydXRoeT8oYHZhbHVlYCl9KSB7XG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAje3JhaXNlIFN0b3BMYXp5RXJyb3J9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QGVudW1lcmF0b3IuaW5zcGVjdH0+XCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwiZm9yIiwic2VsZiIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiQG9iamVjdCIsIm5ldyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwiY29lcmNlX3RvIiwiZWFjaCIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsIl9fc2VuZF9fIiwic2l6ZSIsIj09PSIsImNhbGwiLCJ3aXRoX2luZGV4IiwiMCIsIm9mZnNldCIsImVudW1fZm9yIiwiZGVzdHJ1Y3R1cmUiLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIltdIiwiMSIsIi0yIiwicmFpc2UiLCJAYmxvY2siLCJ5aWVsZGVyIiwieWllbGQiLCI8PCIsInZhbHVlcyIsImJsb2NrX2dpdmVuPyIsIkBlbnVtZXJhdG9yIiwib2JqZWN0IiwiZWFjaF9hcmdzIiwibGF6eSIsImNvbGxlY3QiLCJlbnVtZXJhdG9yX3NpemUiLCJlbnVtJCIsImNvbGxlY3RfY29uY2F0IiwicmVzcG9uZF90bz8iLCJ2IiwidHJ5X2NvbnZlcnQiLCJkcm9wIiwibiIsIjwiLCJjdXJyZW50X3NpemUiLCJzZXRfc2l6ZSIsImRyb3BwZWQiLCJkcm9wX3doaWxlIiwic3VjY2VlZGluZyIsImZhbHN5PyIsIm1ldGhvZCIsImZpbmRfYWxsIiwidHJ1dGh5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aUJBQU0sU0FBTixFQUFjLFVBQWQsQ0FyT0E7QUFBQSxNQXVPQSxPQUFBekMsQ0FBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQSxFQUFBLEdBQUEsSUFBQSxHQUFBLENBQUt4QixJQUFBSCxPQUFBQSxDQUFBQSxDQUFMLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBb0J3QyxlQUFBYixTQUFBQSxDQUFBQSxDQUFwQixDQUFBLEdBQUE7QUFERkEsTUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLG1CQXZPQTtBQURGM0IsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYUcsSUFBYkgsV0E5SUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMDU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1lcmljLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgTnVtZXJpY1xuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIG90aGVyLmluc3RhbmNlX29mPyBzZWxmLmNsYXNzXG4gICAgICByZXR1cm4gW290aGVyLCBzZWxmXVxuICAgIGVuZFxuXG4gICAgW0Zsb2F0KG90aGVyKSwgRmxvYXQoc2VsZildXG4gIGVuZFxuXG4gIGRlZiBfX2NvZXJjZWRfXyhtZXRob2QsIG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/KDpjb2VyY2UpXG4gICAgICBhLCBiID0gb3RoZXIuY29lcmNlKHNlbGYpXG4gICAgICBhLl9fc2VuZF9fIG1ldGhvZCwgYlxuICAgIGVsc2VcbiAgICAgIGNhc2UgbWV0aG9kXG4gICAgICB3aGVuIDorLCA6LSwgOiosIDovLCA6JSwgOiYsIDp8LCA6XiwgOioqXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gTnVtZXJpY1wiXG4gICAgICB3aGVuIDo+LCA6Pj0sIDo8LCA6PD0sIDo8PT5cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje290aGVyLmNsYXNzfSBmYWlsZWRcIlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgZXF1YWw/IG90aGVyXG4gICAgICByZXR1cm4gMFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgMCAtIHNlbGZcbiAgZW5kXG5cbiAgZGVmICUob3RoZXIpXG4gICAgc2VsZiAtIG90aGVyICogZGl2KG90aGVyKVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgc2VsZiA8IDAgPyAtc2VsZiA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBzZWxmICogc2VsZlxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICBzZWxmIDwgMCA/IE1hdGg6OlBJIDogMFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICB0b19mLmNlaWwobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGNvbmpcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgdG9fci5kZW5vbWluYXRvclxuICBlbmRcblxuICBkZWYgZGl2KG90aGVyKVxuICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSBvJyBpZiBvdGhlciA9PSAwXG5cbiAgICAoc2VsZiAvIG90aGVyKS5mbG9vclxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIFtkaXYob3RoZXIpLCBzZWxmICUgb3RoZXJdXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHRvX2YgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5mbG9vcihuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgaVxuICAgIENvbXBsZXgoMCwgc2VsZilcbiAgZW5kXG5cbiAgZGVmIGltYWdcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG5cbiAgZGVmIGludGVnZXI/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuXG4gIGFsaWFzIG1vZHVsbyAlXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgemVybz8gPyBuaWwgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICB0b19yLm51bWVyYXRvclxuICBlbmRcblxuICBhbGlhcyBwaGFzZSBhcmdcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIGRlZiBxdW8ob3RoZXIpXG4gICAgT3BhbC5jb2VyY2VfdG8hKHNlbGYsIFJhdGlvbmFsLCA6dG9fcikgLyBvdGhlclxuICBlbmRcblxuICBkZWYgcmVhbFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtzZWxmLCAwXVxuICBlbmRcblxuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgZGVmIHJvdW5kKGRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICB0b19mLnJvdW5kKGRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4KHNlbGYsIDApXG4gIGVuZFxuXG4gIGRlZiB0b19pbnRcbiAgICB0b19pXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICB0b19mLnRydW5jYXRlKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIHNlbGYgPT0gMFxuICBlbmRcblxuICBkZWYgcG9zaXRpdmU/XG4gICAgc2VsZiA+IDBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIHNlbGYgPCAwXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJjb2VyY2UiLCJvdGhlciIsImluc3RhbmNlX29mPyIsInNlbGYiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwibWV0aG9kIiwicmFpc2UiLCI8PT4iLCJlcXVhbD8iLCIwIiwiK0AiLCItQCIsIi0iLCIlIiwiKiIsImRpdiIsImFicyIsIjwiLCJhYnMyIiwiYW5nbGUiLCJjZWlsIiwidG9fZiIsIm5kaWdpdHMiLCJjb25qIiwiZGVub21pbmF0b3IiLCJ0b19yIiwiPT0iLCIvIiwiZmxvb3IiLCJkaXZtb2QiLCJmZGl2IiwiaSIsIkNvbXBsZXgiLCJpbWFnIiwiaW50ZWdlcj8iLCJub256ZXJvPyIsInplcm8/IiwibnVtZXJhdG9yIiwicG9sYXIiLCJhcmciLCJxdW8iLCJjb2VyY2VfdG8hIiwicmVhbCIsInJlYWw/IiwicmVjdCIsInJvdW5kIiwiZGlnaXRzIiwidG9fYyIsInRvX2ludCIsInRvX2kiLCJ0cnVuY2F0ZSIsInBvc2l0aXZlPyIsIj4iLCJuZWdhdGl2ZT8iLCJkdXAiLCJjbG9uZSIsImZpbml0ZT8iLCJpbmZpbml0ZT8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxTQUFBQSxD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QUEsTUFpTEksT0FBQXpELElBakxKO0FBZ0xFeUQsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBNUtBO0FBQUE7QUFnTEFDLElBQUFBLDJCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FoTEE7QUFBQSxJQW9MQSxPQUFBQyxDQUFBQSw2QkFBQUEsNEJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUFBLHFCQXBMQTtBQURGaEUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExMzc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9hcnJheS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5yZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIEFycmF5IDwgYEFycmF5YFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGphdmFzY3JpcHQgYXJyYXlzIGFzIGJlaW5nIHZhbGlkIHJ1YnkgYXJyYXlzXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FycmF5JywgdHJ1ZSlgXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gdG9BcnJheVN1YmNsYXNzKG9iaiwga2xhc3MpIHtcbiAgICAgIGlmIChrbGFzcy4kJG5hbWUgPT09IE9wYWwuQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrbGFzcy4kYWxsb2NhdGUoKS4kcmVwbGFjZSgje2BvYmpgLnRvX2F9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWYgc2VsZi5bXSgqb2JqZWN0cylcbiAgICBgdG9BcnJheVN1YmNsYXNzKG9iamVjdHMsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzaXplID0gbmlsLCBvYmogPSBuaWwsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChvYmogIT09IG5pbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplID4gI3tJbnRlZ2VyOjpNQVh9KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2FycmF5IHNpemUgdG9vIGJpZyd9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4yKVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoc2l6ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSBpZiAoI3tzaXplLnJlc3BvbmRfdG8/IDp0b19hcnl9KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYXJ5KX1cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaXplID0gI3tPcGFsLmNvZXJjZV90byBzaXplLCBJbnRlZ2VyLCA6dG9faW50fVxuXG4gICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgdmFsdWU7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGkpO1xuICAgICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8gb2JqLCBBcnJheSwgOnRvX2FyeVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIE9wYWwuY29lcmNlX3RvKG90aGVyLCBBcnJheSwgOnRvX2FyeSkudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShoYXNoLCBpdGVtKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgT3BhbC5jb2VyY2VfdG8ob3RoZXIsIEFycmF5LCA6dG9fYXJ5KS50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgc2VsZltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaC4ka2V5cygpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgcmV0dXJuIGpvaW4ob3RoZXIudG9fc3RyKSBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG5cbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIG90aGVyLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBgb3RoZXIgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29udmVydGVkID0gI3t0b19hfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlcjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY29udmVydGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcyhyZXN1bHQsICN7c2VsZi5jbGFzc30pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBPcGFsLmNvZXJjZV90byhvdGhlciwgQXJyYXksIDp0b19hcnkpLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgYHNlbGYuY29uY2F0KG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBPcGFsLmNvZXJjZV90byhvdGhlciwgQXJyYXksIDp0b19hcnkpLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICByZXR1cm4gYHNlbGYuc2xpY2UoKWAgaWYgYG90aGVyLmxlbmd0aCA9PT0gMGBcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGlmIChPcGFsLmhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw8KG9iamVjdClcbiAgICBgc2VsZi5wdXNoKG9iamVjdClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FcbiAgICBlbHNpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fYXJ5XG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FyeS50b19hXG4gICAgZWxzZVxuICAgICAgcmV0dXJuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICgje2hhc2h9ID09PSAje290aGVyLmhhc2h9KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihzZWxmLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB0bXAgPSAje2BzZWxmW2ldYCA8PT4gYG90aGVyW2ldYH07XG5cbiAgICAgICAgaWYgKHRtcCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YHNlbGYubGVuZ3RoYCA8PT4gYG90aGVyLmxlbmd0aGB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmIChhcnJheSA9PT0gb3RoZXIpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgaWYgKCN7T3BhbC5yZXNwb25kX3RvPyBgb3RoZXJgLCA6dG9fYXJ5fSkge1xuICAgICAgICAgICAgcmV0dXJuICN7YG90aGVyYCA9PSBgYXJyYXlgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheS4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcbiAgICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcbiAgICAgICAgaWYgKG90aGVyLiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIG90aGVyID0gI3tgb3RoZXJgLnRvX2F9O1xuXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhID0gYXJyYXlbaV07XG4gICAgICAgICAgYiA9IG90aGVyW2ldO1xuICAgICAgICAgIGlmIChhLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGV4Y2x1ZGUgPSBpbmRleC5leGNsO1xuICAgICAgZnJvbSAgICA9IE9wYWwuT3BhbC4kY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcbiAgICAgIHRvICAgICAgPSBPcGFsLk9wYWwuJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgdG8gKz0gc2l6ZTtcblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICB0byArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgIHJldHVybiB0b0FycmF5U3ViY2xhc3MocmVzdWx0LCBzZWxmLiRjbGFzcygpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgaW5kZXggPSBPcGFsLk9wYWwuJGNvZXJjZV90byhpbmRleCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZW5ndGggPSBPcGFsLk9wYWwuJGNvZXJjZV90byhsZW5ndGgsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwIHx8IGluZGV4ID4gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcyhyZXN1bHQsIHNlbGYuJGNsYXNzKCkpO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9pbmRleF9sZW5ndGgoc2VsZiwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSwgZXh0cmEgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc2l6ZSA9IHNlbGYubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIFJhbmdlID09PSBpbmRleFxuICAgICAgZGF0YSA9IGlmIEFycmF5ID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgIGVsc2lmIHZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnlcbiAgICAgICAgICAgICAgIHZhbHVlLnRvX2FyeS50b19hXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSBpbmRleC5leGNsLFxuICAgICAgICAgICAgZnJvbSAgICA9ICN7T3BhbC5jb2VyY2VfdG8gYGluZGV4LmJlZ2luYCwgSW50ZWdlciwgOnRvX2ludH0sXG4gICAgICAgICAgICB0byAgICAgID0gI3tPcGFsLmNvZXJjZV90byBgaW5kZXguZW5kYCwgSW50ZWdlciwgOnRvX2ludH07XG5cbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwiI3tpbmRleC5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHRvICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUpIHtcbiAgICAgICAgICB0byArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIDBdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIHRvIC0gZnJvbV0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiBgZXh0cmEgPT09IHVuZGVmaW5lZGBcbiAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgZWxzZVxuICAgICAgICBsZW5ndGggPSB2YWx1ZVxuICAgICAgICB2YWx1ZSAgPSBleHRyYVxuXG4gICAgICAgIGRhdGEgPSBpZiBBcnJheSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgICB2YWx1ZS50b19hcnkudG9fYVxuICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIG9sZDtcblxuICAgICAgICBpbmRleCAgPSAje09wYWwuY29lcmNlX3RvIGluZGV4LCBJbnRlZ2VyLCA6dG9faW50fTtcbiAgICAgICAgbGVuZ3RoID0gI3tPcGFsLmNvZXJjZV90byBsZW5ndGgsIEludGVnZXIsIDp0b19pbnR9O1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBvbGQgICAgPSBpbmRleDtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9sZGB9IHRvbyBzbWFsbCBmb3IgYXJyYXk7IG1pbmltdW0gI3tgLXNlbGYubGVuZ3RoYH1cIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwibmVnYXRpdmUgbGVuZ3RoICgje2xlbmd0aH0pXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgbGVuZ3RoXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgYGlmIChzZWxmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbSA9IHNlbGZbaV0sIGl0ZW0ubGVuZ3RoICYmICN7YGl0ZW1bMF1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0KGluZGV4KVxuICAgIGluZGV4ID0gT3BhbC5jb2VyY2VfdG8gaW5kZXgsIEludGVnZXIsIDp0b19pbnRcblxuICAgICV4e1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnNlYXJjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoX2luZGV4IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIG1pbiA9IDAsXG4gICAgICAgICAgbWF4ID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgbWlkLFxuICAgICAgICAgIHZhbCxcbiAgICAgICAgICByZXQsXG4gICAgICAgICAgc21hbGxlciA9IGZhbHNlLFxuICAgICAgICAgIHNhdGlzZmllZCA9IG5pbDtcblxuICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xuICAgICAgICBtaWQgPSBtaW4gKyBNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gMik7XG4gICAgICAgIHZhbCA9IHNlbGZbbWlkXTtcbiAgICAgICAgcmV0ID0gT3BhbC55aWVsZDEoYmxvY2ssIHZhbCk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNhdGlzZmllZCA9IG1pZDtcbiAgICAgICAgICBzbWFsbGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQgPT09IGZhbHNlIHx8IHJldCA9PT0gbmlsKSB7XG4gICAgICAgICAgc21hbGxlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJldC4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmIChyZXQgPT09IDApIHsgcmV0dXJuIG1pZDsgfVxuICAgICAgICAgIHNtYWxsZXIgPSAocmV0IDwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2ByZXRgLmNsYXNzfSAobXVzdCBiZSBudW1lcmljLCB0cnVlLCBmYWxzZSBvciBuaWwpXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc21hbGxlcikgeyBtYXggPSBtaWQ7IH0gZWxzZSB7IG1pbiA9IG1pZCArIDE7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNhdGlzZmllZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaW5kZXggPSBic2VhcmNoX2luZGV4KCZibG9jaylcblxuICAgICV4e1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwgJiYgaW5kZXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGN5Y2xlKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmN5Y2xlLCBuKSBkb1xuICAgICAgICBpZiBuLm5pbD9cbiAgICAgICAgICBGbG9hdDo6SU5GSU5JVFlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgICBuID4gMCA/IGVudW1lcmF0b3Jfc2l6ZSAqIG4gOiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXR1cm4gaWYgZW1wdHk/IHx8IG4gPT0gMFxuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNsZWFyXG4gICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IG5pbCwgJmJsb2NrKVxuICAgIGlmIG9iamVjdCB8fCBibG9ja1xuICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzaXplXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgcmVwbGFjZSBvdGhlclxuICBlbmRcblxuICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29sbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICBzZWxmW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBiaW5vbWlhbF9jb2VmZmljaWVudChuLCBrKSB7XG4gICAgICBpZiAobiA9PT0gayB8fCBrID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoayA+IDAgJiYgbiA+IGspIHtcbiAgICAgICAgcmV0dXJuIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrIC0gMSkgKyBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudCgje3NlbGZ9Lmxlbmd0aCwgbnVtKWAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHN0YWNrLCBjaG9zZW4sIGxldiwgZG9uZSwgbmV4dDtcblxuICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAje3lpZWxkIFtdfVxuICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYFtzZWxmW2ldXWB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5zbGljZSgpYH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA+PSAwICYmIG51bSA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbnVtICsgMTsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob3NlbiA9IFtdO1xuICAgICAgICBsZXYgPSAwO1xuICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIHN0YWNrWzBdID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW3N0YWNrW2xldisxXV07XG4gICAgICAgICAgd2hpbGUgKGxldiA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgIGxldisrO1xuICAgICAgICAgICAgbmV4dCA9IHN0YWNrW2xldisxXSA9IHN0YWNrW2xldl0gKyAxO1xuICAgICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW25leHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAjeyB5aWVsZCBgY2hvc2VuLnNsaWNlKClgIH1cbiAgICAgICAgICBsZXYrKztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkb25lID0gKGxldiA9PT0gMCk7XG4gICAgICAgICAgICBzdGFja1tsZXZdKys7XG4gICAgICAgICAgICBsZXYtLTtcbiAgICAgICAgICB9IHdoaWxlICggc3RhY2tbbGV2KzFdICsgbnVtID09PSBzZWxmLmxlbmd0aCArIGxldiArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9jb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX2NvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KHNlbGYubGVuZ3RoICsgbnVtIC0gMSwgbnVtKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgZnJvbSwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBpLCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgaXRlcmF0ZShudW0sIDAsIFtdLCBzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKGl0ZW0gPSBzZWxmW2ldKSAhPT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0IVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmW2ldID09PSBuaWwpIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25jYXQoKm90aGVycylcbiAgICBvdGhlcnMgPSBvdGhlcnMubWFwIGRvIHxvdGhlcnxcbiAgICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgT3BhbC5jb2VyY2VfdG8ob3RoZXIsIEFycmF5LCA6dG9fYXJ5KS50b19hXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgICBpZiBvdGhlci5lcXVhbD8oc2VsZilcbiAgICAgICAgb3RoZXIgPSBvdGhlci5kdXBcbiAgICAgIGVuZFxuXG4gICAgICBvdGhlclxuICAgIGVuZFxuXG4gICAgb3RoZXJzLmVhY2ggZG8gfG90aGVyfFxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvdGhlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShvYmplY3QpXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsKSB7XG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICByZXR1cm4gI3t5aWVsZH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2F0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAje09wYWwuY29lcmNlX3RvIGBpbmRleGAsIEludGVnZXIsIDp0b19pbnR9O1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBzZWxmW2luZGV4XTtcblxuICAgICAgc2VsZi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkaWcoaWR4LCAqaWR4cylcbiAgICBpdGVtID0gc2VsZltpZHhdXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwgaWR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmlkeHMpXG4gIGVuZFxuXG4gIGRlZiBkcm9wKG51bWJlcilcbiAgICAleHtcbiAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UobnVtYmVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuQXJyYXkgJiZcbiAgICAgICAgICBzZWxmLiQkY2xhc3MuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcy4kJHByaXN0aW5lICYmXG4gICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxbChhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9ICN7b3RoZXIudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWwoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZldGNoKGluZGV4LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG5cbiAgICAgIGluZGV4ID0gI3tPcGFsLmNvZXJjZV90byBgaW5kZXhgLCBJbnRlZ2VyLCA6dG9faW50fTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsICYmIGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBibG9jayBzdXBlcnNlZGVzIGRlZmF1bHQgdmFsdWUgYXJndW1lbnQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKG9yaWdpbmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IDAuLi4wXCJ9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IC0je2BzZWxmLmxlbmd0aGB9Li4uI3tgc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaWxsKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiBibG9ja1xuICAgICAgaWYgYGFyZ3MubGVuZ3RoID4gMmBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3MubGVuZ3RofSBmb3IgMC4uMilcIlxuICAgICAgZW5kXG5cbiAgICAgIG9uZSwgdHdvID0gYXJnc1xuICAgIGVsc2VcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA9PSAwYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknXG4gICAgICBlbHNpZiBgYXJncy5sZW5ndGggPiAzYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5sZW5ndGh9IGZvciAxLi4zKVwiXG4gICAgICBlbmRcblxuICAgICAgb2JqLCBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbmRcblxuICAgIGlmIFJhbmdlID09PSBvbmVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2xlbmd0aCBpbnZhbGlkIHdpdGggcmFuZ2UnIGlmIHR3b1xuXG4gICAgICBsZWZ0ICAgPSBPcGFsLmNvZXJjZV90byBvbmUuYmVnaW4sIEludGVnZXIsIDp0b19pbnRcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcIiN7b25lLmluc3BlY3R9IG91dCBvZiByYW5nZVwiIGlmIGBsZWZ0IDwgMGBcblxuICAgICAgcmlnaHQgPSBPcGFsLmNvZXJjZV90byBvbmUuZW5kLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICBgcmlnaHQgKz0gdGhpcy5sZW5ndGhgIGlmIGByaWdodCA8IDBgXG4gICAgICBgcmlnaHQgKz0gMWAgdW5sZXNzIG9uZS5leGNsdWRlX2VuZD9cblxuICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0IDw9IGxlZnRgXG4gICAgZWxzaWYgb25lXG4gICAgICBsZWZ0ICAgPSBPcGFsLmNvZXJjZV90byBvbmUsIEludGVnZXIsIDp0b19pbnRcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXG4gICAgICBsZWZ0ICAgPSAwIGlmIGBsZWZ0IDwgMGBcblxuICAgICAgaWYgdHdvXG4gICAgICAgIHJpZ2h0ID0gT3BhbC5jb2VyY2VfdG8gdHdvLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0ID09IDBgXG5cbiAgICAgICAgYHJpZ2h0ICs9IGxlZnRgXG4gICAgICBlbHNlXG4gICAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgbGVmdCAgPSAwXG4gICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICBlbmRcblxuICAgIGlmIGBsZWZ0ID4gdGhpcy5sZW5ndGhgXG4gICAgICAleHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGg7IGkgPCByaWdodDsgaSsrKSB7XG4gICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgaWYgYHJpZ2h0ID4gdGhpcy5sZW5ndGhgXG4gICAgICBgdGhpcy5sZW5ndGggPSByaWdodGBcbiAgICBlbmRcblxuICAgIGlmIGJsb2NrXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGxlZnQpO1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSAje29ian07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZlswXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAje09wYWwuY29lcmNlX3RvIGBjb3VudGAsIEludGVnZXIsIDp0b19pbnR9O1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBfZmxhdHRlbihhcnJheSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuZ3RoLFxuICAgICAgICAgICAgaXRlbSwgYXJ5O1xuXG4gICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgaWYgKCEje09wYWwucmVzcG9uZF90bz8gYGl0ZW1gLCA6dG9fYXJ5LCB0cnVlfSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnkgPSAje2BpdGVtYC50b19hcnl9O1xuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBzZWxmKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoX2ZsYXR0ZW4oYXJ5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwgPSAje09wYWwuY29lcmNlX3RvKGBsZXZlbGAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcyhfZmxhdHRlbihzZWxmLCBsZXZlbCksICN7c2VsZi5jbGFzc30pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4hKGxldmVsID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGZsYXR0ZW5lZCA9ICN7ZmxhdHRlbiBsZXZlbH07XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PSBmbGF0dGVuZWQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNlbGZbaV0gIT09IGZsYXR0ZW5lZFtpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAje3JlcGxhY2UgYGZsYXR0ZW5lZGB9O1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoT3BhbC5oYXNoX2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICByZXN1bHQgPSBbJ0EnXSxcbiAgICAgICAgICBoYXNoX2lkID0gc2VsZi4kb2JqZWN0X2lkKCksXG4gICAgICAgICAgaXRlbSwgaSwga2V5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX2lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gZWFybHkgZm9yIHJlY3Vyc2l2ZSBzdHJ1Y3R1cmVzXG4gICAgICAgIGlmIChPcGFsLmhhc2hfaWRzW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIE9wYWwuaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gT3BhbC5oYXNoX2lkc1trZXldO1xuICAgICAgICAgIGlmICgje2VxbD8oYGl0ZW1gKX0pIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC5oYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtLiRoYXNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsJyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1lbWJlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBtZW1iZXJ9KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6aW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc2VydChpbmRleCwgKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICN7T3BhbC5jb2VyY2VfdG8gYGluZGV4YCwgSW50ZWdlciwgOnRvX2ludH07XG5cbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7IHJhaXNlIEluZGV4RXJyb3IsIFwiI3tpbmRleH0gaXMgb3V0IG9mIGJvdW5kc1wiIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYubGVuZ3RoOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5wdXNoKG5pbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCAwXS5jb25jYXQob2JqZWN0cykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBpZCAgICAgPSAje19faWRfX307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3tzZWxmW2BpYF19O1xuXG4gICAgICAgIGlmICgje2BpdGVtYC5fX2lkX199ID09PSBpZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdbLi4uXScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YGl0ZW1gLmluc3BlY3R9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG4gICAgfVxuICBlbmRcblxuICBkZWYgam9pbihzZXAgPSBuaWwpXG4gICAgcmV0dXJuICcnIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGlmIGBzZXAgPT09IG5pbGBcbiAgICAgIHNlcCA9ICQsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBpLCBsZW5ndGgsIGl0ZW0sIHRtcDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoI3tPcGFsLnJlc3BvbmRfdG8/IGBpdGVtYCwgOnRvX3N0cn0pIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19zdHJ9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLnRvX3N9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7T3BhbC5yZXNwb25kX3RvPyBgaXRlbWAsIDp0b19hcnl9KSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fYXJ5fTtcblxuICAgICAgICAgIGlmICh0bXAgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLmpvaW4oc2VwKX0pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tPcGFsLnJlc3BvbmRfdG8/IGBpdGVtYCwgOnRvX3N9KSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc307XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICN7cmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCIje2BPcGFsLmluc3BlY3QoaXRlbSlgfSBkb2Vzbid0IHJlc3BvbmQgdG8gI3RvX3N0ciwgI3RvX2FyeSBvciAjdG9fc1wiLCAndG9fc3RyJyl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VwID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oI3tPcGFsLmNvZXJjZV90byEoc2VwLCBTdHJpbmcsIDp0b19zdHIpLnRvX3N9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZltzZWxmLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA9ICN7T3BhbC5jb2VyY2VfdG8gYGNvdW50YCwgSW50ZWdlciwgOnRvX2ludH07XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gIGFsaWFzIG1hcCEgY29sbGVjdCFcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBlYWNoLm1heChuLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtaW4oJmJsb2NrKVxuICAgIGVhY2gubWluKCZibG9jaylcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gUmV0dXJucyB0aGUgcHJvZHVjdCBvZiBmcm9tLCBmcm9tLTEsIC4uLiwgZnJvbSAtIGhvd19tYW55ICsgMS5cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nX2ZhY3RvcmlhbChmcm9tLCBob3dfbWFueSkge1xuICAgICAgdmFyIGNvdW50ID0gaG93X21hbnkgPj0gMCA/IDEgOiAwO1xuICAgICAgd2hpbGUgKGhvd19tYW55KSB7XG4gICAgICAgIGNvdW50ICo9IGZyb207XG4gICAgICAgIGZyb20tLTtcbiAgICAgICAgaG93X21hbnktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIH1cblxuICBkZWYgcGVybXV0YXRpb24obnVtID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpwZXJtdXRhdGlvbiwgbnVtKSBkb1xuICAgICAgICBgZGVzY2VuZGluZ19mYWN0b3JpYWwoc2VsZi5sZW5ndGgsIG51bSA9PT0gdW5kZWZpbmVkID8gc2VsZi5sZW5ndGggOiBudW0pYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBwZXJtdXRlLCBvZmZlbnNpdmUsIG91dHB1dDtcblxuICAgICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG51bSA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG51bSA9ICN7IE9wYWwuY29lcmNlX3RvIG51bSwgSW50ZWdlciwgOnRvX2ludCB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPCAwIHx8IHNlbGYubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIC8vIG5vIHBlcm11dGF0aW9ucywgeWllbGQgbm90aGluZ1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAwKSB7XG4gICAgICAgIC8vIGV4YWN0bHkgb25lIHBlcm11dGF0aW9uOiB0aGUgemVyby1sZW5ndGggYXJyYXlcbiAgICAgICAgI3sgeWllbGQgW10gfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLCBlYXN5IGNhc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3sgeWllbGQgYFtzZWxmW2ldXWAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgICN7IHBlcm0gPSBBcnJheS5uZXcobnVtKSB9O1xuICAgICAgICAjeyB1c2VkID0gQXJyYXkubmV3KGBzZWxmLmxlbmd0aGAsIGZhbHNlKSB9O1xuXG4gICAgICAgIHBlcm11dGUgPSBmdW5jdGlvbihudW0sIHBlcm0sIGluZGV4LCB1c2VkLCBibGspIHtcbiAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZigjeyAhdXNlZFtgaWBdIH0pIHtcbiAgICAgICAgICAgICAgcGVybVtpbmRleF0gPSBpO1xuICAgICAgICAgICAgICBpZihpbmRleCA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCBpbmRleCArIDEsIHVzZWQsIGJsayk7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVybS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZltwZXJtW2pdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9wYWwueWllbGQxKGJsaywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICAvLyBvZmZlbnNpdmUgKGJvdGggZGVmaW5pdGlvbnMpIGNvcHkuXG4gICAgICAgICAgb2ZmZW5zaXZlID0gc2VsZi5zbGljZSgpO1xuICAgICAgICAgIHBlcm11dGUuY2FsbChvZmZlbnNpdmUsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHBlcm11dGUuY2FsbChzZWxmLCBudW0sIHBlcm0sIDAsIHVzZWQsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGVhdGVkX3Blcm11dGF0aW9uKG4pXG4gICAgbnVtID0gT3BhbC5jb2VyY2VfdG8hIG4sIEludGVnZXIsIDp0b19pbnRcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX3Blcm11dGF0aW9uLCBudW0pIHsgbnVtID49IDAgPyBzaXplKipudW0gOiAwIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpdGVyYXRlKG51bSwgW10sIHNlbGYuc2xpY2UoKSk7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG9wKGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2VsZi5wb3AoKWBcbiAgICBlbmRcblxuICAgIGNvdW50ID0gT3BhbC5jb2VyY2VfdG8gY291bnQsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGBjb3VudCA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgY291bnQgPiBzZWxmLmxlbmd0aGBcbiAgICAgIGBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aClgXG4gICAgZWxzZVxuICAgICAgYHNlbGYuc3BsaWNlKHNlbGYubGVuZ3RoIC0gY291bnQsIHNlbGYubGVuZ3RoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHByb2R1Y3QoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAje2Jsb2NrX2dpdmVuP30gPyBudWxsIDogW10sXG4gICAgICAgICAgbiA9IGFyZ3MubGVuZ3RoICsgMSxcbiAgICAgICAgICBjb3VudGVycyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBsZW5ndGhzICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBhcnJheXMgICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBpLCBtLCBzdWJhcnJheSwgbGVuLCByZXN1bHRsZW4gPSAxO1xuXG4gICAgICBhcnJheXNbMF0gPSBzZWxmO1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBhcnJheXNbaV0gPSAje09wYWwuY29lcmNlX3RvKGBhcmdzW2kgLSAxXWAsIEFycmF5LCA6dG9fYXJ5KX07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGVuID0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRsZW4gKj0gbGVuO1xuICAgICAgICBpZiAocmVzdWx0bGVuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgJ3RvbyBiaWcgdG8gcHJvZHVjdCd9XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3Roc1tpXSA9IGxlbjtcbiAgICAgICAgY291bnRlcnNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBvdXRlcl9sb29wOiBmb3IgKDs7KSB7XG4gICAgICAgIHN1YmFycmF5ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzdWJhcnJheS5wdXNoKGFycmF5c1tpXVtjb3VudGVyc1tpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzdWJhcnJheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3t5aWVsZCBgc3ViYXJyYXlgfVxuICAgICAgICB9XG4gICAgICAgIG0gPSBuIC0gMTtcbiAgICAgICAgY291bnRlcnNbbV0rKztcbiAgICAgICAgd2hpbGUgKGNvdW50ZXJzW21dID09PSBsZW5ndGhzW21dKSB7XG4gICAgICAgICAgY291bnRlcnNbbV0gPSAwO1xuICAgICAgICAgIGlmICgtLW0gPCAwKSBicmVhayBvdXRlcl9sb29wO1xuICAgICAgICAgIGNvdW50ZXJzW21dKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1c2goKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gob2JqZWN0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBhcHBlbmQgcHVzaFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICYmIGl0ZW1bMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgje2BpdGVtWzFdYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc2VsZltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBvcmlnaW5hbCA9IGxlbmd0aFxuICAgIGRlbGV0ZV9pZigmYmxvY2spXG5cbiAgICB1bmxlc3MgbGVuZ3RoID09IG9yaWdpbmFsXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgT3BhbC5jb2VyY2VfdG8ob3RoZXIsIEFycmF5LCA6dG9fYXJ5KS50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgc2VsZi5wdXNoLmFwcGx5KHNlbGYsIG90aGVyKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc2xpY2UoMCkucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZSFcbiAgICBgc2VsZi5yZXZlcnNlKClgXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlX2VhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICByZXZlcnNlLmVhY2goJmJsb2NrKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IGBvYmplY3RgfSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IHNlbGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6cmluZGV4fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3RhdGUobiA9IDEpXG4gICAgbiA9IE9wYWwuY29lcmNlX3RvIG4sIEludGVnZXIsIDp0b19pbnRcbiAgICAleHtcbiAgICAgIHZhciBhcnksIGlkeCwgZmlyc3RQYXJ0LCBsYXN0UGFydDtcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gICAgY250ID0gT3BhbC5jb2VyY2VfdG8gY250LCBJbnRlZ2VyLCA6dG9faW50XG4gICAgYXJ5ID0gcm90YXRlKGNudClcbiAgICByZXBsYWNlIGFyeVxuICBlbmRcblxuICBjbGFzcyBTYW1wbGVSYW5kb21cbiAgICBkZWYgaW5pdGlhbGl6ZShybmcpXG4gICAgICBAcm5nID0gcm5nXG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZChzaXplKVxuICAgICAgcmFuZG9tID0gT3BhbC5jb2VyY2VfdG8gQHJuZy5yYW5kKHNpemUpLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICByYWlzZSBSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgPj0gMCcgaWYgYHJhbmRvbSA8IDBgXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIEFycmF5IHNpemUnIHVubGVzcyBgcmFuZG9tIDwgc2l6ZWBcblxuICAgICAgcmFuZG9tXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzYW1wbGUoY291bnQgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGF0IEtlcm5lbC5yYW5kKGBzZWxmLmxlbmd0aGApIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuXG4gICAgaWYgYG9wdGlvbnMgPT09IHVuZGVmaW5lZGBcbiAgICAgIGlmIChvID0gT3BhbC5jb2VyY2VfdG8/IGNvdW50LCBIYXNoLCA6dG9faGFzaClcbiAgICAgICAgb3B0aW9ucyA9IG9cbiAgICAgICAgY291bnQgPSBuaWxcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucyA9IG5pbFxuICAgICAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvIGNvdW50LCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvIGNvdW50LCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICBvcHRpb25zID0gT3BhbC5jb2VyY2VfdG8gb3B0aW9ucywgSGFzaCwgOnRvX2hhc2hcbiAgICBlbmRcblxuICAgIGlmIGNvdW50ICYmIGBjb3VudCA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnY291bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCdcbiAgICBlbmRcblxuICAgIHJuZyA9IG9wdGlvbnNbOnJhbmRvbV0gaWYgb3B0aW9uc1xuICAgIHJuZyA9IGlmIHJuZyAmJiBybmcucmVzcG9uZF90bz8oOnJhbmQpXG4gICAgICAgICAgICBTYW1wbGVSYW5kb20ubmV3IHJuZ1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEtlcm5lbFxuICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIGBzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XWAgdW5sZXNzIGNvdW50XG5cbiAgICAleHtcblxuICAgICAgdmFyIGFiYW5kb24sIHNwaW4sIHJlc3VsdCwgaSwgaiwgaywgdGFyZ2V0SW5kZXgsIG9sZFZhbHVlO1xuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gW3NlbGZbI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX1dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGkgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICBqID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIGogPSBpID09PSAwID8gaSArIDEgOiBpIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtzZWxmW2ldLCBzZWxmW2pdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoc2VsZi5sZW5ndGggLyBjb3VudCA+IDMpIHtcbiAgICAgICAgICAgIGFiYW5kb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHNwaW4gPSAwO1xuXG4gICAgICAgICAgICByZXN1bHQgPSAjeyBBcnJheS5uZXcoY291bnQpIH07XG4gICAgICAgICAgICBpID0gMTtcblxuICAgICAgICAgICAgcmVzdWx0WzBdID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGogPCBpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPT09IHJlc3VsdFtqXSkge1xuICAgICAgICAgICAgICAgICAgc3BpbisrO1xuICAgICAgICAgICAgICAgICAgaWYgKHNwaW4gPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWJhbmRvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgayA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWJhbmRvbikgeyBicmVhazsgfVxuXG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICByZXN1bHRbaV0gPSBrO1xuXG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhYmFuZG9uKSB7XG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gc2VsZltyZXN1bHRbaV1dO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb3VudDsgYysrKSB7XG4gICAgICAgICAgICB0YXJnZXRJbmRleCA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgb2xkVmFsdWUgPSByZXN1bHRbY107XG4gICAgICAgICAgICByZXN1bHRbY10gPSByZXN1bHRbdGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0W3RhcmdldEluZGV4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3VudCA9PT0gc2VsZi5sZW5ndGggPyByZXN1bHQgOiAje2ByZXN1bHRgWzAsIGNvdW50XX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBpdGVtKTtcblxuICAgICAgICBpZiAoT3BhbC50cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG4gICAgICAjeyBrZWVwX2lmKCZibG9jaykgfTtcbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwgPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNoaWZ0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2VsZi5zaGlmdCgpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBPcGFsLmNvZXJjZV90byBjb3VudCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGBzZWxmLnNwbGljZSgwLCBjb3VudClgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHNodWZmbGUocm5nID0gdW5kZWZpbmVkKVxuICAgIGR1cC50b19hLnNodWZmbGUhKHJuZylcbiAgZW5kXG5cbiAgZGVmIHNodWZmbGUhKHJuZyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciByYW5kZ2VuLCBpID0gc2VsZi5sZW5ndGgsIGosIHRtcDtcblxuICAgICAgaWYgKHJuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJuZyA9ICN7T3BhbC5jb2VyY2VfdG8/KHJuZywgSGFzaCwgOnRvX2hhc2gpfTtcblxuICAgICAgICBpZiAocm5nICE9PSBuaWwpIHtcbiAgICAgICAgICBybmcgPSAje3JuZ1s6cmFuZG9tXX07XG5cbiAgICAgICAgICBpZiAocm5nICE9PSBuaWwgJiYgI3tybmcucmVzcG9uZF90bz8oOnJhbmQpfSkge1xuICAgICAgICAgICAgcmFuZGdlbiA9IHJuZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaWYgKHJhbmRnZW4pIHtcbiAgICAgICAgICBqID0gcmFuZGdlbi4kcmFuZChpKS4kdG9faW50KCk7XG5cbiAgICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBzbWFsbCAje2BqYH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaiA+PSBpKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwicmFuZG9tIG51bWJlciB0b28gYmlnICN7YGpgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBqID0gI3tyYW5kKGBpYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gc2VsZlstLWldO1xuICAgICAgICBzZWxmW2ldID0gc2VsZltqXTtcbiAgICAgICAgc2VsZltqXSA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzbGljZSBbXVxuXG4gIGRlZiBzbGljZSEoaW5kZXgsIGxlbmd0aCA9IHVuZGVmaW5lZClcbiAgICByZXN1bHQgPSBuaWxcblxuICAgIGlmIGBsZW5ndGggPT09IHVuZGVmaW5lZGBcbiAgICAgIGlmIFJhbmdlID09PSBpbmRleFxuICAgICAgICByYW5nZSA9IGluZGV4XG4gICAgICAgIHJlc3VsdCA9IHNlbGZbcmFuZ2VdXG5cbiAgICAgICAgcmFuZ2Vfc3RhcnQgPSBPcGFsLmNvZXJjZV90byhyYW5nZS5iZWdpbiwgSW50ZWdlciwgOnRvX2ludClcbiAgICAgICAgcmFuZ2VfZW5kID0gT3BhbC5jb2VyY2VfdG8ocmFuZ2UuZW5kLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX3N0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9lbmQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZV9lbmQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCA9IHNlbGYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICAgIHJhbmdlX2VuZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZV9sZW5ndGggPSByYW5nZV9lbmQgLSByYW5nZV9zdGFydDtcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kIC09IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2UocmFuZ2Vfc3RhcnQsIHJhbmdlX2xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXJ0ID0gT3BhbC5jb2VyY2VfdG8oaW5kZXgsIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZltzdGFydF07XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuc2hpZnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2Uoc3RhcnQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3RhcnQgPSBPcGFsLmNvZXJjZV90byhpbmRleCwgSW50ZWdlciwgOnRvX2ludClcbiAgICAgIGxlbmd0aCA9IE9wYWwuY29lcmNlX3RvKGxlbmd0aCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICByZXN1bHQgPSAje3NlbGZbc3RhcnQsIGxlbmd0aF19O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXG5cbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGJsb2NrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiAje2BhYCA8PT4gYGJgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsb2NrKHgsIHkpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7YHhgLmluc3BlY3R9IHdpdGggI3tgeWAuaW5zcGVjdH0gZmFpbGVkXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7YHJldGAgPiAwfSA/IDEgOiAoI3tgcmV0YCA8IDB9ID8gLTEgOiAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnQhKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0KCZibG9jayl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYubGVuZ3RoID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydF9ieSEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c29ydF9ieSEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJlcGxhY2Ugc29ydF9ieSgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0YWtlKGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBjb3VudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IGJsb2NrKGl0ZW0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyB0b19hcnkgdG9fYVxuXG4gIGRlZiB0b19oXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuID0gc2VsZi5sZW5ndGgsIGFyeSwga2V5LCB2YWwsIGhhc2ggPSAje3t9fTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFyeSA9ICN7T3BhbC5jb2VyY2VfdG8/KGBzZWxmW2ldYCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSBhdCAje2BpYH0gKGV4cGVjdGVkIGFycmF5KVwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcnkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCBhdCAje2BpYH0gKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0cmFuc3Bvc2VcbiAgICByZXR1cm4gW10gaWYgZW1wdHk/XG5cbiAgICByZXN1bHQgPSBbXVxuICAgIG1heCAgICA9IG5pbFxuXG4gICAgZWFjaCBkbyB8cm93fFxuICAgICAgcm93ID0gaWYgQXJyYXkgPT09IHJvd1xuICAgICAgICAgICAgICByb3cudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBPcGFsLmNvZXJjZV90byhyb3csIEFycmF5LCA6dG9fYXJ5KS50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICAgbWF4IHx8PSBgcm93Lmxlbmd0aGBcblxuICAgICAgaWYgYHJvdy5sZW5ndGhgICE9IG1heFxuICAgICAgICByYWlzZSBJbmRleEVycm9yLCBcImVsZW1lbnQgc2l6ZSBkaWZmZXJzICgje2Byb3cubGVuZ3RoYH0gc2hvdWxkIGJlICN7bWF4fSlcIlxuICAgICAgZW5kXG5cbiAgICAgIGByb3cubGVuZ3RoYC50aW1lcyBkbyB8aXxcbiAgICAgICAgZW50cnkgPSAocmVzdWx0W2ldIHx8PSBbXSlcbiAgICAgICAgZW50cnkgPDwgcm93LmF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdW5pcSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW0sIGtleTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgaXRlbSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGtleSA9IE9wYWwueWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2dldChoYXNoLCBrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvQXJyYXlTdWJjbGFzcygje2BoYXNoYC52YWx1ZXN9LCAje3NlbGYuY2xhc3N9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1bmlxISgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsX2xlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBrZXkgPSAoYmxvY2sgPT09IG5pbCA/IGl0ZW0gOiBPcGFsLnlpZWxkMShibG9jaywgaXRlbSkpO1xuXG4gICAgICAgIGlmIChPcGFsLmhhc2hfZ2V0KGhhc2gsIGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsX2xlbmd0aCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5zaGlmdCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSBvYmplY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHNlbGYudW5zaGlmdChvYmplY3RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIHByZXBlbmQgdW5zaGlmdFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgb3V0ID0gW11cblxuICAgIGFyZ3MuZWFjaCBkbyB8ZWxlbXxcbiAgICAgIGlmIGVsZW0uaXNfYT8gUmFuZ2VcbiAgICAgICAgZmluaXNoID0gT3BhbC5jb2VyY2VfdG8gZWxlbS5sYXN0LCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICAgIHN0YXJ0ID0gT3BhbC5jb2VyY2VfdG8gZWxlbS5maXJzdCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IGZpbmlzaCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tlbGVtLmV4Y2x1ZGVfZW5kP30pIHtcbiAgICAgICAgICAgIGZpbmlzaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmluaXNoIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQudXB0byhmaW5pc2gpIHsgfGl8IG91dCA8PCBhdChpKSB9XG4gICAgICBlbHNlXG4gICAgICAgIGkgPSBPcGFsLmNvZXJjZV90byBlbGVtLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgICAgIG91dCA8PCBhdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvdXRcbiAgZW5kXG5cbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHNpemUgPSBzZWxmLmxlbmd0aCwgcGFydCwgbywgaSwgaiwgamo7XG5cbiAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgbyA9IG90aGVyc1tqXTtcbiAgICAgICAgaWYgKG8uJCRpc19hcnJheSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLiQkaXNfZW51bWVyYXRvcikge1xuICAgICAgICAgIGlmIChvLiRzaXplKCkgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBvdGhlcnNbal0gPSBvLiR0YWtlKHNpemUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlcnNbal0gPSBvLiR0b19hKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyc1tqXSA9ICN7KFxuICAgICAgICAgIE9wYWwuY29lcmNlX3RvPyhgb2AsIEFycmF5LCA6dG9fYXJ5KSB8fFxuICAgICAgICAgIE9wYWwuY29lcmNlX3RvIShgb2AsIEVudW1lcmF0b3IsIDplYWNoKVxuICAgICAgICApLnRvX2F9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHBhcnQgPSBbc2VsZltpXV07XG5cbiAgICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIG8gPSBvdGhlcnNbal1baV07XG5cbiAgICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvID0gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRbaiArIDFdID0gbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBibG9jayhyZXN1bHRbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluaGVyaXRlZChrbGFzcylcbiAgICAleHtcbiAgICAgIGtsYXNzLiQkcHJvdG90eXBlLiR0b19hID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBzdXBlci5yZWplY3QgeyB8aXZhcnwgYC9eQFxcZCskLy50ZXN0KCN7aXZhcn0pYCB8fCBpdmFyID09ICdAbGVuZ3RoJyB9XG4gIGVuZFxuXG4gIE9wYWwucHJpc3RpbmUgc2luZ2xldG9uX2NsYXNzLCA6YWxsb2NhdGVcbiAgT3BhbC5wcmlzdGluZSBzZWxmLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuXG4gIGRlZiBwYWNrKCphcmdzKVxuICAgIHJhaXNlIFwiVG8gdXNlIEFycmF5I3BhY2ssIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvYXJyYXkvcGFjaycuXCJcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwidG9fYSIsIltdIiwic2VsZiIsImluaXRpYWxpemUiLCJ3YXJuIiwicmFpc2UiLCJyZXBsYWNlIiwic2l6ZSIsInJlc3BvbmRfdG8/IiwidG9fYXJ5IiwiY29lcmNlX3RvIiwidHJ5X2NvbnZlcnQiLCJjb2VyY2VfdG8/Iiwib2JqIiwiJiIsIm90aGVyIiwiPT09IiwifCIsIioiLCJqb2luIiwidG9fc3RyIiwiKyIsIi0iLCI8PCIsIjw9PiIsImhhc2giLCI9PSIsIm9iamVjdF9pZCIsIltdPSIsImluZGV4IiwiZGF0YSIsInZhbHVlIiwiaW5zcGVjdCIsImxlbmd0aCIsIjEiLCJleHRyYSIsImFueT8iLCJhc3NvYyIsIm9iamVjdCIsImF0IiwiYnNlYXJjaF9pbmRleCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYnNlYXJjaCIsImJsb2NrIiwiY3ljbGUiLCJuIiwibmlsPyIsImNvZXJjZV90byEiLCI+IiwiMCIsImVudW1lcmF0b3Jfc2l6ZSIsImVtcHR5PyIsImNsZWFyIiwiY291bnQiLCJpbml0aWFsaXplX2NvcHkiLCJjb2xsZWN0IiwiY29sbGVjdCEiLCJjb21iaW5hdGlvbiIsIm51bSIsInJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29uY2F0Iiwib3RoZXJzIiwibWFwIiwiZXF1YWw/IiwiZHVwIiwiZWFjaCIsImRlbGV0ZSIsImRlbGV0ZV9hdCIsImRlbGV0ZV9pZiIsImRpZyIsIml0ZW0iLCJpZHgiLCJpZHhzIiwiZHJvcCIsImVhY2hfaW5kZXgiLCJlcWw/IiwiZmV0Y2giLCJmaWxsIiwiYXJncyIsIm9uZSIsInR3byIsImxlZnQiLCJiZWdpbiIsInJpZ2h0IiwiZW5kIiwiZXhjbHVkZV9lbmQ/IiwiZmlyc3QiLCJmbGF0dGVuIiwiZmxhdHRlbiEiLCJsZXZlbCIsImluY2x1ZGU/IiwibWVtYmVyIiwiaW5zZXJ0IiwiX19pZF9fIiwic2VwIiwiJCwiLCJ0b19zIiwibmV3Iiwia2VlcF9pZiIsImxhc3QiLCJtYXgiLCJtaW4iLCJwZXJtdXRhdGlvbiIsInBlcm0iLCJ1c2VkIiwiISIsInJlcGVhdGVkX3Blcm11dGF0aW9uIiwiPj0iLCIqKiIsInBvcCIsInByb2R1Y3QiLCJwdXNoIiwicmFzc29jIiwicmVqZWN0IiwicmVqZWN0ISIsIm9yaWdpbmFsIiwicmV2ZXJzZSIsInJldmVyc2UhIiwicmV2ZXJzZV9lYWNoIiwicmluZGV4Iiwicm90YXRlIiwicm90YXRlISIsImNudCIsImFyeSIsIkBybmciLCJybmciLCJyYW5kIiwicmFuZG9tIiwic2FtcGxlIiwibyIsIm9wdGlvbnMiLCJzZWxlY3QiLCJzZWxlY3QhIiwic2hpZnQiLCJzaHVmZmxlIiwic2h1ZmZsZSEiLCJzbGljZSEiLCJyZXN1bHQiLCJyYW5nZSIsInJhbmdlX3N0YXJ0IiwicmFuZ2VfZW5kIiwic3RhcnQiLCJzb3J0IiwiPCIsInNvcnQhIiwic29ydF9ieSEiLCJzb3J0X2J5IiwidGFrZSIsInRha2Vfd2hpbGUiLCJ0b19oIiwidHJhbnNwb3NlIiwicm93IiwiIT0iLCJ0aW1lcyIsImVudHJ5IiwiaSIsIiR3cml0ZXIiLCJ1bmlxIiwidmFsdWVzIiwidW5pcSEiLCJ1bnNoaWZ0IiwidmFsdWVzX2F0Iiwib3V0IiwiZWxlbSIsImlzX2E/IiwiZmluaXNoIiwidXB0byIsInppcCIsImluaGVyaXRlZCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIml2YXIiLCJwcmlzdGluZSIsInNpbmdsZXRvbl9jbGFzcyIsInBhY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQURBO0FBQUEsRUFHQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBLElBR0MseURBSEQ7QUFBQTtBQU1GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTRDLENBQUMsR0FBRCxDQUFB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d3lFMEIsT0FBQSxjQUFDLGNBQWdCeUQsSUFBSyxDQUF0QixTQUE0QkEsSUFBQW5KLE9BQUFBLENBQVEsU0FBUkEsQ0FBNUIsQ0F4eUUxQixDQUFBLG9CQUFBLG1CQUFBLE9Bd3lFSTBGO0FBREZ3RCxJQUFBQSxDQUFBQSwyQ0FBQUEsQ0FseUVBO0FBQUEsSUFzeUVBLG9CQUFBRSxVQUFBQSxLQUFjQyxpQkFBQUEsQ0FBQUEsR0FBaUIsVUFBL0JELENBdHlFQTtBQUFBLElBdXlFQSxvQkFBQUEsVUFBQUEsQ0FBYzVLLE1BQU0sMkJBQTBCLGdCQUE5QzRLLENBdnlFQTtBQUFBLElBeXlFQSxPQUFBRSxDQUFBQSx3QkFBQUEsa0JBQUFBLGdCQTl5RUYsRUE4eUVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE5eUVGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBOHlFVyxNQUFBLGtCQTl5RVg7QUFBQSxNQSt5RUksV0FBQTNLLE9BQUFBLENBQU0saUVBQU5BLENBL3lFSjtBQTh5RUUySyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEsZ0JBenlFQTtBQURGbEwsRUFBQUEsR0FBQUEsV0FBQUEsRUFBZSxLQUFmQSxXQUhBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTQyNzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hhc2gucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG4jIC0tLVxuIyBJbnRlcm5hbCBwcm9wZXJ0aWVzOlxuI1xuIyAtICQkbWFwICAgICAgICAgW0pTOjpPYmplY3Q8U3RyaW5nID0+IGhhc2gtYnVja2V0Pl0gdGhlIGhhc2ggdGFibGUgZm9yIG9yZGluYXJ5IGtleXNcbiMgLSAkJHNtYXAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBzdHJpbmcga2V5c1xuIyAtICQka2V5cyAgICAgICAgW0FycmF5PGhhc2gtYnVja2V0Pl0gdGhlIGxpc3Qgb2YgYWxsIGtleXNcbiMgLSAkJHByb2MgICAgICAgIFtQcm9jLG51bGwsbmlsXSB0aGUgZGVmYXVsdCBwcm9jIHVzZWQgZm9yIG1pc3Npbmcga2V5c1xuIyAtIGhhc2gtYnVja2V0ICAgW0pTOjpPYmplY3RdIGFuIGVsZW1lbnQgb2YgYSBsaW5rZWQgbGlzdCB0aGF0IGhvbGRzIGhhc2ggdmFsdWVzLCBrZXlzIGFyZSBge2tleTosa2V5X2hhc2g6LHZhbHVlOixuZXh0On1gXG5jbGFzcyBIYXNoXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgaGFzaCBpbnN0YW5jZXMgYXMgdmFsaWQgaGFzaGVzICh1c2VkIHRvIGNoZWNrIGtleXdvcmQgYXJncywgZXRjKVxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2hhc2ggPSB0cnVlYFxuXG4gIGRlZiBzZWxmLltdKCphcmd2KVxuICAgICV4e1xuICAgICAgdmFyIGhhc2gsIGFyZ2MgPSBhcmd2Lmxlbmd0aCwgaTtcblxuICAgICAgaWYgKGFyZ2MgPT09IDEpIHtcbiAgICAgICAgaGFzaCA9ICN7T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIEhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIGlmIChoYXNoICE9PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gI3thbGxvY2F0ZS5tZXJnZSEoYGhhc2hgKX07XG4gICAgICAgIH1cblxuICAgICAgICBhcmd2ID0gI3tPcGFsLmNvZXJjZV90bz8oYXJndlswXSwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKGFyZ3YgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWFyZ3ZbaV0uJCRpc19hcnJheSkgY29udGludWU7XG4gICAgICAgICAgc3dpdGNoKGFyZ3ZbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXVswXSwgbmlsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIGFyZ3ZbaV1bMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyAoI3tgYXJndltpXS5sZW5ndGhgfSBmb3IgMS4uMilcIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ2MgJSAyICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgIH1cblxuICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSArPSAyKSB7XG4gICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV0sIGFyZ3ZbaSArIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgICBoYXNoLiQkbm9uZSA9IG5pbDtcbiAgICAgIGhhc2guJCRwcm9jID0gbmlsO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8ob2JqLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMCknfVxuICAgICAgfVxuICAgICAgc2VsZi4kJG5vbmUgPSAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IG5pbCA6IGRlZmF1bHRzKTtcbiAgICAgIHNlbGYuJCRwcm9jID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggIT09IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IE9wYWwuaGFzaF9nZXQob3RoZXIsIGtleS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG90aGVyX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgIXZhbHVlWyckZXFsPyddKG90aGVyX3ZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPCBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcblxuICAgIG90aGVyLmVhY2ggZG8gfG90aGVyX2tleSwgb3RoZXJfdmFsfFxuICAgICAgdmFsID0gZmV0Y2gob3RoZXJfa2V5LCBgbnVsbGApXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsICE9PSBvdGhlcl92YWwpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPD0gb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmID49IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+IHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShrZXkpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGRlZmF1bHQoa2V5KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIGlmICgje2BrZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCBzZWxmLiQkc21hcFtrZXldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCN7YGtleS5rZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LmtleSwga2V5LnZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgICV4e1xuICAgICAgT3BhbC5oYXNoX2luaXQoc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNsYXNzKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eVxuICAgICV4e1xuICAgICAgdmFyIGksIGlpLCBrZXksIGtleXMgPSBzZWxmLiQka2V5cywgaWRlbnRpdHlfaGFzaDtcblxuICAgICAgaWYgKHNlbGYuJCRieV9pZGVudGl0eSkgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlkZW50aXR5X2hhc2ggPSAjeyB7fS5jb21wYXJlX2J5X2lkZW50aXR5IH07XG4gICAgICBmb3IoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICgha2V5LiQkaXNfc3RyaW5nKSBrZXkgPSBrZXkua2V5O1xuICAgICAgICBPcGFsLmhhc2hfcHV0KGlkZW50aXR5X2hhc2gsIGtleSwgT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIHNlbGYuJCRtYXAgPSBpZGVudGl0eV9oYXNoLiQkbWFwO1xuICAgICAgc2VsZi4kJHNtYXAgPSBpZGVudGl0eV9oYXNoLiQkc21hcDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gICAgYHNlbGYuJCRieV9pZGVudGl0eSA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQoa2V5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIHNlbGYuJCRwcm9jICE9PSBuaWwgJiYgc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2MuJGNhbGwoc2VsZiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLiQkbm9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJG5vbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdD0ob2JqZWN0KVxuICAgICV4e1xuICAgICAgc2VsZi4kJHByb2MgPSBuaWw7XG4gICAgICBzZWxmLiQkbm9uZSA9IG9iamVjdDtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jPShkZWZhdWx0X3Byb2MpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvYyA9IGRlZmF1bHRfcHJvYztcblxuICAgICAgaWYgKHByb2MgIT09IG5pbCkge1xuICAgICAgICBwcm9jID0gI3tPcGFsLmNvZXJjZV90byEoYHByb2NgLCBQcm9jLCA6dG9fcHJvYyl9O1xuXG4gICAgICAgIGlmICgje2Bwcm9jYC5sYW1iZGE/fSAmJiAje2Bwcm9jYC5hcml0eS5hYnN9ICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdkZWZhdWx0X3Byb2MgdGFrZXMgdHdvIGFyZ3VtZW50cyd9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRub25lID0gbmlsO1xuICAgICAgc2VsZi4kJHByb2MgPSBwcm9jO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdF9wcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShrZXksICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3t5aWVsZCBrZXl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHVwIGNsb25lXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBzZWxmW2tleV1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9rZXkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9rZXkpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlYWNoX3BhaXIgZWFjaFxuXG4gIGRlZiBlYWNoX3ZhbHVlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfdmFsdWUpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBzZWxmLiQkc21hcFtrZXldIDoga2V5LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBmZXRjaChrZXksIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSBLZXlFcnJvci5uZXcoXCJrZXkgbm90IGZvdW5kOiAje2tleS5pbnNwZWN0fVwiLCBrZXk6IGtleSwgcmVjZWl2ZXI6IHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmZXRjaF92YWx1ZXMoKmtleXMsICZibG9jaylcbiAgICBrZXlzLm1hcCB7IHxrZXl8IGZldGNoKGtleSwgJmJsb2NrKSB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gMSlcbiAgICBsZXZlbCA9IE9wYWwuY29lcmNlX3RvIShsZXZlbCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcblxuICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCgje2B2YWx1ZWAuZmxhdHRlbihgbGV2ZWwgLSAyYCl9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhrZXkpXG4gICAgYE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYgaGFzX3ZhbHVlPyh2YWx1ZSlcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmICgje2Aoa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSlgID09IHZhbHVlfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKE9wYWwuaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnSGFzaCddLFxuICAgICAgICAgIGtleSwgaXRlbTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9wYWxbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gT3BhbC5oYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSBPcGFsLmhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHNlbGYuJCRzbWFwW2tleV0uJGhhc2goKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LmtleV9oYXNoLCBrZXkudmFsdWUuJGhhc2goKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydCgpLmpvaW4oKTtcblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGhhc19rZXk/XG5cbiAgZGVmIGluZGV4KG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXhlcygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gYXJnc1tpXTtcbiAgICAgICAgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2RlZmF1bHR9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluZGljZXMgaW5kZXhlc1xuXG4gIGB2YXIgaW5zcGVjdF9pZHNgXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoaW5zcGVjdF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnNwZWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShoYXNoX2lkKSkge1xuICAgICAgICAgIHJldHVybiAney4uLn0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zcGVjdF9pZHNbaGFzaF9pZF0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LiRpbnNwZWN0KCkgKyAnPT4nICsgdmFsdWUuJGluc3BlY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnfSc7XG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBpbnNwZWN0X2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludmVydFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgdmFsdWUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBrZXkgaW5kZXhcblxuICBhbGlhcyBrZXk/IGhhc19rZXk/XG5cbiAgZGVmIGtleXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi4kJGtleXMubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGhhc19rZXk/XG5cbiAgZGVmIG1lcmdlKG90aGVyLCAmYmxvY2spXG4gICAgZHVwLm1lcmdlIShvdGhlciwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWVyZ2UhKG90aGVyLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICBvdGhlciA9ICN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaCl9O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgb3RoZXJfa2V5cyA9IG90aGVyLiQka2V5cywgbGVuZ3RoID0gb3RoZXJfa2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlO1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IG90aGVyX2tleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBibG9jayhrZXksIHZhbHVlLCBvdGhlcl92YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWhhc2hcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9yZWhhc2goc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVwbGFjZShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9pbml0KHNlbGYpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgb3RoZXJfa2V5cyA9IG90aGVyLiQka2V5cywgbGVuZ3RoID0gb3RoZXJfa2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBvdGhlci5kZWZhdWx0X3Byb2NcbiAgICAgIHNlbGYuZGVmYXVsdF9wcm9jID0gb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgZWxzZVxuICAgICAgc2VsZi5kZWZhdWx0ID0gb3RoZXIuZGVmYXVsdFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmlsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBzZWxmLiQka2V5cyxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBrZXkgPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5O1xuXG4gICAgICAgIHJldHVybiBba2V5LCBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChuaWwpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2xpY2UoKmtleXMpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLCB2YWx1ZSA9IE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3RvcmUgW109XG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5IYXNoKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcblxuICAgICAgT3BhbC5oYXNoX2luaXQoaGFzaCk7XG4gICAgICBPcGFsLmhhc2hfY2xvbmUoc2VsZiwgaGFzaCk7XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2hhc2hcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgcHJvYyBkbyB8a2V5ID0gdW5kZWZpbmVkfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIGtleSBnaXZlbid9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZltrZXldXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0cmFuc2Zvcm1fa2V5cygmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fa2V5cykgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IE9wYWwueWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fa2V5cyEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBPcGFsLnNsaWNlLmNhbGwoc2VsZi4kJGtleXMpLFxuICAgICAgICAgIGksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBuZXdfa2V5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdfa2V5ID0gT3BhbC55aWVsZDEoYmxvY2ssIGtleSk7XG5cbiAgICAgICAgT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpO1xuICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIG5ld19rZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX3ZhbHVlcygmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fdmFsdWVzKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fdmFsdWVzISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fdmFsdWVzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB1cGRhdGUgbWVyZ2UhXG5cbiAgYWxpYXMgdmFsdWU/IGhhc192YWx1ZT9cblxuICBhbGlhcyB2YWx1ZXNfYXQgaW5kZXhlc1xuXG4gIGRlZiB2YWx1ZXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYuJCRzbWFwW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsIltdIiwic2VsZiIsImNvZXJjZV90bz8iLCJhcmd2IiwiMCIsImFsbG9jYXRlIiwibWVyZ2UhIiwicmFpc2UiLCJ0cnlfY29udmVydCIsIm9iaiIsImluaXRpYWxpemUiLCI9PSIsIj49Iiwib3RoZXIiLCJjb2VyY2VfdG8hIiwicmVzdWx0IiwiZWFjaCIsInZhbCIsImZldGNoIiwib3RoZXJfa2V5IiwiPiIsIjwiLCI8PSIsIltdPSIsImFzc29jIiwib2JqZWN0IiwiY2xlYXIiLCJjbG9uZSIsImNvbXBhY3QiLCJjb21wYWN0ISIsImNvbXBhcmVfYnlfaWRlbnRpdHkiLCJjb21wYXJlX2J5X2lkZW50aXR5PyIsImRlZmF1bHQiLCJkZWZhdWx0PSIsImRlZmF1bHRfcHJvYyIsImRlZmF1bHRfcHJvYz0iLCJsYW1iZGE/IiwiYXJpdHkiLCJhYnMiLCJkZWxldGUiLCJrZXkiLCJkZWxldGVfaWYiLCJibG9jayIsImVudW1fZm9yIiwic2l6ZSIsImRpZyIsIml0ZW0iLCJyZXNwb25kX3RvPyIsImtleXMiLCJlYWNoX2tleSIsImVhY2hfdmFsdWUiLCJlbXB0eT8iLCJuZXciLCJpbnNwZWN0IiwiZmV0Y2hfdmFsdWVzIiwibWFwIiwiZmxhdHRlbiIsIjEiLCJsZXZlbCIsImhhc19rZXk/IiwiaGFzX3ZhbHVlPyIsInZhbHVlIiwiaGFzaCIsImVxbD8iLCJpbmRleCIsImluZGV4ZXMiLCJpbnZlcnQiLCJrZWVwX2lmIiwibGVuZ3RoIiwibWVyZ2UiLCJkdXAiLCJyYXNzb2MiLCJyZWhhc2giLCJyZWplY3QiLCJyZWplY3QhIiwicmVwbGFjZSIsIiR3cml0ZXIiLCItIiwic2VsZWN0Iiwic2VsZWN0ISIsInNoaWZ0Iiwic2xpY2UiLCJ0b19hIiwidG9faCIsInRvX2hhc2giLCJ0b19wcm9jIiwicHJvYyIsInRyYW5zZm9ybV9rZXlzIiwidHJhbnNmb3JtX2tleXMhIiwidHJhbnNmb3JtX3ZhbHVlcyIsInRyYW5zZm9ybV92YWx1ZXMhIiwidmFsdWVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsRUFVQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBLElBR0MsaUNB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aUJBQU0sV0FBTixFQUFnQixTQUFoQixDQXRwQ0E7QUFBQSxJQXdwQ0EsT0FBQUMsQ0FBQUEsMEJBQUFBLGtCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWZFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUEsa0JBeHBDQTtBQURGN0YsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FWQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE1NzY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1iZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBOdW1iZXIgPCBOdW1lcmljXG4gIE9wYWwuYnJpZGdlKGBOdW1iZXJgLCBzZWxmKVxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19udW1iZXInLCB0cnVlKWBcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlciA9PT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tvdGhlci5jbGFzc30gaW50byBGbG9hdFwifTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbI3tGbG9hdChvdGhlcil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8oOnRvX2YpfSkge1xuICAgICAgICByZXR1cm4gWyN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBGbG9hdCwgOnRvX2YpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gW290aGVyLCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYChzZWxmICogMikgKyAxYFxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmICsob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6LSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Lywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmRpdiAvXG5cbiAgZGVmICUob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyIDwgMCB8fCBzZWxmIDwgMCkge1xuICAgICAgICAgIHJldHVybiAoc2VsZiAlIG90aGVyICsgb3RoZXIpICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYgJSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDolLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAmIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDomLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiB8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDp8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiBeIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDpeLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPD0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA+IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPj0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOj49LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICAjIENvbXB1dGUgdGhlIHJlc3VsdCBvZiB0aGUgc3BhY2VzaGlwIG9wZXJhdG9yIGluc2lkZSBpdHMgb3duIGZ1bmN0aW9uIHNvIGl0XG4gICMgY2FuIGJlIG9wdGltaXplZCBkZXNwaXRlIGEgdHJ5L2ZpbmFsbHkgY29uc3RydWN0LlxuICAleHtcbiAgICB2YXIgc3BhY2VzaGlwX29wZXJhdG9yID0gZnVuY3Rpb24oc2VsZiwgb3RoZXIpIHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoaXNOYU4oc2VsZikgfHwgaXNOYU4ob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmID4gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmIDwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0+LCBgb3RoZXJgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGBzcGFjZXNoaXBfb3BlcmF0b3Ioc2VsZiwgb3RoZXIpYFxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgPDwoY291bnQpXG4gICAgY291bnQgPSBPcGFsLmNvZXJjZV90byEgY291bnQsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmIDw8ICN7Y291bnR9IDogc2VsZiA+PiAtI3tjb3VudH1gXG4gIGVuZFxuXG4gIGRlZiA+Pihjb3VudClcbiAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvISBjb3VudCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPj4gI3tjb3VudH0gOiBzZWxmIDw8IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmIFtdKGJpdClcbiAgICBiaXQgPSBPcGFsLmNvZXJjZV90byEgYml0LCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAleHtcbiAgICAgIGlmICgje2JpdH0gPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKCN7Yml0fSA+PSAzMikge1xuICAgICAgICByZXR1cm4gI3sgc2VsZiB9IDwgMCA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzZWxmID4+ICN7Yml0fSkgJiAxO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgYCtzZWxmYFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBgLXNlbGZgXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgYH5zZWxmYFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmICEoSW50ZWdlciA9PT0gc2VsZikgfHwgb3RoZXIgPiAwXG4gICAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgICBlbHNlXG4gICAgICAgIFJhdGlvbmFsLm5ldyhzZWxmLCAxKSoqb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIHNlbGYgPCAwICYmIChGbG9hdCA9PT0gb3RoZXIgfHwgUmF0aW9uYWwgPT09IG90aGVyKVxuICAgICAgQ29tcGxleC5uZXcoc2VsZiwgMCkqKm90aGVyLnRvX2ZcbiAgICBlbHNpZiBgb3RoZXIuJCRpc19udW1iZXIgIT0gbnVsbGBcbiAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyA6PT19KSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZi52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8gOj09fSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgYE1hdGguYWJzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIGBNYXRoLmFicyhzZWxmICogc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhbGxiaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IG1hc2tgXG4gIGVuZFxuXG4gIGRlZiBhbnliaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spICE9PSAwYFxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICByZXR1cm4gc2VsZiBpZiBuYW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgaWYgKDEgLyBzZWxmID4gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBwaGFzZSBhbmdsZVxuXG4gIGRlZiBiaXRfbGVuZ3RoXG4gICAgdW5sZXNzIEludGVnZXIgPT09IHNlbGZcbiAgICAgIHJhaXNlIE5vTWV0aG9kRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgYml0X2xlbmd0aGAgZm9yICN7c2VsZn06RmxvYXRcIiwgJ2JpdF9sZW5ndGgnKVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gMCB8fCBzZWxmID09PSAtMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgdmFsdWUgID0gc2VsZiA8IDAgPyB+c2VsZiA6IHNlbGY7XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICAgIHJlc3VsdCAgICs9IDE7XG4gICAgICAgIHZhbHVlICA+Pj49IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmNlaWwoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyKGVuY29kaW5nID0gdW5kZWZpbmVkKVxuICAgIGBTdHJpbmcuZnJvbUNoYXJDb2RlKHNlbGYpYFxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgMVxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkb3dudG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZG93bnRvLCBzdG9wKSBkb1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCIgdW5sZXNzIE51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA+IHNlbGYgPyAwIDogc2VsZiAtIHN0b3AgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHNlbGY7IGkgPj0gc3RvcDsgaS0tKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBlcXVhbD8ob3RoZXIpXG4gICAgc2VsZiA9PSBvdGhlciB8fCBgaXNOYU4oc2VsZikgJiYgaXNOYU4ob3RoZXIpYFxuICBlbmRcblxuICBkZWYgZXZlbj9cbiAgICBgc2VsZiAlIDIgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBmbG9vcihuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmZsb29yKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZChvdGhlcilcbiAgICB1bmxlc3MgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gTWF0aC5hYnMoc2VsZiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMob3RoZXIpO1xuXG4gICAgICB3aGlsZSAobWluID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gbWluO1xuXG4gICAgICAgIG1pbiA9IG1heCAlIG1pbjtcbiAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZGxjbShvdGhlcilcbiAgICBbZ2NkLCBsY21dXG4gIGVuZFxuXG4gIGRlZiBpbnRlZ2VyP1xuICAgIGBzZWxmICUgMSA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEZsb2F0ICYmIEZsb2F0ID09PSBzZWxmXG5cbiAgICBzdXBlclxuICBlbmRcblxuICBhbGlhcyBraW5kX29mPyBpc19hP1xuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gRmxvYXQgJiYgRmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBsY20ob3RoZXIpXG4gICAgdW5sZXNzIEludGVnZXIgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYW4gaW50ZWdlcidcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCB8fCBvdGhlciA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhzZWxmICogb3RoZXIgLyAje2djZChvdGhlcil9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcblxuICBhbGlhcyBtb2R1bG8gJVxuXG4gIGRlZiBuZXh0XG4gICAgYHNlbGYgKyAxYFxuICBlbmRcblxuICBkZWYgbm9iaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IDBgXG4gIGVuZFxuXG4gIGRlZiBub256ZXJvP1xuICAgIGBzZWxmID09IDAgPyBuaWwgOiBzZWxmYFxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgIHNlbGZcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgb2RkP1xuICAgIGBzZWxmICUgMiAhPT0gMGBcbiAgZW5kXG5cbiAgZGVmIG9yZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHBvdyhiLCBtID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCkge1xuICAgICAgICAje3JhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgIH1cblxuICAgICAgaWYgKG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tzZWxmKipifTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKCN7SW50ZWdlciA9PT0gYn0pKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYSAxc3QgYXJndW1lbnQgaXMgaW50ZWdlcid9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYiA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMXN0IGFyZ3VtZW50IGNhbm5vdCBiZSBuZWdhdGl2ZSB3aGVuIDJuZCBhcmd1bWVudCBzcGVjaWZpZWQnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoI3tJbnRlZ2VyID09PSBtfSkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMm5kIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhbGwgYXJndW1lbnRzIGFyZSBpbnRlZ2Vycyd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7KHNlbGYqKmIpICUgbX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmVkXG4gICAgYHNlbGYgLSAxYFxuICBlbmRcblxuICBkZWYgcXVvKG90aGVyKVxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2VsZiAvIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgUmF0aW9uYWwubmV3KHNlbGYsIDEpXG4gICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgZWxzaWYgbmFuP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBgZXBzID09IG51bGxgXG4gICAgICBmLCBuICA9IE1hdGguZnJleHAgc2VsZlxuICAgICAgZiAgICAgPSBNYXRoLmxkZXhwKGYsIEZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgbiAgICAtPSBGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgUmF0aW9uYWwubmV3KDIgKiBmLCAxIDw8ICgxIC0gbikpLnJhdGlvbmFsaXplKFJhdGlvbmFsLm5ldygxLCAxIDw8ICgxIC0gbikpKVxuICAgIGVsc2VcbiAgICAgIHRvX3IucmF0aW9uYWxpemUoZXBzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVtYWluZGVyKHkpXG4gICAgc2VsZiAtIHkgKiAoc2VsZiAvIHkpLnRydW5jYXRlXG4gIGVuZFxuXG4gIGRlZiByb3VuZChuZGlnaXRzID0gdW5kZWZpbmVkKVxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIGlmIGBuZGlnaXRzID09IG51bGxgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgRmxvYXQgPT09IG5kaWdpdHMgJiYgbmRpZ2l0cy5pbmZpbml0ZT9cbiAgICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ0luZmluaXR5J1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSBPcGFsLmNvZXJjZV90byEobmRpZ2l0cywgSW50ZWdlciwgOnRvX2ludClcblxuICAgICAgaWYgbmRpZ2l0cyA8IEludGVnZXI6Ok1JTlxuICAgICAgICByYWlzZSBSYW5nZUVycm9yLCAnb3V0IG9mIGJvdW5kcydcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbmRpZ2l0cyA+PSAwYFxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSAtbmRpZ2l0c1xuXG4gICAgICAleHtcbiAgICAgICAgaWYgKDAuNDE1MjQxICogbmRpZ2l0cyAtIDAuMTI1ID4gI3tzaXplfSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoTWF0aC5hYnMoeCkgKyBmIC8gMikgLyBmKSAqIGY7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYgPCAwID8gLXggOiB4O1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGlmIG5hbj8gJiYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gT3BhbC5jb2VyY2VfdG8hKGBuZGlnaXRzIHx8IDBgLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDw9IDBcbiAgICAgICAgaWYgbmFuP1xuICAgICAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdOYU4nXG4gICAgICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBuZGlnaXRzID09IDBcbiAgICAgICAgcmV0dXJuIGBNYXRoLnJvdW5kKHNlbGYpYFxuICAgICAgZWxzaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBfLCBleHAgPSBNYXRoLmZyZXhwKHNlbGYpXG5cbiAgICAgIGlmIG5kaWdpdHMgPj0gKEZsb2F0OjpESUcgKyAyKSAtIChleHAgPiAwID8gZXhwIC8gNCA6IGV4cCAvIDMgLSAxKVxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5kaWdpdHMgPCAtKGV4cCA+IDAgPyBleHAgLyAzICsgMSA6IGV4cCAvIDQpXG4gICAgICAgIHJldHVybiAwXG4gICAgICBlbmRcblxuICAgICAgYE1hdGgucm91bmQoc2VsZiAqIE1hdGgucG93KDEwLCBuZGlnaXRzKSkgLyBNYXRoLnBvdygxMCwgbmRpZ2l0cylgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzdGVwKGxpbWl0ID0gdW5kZWZpbmVkLCBzdGVwID0gdW5kZWZpbmVkLCB0bzogdW5kZWZpbmVkLCBieTogdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiB0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvIGlzIGdpdmVuIHR3aWNlJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCAmJiBieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3N0ZXAgaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGltaXQgPSB0bztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGltaXQgPSBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdzdGVwIG11c3QgYmUgbnVtZXJpYyd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RlcCA9IGJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCB8fCBzdGVwID09IG51bGwpIHtcbiAgICAgICAgICBzdGVwID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWduID0gI3tzdGVwIDw9PiAwfTtcblxuICAgICAgICBpZiAoc2lnbiA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIjAgY2FuJ3QgYmUgY29lcmNlZCBpbnRvICN7c3RlcC5jbGFzc31cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PT0gbmlsIHx8IGxpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICBsaW1pdCA9IHNpZ24gPiAwID8gI3tGbG9hdDo6SU5GSU5JVFl9IDogI3stRmxvYXQ6OklORklOSVRZfTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7T3BhbC5jb21wYXJlKHNlbGYsIGxpbWl0KX1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcEZsb2F0U2l6ZSgpIHtcbiAgICAgICAgaWYgKChzdGVwID4gMCAmJiBzZWxmID4gbGltaXQpIHx8IChzdGVwIDwgMCAmJiBzZWxmIDwgbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gSW5maW5pdHkgfHwgc3RlcCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgIGVyciA9IChhYnMoc2VsZikgKyBhYnMobGltaXQpICsgYWJzKGxpbWl0IC0gc2VsZikpIC8gYWJzKHN0ZXApICogI3tGbG9hdDo6RVBTSUxPTn07XG5cbiAgICAgICAgICBpZiAoZXJyID09PSBJbmZpbml0eSB8fCBlcnIgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmxvb3IoKGxpbWl0IC0gc2VsZikgLyBzdGVwICsgZXJyKSArIDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcFNpemUoKSB7XG4gICAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgJSAxICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXBGbG9hdFNpemUoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLCBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgICAgbGhzID0gYWJzKHNlbGYgLSBsaW1pdCkgKyAxLFxuICAgICAgICAgICAgICByaHMgPSBhYnMoc3RlcCk7XG5cbiAgICAgICAgICByZXR1cm4gY2VpbChsaHMgLyByaHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcG9zaXRpb25hbF9hcmdzID0gW11cbiAgICAgIGtleXdvcmRfYXJncyA9IHt9XG5cbiAgICAgICV4e1xuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvc2l0aW9uYWxfYXJncy5wdXNoKGxpbWl0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3NpdGlvbmFsX2FyZ3MucHVzaChzdGVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChrZXl3b3JkX2FyZ3MsIFwidG9cIiwgdG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGtleXdvcmRfYXJncywgXCJieVwiLCBieSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3trZXl3b3JkX2FyZ3MuYW55P30pIHtcbiAgICAgICAgICBwb3NpdGlvbmFsX2FyZ3MucHVzaChrZXl3b3JkX2FyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgKnBvc2l0aW9uYWxfYXJncykgeyBgc3RlcFNpemUoKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBibG9jayhzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZiAlIDEgIT09IDAgfHwgbGltaXQgJSAxICE9PSAwIHx8IHN0ZXAgJSAxICE9PSAwKSB7XG4gICAgICAgIHZhciBuID0gc3RlcEZsb2F0U2l6ZSgpO1xuXG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgIGlmIChzdGVwID09PSBJbmZpbml0eSB8fCBzdGVwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIGJsb2NrKHNlbGYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGQ7XG5cbiAgICAgICAgICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICBkID0gaSAqIHN0ZXAgKyBzZWxmO1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8IGQpIHtcbiAgICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2soZCk7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICBkID0gaSAqIHN0ZXAgKyBzZWxmO1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+IGQpIHtcbiAgICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2soZCk7XG4gICAgICAgICAgICAgICAgaSArPSAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNlbGY7XG5cbiAgICAgICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSArPSBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAodmFsdWUgPj0gbGltaXQpIHtcbiAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlICs9IHN0ZXBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzdWNjIG5leHRcblxuICBkZWYgdGltZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dGltZXMpIHsgc2VsZiB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGY7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBwYXJzZUludChzZWxmLCAxMClgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2ludCB0b19pXG5cbiAgZGVmIHRvX3JcbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNlXG4gICAgICBmLCBlICA9IE1hdGguZnJleHAoc2VsZilcbiAgICAgIGYgICAgID0gTWF0aC5sZGV4cChmLCBGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIGUgICAgLT0gRmxvYXQ6Ok1BTlRfRElHXG5cbiAgICAgIChmICogKEZsb2F0OjpSQURJWCoqZSkpLnRvX3JcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3MoYmFzZSA9IDEwKVxuICAgIGJhc2UgPSBPcGFsLmNvZXJjZV90byEgYmFzZSwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDIgfHwgYmFzZSA+IDM2XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICBgc2VsZi50b1N0cmluZyhiYXNlKWBcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50KGYgKiBmYWN0b3IsIDEwKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuXG4gIGRlZiBkaWdpdHMoYmFzZSA9IDEwKVxuICAgIGlmIHNlbGYgPCAwXG4gICAgICByYWlzZSBNYXRoOjpEb21haW5FcnJvciwgJ291dCBvZiBkb21haW4nXG4gICAgZW5kXG5cbiAgICBiYXNlID0gT3BhbC5jb2VyY2VfdG8hIGJhc2UsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGJhc2UgPCAyXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IHNlbGYsIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAodmFsdWUgIT09IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUgJSBiYXNlKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSAvIGJhc2UsIDEwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaXZtb2Qob3RoZXIpXG4gICAgaWYgbmFuPyB8fCBvdGhlci5uYW4/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnVwdG8sIHN0b3ApIGRvXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgTnVtZXJpYyA9PT0gc3RvcFxuICAgICAgICBzdG9wIDwgc2VsZiA/IDAgOiBzdG9wIC0gc2VsZiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBgc2VsZiA9PSAwYFxuICBlbmRcblxuICAjIFNpbmNlIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgMzIgYml0LCBkZWNsYXJlIGl0IHRvIGJlIHNvLlxuICBkZWYgc2l6ZVxuICAgIDRcbiAgZW5kXG5cbiAgZGVmIG5hbj9cbiAgICBgaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgYHNlbGYgIT0gSW5maW5pdHkgJiYgc2VsZiAhPSAtSW5maW5pdHkgJiYgIWlzTmFOKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gKzE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBgc2VsZiAhPSAwICYmIChzZWxmID09IEluZmluaXR5IHx8IDEgLyBzZWxmID4gMClgXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBgc2VsZiA9PSAtSW5maW5pdHkgfHwgMSAvIHNlbGYgPCAwYFxuICBlbmRcbmVuZFxuXG5GaXhudW0gPSBOdW1iZXJcblxuY2xhc3MgSW50ZWdlciA8IE51bWVyaWNcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiA9PT0ob3RoZXIpXG4gICAgICAleHtcbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAob3RoZXIgJSAxKSA9PT0gMDtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBzcXJ0KG4pXG4gICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBNYXRoOjpEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJpc3FydFwiJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChNYXRoLnNxcnQobiksIDEwKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgTUFYID0gYE1hdGgucG93KDIsIDMwKSAtIDFgXG4gIE1JTiA9IGAtTWF0aC5wb3coMiwgMzApYFxuZW5kXG5cbmNsYXNzIEZsb2F0IDwgTnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmID09PShvdGhlcilcbiAgICAgIGAhIW90aGVyLiQkaXNfbnVtYmVyYFxuICAgIGVuZFxuICBlbmRcblxuICBJTkZJTklUWSA9IGBJbmZpbml0eWBcbiAgTUFYICAgICAgPSBgTnVtYmVyLk1BWF9WQUxVRWBcbiAgTUlOICAgICAgPSBgTnVtYmVyLk1JTl9WQUxVRWBcbiAgTkFOICAgICAgPSBgTmFOYFxuXG4gIERJRyAgICAgID0gMTVcbiAgTUFOVF9ESUcgPSA1M1xuICBSQURJWCAgICA9IDJcblxuICBFUFNJTE9OID0gYE51bWJlci5FUFNJTE9OIHx8IDIuMjIwNDQ2MDQ5MjUwMzEzMDgwODQ3MjYzMzM2MTgxNkUtMTZgXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJicmlkZ2UiLCJzZWxmIiwiYWxsb2NhdGUiLCJyYWlzZSIsIm5hbWUiLCJjb2VyY2UiLCJvdGhlciIsIkZsb2F0IiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiX19pZF9fIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIiYiLCJ8IiwiXiIsIjwiLCI8PSIsIj4iLCI+PSIsIjw9PiIsIjw8IiwiY291bnQiLCI+PiIsIltdIiwiYml0IiwiK0AiLCItQCIsIn4iLCIqKiIsIj09PSIsIiEiLCIwIiwibmV3IiwiMSIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJjZWlsIiwiY2hyIiwiZGVub21pbmF0b3IiLCJpbmZpbml0ZT8iLCJkb3dudG8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInN0b3AiLCJlcXVhbD8iLCJldmVuPyIsImZsb29yIiwiZ2NkIiwiZ2NkbGNtIiwibGNtIiwiaW50ZWdlcj8iLCJpc19hPyIsImtsYXNzIiwiaW5zdGFuY2Vfb2Y/IiwibmV4dCIsIm5vYml0cz8iLCJub256ZXJvPyIsIm51bWVyYXRvciIsIm9kZD8iLCJvcmQiLCJwb3ciLCJiIiwibSIsInByZWQiLCJxdW8iLCJyYXRpb25hbGl6ZSIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsInRvX2kiLCIyIiwidG9fciIsImVwcyIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwibmRpZ2l0cyIsInNpemUiLCJfIiwiZXhwIiwiNCIsIjMiLCJzdGVwIiwiY29tcGFyZSIsImxpbWl0IiwicG9zaXRpb25hbF9hcmdzIiwia2V5d29yZF9hcmdzIiwiYW55PyIsInRpbWVzIiwiYmxvY2siLCJlIiwidG9fcyIsIjEwIiwiYmFzZSIsIjM2IiwiZGlnaXRzIiwiZGl2bW9kIiwidXB0byIsInplcm8/IiwiZmluaXRlPyIsInBv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QUEsR0FBQUEsV0FBQUEsRUFBZ0IsdUJBQWhCQSxXQWwvQkE7QUFBQSxFQXNoQ0EsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsNkJBQUQ7QUFBQSxJQUVBO0FBQUEsTUFBQTs7QUFBQTtBQUNFO0FBQUFHLE1BQUFBLDRCQUFBQSxlQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsV0FBQUMsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsMEJBQUEsR0FBQSxLQUEyQkMsTUFBQUEsQ0FBQUEsQ0FBM0IsQ0FBakJEO0FBREZELE1BQUFBLENBQUFBLDBCQUFBQSxDQUFBO0FBQUE7QUFJQSxNQUFBLHNCQUFNLEtBQU4sRUFKQTtBQUFBLE1BTUEsT0FBQWdDLENBQUFBLHVCQUFBQSxlQUFBQSxTQUFRLEtBQVJBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUMsbUJBQUQ7QUFERkEsTUFBQUEsQ0FBQUEsMEJBQUFBLENBQUFBLGVBTkE7QUFERixJQUFBLDRCQUFTakMsSUFBVCxZQUZBO0FBQUEsSUFjQSx3Q0FBWSxRQUFaLENBZEE7QUFBQSxJQWVBLG1DQUFZLGdCQUFaLENBZkE7QUFBQSxJQWdCQSxtQ0FBWSxnQkFBWixDQWhCQTtBQUFBLElBaUJBLG1DQUFZLEdBQVosQ0FqQkE7QUFBQSxJQW1CQSxtQ0FBV3FILEVBQVgsQ0FuQkE7QUFBQSxJQW9CQSx3Q0FBV0MsRUFBWCxDQXBCQTtBQUFBLElBcUJBLHFDQUFXbkMsQ0FBWCxDQXJCQTtBQUFBLElBdUJBLE9BQUEsdUNBQVcsdURBQVgsQ0F2QkE7QUFERnJGLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWMsdUJBQWRBLFdBdGhDQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3MTQ5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5nZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIFJhbmdlXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfcmFuZ2UgPSB0cnVlYFxuXG4gIGF0dHJfcmVhZGVyIDpiZWdpbiwgOmVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGZpcnN0LCBsYXN0LCBleGNsdWRlID0gZmFsc2UpXG4gICAgcmFpc2UgTmFtZUVycm9yLCBcIidpbml0aWFsaXplJyBjYWxsZWQgdHdpY2VcIiBpZiBAYmVnaW5cbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYmFkIHZhbHVlIGZvciByYW5nZScgdW5sZXNzIGZpcnN0IDw9PiBsYXN0XG5cbiAgICBAYmVnaW4gPSBmaXJzdFxuICAgIEBlbmQgICA9IGxhc3RcbiAgICBAZXhjbCAgPSBleGNsdWRlXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19yYW5nZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmV4Y2wgID09PSBvdGhlci5leGNsICYmXG4gICAgICAgICAgICAgc2VsZi5iZWdpbiA9PSAgb3RoZXIuYmVnaW4gJiZcbiAgICAgICAgICAgICBzZWxmLmVuZCAgID09ICBvdGhlci5lbmQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT09KHZhbHVlKVxuICAgIGluY2x1ZGU/IHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBjb3Zlcj8odmFsdWUpXG4gICAgYmVnX2NtcCA9IChAYmVnaW4gPD0+IHZhbHVlKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgYmVnX2NtcCAmJiBiZWdfY21wIDw9IDBcbiAgICBlbmRfY21wID0gKHZhbHVlIDw9PiBAZW5kKVxuICAgIGlmIEBleGNsXG4gICAgICBlbmRfY21wICYmIGVuZF9jbXAgPCAwXG4gICAgZWxzZVxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDw9IDBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsaW1pdDtcblxuICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX251bWJlciAmJiAje0BlbmR9LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmICgje0BiZWdpbn0gJSAxICE9PSAwIHx8ICN7QGVuZH0gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tIEZsb2F0XCJ9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAje0BiZWdpbn0sIGxpbWl0ID0gI3tAZW5kfSArICN7QGV4Y2wgPyAwIDogMX07IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgYmxvY2soaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7QGJlZ2luLnVwdG8oQGVuZCwgQGV4Y2wsICZibG9jayl9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnQgPSBAYmVnaW5cbiAgICBsYXN0ICAgID0gQGVuZFxuXG4gICAgdW5sZXNzIGN1cnJlbnQucmVzcG9uZF90bz8oOnN1Y2MpXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgaXRlcmF0ZSBmcm9tICN7Y3VycmVudC5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgd2hpbGUgKGN1cnJlbnQgPD0+IGxhc3QpIDwgMFxuICAgICAgeWllbGQgY3VycmVudFxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5zdWNjXG4gICAgZW5kXG5cbiAgICB5aWVsZCBjdXJyZW50IGlmICFAZXhjbCAmJiBjdXJyZW50ID09IGxhc3RcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBSYW5nZSA9PT0gb3RoZXJcblxuICAgIEBleGNsID09PSBvdGhlci5leGNsdWRlX2VuZD8gJiZcbiAgICAgIEBiZWdpbi5lcWw/KG90aGVyLmJlZ2luKSAmJlxuICAgICAgQGVuZC5lcWw/KG90aGVyLmVuZClcbiAgZW5kXG5cbiAgZGVmIGV4Y2x1ZGVfZW5kP1xuICAgIEBleGNsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChuID0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBAYmVnaW4gaWYgYG4gPT0gbnVsbGBcbiAgICBzdXBlclxuICBlbmRcblxuICBhbGlhcyBpbmNsdWRlPyBjb3Zlcj9cblxuICBkZWYgbGFzdChuID0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBAZW5kIGlmIGBuID09IG51bGxgXG4gICAgdG9fYS5sYXN0KG4pXG4gIGVuZFxuXG4gICMgRklYTUU6IGN1cnJlbnRseSBoYXJkY29kZWQgdG8gYXNzdW1lIHJhbmdlIGhvbGRzIG51bWVyaWNzXG4gIGRlZiBtYXhcbiAgICBpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgQGJlZ2luID4gQGVuZFxuICAgICAgbmlsXG4gICAgZWxzaWYgQGV4Y2wgJiYgQGJlZ2luID09IEBlbmRcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGAje0BleGNsfSA/ICN7QGVuZH0gLSAxIDogI3tAZW5kfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgbWVtYmVyPyBjb3Zlcj9cblxuICBkZWYgbWluXG4gICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBzdXBlclxuICAgIGVsc2lmIEBiZWdpbiA+IEBlbmRcbiAgICAgIG5pbFxuICAgIGVsc2lmIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kXG4gICAgICBuaWxcbiAgICBlbHNlXG4gICAgICBAYmVnaW5cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNpemVcbiAgICByYW5nZV9iZWdpbiA9IEBiZWdpblxuICAgIHJhbmdlX2VuZCAgID0gQGVuZFxuICAgIHJhbmdlX2VuZCAgLT0gMSBpZiBAZXhjbFxuXG4gICAgcmV0dXJuIG5pbCB1bmxlc3MgTnVtZXJpYyA9PT0gcmFuZ2VfYmVnaW4gJiYgTnVtZXJpYyA9PT0gcmFuZ2VfZW5kXG4gICAgcmV0dXJuIDAgaWYgcmFuZ2VfZW5kIDwgcmFuZ2VfYmVnaW5cbiAgICBpbmZpbml0eSA9IEZsb2F0OjpJTkZJTklUWVxuICAgIHJldHVybiBpbmZpbml0eSBpZiBbcmFuZ2VfYmVnaW4uYWJzLCByYW5nZV9lbmQuYWJzXS5pbmNsdWRlPyhpbmZpbml0eSlcblxuICAgIGBNYXRoLmFicyhyYW5nZV9lbmQgLSByYW5nZV9iZWdpbikgKyAxYC50b19pXG4gIGVuZFxuXG4gIGRlZiBzdGVwKG4gPSAxKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gY29lcmNlU3RlcFNpemUoKSB7XG4gICAgICAgIGlmICghbi4kJGlzX251bWJlcikge1xuICAgICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIG5lZ2F0aXZlXCJ9XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdG9yU2l6ZSgpIHtcbiAgICAgICAgaWYgKCEje0BiZWdpbi5yZXNwb25kX3RvPyg6c3VjYyl9KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiAlIDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gI3soc2l6ZSAvIG4pLmNlaWx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG4gaXMgYSBmbG9hdFxuICAgICAgICAgIHZhciBiZWdpbiA9IHNlbGYuYmVnaW4sIGVuZCA9IHNlbGYuZW5kLFxuICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKGJlZ2luKSArIGFicyhlbmQpICsgYWJzKGVuZCAtIGJlZ2luKSkgLyBhYnMobikgKiAje0Zsb2F0OjpFUFNJTE9OfSxcbiAgICAgICAgICAgICAgc2l6ZTtcblxuICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5leGNsKSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gLSBlcnIpO1xuICAgICAgICAgICAgaWYgKHNpemUgKiBuICsgYmVnaW4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gKyBlcnIpICsgMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBuKSBkb1xuICAgICAgICAleHtcbiAgICAgICAgICBjb2VyY2VTdGVwU2l6ZSgpO1xuICAgICAgICAgIHJldHVybiBlbnVtZXJhdG9yU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGBjb2VyY2VTdGVwU2l6ZSgpYFxuXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICBpID0gMFxuICAgICAgbG9vcCBkb1xuICAgICAgICBjdXJyZW50ID0gQGJlZ2luICsgaSAqIG5cbiAgICAgICAgaWYgQGV4Y2xcbiAgICAgICAgICBicmVhayBpZiBjdXJyZW50ID49IEBlbmRcbiAgICAgICAgZWxzaWYgY3VycmVudCA+IEBlbmRcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbmRcbiAgICAgICAgeWllbGQoY3VycmVudClcbiAgICAgICAgaSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nICYmIG4gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGZsb2F0IGZyb20gc3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWFjaF93aXRoX2luZGV4IGRvIHx2YWx1ZSwgaWR4fFxuICAgICAgICB5aWVsZCh2YWx1ZSkgaWYgaWR4ICUgbiA9PSAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmJzZWFyY2gpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHVubGVzcyBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBkbyBiaW5hcnkgc2VhcmNoIGZvciAje0BiZWdpbi5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgdG9fYS5ic2VhcmNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QGJlZ2lufSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kfVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIje0BiZWdpbi5pbnNwZWN0fSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kLmluc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIG1hcnNoYWxfbG9hZChhcmdzKVxuICAgIEBiZWdpbiA9IGFyZ3NbOmJlZ2luXVxuICAgIEBlbmQgPSBhcmdzWzplbmRdXG4gICAgQGV4Y2wgPSBhcmdzWzpleGNsXVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFtAYmVnaW4sIEBlbmQsIEBleGNsXS5oYXNoXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkBiZWdpbiIsInJhaXNlIiwiZmlyc3QiLCI8PT4iLCJsYXN0IiwiQGVuZCIsIkBleGNsIiwiZXhjbHVkZSIsIj09IiwiPT09IiwiaW5jbHVkZT8iLCJ2YWx1ZSIsImNvdmVyPyIsImJlZ19jbXAiLCI8PSIsIjAiLCJlbmRfY21wIiwiPCIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsIjEiLCJ1cHRvIiwiYmxvY2siLCJjdXJyZW50IiwicmVzcG9uZF90bz8iLCJzdWNjIiwiISIsInNlbGYiLCJlcWw/Iiwib3RoZXIiLCJleGNsdWRlX2VuZD8iLCJiZWdpbiIsImVuZCIsInRvX2EiLCJuIiwibWF4IiwiPiIsIm1pbiIsInNpemUiLCJyYW5nZV9iZWdpbiIsInJhbmdlX2VuZCIsIi0iLCJpbmZpbml0eSIsImFicyIsInRvX2kiLCJzdGVwIiwiY29lcmNlX3RvISIsIi8iLCJjZWlsIiwiaSIsImxvb3AiLCIrIiwiKiIsIj49IiwiZWFjaF93aXRoX2luZGV4IiwiaWR4IiwiJSIsImJzZWFyY2giLCJ0b19zIiwiaW5zcGVjdCIsIm1hcnNoYWxfbG9hZCIsImFyZ3MiLCJbXSIsImhhc2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFB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QSxDQUFLLE9BQUxBLENBQVQ7QUFBQSxNQUNBMUQsV0FBT3lELElBQUFDLE9BQUFBLENBQUssS0FBTEEsQ0FEUDtBQUFBLE1BRUEsT0FBQXpELENBQUFBLFlBQVF3RCxJQUFBQyxPQUFBQSxDQUFLLE1BQUxBLENBQVJ6RCxDQUZBO0FBREZ1RCxJQUFBQSxDQUFBQSxvQ0FBQUEsQ0E1UEE7QUFBQSxJQWtRQSxPQUFBRyxDQUFBQSx3QkFBQUEsaUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLENBQUNoRSxVQUFELEVBQVNLLFFBQVQsRUFBZUMsU0FBZixDQUFBMEQsTUFBQUEsQ0FBQUE7QUFERkEsSUFBQUEsQ0FBQUEsNEJBQUFBLENBQUFBLGdCQWxRQTtBQURGcEUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3NTY4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFByb2MgPCBgRnVuY3Rpb25gXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3Byb2MnLCB0cnVlKWBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsICRicmsgPSBzZWxmLiQkYnJrO1xuXG4gICAgICBpZiAoJGJyaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJGJyaykge1xuICAgICAgICAgICAgcmV0dXJuICRicmsuJHZcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbiAgYWxpYXMgeWllbGQgY2FsbFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhP1xuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcbiAgICAjIChzZWUgUHJvYyNsYW1iZGE/IG9uIHJ1YnkgZG9jcyB0byBmaW5kIG91dCBtb3JlKS5cbiAgICBgISFzZWxmLiQkaXNfbGFtYmRhYFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGFyaXR5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgcmV0dXJuIG5pbDsgfWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGJpbmRpbmdcbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJDYW4ndCBjcmVhdGUgQmluZGluZ1wifSB9YFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAje1tbOnJlc3RdXX07XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi4kJHBhcmFtZXRlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBzZWxmLiQkcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXSA9PT0gJ3JlcScpIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRzIGFsd2F5cyBoYXZlIG5hbWVcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyaXR5ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJpdHkgPSAje09wYWwuY29lcmNlX3RvIShhcml0eSwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBhcml0eSAhPT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJpdHlgfSBmb3IgI3tgc2VsZi5sZW5ndGhgfSlcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyaWVkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGxlbmd0aGB9IGZvciAje2Bhcml0eWB9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KG51bGwsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdCgkc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgICAgcmVzdWx0LiQkaXNfY3VycmllZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgY3VycmllZC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN1cnJpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfcHJvYyA9IHNlbGYuJCRvcmlnaW5hbF9wcm9jIHx8IHNlbGYsXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF9wcm9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcHJvY1twcm9wXSA9IHNlbGZbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbG9uZSBkdXBcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwibmV3Iiwic2VsZiIsImJsb2NrIiwicmFpc2UiLCJjYWxsIiwidG9fcHJvYyIsImxhbWJkYT8iLCJhcml0eSIsInNvdXJjZV9sb2NhdGlvbiIsImJpbmRpbmciLCJw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QUFTLFFBQWhDSyxDQUF5QztBQUMzRDtBQUNBLGNBQVlULE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLDZCQUFBLEdBQUEsQ0FBK0IsS0FBL0IsQ0FBQSxHQUFBLE9BQUEsR0FBQSxDQUE4QyxXQUE5QyxDQUFBLEdBQUEsR0FBckJBO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQVlBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLDZCQUFBLEdBQUEsQ0FBK0IsTUFBL0IsQ0FBQSxHQUFBLE9BQUEsR0FBQSxDQUErQyxLQUEvQyxDQUFBLEdBQUEsR0FBckJBO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBeEpBO0FBa0hFUSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FoSEE7QUFBQTtBQXlKQUUsSUFBQUEsdUJBQUFBLGVBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWRFQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0F6SkE7QUFBQSxJQTBLQSxPQUFBLGlCQUFNLE9BQU4sRUFBWSxLQUFaLENBMUtBO0FBREZkLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWMsUUFBZEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzc4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbWV0aG9kLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE1ldGhvZFxuICBhdHRyX3JlYWRlciA6b3duZXIsIDpyZWNlaXZlciwgOm5hbWVcblxuICBkZWYgaW5pdGlhbGl6ZShyZWNlaXZlciwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBvd25lciAgICA9IG93bmVyXG4gICAgQG5hbWUgICAgID0gbmFtZVxuICAgIEBtZXRob2QgICA9IG1ldGhvZFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICBAbWV0aG9kLmFyaXR5XG4gIGVuZFxuXG4gIGRlZiBwYXJhbWV0ZXJzXG4gICAgYCN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzYFxuICBlbmRcblxuICBkZWYgc291cmNlX2xvY2F0aW9uXG4gICAgYCN7QG1ldGhvZH0uJCRzb3VyY2VfbG9jYXRpb25gIHx8IFsnKGV2YWwpJywgMF1cbiAgZW5kXG5cbiAgZGVmIGNvbW1lbnRzXG4gICAgYCN7QG1ldGhvZH0uJCRjb21tZW50c2AgfHwgW11cbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgICN7QG1ldGhvZH0uJCRwID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiAje0BtZXRob2R9LmFwcGx5KCN7QHJlY2VpdmVyfSwgYXJncyk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBbXSBjYWxsXG5cbiAgZGVmIHVuYmluZFxuICAgIFVuYm91bmRNZXRob2QubmV3KEByZWNlaXZlci5jbGFzcywgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSlcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICAleHtcbiAgICAgIHZhciBwcm9jID0gc2VsZi4kY2FsbC5iaW5kKHNlbGYpO1xuICAgICAgcHJvYy4kJHVuYm91bmQgPSAje0BtZXRob2R9O1xuICAgICAgcHJvYy4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgICBwcm9jLiQkYXJpdHkgPSAje0BtZXRob2R9LiQkYXJpdHk7XG4gICAgICBwcm9jLiQkcGFyYW1ldGVycyA9ICN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0ByZWNlaXZlci5jbGFzc30jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFVuYm91bmRNZXRob2RcbiAgYXR0cl9yZWFkZXIgOnNvdXJjZSwgOm93bmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHNvdXJjZSwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAc291cmNlID0gc291cmNlXG4gICAgQG93bmVyICA9IG93bmVyXG4gICAgQG1ldGhvZCA9IG1ldGhvZFxuICAgIEBuYW1lICAgPSBuYW1lXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgYmluZChvYmplY3QpXG4gICAgJXh7XG4gICAgICBpZiAoI3tAb3duZXJ9LiQkaXNfbW9kdWxlIHx8IE9wYWwuaXNfYSgje29iamVjdH0sICN7QG93bmVyfSkpIHtcbiAgICAgICAgcmV0dXJuICN7TWV0aG9kLm5ldyhvYmplY3QsIEBvd25lciwgQG1ldGhvZCwgQG5hbWUpfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBiaW5kIHNpbmdsZXRvbiBtZXRob2QgdG8gYSBkaWZmZXJlbnQgY2xhc3MgKGV4cGVjdGVkICN7b2JqZWN0fS5raW5kX29mPygje0Bvd25lcn0gdG8gYmUgdHJ1ZSlcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0Bzb3VyY2V9IyN7QG5hbWV9IChkZWZpbmVkIGluICN7QG93bmVyfSBpbiAje3NvdXJjZV9sb2NhdGlvbi5qb2luKCc6Jyl9KT5cIlxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlY2VpdmVyIiwicmVjZWl2ZXIiLCJAb3duZXIiLCJvd25lciIsIkBuYW1lIiwibmFtZSIsIkBtZXRob2QiLCJtZXRob2QiLCJhcml0eSIsInBhcmFtZXRlcnMiLCJzb3VyY2VfbG9jYXRpb24iLCIwIiwiY29tbWVudHMiLCJjYWxsIiwidW5iaW5kIiwibmV3IiwidG9fcHJvYyIsImluc3BlY3QiLCJzZWxmIiwiam9pbiIsIkBzb3VyY2UiLCJzb3VyY2UiLCJiaW5kIiwib2JqZWN0IiwicmFpc2UiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxRQUFBQyxhQUFBQSxDQUFZLFNBQVEsWUFBVyxNQUEvQkEsQ0FBQTtBQUFBO0FBRUFDLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQWUsUUFBRCxFQUFXLEtBQVgsRUFBa0IsTUFBbEIsRUFBMEIsSUFBeENBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLGdCQUFZQyxRQUFaO0FBQUEsTUFDQUMsYUFBWUMsS0FEWjtBQUFBLE1BRUFDLFlBQVlDLElBRlo7QUFBQSxNQUdBLE9BQUFDLENBQUFBLGNBQVlDLE1BQVpELENBSEE7QUFERlAsSUFBQUEsQ0FBQUEsa0NBQUFBLENBRkE7QUFBQTtBQVNBUyxJQUFBQSx5QkFBQUEsa0JBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBRixXQUFBRSxPQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FUQTtBQUFBO0FBYUFDLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUdILFdBQVE7QUFEYkcsSUFBQUEsQ0FBQUEsa0NBQUFB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R0FBQSxLQUFpRVEsaUJBQUFBLENBQUFBLENBQUFTLE1BQUFBLENBQXFCLEdBQXJCQSxDQUFqRSxDQUFBLEdBQUE7QUFERkYsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUFBLG1CQXBDQTtBQURGcEIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0F4REE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzkzOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvdmFyaWFibGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgcmVnZXhwIG1hdGNoZXNcbiV4eyRndmFyc1snJiddID0gJGd2YXJzWyd+J10gPSAkZ3ZhcnNbJ2AnXSA9ICRndmFyc1tcIidcIl0gPSBuaWx9XG5cbiMgcmVxdWlyZXNcbiRMT0FERURfRkVBVFVSRVMgPSAkXCIgPSBgT3BhbC5sb2FkZWRfZmVhdHVyZXNgXG4kTE9BRF9QQVRIICAgICAgID0gJDogPSBbXVxuXG4jIHNwbGl0IGxpbmVzXG4kLyA9IFwiXFxuXCJcbiQsID0gbmlsXG5cbkFSR1YgPSBbXVxuQVJHRiA9IE9iamVjdC5uZXdcbkVOViAgPSB7fVxuXG4kVkVSQk9TRSA9IGZhbHNlXG4kREVCVUcgICA9IGZhbHNlXG4kU0FGRSAgICA9IDBcbiJdLCJuYW1lcyI6WyIkTE9BREVEX0ZFQVRVUkVTIiwiJFwiIiwiJExPQURfUEFUSCIsIiQ6IiwiJC8iLCIkLCIsIm5ldyIsIiRWRVJCT1NFIiwiJERFQlVHIiwiJFNBRkUiLCIwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxFQUFHLDJEQUFIO0FBQUEsRUFHQUEseUJBQW1CQyxDQUFBQSxlQUFNLG9CQUFOQSxDQUhuQjtBQUFBLEVBSUFDLG1CQUFtQkMsQ0FBQUEsY0FBSyxFQUFMQSxDQUpuQjtBQUFBLEVBT0FDLGNBQUssSUFQTDtBQUFBLEVBUUFDLGNBQUssR0FSTDtBQUFBLEVBVUEsb0NBQU8sRUFBUCxDQVZBO0FBQUEsRUFXQSxvQ0FBTyxzQkFBQUMsS0FBQUEsQ0FBQUEsQ0FBUCxDQVhBO0FBQUEsRUFZQSxtQ0FBTyxZQUFBLEVBQVAsQ0FaQTtBQUFBLEVBY0FDLGlCQUFXLEtBZFg7QUFBQSxFQWVBQyxlQUFXLEtBZlg7QUFBQSxFQWdCQSxPQUFBQyxDQUFBQSxjQUFXQyxDQUFYRCxDQWhCQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3OTU4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9yZWdleHBfYW5jaG9ycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgT3BhbFxuICBSRUdFWFBfU1RBUlQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnXicgOiAnXFxBJ1xuICBSRUdFWFBfRU5EID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gJyQnIDogJ1xceidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyRiAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UgKyAhXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDQwICg6Ozw9Pj9AIGNoYXJzKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGJlZ2dpbmluZyBvciBtaWRkbGUgb2YgaXRzIG5hbWVcbiAgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDJGXFx1MDAzQS1cXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyMCAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UpXG4gICMgXFx1MDAyMiAtIFxcdTAwMkYgKFwiIyQlJicoKSorLC0uLyBjaGFycylcbiAgIyBcXHUwMDNBIC0gXFx1MDAzRSAoOjs8PT4gY2hhcnMpXG4gICMgXFx1MDA0MCAgICAgICAgICAoQCBjaGFyKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGVuZCBvZiBpdHMgbmFtZVxuICAjIEluIGZhY3QsIEZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTID0gRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICsgXFx1MDAyMSAoJz8nKSArIFxcdTAwM0YgKCchJylcbiAgRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICAgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMi1cXHUwMDJGXFx1MDAzQS1cXHUwMDNFXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIElOTElORV9JREVOVElGSUVSX1JFR0VYUCA9IFJlZ2V4cC5uZXcoXCJbXiN7Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlN9XSpbXiN7Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTfV1cIilcblxuICAjIEZvciBjb25zdGFudHMgcnVsZXMgYXJlIHByZXR0eSBtdWNoIHRoZSBzYW1lLCBidXQgJzonIGlzIGFsbG93ZWQgYW5kICc/IScgYXJlIG5vdC5cbiAgIyBQbHVzIGl0IG1heSBzdGFydCB3aXRoIGEgJzo6JyB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29uc3RhbnQgY29tZXMgZnJvbSB0b3BsZXZlbC5cbiAgRk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMS1cXHUwMDJGXFx1MDAzQi1cXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIENPTlNUX05BTUVfUkVHRVhQID0gUmVnZXhwLm5ldyhcIiN7UkVHRVhQX1NUQVJUfSg6Oik/W0EtWl1bXiN7Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlN9XSoje1JFR0VYUF9FTkR9XCIpXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCI9PSIsIm5ldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQSw0Q0FBZSxhQUFBLElBQUEsMkJBQUFDLE9BQUFBLENBQWUsTUFBZkEsQ0FBQTtBQUFBLE1BQXdCLE9BQUE7QUFBeEIsSUFBQTtBQUFBLE1BQUEsT0FBQTtBQUFBLElBQUEsQ0FBQSxrQkFBZixDQUFBO0FBQUEsSUFDQSwwQ0FBYSxhQUFBLElBQUEsMkJBQUFBLE9BQUFBLENBQWUsTUFBZkEsQ0FBQTtBQUFBLE1BQXdCLE9BQUE7QUFBeEIsSUFBQTtBQUFBLE1BQUEsT0FBQTtBQUFBLElBQUEsQ0FBQSxrQkFBYixDQURBO0FBQUEsSUFVQSxtRUFBc0MscUVBQXRDLENBVkE7QUFBQSxJQXNCQSxpRUFBc0MsMkZBQXRDLENBdEJBO0FBQUEsSUF1QkEsd0RBQTJCLHNCQUFBQyxLQUFBQSxDQUFXLEVBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBSyxtREFBTCxDQUFBLEdBQUEsTUFBQSxHQUFBLENBQStDLGlEQUEvQyxDQUFBLEdBQUEsR0FBWEEsQ0FBM0IsQ0F2QkE7QUFBQSxJQTJCQSwwREFBNkIsMkZBQTdCLENBM0JBO0FBQUEsSUE0QkEsaURBQW9CLHNCQUFBQSxLQUFBQSxDQUFXLEVBQUEsR0FBQSxDQUFHLDRCQUFILENBQUEsR0FBQSxjQUFBLEdBQUEsQ0FBOEIsMENBQTlCLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBNkQsMEJBQTdELENBQVhBLENBQXBCLENBNUJBO0FBREZGLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTc5ODcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL21pbmkucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnb3BhbC9iYXNlJ1xuXG5yZXF1aXJlICdjb3JlbGliL25pbCdcbnJlcXVpcmUgJ2NvcmVsaWIvYm9vbGVhbidcbnJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nJ1xucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhdG9yJ1xucmVxdWlyZSAnY29yZWxpYi9hcnJheSdcbnJlcXVpcmUgJ2NvcmVsaWIvaGFzaCdcbnJlcXVpcmUgJ2NvcmVsaWIvbnVtYmVyJ1xucmVxdWlyZSAnY29yZWxpYi9yYW5nZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcHJvYydcbnJlcXVpcmUgJ2NvcmVsaWIvbWV0aG9kJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5cbnJlcXVpcmUgJ2NvcmVsaWIvdmFyaWFibGVzJ1xucmVxdWlyZSAnb3BhbC9yZWdleHBfYW5jaG9ycydcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFdBQVJBLENBQUE7QUFBQSxNQUVBQSxTQUFBQSxDQUFRLGFBQVJBLENBRkE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEsb0JBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLG9CQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsZUFBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FUQTtBQUFBLE1BVUFBLFNBQUFBLENBQVEsZ0JBQVJBLENBVkE7QUFBQSxNQVdBQSxTQUFBQSxDQUFRLGVBQVJBLENBWEE7QUFBQSxNQVlBQSxTQUFBQSxDQUFRLGNBQVJBLENBWkE7QUFBQSxNQWFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWJBO0FBQUEsTUFjQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FkQTtBQUFBLE1BZ0JBQSxTQUFBQSxDQUFRLG1CQUFSQSxDQWhCQTtBQUFBLEVBaUJBLFdBQUFBLFNBQUFBLENBQVEscUJBQVJBLENBakJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTgwMTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC9mb3JtYXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEtlcm5lbFxuICBkZWYgZm9ybWF0KGZvcm1hdF9zdHJpbmcsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID09IDEgJiYgYXJnc1swXS5yZXNwb25kX3RvPyg6dG9fYXJ5KVxuICAgICAgYXJ5ID0gT3BhbC5jb2VyY2VfdG8/KGFyZ3NbMF0sIEFycmF5LCA6dG9fYXJ5KVxuICAgICAgYXJncyA9IGFyeS50b19hIHVubGVzcyBhcnkubmlsP1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgLy91c2VkIGZvciBzbGljaW5nOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gMCxcbiAgICAgICAgICBlbmRfc2xpY2UsXG4gICAgICAgICAgLy91c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZm9ybWF0IHN0cmluZzpcbiAgICAgICAgICBpLFxuICAgICAgICAgIGxlbiA9IGZvcm1hdF9zdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBmaWVsZCB2YWx1ZXM6XG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHN0cixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWcgYW5kICVHIGZpZWxkczpcbiAgICAgICAgICBleHBvbmVudCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2lkdGggYW5kIHByZWNpc2lvbjpcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgLy91c2VkIGZvciBob2xkaW5nIHRlbXBvcmFyeSB2YWx1ZXM6XG4gICAgICAgICAgdG1wX251bSxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJXt9IGFuZCAlPD4gZmlsZWRzOlxuICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSxcbiAgICAgICAgICBjbG9zaW5nX2JyYWNlX2NoYXIsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICViLCAlQiwgJW8sICV4LCBhbmQgJVggZmllbGRzOlxuICAgICAgICAgIGJhc2VfbnVtYmVyLFxuICAgICAgICAgIGJhc2VfcHJlZml4LFxuICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgIG5leHRfYXJnLFxuICAgICAgICAgIHNlcV9hcmdfbnVtID0gMSxcbiAgICAgICAgICBwb3NfYXJnX251bSA9IDAsXG4gICAgICAgICAgLy91c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGZsYWdzOlxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIEZOT05FICA9IDAsXG4gICAgICAgICAgRlNIQVJQID0gMSxcbiAgICAgICAgICBGTUlOVVMgPSAyLFxuICAgICAgICAgIEZQTFVTICA9IDQsXG4gICAgICAgICAgRlpFUk8gID0gOCxcbiAgICAgICAgICBGU1BBQ0UgPSAxNixcbiAgICAgICAgICBGV0lEVEggPSAzMixcbiAgICAgICAgICBGUFJFQyAgPSA2NCxcbiAgICAgICAgICBGUFJFQzAgPSAxMjg7XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9GTEFHUygpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdmbGFnIGFmdGVyIHdpZHRoJ30gfVxuICAgICAgICBpZiAoZmxhZ3MmRlBSRUMwKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfV0lEVEgoKSB7XG4gICAgICAgIGlmIChmbGFncyZGV0lEVEgpIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd2lkdGggZ2l2ZW4gdHdpY2UnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd2lkdGggYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTlRIX0FSRyhudW0pIHtcbiAgICAgICAgaWYgKG51bSA+PSBhcmdzLmxlbmd0aCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0b28gZmV3IGFyZ3VtZW50cyd9IH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbbnVtXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX05FWFRfQVJHKCkge1xuICAgICAgICBzd2l0Y2ggKHBvc19hcmdfbnVtKSB7XG4gICAgICAgIGNhc2UgLTE6ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bm51bWJlcmVkKCN7YHNlcV9hcmdfbnVtYH0pIG1peGVkIHdpdGggbnVtYmVyZWRcIn1cbiAgICAgICAgY2FzZSAtMjogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIHBvc19hcmdfbnVtID0gc2VxX2FyZ19udW0rKztcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKHBvc19hcmdfbnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9QT1NfQVJHKG51bSkge1xuICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJudW1iZXJlZCgje2BudW1gfSkgYWZ0ZXIgbmFtZWRcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgMSkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGluZGV4IC0gI3tgbnVtYH0kXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSAtMTtcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKG51bSAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfQVJHKCkge1xuICAgICAgICByZXR1cm4gKG5leHRfYXJnID09PSB1bmRlZmluZWQgPyBHRVRfTkVYVF9BUkcoKSA6IG5leHRfYXJnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU0obGFiZWwpIHtcbiAgICAgICAgdmFyIG51bSwgc3RyID0gJyc7XG4gICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlKlswLTldJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA8IDQ4IHx8IGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA+IDU3KSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBudW0gPSBwYXJzZUludChzdHIsIDEwKSB8fCAwO1xuICAgICAgICAgICAgaWYgKG51bSA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7YGxhYmVsYH0gdG9vIGJpZ1wifVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJFQURfTlVNX0FGVEVSX0FTVEVSKGxhYmVsKSB7XG4gICAgICAgIHZhciBhcmcsIG51bSA9IFJFQURfTlVNKGxhYmVsKTtcbiAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGFyZyA9IEdFVF9QT1NfQVJHKG51bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJnID0gR0VUX05FWFRfQVJHKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7YGFyZ2AudG9faW50fTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJyk7IGkgIT09IC0xOyBpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJywgaSkpIHtcbiAgICAgICAgc3RyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGZsYWdzID0gRk5PTkU7XG4gICAgICAgIHdpZHRoID0gLTE7XG4gICAgICAgIHByZWNpc2lvbiA9IC0xO1xuICAgICAgICBuZXh0X2FyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICBlbmRfc2xpY2UgPSBpO1xuXG4gICAgICAgIGkrKztcblxuICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gaTtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFwwJzpcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXRfc2VxdWVuY2U6IGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG5cbiAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlNQQUNFO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTSEFSUDtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGUExVUztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGTUlOVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlpFUk87XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICBjYXNlICc2JzpcbiAgICAgICAgICBjYXNlICc3JzpcbiAgICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgIHRtcF9udW0gPSBSRUFEX05VTSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpICsgMSkgPT09ICckJykge1xuICAgICAgICAgICAgICBpZiAoaSArIDIgPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHN0ciA9ICclJztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXh0X2FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInZhbHVlIGdpdmVuIHR3aWNlIC0gJSN7YHRtcF9udW1gfSRcIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXh0X2FyZyA9IEdFVF9QT1NfQVJHKHRtcF9udW0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgICB3aWR0aCA9IHRtcF9udW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXNlICdcXHsnOlxuICAgICAgICAgICAgY2xvc2luZ19icmFjZV9jaGFyID0gKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSAnPCcgPyAnPicgOiAnXFx9Jyk7XG4gICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgPSAnJztcblxuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIG5hbWUgLSB1bm1hdGNoZWQgcGFyZW50aGVzaXMnfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gY2xvc2luZ19icmFjZV9jaGFyKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgdW5udW1iZXJlZCgje2Bwb3NfYXJnX251bWB9KVwifVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgbnVtYmVyZWRcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zX2FyZ19udW0gPSAtMjtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSB1bmRlZmluZWQgfHwgIWFyZ3NbMF0uJCRpc19oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdvbmUgaGFzaCByZXF1aXJlZCd9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV4dF9hcmcgPSAje2BhcmdzWzBdYC5mZXRjaChgaGFzaF9wYXJhbWV0ZXJfa2V5YCl9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NpbmdfYnJhY2VfY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IG5leHRfYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgIHdpZHRoID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGlmIChmbGFncyZGUFJFQzApIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAncHJlY2lzaW9uIGdpdmVuIHR3aWNlJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYWdzIHw9IEZQUkVDfEZQUkVDMDtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09ICcqJykge1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHByZWNpc2lvbiA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBmbGFncyAmPSB+RlBSRUM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU0oJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICBhcmcgPSAje0ludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAyO1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwYic7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXjErLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICcxJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSA4O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMz83Ky87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnNyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAxNjtcbiAgICAgICAgICAgICAgYmFzZV9wcmVmaXggPSAnMHgnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL15mKy87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnZic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0gI3tJbnRlZ2VyKGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDApIHtcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkgLSAoKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSAtIChmbGFncyZGU0hBUlAgPyAyIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IChhcmcgPj4+IDApLnRvU3RyaW5nKGJhc2VfbnVtYmVyKS5yZXBsYWNlKGJhc2VfbmVnX3plcm9fcmVnZXgsIGJhc2VfbmVnX3plcm9fZGlnaXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uIC0gMikgeyBzdHIgPSBiYXNlX25lZ196ZXJvX2RpZ2l0ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAyIC0gKGZsYWdzJkZTSEFSUCA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICBhcmcgPSAje0Zsb2F0KGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDAgfHwgaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdJbmYnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0ZpeGVkKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChzdHIuc3BsaXQoJ2UnKVsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwb25lbnQgPCAtNCB8fCBleHBvbmVudCA+PSAocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9QcmVjaXNpb24ocHJlY2lzaW9uID09PSAtMSA/IChmbGFncyZGU0hBUlAgPyA2IDogdW5kZWZpbmVkKSA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkudG9VcHBlckNhc2UoKSAmJiBhcmcgIT09IEluZmluaXR5ICYmIGFyZyAhPT0gLUluZmluaXR5ICYmICFpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbZUVdWy0rXT8pKFswLTldKSQvLCAnJDEwJDInKTtcbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHNwZWNzIGZvciB0aGlzIGZpZWxkIHR5cGUuXG4gICAgICAgICAgICAje3JhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdgQWAgYW5kIGBhYCBmb3JtYXQgZmllbGQgdHlwZXMgYXJlIG5vdCBpbXBsZW1lbnRlZCBpbiBPcGFsIHlldCd9XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGFyZyA9IEdFVF9BUkcoKTtcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgICAgICBzdHIgPSAje2BhcmdgLnRvX3N0cn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCN7T3BhbC5jb2VyY2VfdG8oYGFyZ2AsIEludGVnZXIsIDp0b19pbnQpfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICclYyByZXF1aXJlcyBhIGNoYXJhY3Rlcid9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLmluc3BlY3R9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHN0ciA9ICN7YEdFVF9BUkcoKWAudG9fc307XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlI3tgZm9ybWF0X3N0cmluZy5jaGFyQXQoaSlgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSd9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gZm9ybWF0X3N0cmluZy5zbGljZShiZWdpbl9zbGljZSwgZW5kX3NsaWNlKSArIHN0cjtcbiAgICAgICAgYmVnaW5fc2xpY2UgPSBpICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JERFQlVHfSAmJiBwb3NfYXJnX251bSA+PSAwICYmIHNlcV9hcmdfbnVtIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAndG9vIG1hbnkgYXJndW1lbnRzIGZvciBmb3JtYXQgc3RyaW5nJ31cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCArIGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3ByaW50ZiBmb3JtYXRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImZvcm1hdCIsImFyZ3MiLCJsZW5ndGgiLCI9PSIsIjEiLCJbXSIsIjAiLCJyZXNwb25kX3RvPyIsImFyeSIsImNvZXJjZV90bz8iLCJuaWw/IiwidG9fYSIsInJhaXNlIiwidG9faW50IiwiZmV0Y2giLCJJbnRlZ2VyIiwiRmxvYXQiLCJ0b19hcnkiLCJ0b19zdHIiLCJjb2VyY2VfdG8iLCJpbnNwZWN0IiwidG9fcyIsIiRERUJVRyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFBQUMsSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBVyxhQUFELEVBRlosRUFFRUE7QUFBQUEsTUFBQUE7QUFBQUE7O0FBQUFBO0FBRkY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFFNEIsTUFBQSxrQkFGNUI7QUFBQSxNQUdJLElBQUEsUUFBRyxPQUFBQyxJQUFBQyxRQUFBQSxDQUFBQSxD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QTtBQUNBO0FBQ0E7QUFDQSxzQkFBb0JHLFNBQUFBLENBQVMsU0FBVEEsQ0FBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBb0JBLFNBQUFBLENBQVMsU0FBVEEsQ0FBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFvQkMsT0FBQUEsQ0FBTyxTQUFQQSxDQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFjSixPQUFBQSxDQUFNLHFDQUFxQixnRUFBM0JBOztBQUVkO0FBQ0E7QUFDQSxnQkFBa0IsQ0FBQyxHQUFELENBQUFMLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkIsVUFBWSxDQUFDLEdBQUQsQ0FBQVUsUUFBQUEsQ0FBQUEsQ0FBYTtBQUN0RSxnQkFBa0IsQ0FBQyxHQUFELENBQUFWLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkI7QUFDN0Msb0JBQXNCLENBQUMsR0FBRCxDQUFBVyxRQUFBQSxDQUFBQSxDQUFhO0FBQ25DO0FBQ0Esd0NBQTBDLG9CQUFBQyxXQUFBQSxDQUFnQixLQUFNLHlCQUFTLFFBQS9CQSxDQUF3QztBQUNsRjtBQUNBO0FBQ0Esa0JBQWdCUCxPQUFBQSxDQUFNLCtCQUFlLHlCQUFyQkE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBb0IsQ0FBQyxTQUFELENBQUFRLFNBQUFBLENBQUFBLENBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQW9CLENBQUMsU0FBRCxDQUFBQyxNQUFBQSxDQUFBQSxDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFjVCxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSw2QkFBQSxHQUFBLENBQStCLHVCQUEvQixDQUFyQkE7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBWUEsT0FBQUEsQ0FBTSwrQkFBZSw2QkFBckJBO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVlVLFlBQU87QUFDbkIsWUFBVVYsT0FBQUEsQ0FBTSwrQkFBZSxzQ0FBckJBO0FBQ1Y7O0FBRUE7QUFDQSxJQTVoQkE7QUFFRVosSUFBQUEsQ0FBQUEsK0JBQUFBLENBQUE7QUFBQSxJQTZoQkEsaUJBQU0sU0FBTixFQUFjLFFBQWQsQ0E3aEJBO0FBREZELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTg1NzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cmluZy9lbmNvZGluZy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL3N0cmluZydcblxuY2xhc3MgRW5jb2RpbmdcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZiwgJyQkcmVnaXN0ZXInLCB7fSlgXG5cbiAgZGVmIHNlbGYucmVnaXN0ZXIobmFtZSwgb3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgbmFtZXMgICAgPSBbbmFtZV0gKyAob3B0aW9uc1s6YWxpYXNlc10gfHwgW10pXG4gICAgZW5jb2RpbmcgPSBDbGFzcy5uZXcoc2VsZiwgJmJsb2NrKVxuICAgICAgICAgICAgICAgICAgICAubmV3KG5hbWUsIG5hbWVzLCBvcHRpb25zWzphc2NpaV0gfHwgZmFsc2UsIG9wdGlvbnNbOmR1bW15XSB8fCBmYWxzZSlcblxuICAgIHJlZ2lzdGVyID0gc2VsZi5KU1snJCRyZWdpc3RlciddXG4gICAgbmFtZXMuZWFjaCBkbyB8ZW5jb2RpbmdfbmFtZXxcbiAgICAgIGNvbnN0X3NldCBlbmNvZGluZ19uYW1lLnN1YignLScsICdfJyksIGVuY29kaW5nXG4gICAgICByZWdpc3Rlci5KU1tcIiQkI3tlbmNvZGluZ19uYW1lfVwiXSA9IGVuY29kaW5nXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZpbmQobmFtZSlcbiAgICByZXR1cm4gZGVmYXVsdF9leHRlcm5hbCBpZiBuYW1lID09IDpkZWZhdWx0X2V4dGVybmFsXG4gICAgcmVnaXN0ZXIgPSBzZWxmLkpTWyckJHJlZ2lzdGVyJ11cbiAgICBlbmNvZGluZyA9IHJlZ2lzdGVyLkpTW1wiJCQje25hbWV9XCJdIHx8IHJlZ2lzdGVyLkpTW1wiJCQje25hbWUudXBjYXNlfVwiXVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5rbm93biBlbmNvZGluZyBuYW1lIC0gI3tuYW1lfVwiIHVubGVzcyBlbmNvZGluZ1xuICAgIGVuY29kaW5nXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhdHRyX2FjY2Vzc29yIDpkZWZhdWx0X2V4dGVybmFsXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpuYW1lLCA6bmFtZXNcblxuICBkZWYgaW5pdGlhbGl6ZShuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIEBuYW1lICA9IG5hbWVcbiAgICBAbmFtZXMgPSBuYW1lc1xuICAgIEBhc2NpaSA9IGFzY2lpXG4gICAgQGR1bW15ID0gZHVtbXlcbiAgZW5kXG5cbiAgZGVmIGFzY2lpX2NvbXBhdGlibGU/XG4gICAgQGFzY2lpXG4gIGVuZFxuXG4gIGRlZiBkdW1teT9cbiAgICBAZHVtbXlcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBAbmFtZVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxFbmNvZGluZzoje0BuYW1lfSN7JyAoZHVtbXkpJyBpZiBAZHVtbXl9PlwiXG4gIGVuZFxuXG4gICMgbWV0aG9kcyB0byBpbXBsZW1lbnQgcGVyIGVuY29kaW5nXG4gIGRlZiBlYWNoX2J5dGUoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGRlZiBnZXRieXRlKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIEVuY29kaW5nRXJyb3IgPCBTdGFuZGFyZEVycm9yOyBlbmRcbiAgY2xhc3MgQ29tcGF0aWJpbGl0eUVycm9yIDwgRW5jb2RpbmdFcnJvcjsgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNvZGUgPD0gMHg3Zikge1xuICAgICAgICAgICN7eWllbGQgYGNvZGVgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmcuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBlbmNvZGVkX2xlbmd0aCA9IGVuY29kZWQubGVuZ3RoOyBqIDwgZW5jb2RlZF9sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgI3t5aWVsZCBgcGFyc2VJbnQoZW5jb2RlZFtqXSwgMTYpYH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0xNkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBzdHJpbmcuYnl0ZXMubGVuZ3RoXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZCRScgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgc3RyaW5nLmJ5dGVzLmxlbmd0aFxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyTEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ0FTQ0lJLThCSVQnLCBhbGlhc2VzOiBbJ0JJTkFSWScsICdVUy1BU0NJSScsICdBU0NJSSddLCBhc2NpaTogdHJ1ZSwgZHVtbXk6IHRydWUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gIGF0dHJfcmVhZGVyIDplbmNvZGluZ1xuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnZW5jb2RpbmcnLCAje0VuY29kaW5nOjpVVEZfMTZMRX0pYFxuXG4gIGRlZiBieXRlc1xuICAgIGVhY2hfYnl0ZS50b19hXG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZVxuICAgIEBlbmNvZGluZy5ieXRlc2l6ZShzZWxmKVxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfYnl0ZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAZW5jb2RpbmcuZWFjaF9ieXRlKHNlbGYsICZibG9jaylcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29kZXBvaW50KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY29kZXBvaW50IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICN7eWllbGQgYHNlbGYuY29kZVBvaW50QXQoaSlgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29kZXBvaW50cygmYmxvY2spXG4gICAgIyBJZiBhIGJsb2NrIGlzIGdpdmVuLCB3aGljaCBpcyBhIGRlcHJlY2F0ZWQgZm9ybSwgd29ya3MgdGhlIHNhbWUgYXMgZWFjaF9jb2RlcG9pbnQuXG4gICAgcmV0dXJuIGVhY2hfY29kZXBvaW50KCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgZWFjaF9jb2RlcG9pbnQudG9fYVxuICBlbmRcblxuICBkZWYgZW5jb2RlKGVuY29kaW5nKVxuICAgIGR1cC5mb3JjZV9lbmNvZGluZyhlbmNvZGluZylcbiAgZW5kXG5cbiAgZGVmIGZvcmNlX2VuY29kaW5nKGVuY29kaW5nKVxuICAgICV4e1xuICAgICAgaWYgKGVuY29kaW5nID09PSBzZWxmLmVuY29kaW5nKSB7IHJldHVybiBzZWxmOyB9XG5cbiAgICAgIGVuY29kaW5nID0gI3tPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIFN0cmluZywgOnRvX3MpfTtcbiAgICAgIGVuY29kaW5nID0gI3tFbmNvZGluZy5maW5kKGVuY29kaW5nKX07XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc2VsZi5lbmNvZGluZykgeyByZXR1cm4gc2VsZjsgfVxuXG4gICAgICBzZWxmLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRieXRlKGlkeClcbiAgICBAZW5jb2RpbmcuZ2V0Ynl0ZShzZWxmLCBpZHgpXG4gIGVuZFxuXG4gICMgc3R1YlxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsInJlZ2lzdGVyIiwic2VsZiIsIm5hbWVzIiwiKyIsIm5hbWUiLCJvcHRpb25zIiwiW10iLCJlbmNvZGluZyIsIm5ldyIsImJsb2NrIiwiZWFjaCIsImNvbnN0X3NldCIsImVuY29kaW5nX25hbWUiLCJzdWIiLCJmaW5kIiwiPT0iLCJkZWZhdWx0X2V4dGVybmFsIiwidXBjYXNlIiwicmFpc2UiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQG5hbWUiLCJAbmFtZXMiLCJAYXNjaWkiLCJhc2NpaSIsIkBkdW1teSIsImR1bW15IiwiYXNjaWlfY29tcGF0aWJsZT8iLCJkdW1teT8iLCJ0b19zIiwiaW5zcGVjdCIsImVhY2hfYnl0ZSIsImdldGJ5dGUiLCJieXRlc2l6ZSIsInN0cmluZyIsImJ5dGVzIiwibGVuZ3RoIiwidG9fYSIsIkBlbmNvZGluZyIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiZWFjaF9jb2RlcG9pbnQiLCJjb2RlcG9pbnRzIiwiZW5jb2RlIiwiZHVwIiwiZm9yY2VfZW5jb2RpbmciLCJjb2VyY2VfdG8hIiwiaWR4IiwidmFsaWRfZW5jb2Rpbmc/Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUFBO0FBQUEsRUFFQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLElBQUMsMkNBQUQ7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxlQUFBQSx1QkFBQUEsb0JBQWtCLElBQUQsRUFBTyxPQUF4QkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBTkY7QUFNd0MsTUFBQSwyQ0FOeEM7QUFBQTtBQU0wQixNQUFBO0FBQUEsTUFBQSxZQUFVLFlBQUEsRUFBVjtBQUFBLE1BQUEsQ0FOMUI7QUFBQSxNQU9JRSxRQUFXQyxTQUFBLENBQUNDLElBQUQsQ0FBQUQsRUFBVSxjQUFBRSxPQUFBQyxPQUFBQSxDQUFRLFNBQVJBLENBQUEsU0FBcUIsRUFBckIsQ0FBVkgsQ0FQZjtBQUFBLE1BUUlJLFdBQVdDLE1BQUEscUJBQUFBLE9BQUFBLEVBQUFBLENBQVVQLElBQVZPLENBQUFBLEVBQWlCQyxnQkFBakJELENBQUFBLEtBQUFB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YXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBNYXRoXG4gIEUgID0gYE1hdGguRWBcbiAgUEkgPSBgTWF0aC5QSWBcblxuICBEb21haW5FcnJvciA9IENsYXNzLm5ldyhTdGFuZGFyZEVycm9yKVxuXG4gIGRlZiBzZWxmLmNoZWNrZWQobWV0aG9kLCAqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCAoYXJncy5sZW5ndGggPT0gMiAmJiBpc05hTihhcmdzWzFdKSkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IE1hdGhbbWV0aG9kXS5hcHBseShudWxsLCBhcmdzKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgI3tyYWlzZSBEb21haW5FcnJvciwgXCJOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFxcXCIje21ldGhvZH1cXFwiXCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmxvYXQhKHZhbHVlKVxuICAgIEZsb2F0KHZhbHVlKVxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIHJhaXNlIE9wYWwudHlwZV9lcnJvcih2YWx1ZSwgRmxvYXQpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmludGVnZXIhKHZhbHVlKVxuICAgIEludGVnZXIodmFsdWUpXG4gIHJlc2N1ZSBBcmd1bWVudEVycm9yXG4gICAgcmFpc2UgT3BhbC50eXBlX2Vycm9yKHZhbHVlLCBJbnRlZ2VyKVxuICBlbmRcblxuICBtb2R1bGVfZnVuY3Rpb25cblxuICBkZWYgYWNvcyh4KVxuICAgIE1hdGguY2hlY2tlZCA6YWNvcywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmFjb3NoYClcbiAgICAleHtcbiAgICAgIE1hdGguYWNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4IC0gMSkpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFjb3NoKHgpXG4gICAgTWF0aC5jaGVja2VkIDphY29zaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGFzaW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOmFzaW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5hc2luaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmFzaW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFzaW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDphc2luaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGF0YW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOmF0YW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBhdGFuMih5LCB4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbjIsIE1hdGguZmxvYXQhKHkpLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguYXRhbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC5hdGFuaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdGFuaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5jYnJ0YClcbiAgICAleHtcbiAgICAgIE1hdGguY2JydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC1NYXRoLmNicnQoLXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHIgID0geCxcbiAgICAgICAgICAgIGV4ID0gMDtcblxuICAgICAgICB3aGlsZSAociA8IDAuMTI1KSB7XG4gICAgICAgICAgciAqPSA4O1xuICAgICAgICAgIGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAociA+IDEuMCkge1xuICAgICAgICAgIHIgKj0gMC4xMjU7XG4gICAgICAgICAgZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAoLTAuNDY5NDYxMTYgKiByICsgMS4wNzIzMDIpICogciArIDAuMzgxMjUxMztcblxuICAgICAgICB3aGlsZSAoZXggPCAwKSB7XG4gICAgICAgICAgciAqPSAwLjU7XG4gICAgICAgICAgZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChleCA+IDApIHtcbiAgICAgICAgICByICo9IDI7XG4gICAgICAgICAgZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNicnQoeClcbiAgICBNYXRoLmNoZWNrZWQgOmNicnQsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBjb3MoeClcbiAgICBNYXRoLmNoZWNrZWQgOmNvcywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmNvc2hgKVxuICAgICV4e1xuICAgICAgTWF0aC5jb3NoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29zaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6Y29zaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmApXG4gICAgJXh7XG4gICAgICBPcGFsLmRlZmluZVByb3BlcnR5KE1hdGgsICdlcmYnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBBMSA9ICAwLjI1NDgyOTU5MixcbiAgICAgICAgICAgIEEyID0gLTAuMjg0NDk2NzM2LFxuICAgICAgICAgICAgQTMgPSAgMS40MjE0MTM3NDEsXG4gICAgICAgICAgICBBNCA9IC0xLjQ1MzE1MjAyNyxcbiAgICAgICAgICAgIEE1ID0gIDEuMDYxNDA1NDI5LFxuICAgICAgICAgICAgUCAgPSAgMC4zMjc1OTExO1xuXG4gICAgICAgIHZhciBzaWduID0gMTtcblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBNYXRoLmFicyh4KTtcblxuICAgICAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBQICogeCk7XG4gICAgICAgIHZhciB5ID0gMS4wIC0gKCgoKChBNSAqIHQgKyBBNCkgKiB0KSArIEEzKSAqIHQgKyBBMikgKiB0ICsgQTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB5O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXJmKHgpXG4gICAgTWF0aC5jaGVja2VkIDplcmYsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZjYClcbiAgICAleHtcbiAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoTWF0aCwgJ2VyZmMnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoeCksXG4gICAgICAgICAgICB0ID0gMS4wIC8gKDAuNSAqIHogKyAxLjApO1xuXG4gICAgICAgIHZhciBBMSA9IHQgKiAwLjE3MDg3Mjc3ICsgLTAuODIyMTUyMjMsXG4gICAgICAgICAgICBBMiA9IHQgKiBBMSArIDEuNDg4NTE1ODcsXG4gICAgICAgICAgICBBMyA9IHQgKiBBMiArIC0xLjEzNTIwMzk4LFxuICAgICAgICAgICAgQTQgPSB0ICogQTMgKyAwLjI3ODg2ODA3LFxuICAgICAgICAgICAgQTUgPSB0ICogQTQgKyAtMC4xODYyODgwNixcbiAgICAgICAgICAgIEE2ID0gdCAqIEE1ICsgMC4wOTY3ODQxOCxcbiAgICAgICAgICAgIEE3ID0gdCAqIEE2ICsgMC4zNzQwOTE5NixcbiAgICAgICAgICAgIEE4ID0gdCAqIEE3ICsgMS4wMDAwMjM2OCxcbiAgICAgICAgICAgIEE5ID0gdCAqIEE4LFxuICAgICAgICAgICAgQTEwID0gLXogKiB6IC0gMS4yNjU1MTIyMyArIEE5O1xuXG4gICAgICAgIHZhciBhID0gdCAqIE1hdGguZXhwKEExMCk7XG5cbiAgICAgICAgaWYgKHggPCAwLjApIHtcbiAgICAgICAgICByZXR1cm4gMi4wIC0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXJmYyh4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXJmYywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGV4cCh4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXhwLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgZnJleHAoeClcbiAgICB4ID0gTWF0aC5mbG9hdCEoeClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiBbTmFOLCAwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ICAgPSBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHgpKSAvIE1hdGgubG9nKDIpKSArIDEsXG4gICAgICAgICAgZnJhYyA9IHggLyBNYXRoLnBvdygyLCBleCk7XG5cbiAgICAgIHJldHVybiBbZnJhYywgZXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdhbW1hKG4pXG4gICAgbiA9IE1hdGguZmxvYXQhKG4pXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCB0LCB4LCB2YWx1ZSwgcmVzdWx0LCB0d29OLCB0aHJlZU4sIGZvdXJOLCBmaXZlTjtcblxuICAgICAgdmFyIEcgPSA0Ljc0MjE4NzU7XG5cbiAgICAgIHZhciBQID0gW1xuICAgICAgICAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MixcbiAgICAgICAgIDU3LjE1NjIzNTY2NTg2MjkyMzUxNyxcbiAgICAgICAgLTU5LjU5Nzk2MDM1NTQ3NTQ5MTI0OCxcbiAgICAgICAgIDE0LjEzNjA5Nzk3NDc0MTc0NzE3NCxcbiAgICAgICAgLTAuNDkxOTEzODE2MDk3NjIwMTk5NzgsXG4gICAgICAgICAwLjMzOTk0NjQ5OTg0ODExODg4Njk5ZS00LFxuICAgICAgICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCxcbiAgICAgICAgLTAuOTgzNzQ0NzUzMDQ4Nzk1NjQ2NzdlLTQsXG4gICAgICAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLFxuICAgICAgICAtMC4yMTAyNjQ0NDE3MjQxMDQ4ODMxOWUtMyxcbiAgICAgICAgIDAuMjE3NDM5NjE4MTE1MjEyNjQzMjBlLTMsXG4gICAgICAgIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxuICAgICAgICAgMC44NDQxODIyMzk4Mzg1Mjc0MzI5M2UtNCxcbiAgICAgICAgLTAuMjYxOTA4Mzg0MDE1ODE0MDg2NzBlLTQsXG4gICAgICAgICAwLjM2ODk5MTgyNjU5NTMxNjIyNzA0ZS01XG4gICAgICBdO1xuXG5cbiAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcbiAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IC0xIHx8IG4gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAje3JhaXNlIERvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImdhbW1hXCInfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7SW50ZWdlciA9PT0gbn0pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpc0Zpbml0ZShuKSA/IEluZmluaXR5IDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPiAxNzEpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAgPSBuIC0gMjtcbiAgICAgICAgcmVzdWx0ID0gbiAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMSkge1xuICAgICAgICAgIHJlc3VsdCAqPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PSAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDwgMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiBuKSAqICN7TWF0aC5nYW1tYSgxIC0gbil9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPj0gMTcxLjM1KSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPiA4NS4wKSB7XG4gICAgICAgIHR3b04gICA9IG4gKiBuO1xuICAgICAgICB0aHJlZU4gPSB0d29OICogbjtcbiAgICAgICAgZm91ck4gID0gdGhyZWVOICogbjtcbiAgICAgICAgZml2ZU4gID0gZm91ck4gKiBuO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkgLyBuKSAqIE1hdGgucG93KChuIC8gTWF0aC5FKSwgbikgKlxuICAgICAgICAgICgxICsgMSAvICgxMiAqIG4pICsgMSAvICgyODggKiB0d29OKSAtIDEzOSAvICg1MTg0MCAqIHRocmVlTikgLVxuICAgICAgICAgIDU3MSAvICgyNDg4MzIwICogZm91ck4pICsgMTYzODc5IC8gKDIwOTAxODg4MCAqIGZpdmVOKSArXG4gICAgICAgICAgNTI0NjgxOSAvICg3NTI0Njc5NjgwMCAqIGZpdmVOICogbikpO1xuICAgICAgfVxuXG4gICAgICBuIC09IDE7XG4gICAgICB4ICA9IFBbMF07XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBQLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHggKz0gUFtpXSAvIChuICsgaSk7XG4gICAgICB9XG5cbiAgICAgIHQgPSBuICsgRyArIDAuNTtcblxuICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSkgKiBNYXRoLnBvdyh0LCBuICsgMC41KSAqIE1hdGguZXhwKC10KSAqIHg7XG4gICAgfVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguaHlwb3RgKVxuICAgICV4e1xuICAgICAgTWF0aC5oeXBvdCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGh5cG90KHgsIHkpXG4gICAgTWF0aC5jaGVja2VkIDpoeXBvdCwgTWF0aC5mbG9hdCEoeCksIE1hdGguZmxvYXQhKHkpXG4gIGVuZFxuXG4gIGRlZiBsZGV4cChtYW50aXNzYSwgZXhwb25lbnQpXG4gICAgbWFudGlzc2EgPSBNYXRoLmZsb2F0IShtYW50aXNzYSlcbiAgICBleHBvbmVudCA9IE1hdGguaW50ZWdlciEoZXhwb25lbnQpXG5cbiAgICAleHtcbiAgICAgIGlmIChpc05hTihleHBvbmVudCkpIHtcbiAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAnZmxvYXQgTmFOIG91dCBvZiByYW5nZSBvZiBpbnRlZ2VyJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZ2FtbWEobilcbiAgICAleHtcbiAgICAgIGlmIChuID09IC0xKSB7XG4gICAgICAgIHJldHVybiBbSW5maW5pdHksIDFdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5sb2coTWF0aC5hYnMoI3tNYXRoLmdhbW1hKG4pfSkpLCAje01hdGguZ2FtbWEobil9IDwgMCA/IC0xIDogMV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbG9nKHgsIGJhc2UgPSB1bmRlZmluZWQpXG4gICAgaWYgU3RyaW5nID09PSB4XG4gICAgICByYWlzZSBPcGFsLnR5cGVfZXJyb3IoeCwgRmxvYXQpXG4gICAgZW5kXG5cbiAgICBpZiBgYmFzZSA9PSBudWxsYFxuICAgICAgTWF0aC5jaGVja2VkIDpsb2csIE1hdGguZmxvYXQhKHgpXG4gICAgZWxzZVxuICAgICAgaWYgU3RyaW5nID09PSBiYXNlXG4gICAgICAgIHJhaXNlIE9wYWwudHlwZV9lcnJvcihiYXNlLCBGbG9hdClcbiAgICAgIGVuZFxuXG4gICAgICBNYXRoLmNoZWNrZWQoOmxvZywgTWF0aC5mbG9hdCEoeCkpIC8gTWF0aC5jaGVja2VkKDpsb2csIE1hdGguZmxvYXQhKGJhc2UpKVxuICAgIGVuZFxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMTBgKVxuICAgICV4e1xuICAgICAgTWF0aC5sb2cxMCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzEwKHgpXG4gICAgaWYgU3RyaW5nID09PSB4XG4gICAgICByYWlzZSBPcGFsLnR5cGVfZXJyb3IoeCwgRmxvYXQpXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOmxvZzEwLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMmApXG4gICAgJXh7XG4gICAgICBNYXRoLmxvZzIgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzIoeClcbiAgICBpZiBTdHJpbmcgPT09IHhcbiAgICAgIHJhaXNlIE9wYWwudHlwZV9lcnJvcih4LCBGbG9hdClcbiAgICBlbmRcblxuICAgIE1hdGguY2hlY2tlZCA6bG9nMiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHNpbih4KVxuICAgIE1hdGguY2hlY2tlZCA6c2luLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguc2luaGApXG4gICAgJXh7XG4gICAgICBNYXRoLnNpbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDpzaW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgc3FydCh4KVxuICAgIE1hdGguY2hlY2tlZCA6c3FydCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHRhbih4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgaWYgeC5pbmZpbml0ZT9cbiAgICAgIHJldHVybiBGbG9hdDo6TkFOXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOnRhbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLnRhbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC50YW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRhbmgoeClcbiAgICBNYXRoLmNoZWNrZWQgOnRhbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwibmV3IiwiY2hlY2tlZCIsInNlbGYiLCJyYWlzZSIsIm1ldGhvZCIsImZsb2F0ISIsIkZsb2F0IiwidmFsdWUiLCJ0eXBlX2Vycm9yIiwiaW50ZWdlciEiLCJJbnRlZ2VyIiwibW9kdWxlX2Z1bmN0aW9uIiwiYWNvcyIsIngiLCJhY29zaCIsImFzaW4iLCJhc2luaCIsImF0YW4iLCJhdGFuMiIsInkiLCJhdGFuaCIsImNicnQiLCJjb3MiLCJjb3NoIiwiZXJmIiwiZXJmYyIsImV4cCIsImZyZXhwIiwiZ2FtbWEiLCJuIiwiPT09IiwiLSIsIjEiLCJoeXBvdCIsImxkZXhwIiwibWFudGlzc2EiLCJleHBvbmVudCIsImxnYW1tYSIsImxvZyIsImJhc2UiLCIvIiwibG9nMTAiLCJsb2cyIiwic2luIiwic2luaCIsInNxcnQiLCJ0YW4iLCJpbmZpbml0ZT8iLCJ0YW5oIl0s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LENBQUFBLDBCQUFBQSxDQW5iQTtBQUFBLElBNmJBLElBQUEsUUFBTyxRQUFVLFNBQVYsa0JBQVAsQ0FBQTtBQUFBLElBQUE7QUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJFLElBQUEsQ0E3YkE7QUFBQTtBQTZjQUUsSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBUyxDQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLG9CQUFBL0MsU0FBQUEsQ0FBYSxRQUFPLG9CQUFBSSxXQUFBQSxDQUFZUSxDQUFaUixDQUFwQko7QUFERitDLElBQUFBLENBQUFBLDJCQUFBQSxDQTdjQTtBQURGakQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTUwNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29tcGxleC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIENvbXBsZXggPCBOdW1lcmljXG4gIGRlZiBzZWxmLnJlY3QocmVhbCwgaW1hZyA9IDApXG4gICAgdW5sZXNzIE51bWVyaWMgPT09IHJlYWwgJiYgcmVhbC5yZWFsPyAmJiBOdW1lcmljID09PSBpbWFnICYmIGltYWcucmVhbD9cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhIHJlYWwnXG4gICAgZW5kXG5cbiAgICBuZXcocmVhbCwgaW1hZylcbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcbiAgZW5kXG5cbiAgZGVmIHNlbGYucG9sYXIociwgdGhldGEgPSAwKVxuICAgIHVubGVzcyBOdW1lcmljID09PSByICYmIHIucmVhbD8gJiYgTnVtZXJpYyA9PT0gdGhldGEgJiYgdGhldGEucmVhbD9cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhIHJlYWwnXG4gICAgZW5kXG5cbiAgICBuZXcociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSlcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOnJlYWwsIDppbWFnXG5cbiAgZGVmIGluaXRpYWxpemUocmVhbCwgaW1hZyA9IDApXG4gICAgQHJlYWwgPSByZWFsXG4gICAgQGltYWcgPSBpbWFnXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIFtvdGhlciwgc2VsZl1cbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgW0NvbXBsZXgubmV3KG90aGVyLCAwKSwgc2VsZl1cbiAgICBlbHNlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIENvbXBsZXhcIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIEByZWFsID09IG90aGVyLnJlYWwgJiYgQGltYWcgPT0gb3RoZXIuaW1hZ1xuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBAcmVhbCA9PSBvdGhlciAmJiBAaW1hZyA9PSAwXG4gICAgZWxzZVxuICAgICAgb3RoZXIgPT0gc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBDb21wbGV4KC1AcmVhbCwgLUBpbWFnKVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgQ29tcGxleChAcmVhbCArIG90aGVyLnJlYWwsIEBpbWFnICsgb3RoZXIuaW1hZylcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbCArIG90aGVyLCBAaW1hZylcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIENvbXBsZXgoQHJlYWwgLSBvdGhlci5yZWFsLCBAaW1hZyAtIG90aGVyLmltYWcpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIENvbXBsZXgoQHJlYWwgLSBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBDb21wbGV4KEByZWFsICogb3RoZXIucmVhbCAtIEBpbWFnICogb3RoZXIuaW1hZyxcbiAgICAgICAgQHJlYWwgKiBvdGhlci5pbWFnICsgQGltYWcgKiBvdGhlci5yZWFsLFxuICAgICAgKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsICogb3RoZXIsIEBpbWFnICogb3RoZXIpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBpZiAoTnVtYmVyID09PSBAcmVhbCAmJiBAcmVhbC5uYW4/KSB8fCAoTnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fFxuICAgICAgICAgKE51bWJlciA9PT0gb3RoZXIucmVhbCAmJiBvdGhlci5yZWFsLm5hbj8pIHx8IChOdW1iZXIgPT09IG90aGVyLmltYWcgJiYgb3RoZXIuaW1hZy5uYW4/KVxuICAgICAgICBDb21wbGV4Lm5ldyhGbG9hdDo6TkFOLCBGbG9hdDo6TkFOKVxuICAgICAgZWxzZVxuICAgICAgICBzZWxmICogb3RoZXIuY29uaiAvIG90aGVyLmFiczJcbiAgICAgIGVuZFxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsLnF1byhvdGhlciksIEBpbWFnLnF1byhvdGhlcikpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBpZiBvdGhlciA9PSAwXG4gICAgICByZXR1cm4gQ29tcGxleC5uZXcoMSwgMClcbiAgICBlbmRcblxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXG4gICAgICBvcmUgICAgICA9IG90aGVyLnJlYWxcbiAgICAgIG9pbSAgICAgID0gb3RoZXIuaW1hZ1xuICAgICAgbnIgICAgICAgPSBNYXRoLmV4cChvcmUgKiBNYXRoLmxvZyhyKSAtIG9pbSAqIHRoZXRhKVxuICAgICAgbnRoZXRhICAgPSB0aGV0YSAqIG9yZSArIG9pbSAqIE1hdGgubG9nKHIpXG5cbiAgICAgIENvbXBsZXgucG9sYXIobnIsIG50aGV0YSlcbiAgICBlbHNpZiBJbnRlZ2VyID09PSBvdGhlclxuICAgICAgaWYgb3RoZXIgPiAwXG4gICAgICAgIHggPSBzZWxmXG4gICAgICAgIHogPSB4XG4gICAgICAgIG4gPSBvdGhlciAtIDFcblxuICAgICAgICB3aGlsZSBuICE9IDBcbiAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgd2hpbGUgbW9kID09IDBcbiAgICAgICAgICAgIHggPSBDb21wbGV4KHgucmVhbCAqIHgucmVhbCAtIHguaW1hZyAqIHguaW1hZywgMiAqIHgucmVhbCAqIHguaW1hZylcbiAgICAgICAgICAgIG4gPSBkaXZcbiAgICAgICAgICAgIGRpdiwgbW9kID0gbi5kaXZtb2QoMilcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHogKj0geFxuICAgICAgICAgIG4gLT0gMVxuICAgICAgICBlbmRcblxuICAgICAgICB6XG4gICAgICBlbHNlXG4gICAgICAgIChSYXRpb25hbC5uZXcoMSwgMSkgLyBzZWxmKSoqLW90aGVyXG4gICAgICBlbmRcbiAgICBlbHNpZiBGbG9hdCA9PT0gb3RoZXIgfHwgUmF0aW9uYWwgPT09IG90aGVyXG4gICAgICByLCB0aGV0YSA9IHBvbGFyXG5cbiAgICAgIENvbXBsZXgucG9sYXIocioqb3RoZXIsIHRoZXRhICogb3RoZXIpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgTWF0aC5oeXBvdChAcmVhbCwgQGltYWcpXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgQHJlYWwgKiBAcmVhbCArIEBpbWFnICogQGltYWdcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgTWF0aC5hdGFuMihAaW1hZywgQHJlYWwpXG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuXG4gIGRlZiBjb25qXG4gICAgQ29tcGxleChAcmVhbCwgLUBpbWFnKVxuICBlbmRcblxuICBhbGlhcyBjb25qdWdhdGUgY29ualxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIEByZWFsLmRlbm9taW5hdG9yLmxjbShAaW1hZy5kZW5vbWluYXRvcilcbiAgZW5kXG5cbiAgYWxpYXMgZGl2aWRlIC9cblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBDb21wbGV4ID09PSBvdGhlciAmJiBAcmVhbC5jbGFzcyA9PSBAaW1hZy5jbGFzcyAmJiBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHVubGVzcyBOdW1lcmljID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcblxuICAgIHNlbGYgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIEByZWFsLmZpbml0ZT8gJiYgQGltYWcuZmluaXRlP1xuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFwiQ29tcGxleDoje0ByZWFsfToje0BpbWFnfVwiXG4gIGVuZFxuXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIEByZWFsLmluZmluaXRlPyB8fCBAaW1hZy5pbmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIigje3NlbGZ9KVwiXG4gIGVuZFxuXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcblxuICB1bmRlZiBuZWdhdGl2ZT9cblxuICBkZWYgbnVtZXJhdG9yXG4gICAgZCA9IGRlbm9taW5hdG9yXG5cbiAgICBDb21wbGV4KEByZWFsLm51bWVyYXRvciAqIChkIC8gQHJlYWwuZGVub21pbmF0b3IpLFxuICAgICAgQGltYWcubnVtZXJhdG9yICogKGQgLyBAaW1hZy5kZW5vbWluYXRvciksXG4gICAgKVxuICBlbmRcblxuICBhbGlhcyBwaGFzZSBhcmdcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIHVuZGVmIHBvc2l0aXZlP1xuXG4gIGFsaWFzIHF1byAvXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBAaW1hZyAhPSAwXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcImNhbid0JyBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICByZWFsLnJhdGlvbmFsaXplKGVwcylcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHJlY3RcbiAgICBbQHJlYWwsIEBpbWFnXVxuICBlbmRcblxuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgZGVmIHRvX2ZcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBGbG9hdFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19mXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgdW5sZXNzIEBpbWFnID09IDBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19pXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgdW5sZXNzIEBpbWFnID09IDBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgQHJlYWwudG9fclxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIHJlc3VsdCA9IEByZWFsLmluc3BlY3RcblxuICAgIHJlc3VsdCArPVxuICAgICAgaWYgKE51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHwgQGltYWcucG9zaXRpdmU/IHx8IEBpbWFnLnplcm8/XG4gICAgICAgICcrJ1xuICAgICAgZWxzZVxuICAgICAgICAnLSdcbiAgICAgIGVuZFxuXG4gICAgcmVzdWx0ICs9IEBpbWFnLmFicy5pbnNwZWN0XG5cbiAgICBpZiBOdW1iZXIgPT09IEBpbWFnICYmIChAaW1hZy5uYW4/IHx8IEBpbWFnLmluZmluaXRlPylcbiAgICAgIHJlc3VsdCArPSAnKidcbiAgICBlbmRcblxuICAgIHJlc3VsdCArICdpJ1xuICBlbmRcblxuICBJID0gbmV3KDAsIDEpXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgQ29tcGxleChyZWFsLCBpbWFnID0gbmlsKVxuICAgIGlmIGltYWdcbiAgICAgIENvbXBsZXgubmV3KHJlYWwsIGltYWcpXG4gICAgZWxzZVxuICAgICAgQ29tcGxleC5uZXcocmVhbCwgMClcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gIGRlZiB0b19jXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZixcbiAgICAgICAgICByZSA9IC9bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/KGVcXGQrKT8vLFxuICAgICAgICAgIG1hdGNoID0gc3RyLm1hdGNoKHJlKSxcbiAgICAgICAgICByZWFsLCBpbWFnLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGVzIGJvdGggZmxvYXRzIGFuZCByYXRpb25hbHNcbiAgICAgIGZ1bmN0aW9uIGN1dE51bWJlcigpIHtcbiAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuXG4gICAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgICByZXR1cm4gI3tSYXRpb25hbChgbnVtZXJhdG9yYCwgYGRlbm9taW5hdG9yYCl9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmV2ZXJ0aW5nICcvJ1xuICAgICAgICAgICAgICBzdHIgPSAnLycgKyBzdHI7XG4gICAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IHJlYWwgcGFydCwgbm8gZGVub21pbmF0b3JcbiAgICAgICAgICAgIHJldHVybiBudW1lcmF0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlYWwgPSBjdXROdW1iZXIoKTtcblxuICAgICAgaWYgKCFyZWFsKSB7XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICdpJykge1xuICAgICAgICAgIC8vIGkgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICctJyAmJiBzdHJbMV0gPT09ICdpJykge1xuICAgICAgICAgIC8vIC1pID0+IENvbXBsZXgoMCwgLTEpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAtMSl9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcrJyAmJiBzdHJbMV0gPT09ICdpJykge1xuICAgICAgICAgIC8vICtpID0+IENvbXBsZXgoMCwgMSlcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbnl0aGluZyA9PiBDb21wbGV4KDAsIDApXG4gICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgMCl9O1xuICAgICAgfVxuXG4gICAgICBpbWFnID0gY3V0TnVtYmVyKCk7XG4gICAgICBpZiAoIWltYWcpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gM2kgPT4gQ29tcGxleCgwLCAzKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgYHJlYWxgKX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gMyA9PiBDb21wbGV4KDMsIDApXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleChgcmVhbGAsIDApfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMysyaSA9PiBDb21wbGV4KDMsIDIpXG4gICAgICAgIHJldHVybiAje0NvbXBsZXgoYHJlYWxgLCBgaW1hZ2ApfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwicmVjdCIsInNlbGYiLCIwIiwiPT09IiwicmVhbCIsInJlYWw/IiwiaW1hZyIsInJhaXNlIiwibmV3IiwicG9sYXIiLCJyIiwidGhldGEiLCIqIiwiY29zIiwic2luIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlYWwiLCJAaW1hZyIsImNvZXJjZSIsIm90aGVyIiwiPT0iLCItQCIsIkNvbXBsZXgiLCIrIiwiX19jb2VyY2VkX18iLCItIiwiLyIsIm5hbj8iLCJjb25qIiwiYWJzMiIsInF1byIsIioqIiwiMSIsIm9yZSIsIm9pbSIsIm5yIiwiZXhwIiwibG9nIiwibnRoZXRhIiwiPiIsIngiLCJ6IiwibiIsIiE9IiwiZGl2bW9kIiwiMiIsImRpdiIsIm1vZCIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsImZkaXYiLCJmaW5pdGU/IiwiaGFzaCIsImluZmluaXRlPyIsImluc3BlY3QiLCJudW1lcmF0b3IiLCJkIiwiYXJnIiwicmF0aW9uYWxpemUiLCJlcHMiLCJ0b19mIiwidG9faSIsInRvX3IiLCJ0b19zIiwicmVzdWx0IiwicG9zaXRpdmU/IiwiemVybz8iLCJtb2R1bGUiLCJ0b19jIiwiUmF0aW9uYWwiLCItMSJdLCJtYXBwaW5ncyI6Ijs7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXVCQyxVQUFBQSxDQUFVLFdBQWEsV0FBdkJBLENBQXFDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFtQnBELFNBQUFBLENBQVFyQixHQUFHK0IsQ0FBWFYsQ0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQSxxQkFBbUJBLFNBQUFBLENBQVFyQixHQUFHMEUsRUFBWHJELENBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0EscUJBQW1CQSxTQUFBQSxDQUFRckIsR0FBRytCLENBQVhWLENBQWM7QUFDakM7QUFDQTtBQUNBLG1CQUFpQkEsU0FBQUEsQ0FBUXJCLEdBQUdBLENBQVhxQixDQUFjO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW1CQSxTQUFBQSxDQUFRckIsR0FBSSxJQUFacUIsQ0FBbUI7QUFDdEM7QUFDQTtBQUNBLHFCQUFtQkEsU0FBQUEsQ0FBUyxNQUFPckIsQ0FBaEJxQixDQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxtQkFBaUJBLFNBQUFBLENBQVMsTUFBUSxJQUFqQkEsQ0FBd0I7QUFDekM7QUFDQTtBQTVFRW1ELElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQTtBQURGM0UsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0EvU0E7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTk5MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBSYXRpb25hbCA8IE51bWVyaWNcbiAgZGVmIHNlbGYucmVkdWNlKG51bSwgZGVuKVxuICAgIG51bSA9IG51bS50b19pXG4gICAgZGVuID0gZGVuLnRvX2lcblxuICAgIGlmIGRlbiA9PSAwXG4gICAgICByYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICBlbHNpZiBkZW4gPCAwXG4gICAgICBudW0gPSAtbnVtXG4gICAgICBkZW4gPSAtZGVuXG4gICAgZWxzaWYgZGVuID09IDFcbiAgICAgIHJldHVybiBuZXcobnVtLCBkZW4pXG4gICAgZW5kXG5cbiAgICBnY2QgPSBudW0uZ2NkKGRlbilcblxuICAgIG5ldyhudW0gLyBnY2QsIGRlbiAvIGdjZClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29udmVydChudW0sIGRlbilcbiAgICBpZiBudW0ubmlsPyB8fCBkZW4ubmlsP1xuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgbmlsIGludG8gUmF0aW9uYWwnXG4gICAgZW5kXG5cbiAgICBpZiBJbnRlZ2VyID09PSBudW0gJiYgSW50ZWdlciA9PT0gZGVuXG4gICAgICByZXR1cm4gcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgaWYgRmxvYXQgPT09IG51bSB8fCBTdHJpbmcgPT09IG51bSB8fCBDb21wbGV4ID09PSBudW1cbiAgICAgIG51bSA9IG51bS50b19yXG4gICAgZW5kXG5cbiAgICBpZiBGbG9hdCA9PT0gZGVuIHx8IFN0cmluZyA9PT0gZGVuIHx8IENvbXBsZXggPT09IGRlblxuICAgICAgZGVuID0gZGVuLnRvX3JcbiAgICBlbmRcblxuICAgIGlmIGRlbi5lcXVhbD8oMSkgJiYgIShJbnRlZ2VyID09PSBudW0pXG4gICAgICBPcGFsLmNvZXJjZV90byEobnVtLCBSYXRpb25hbCwgOnRvX3IpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gbnVtICYmIE51bWVyaWMgPT09IGRlblxuICAgICAgbnVtIC8gZGVuXG4gICAgZWxzZVxuICAgICAgcmVkdWNlKG51bSwgZGVuKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShudW0sIGRlbilcbiAgICBAbnVtID0gbnVtXG4gICAgQGRlbiA9IGRlblxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgQG51bVxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAZGVuXG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIFtvdGhlciwgc2VsZl1cblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgW290aGVyLnRvX3IsIHNlbGZdXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICBbb3RoZXIsIHRvX2ZdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgQG51bSA9PSBvdGhlci5udW1lcmF0b3IgJiYgQGRlbiA9PSBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBAbnVtID09IG90aGVyICYmIEBkZW4gPT0gMVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiA9PSBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgb3RoZXIgPT0gc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yIDw9PiAwXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIEBudW0gLSBAZGVuICogb3RoZXIgPD0+IDBcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgPD0+IG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6PD0+LCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yICsgQGRlbiAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBSYXRpb25hbChAbnVtICsgb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiArIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciAtIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgUmF0aW9uYWwoQG51bSAtIG90aGVyICogQGRlbiwgQGRlbilcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgLSBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi0sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFJhdGlvbmFsKEBudW0gKiBvdGhlciwgQGRlbilcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgKiBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5udW1lcmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgdG9fZiAvIDAuMFxuICAgICAgZWxzZVxuICAgICAgICBSYXRpb25hbChAbnVtLCBAZGVuICogb3RoZXIpXG4gICAgICBlbmRcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgLyBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOi8sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIEZsb2F0OjpJTkZJTklUWVxuICAgICAgZWxzaWYgb3RoZXIgPiAwXG4gICAgICAgIFJhdGlvbmFsKEBudW0qKm90aGVyLCBAZGVuKipvdGhlcilcbiAgICAgIGVsc2lmIG90aGVyIDwgMFxuICAgICAgICBSYXRpb25hbChAZGVuKiotb3RoZXIsIEBudW0qKi1vdGhlcilcbiAgICAgIGVsc2VcbiAgICAgICAgUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVuZFxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZioqb3RoZXJcblxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIGlmIG90aGVyID09IDBcbiAgICAgICAgUmF0aW9uYWwoMSwgMSlcbiAgICAgIGVsc2lmIG90aGVyLmRlbm9taW5hdG9yID09IDFcbiAgICAgICAgaWYgb3RoZXIgPCAwXG4gICAgICAgICAgUmF0aW9uYWwoQGRlbioqb3RoZXIubnVtZXJhdG9yLmFicywgQG51bSoqb3RoZXIubnVtZXJhdG9yLmFicylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJhdGlvbmFsKEBudW0qKm90aGVyLm51bWVyYXRvciwgQGRlbioqb3RoZXIubnVtZXJhdG9yKVxuICAgICAgICBlbmRcbiAgICAgIGVsc2lmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcbiAgICAgICAgcmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgICBlbHNlXG4gICAgICAgIHRvX2YqKm90aGVyXG4gICAgICBlbmRcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIFJhdGlvbmFsKEBudW0uYWJzLCBAZGVuLmFicylcbiAgZW5kXG5cbiAgZGVmIGNlaWwocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuY2VpbFxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpjZWlsLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIGRpdmlkZSAvXG5cbiAgZGVmIGZsb29yKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgICgtKC1AbnVtIC8gQGRlbikpLmZsb29yXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmZsb29yLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgXCJSYXRpb25hbDoje0BudW19OiN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiKCN7c2VsZn0pXCJcbiAgZW5kXG5cbiAgYWxpYXMgcXVvIC9cblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXBzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0gI3tlcHMuYWJzfSxcbiAgICAgICAgICBhID0gI3tzZWxmIC0gYGVgfSxcbiAgICAgICAgICBiID0gI3tzZWxmICsgYGVgfTtcblxuICAgICAgdmFyIHAwID0gMCxcbiAgICAgICAgICBwMSA9IDEsXG4gICAgICAgICAgcTAgPSAxLFxuICAgICAgICAgIHExID0gMCxcbiAgICAgICAgICBwMiwgcTI7XG5cbiAgICAgIHZhciBjLCBrLCB0O1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjID0gI3tgYWAuY2VpbH07XG5cbiAgICAgICAgaWYgKCN7YGNgIDw9IGBiYH0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGsgID0gYyAtIDE7XG4gICAgICAgIHAyID0gayAqIHAxICsgcDA7XG4gICAgICAgIHEyID0gayAqIHExICsgcTA7XG4gICAgICAgIHQgID0gI3sxIC8gKGBiYCAtIGBrYCl9O1xuICAgICAgICBiICA9ICN7MSAvIChgYWAgLSBga2ApfTtcbiAgICAgICAgYSAgPSB0O1xuXG4gICAgICAgIHAwID0gcDE7XG4gICAgICAgIHEwID0gcTE7XG4gICAgICAgIHAxID0gcDI7XG4gICAgICAgIHExID0gcTI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje1JhdGlvbmFsKGBjICogcDEgKyBwMGAsIGBjICogcTEgKyBxMGApfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3VuZChwcmVjaXNpb24gPSAwKVxuICAgIHJldHVybiB3aXRoX3ByZWNpc2lvbig6cm91bmQsIHByZWNpc2lvbikgdW5sZXNzIHByZWNpc2lvbiA9PSAwXG4gICAgcmV0dXJuIDAgaWYgQG51bSA9PSAwXG4gICAgcmV0dXJuIEBudW0gaWYgQGRlbiA9PSAxXG5cbiAgICBudW0gPSBAbnVtLmFicyAqIDIgKyBAZGVuXG4gICAgZGVuID0gQGRlbiAqIDJcblxuICAgIGFwcHJveCA9IChudW0gLyBkZW4pLnRydW5jYXRlXG5cbiAgICBpZiBAbnVtIDwgMFxuICAgICAgLWFwcHJveFxuICAgIGVsc2VcbiAgICAgIGFwcHJveFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIEBudW0gLyBAZGVuXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgdHJ1bmNhdGVcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIje0BudW19LyN7QGRlbn1cIlxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgQG51bSA8IDAgPyBjZWlsIDogZmxvb3JcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6dHJ1bmNhdGUsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHdpdGhfcHJlY2lzaW9uKG1ldGhvZCwgcHJlY2lzaW9uKVxuICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBJbnRlZ2VyJyB1bmxlc3MgSW50ZWdlciA9PT0gcHJlY2lzaW9uXG5cbiAgICBwID0gMTAqKnByZWNpc2lvblxuICAgIHMgPSBzZWxmICogcFxuXG4gICAgaWYgcHJlY2lzaW9uIDwgMVxuICAgICAgKHMuc2VuZChtZXRob2QpIC8gcCkudG9faVxuICAgIGVsc2VcbiAgICAgIFJhdGlvbmFsKHMuc2VuZChtZXRob2QpLCBwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBSYXRpb25hbChudW1lcmF0b3IsIGRlbm9taW5hdG9yID0gMSlcbiAgICBSYXRpb25hbC5jb252ZXJ0KG51bWVyYXRvciwgZGVub21pbmF0b3IpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICBkZWYgdG9fclxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGYudHJpbUxlZnQoKSxcbiAgICAgICAgICByZSA9IC9eWystXT9bXFxkX10rKFxcLltcXGRfXSspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG5cbiAgICAgIGZ1bmN0aW9uIGlzRmxvYXQoKSB7XG4gICAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1dEZsb2F0KCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmUpO1xuICAgICAgICB2YXIgbnVtYmVyID0gbWF0Y2hbMF07XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShudW1iZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG51bWJlci5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICBudW1lcmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuXG4gICAgICAgIGlmIChzdHJbMF0gPT09ICcvJykge1xuICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcbiAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCAxKX07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAje1JhdGlvbmFsKDAsIDEpfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwicmVkdWNlIiwic2VsZiIsIm51bSIsInRvX2kiLCJkZW4iLCI9PSIsIjAiLCJyYWlzZSIsIjwiLCItQCIsIjEiLCJuZXciLCJnY2QiLCIvIiwiY29udmVydCIsIm5pbD8iLCI9PT0iLCJ0b19yIiwiZXF1YWw/IiwiISIsImNvZXJjZV90byEiLCJpbml0aWFsaXplIiwiQG51bSIsIkBkZW4iLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImNvZXJjZSIsIm90aGVyIiwidG9fZiIsIjw9PiIsIi0iLCIqIiwiX19jb2VyY2VkX18iLCIrIiwiUmF0aW9uYWwiLCIqKiIsIj4iLCJhYnMiLCJjZWlsIiwicHJlY2lzaW9uIiwid2l0aF9wcmVjaXNpb24iLCJmbG9vciIsImhhc2giLCJpbnNwZWN0IiwicmF0aW9uYWxpemUiLCJlcHMiLCI8PSIsInJvdW5kIiwiMiIsImFwcHJveCIsInRydW5jYXRlIiwidG9fcyIsInAiLCIxMCIsInMiLCJzZW5kIiwibWV0aG9kIiwibW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUFBO0FBQUEsRUFFQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLElBQUFDLFVBQUlDLElBQUpELGFBQUFBLHFCQUFBQSxrQkFBZ0IsR0FBRCxFQUFNLEdBQXJCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBRSxNQUFNQSxHQUFBQyxNQUFBQSxDQUFBQSxDQUFOO0FBQUEsTUFDQUMsTUFBTUEsR0FBQUQsTUFBQUEsQ0FBQUEsQ0FETjtBQUFBLE1BR0EsSUFBR0MsR0FBQUMsT0FBQUEsQ0FBT0MsQ0FBUEQsQ0FBSDtBQUFBLFlBQ0VFLE9BQUFBLENBQU0sbUNBQW1CLGNB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LFVBQUFBLENBQVM1QixHQUFHSSxDQUFad0IsQ0FBZTtBQUNoQztBQUNBO0FBckNFakIsSUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBO0FBREZsQixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQXhXQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwNDUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi90aW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgVGltZSA8IGBEYXRlYFxuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICAleHtcbiAgICB2YXIgZGF5c19vZl93ZWVrID0gI3sld1tTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheSBTdW5kYXldfSxcbiAgICAgICAgc2hvcnRfZGF5cyAgID0gI3sld1tTdW4gTW9uIFR1ZSBXZWQgVGh1IEZyaSBTYXRdfSxcbiAgICAgICAgc2hvcnRfbW9udGhzID0gI3sld1tKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlY119LFxuICAgICAgICBsb25nX21vbnRocyAgPSAjeyV3W0phbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJdfTtcbiAgfVxuXG4gIGRlZiBzZWxmLmF0KHNlY29uZHMsIGZyYWMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoI3tUaW1lID09PSBzZWNvbmRzfSkge1xuICAgICAgICBpZiAoZnJhYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBUaW1lIGludG8gYW4gZXhhY3QgbnVtYmVyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbmV3IERhdGUoc2Vjb25kcy5nZXRUaW1lKCkpO1xuICAgICAgICByZXN1bHQuaXNfdXRjID0gc2Vjb25kcy5pc191dGM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2Vjb25kcy4kJGlzX251bWJlcikge1xuICAgICAgICBzZWNvbmRzID0gI3tPcGFsLmNvZXJjZV90byEoc2Vjb25kcywgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJhYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShzZWNvbmRzICogMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZnJhYy4kJGlzX251bWJlcikge1xuICAgICAgICBmcmFjID0gI3tPcGFsLmNvZXJjZV90byEoZnJhYywgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDAgKyAoZnJhYyAvIDEwMDApKTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XG4gICAgICBpZiAoeWVhci4kJGlzX3N0cmluZykge1xuICAgICAgICB5ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhciA9ICN7T3BhbC5jb2VyY2VfdG8hKGB5ZWFyYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPT09IG5pbCkge1xuICAgICAgICBtb250aCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFtb250aC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoI3tgbW9udGhgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgIG1vbnRoID0gI3tgbW9udGhgLnRvX3N0cn07XG4gICAgICAgICAgc3dpdGNoIChtb250aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnamFuJzogbW9udGggPSAgMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZmViJzogbW9udGggPSAgMjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWFyJzogbW9udGggPSAgMzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXByJzogbW9udGggPSAgNDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF5JzogbW9udGggPSAgNTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVuJzogbW9udGggPSAgNjsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnanVsJzogbW9udGggPSAgNzsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXVnJzogbW9udGggPSAgODsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2VwJzogbW9udGggPSAgOTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb2N0JzogbW9udGggPSAxMDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbm92JzogbW9udGggPSAxMTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVjJzogbW9udGggPSAxMjsgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogbW9udGggPSAje2Btb250aGAudG9faX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vbnRoID0gI3tPcGFsLmNvZXJjZV90byEoYG1vbnRoYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibW9udGggb3V0IG9mIHJhbmdlOiAje2Btb250aGB9XCJ9XG4gICAgICB9XG4gICAgICBtb250aCA9IG1vbnRoIC0gMTtcblxuICAgICAgaWYgKGRheSA9PT0gbmlsKSB7XG4gICAgICAgIGRheSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGRheS4kJGlzX3N0cmluZykge1xuICAgICAgICBkYXkgPSBwYXJzZUludChkYXksIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRheSA9ICN7T3BhbC5jb2VyY2VfdG8hKGBkYXlgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXkgPCAxIHx8IGRheSA+IDMxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJkYXkgb3V0IG9mIHJhbmdlOiAje2BkYXlgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA9PT0gbmlsKSB7XG4gICAgICAgIGhvdXIgPSAwO1xuICAgICAgfSBlbHNlIGlmIChob3VyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3VyID0gI3tPcGFsLmNvZXJjZV90byEoYGhvdXJgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChob3VyIDwgMCB8fCBob3VyID4gMjQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImhvdXIgb3V0IG9mIHJhbmdlOiAje2Bob3VyYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA9PT0gbmlsKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1pbi4kJGlzX3N0cmluZykge1xuICAgICAgICBtaW4gPSBwYXJzZUludChtaW4sIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbiA9ICN7T3BhbC5jb2VyY2VfdG8hKGBtaW5gLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPCAwIHx8IG1pbiA+IDU5KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJtaW4gb3V0IG9mIHJhbmdlOiAje2BtaW5gfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjID09PSBuaWwpIHtcbiAgICAgICAgc2VjID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoIXNlYy4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoc2VjLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgc2VjID0gcGFyc2VJbnQoc2VjLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VjID0gI3tPcGFsLmNvZXJjZV90byEoYHNlY2AsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VjIDwgMCB8fCBzZWMgPiA2MCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwic2VjIG91dCBvZiByYW5nZTogI3tgc2VjYH1cIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlY107XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYubmV3KHllYXIgPSB1bmRlZmluZWQsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCB1dGNfb2Zmc2V0ID0gbmlsKVxuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0Y19vZmZzZXQgIT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdPcGFsIGRvZXMgbm90IHN1cHBvcnQgZXhwbGljaXRseSBzcGVjaWZ5aW5nIFVUQyBvZmZzZXQgZm9yIFRpbWUnfVxuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5sb2NhbCh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdtKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgeWVhciAgPSBhcmdzWzVdO1xuICAgICAgICBtb250aCA9IGFyZ3NbNF07XG4gICAgICAgIGRheSAgID0gYXJnc1szXTtcbiAgICAgICAgaG91ciAgPSBhcmdzWzJdO1xuICAgICAgICBtaW4gICA9IGFyZ3NbMV07XG4gICAgICAgIHNlYyAgID0gYXJnc1swXTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCkpO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmlzX3V0YyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGFsaWFzIG1rdGltZSBsb2NhbFxuICAgIGFsaWFzIHV0YyBnbVxuICBlbmRcblxuICBkZWYgc2VsZi5ub3dcbiAgICBuZXdcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ3RpbWUgKyB0aW1lPydcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBvdGhlciA9ICN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAob3RoZXIgKiAxMDAwKSk7XG4gICAgICByZXN1bHQuaXNfdXRjID0gc2VsZi5pc191dGM7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHJldHVybiBgKHNlbGYuZ2V0VGltZSgpIC0gb3RoZXIuZ2V0VGltZSgpKSAvIDEwMDBgXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAje09wYWwuY29lcmNlX3RvIShvdGhlciwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpIC0gKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgVGltZSA9PT0gb3RoZXJcbiAgICAgIHRvX2YgPD0+IG90aGVyLnRvX2ZcbiAgICBlbHNlXG4gICAgICByID0gb3RoZXIgPD0+IHNlbGZcbiAgICAgIGlmIHIubmlsP1xuICAgICAgICBuaWxcbiAgICAgIGVsc2lmIHIgPiAwXG4gICAgICAgIC0xXG4gICAgICBlbHNpZiByIDwgMFxuICAgICAgICAxXG4gICAgICBlbHNlXG4gICAgICAgIDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgVGltZSA9PT0gb3RoZXIgJiYgYCN7dG9fZn0gPT09ICN7b3RoZXIudG9fZn1gXG4gIGVuZFxuXG4gIGRlZiBhc2N0aW1lXG4gICAgc3RyZnRpbWUgJyVhICViICVlICVIOiVNOiVTICVZJ1xuICBlbmRcblxuICBhbGlhcyBjdGltZSBhc2N0aW1lXG5cbiAgZGVmIGRheVxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDRGF0ZSgpIDogc2VsZi5nZXREYXRlKClgXG4gIGVuZFxuXG4gIGRlZiB5ZGF5XG4gICAgIyBodHRwOi8vamF2YXNjcmlwdC5hYm91dC5jb20vbGlicmFyeS9ibGRheXllYXIuaHRtXG4gICAgIyBhbHNvIHNlZSBtb21lbnQuanMgaW1wbGVtZW50YXRpb246IGh0dHA6Ly9naXQuaW8vdkNLTkVcblxuICAgIHN0YXJ0X29mX3llYXIgPSBUaW1lLm5ldyh5ZWFyKS50b19pXG4gICAgc3RhcnRfb2ZfZGF5ICA9IFRpbWUubmV3KHllYXIsIG1vbnRoLCBkYXkpLnRvX2lcbiAgICBvbmVfZGF5ICAgICAgID0gODZfNDAwXG5cbiAgICAoKHN0YXJ0X29mX2RheSAtIHN0YXJ0X29mX3llYXIpIC8gb25lX2RheSkucm91bmQgKyAxXG4gIGVuZFxuXG4gIGRlZiBpc2RzdFxuICAgICV4e1xuICAgICAgdmFyIGphbiA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgMCwgMSksXG4gICAgICAgICAganVsID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgICAgIHJldHVybiBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHN0PyBpc2RzdFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gYG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKWBcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIG90aGVyLmlzX2E/KFRpbWUpICYmIChzZWxmIDw9PiBvdGhlcikuemVybz9cbiAgZW5kXG5cbiAgZGVmIGZyaWRheT9cbiAgICBgI3t3ZGF5fSA9PSA1YFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGAnVGltZTonICsgc2VsZi5nZXRUaW1lKClgXG4gIGVuZFxuXG4gIGRlZiBob3VyXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENIb3VycygpIDogc2VsZi5nZXRIb3VycygpYFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIHV0Yz9cbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyBVVEMnXG4gICAgZWxzZVxuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTICV6J1xuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBtZGF5IGRheVxuXG4gIGRlZiBtaW5cbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ01pbnV0ZXMoKSA6IHNlbGYuZ2V0TWludXRlcygpYFxuICBlbmRcblxuICBkZWYgbW9uXG4gICAgYChzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDTW9udGgoKSA6IHNlbGYuZ2V0TW9udGgoKSkgKyAxYFxuICBlbmRcblxuICBkZWYgbW9uZGF5P1xuICAgIGAje3dkYXl9ID09IDFgXG4gIGVuZFxuXG4gIGFsaWFzIG1vbnRoIG1vblxuXG4gIGRlZiBzYXR1cmRheT9cbiAgICBgI3t3ZGF5fSA9PSA2YFxuICBlbmRcblxuICBkZWYgc2VjXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENTZWNvbmRzKCkgOiBzZWxmLmdldFNlY29uZHMoKWBcbiAgZW5kXG5cbiAgZGVmIHN1Y2NcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIDEwMDApO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1c2VjXG4gICAgYHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwYFxuICBlbmRcblxuICBkZWYgem9uZVxuICAgICV4e1xuICAgICAgdmFyIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKSxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignKCcpID09IC0xKSB7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5tYXRjaCgvW0EtWl17Myw0fS8pWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHN0cmluZy5tYXRjaCgvXFwoKC4rKVxcKSg/Olxcc3wkKS8pWzFdXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gXCJHTVRcIiAmJiAvKEdNVFxcVypcXGR7NH0pLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIFJlZ0V4cC4kMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdldGdtXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZ2V0dXRjIGdldGdtXG5cbiAgZGVmIGdtdGltZVxuICAgICV4e1xuICAgICAgc2VsZi5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB1dGMgZ210aW1lXG5cbiAgZGVmIGdtdD9cbiAgICBgc2VsZi5pc191dGMgPT09IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBnbXRfb2Zmc2V0XG4gICAgYHNlbGYuaXNfdXRjID8gMCA6IC1zZWxmLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MGBcbiAgZW5kXG5cbiAgZGVmIHN0cmZ0aW1lKGZvcm1hdClcbiAgICAleHtcbiAgICAgIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJShbXFwtXyNeMF0qOnswLDJ9KShcXGQrKT8oW0VPXSopKC4pL2csIGZ1bmN0aW9uKGZ1bGwsIGZsYWdzLCB3aWR0aCwgXywgY29udikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgICAgICAgIHplcm8gICA9IGZsYWdzLmluZGV4T2YoJzAnKSAhPT0gLTEsXG4gICAgICAgICAgICBwYWQgICAgPSBmbGFncy5pbmRleE9mKCctJykgPT09IC0xLFxuICAgICAgICAgICAgYmxhbmsgID0gZmxhZ3MuaW5kZXhPZignXycpICE9PSAtMSxcbiAgICAgICAgICAgIHVwY2FzZSA9IGZsYWdzLmluZGV4T2YoJ14nKSAhPT0gLTEsXG4gICAgICAgICAgICBpbnZlcnQgPSBmbGFncy5pbmRleE9mKCcjJykgIT09IC0xLFxuICAgICAgICAgICAgY29sb25zID0gKGZsYWdzLm1hdGNoKCc6JykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG5cbiAgICAgICAgaWYgKHplcm8gJiYgYmxhbmspIHtcbiAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZignMCcpIDwgZmxhZ3MuaW5kZXhPZignXycpKSB7XG4gICAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGNvbnYpIHtcbiAgICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3llYXJ9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5yb3VuZCgje3llYXJ9IC8gMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje3llYXJ9ICUgMTAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7bW9ufTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgICByZXN1bHQgKz0gbG9uZ19tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0X21vbnRoc1sje21vbn0gLSAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVyb1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJwbVwiIDogXCJhbVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttaW59O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzZWN9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gOSA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7YHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKWAucmp1c3QoMywgJzAnKX07XG4gICAgICAgICAgICByZXN1bHQgID0gI3tgcmVzdWx0YC5sanVzdChgd2lkdGhgLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ICA9IHNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBob3VycyAgID0gTWF0aC5mbG9vcihNYXRoLmFicyhvZmZzZXQpIC8gNjApLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmFicyhvZmZzZXQpICUgNjA7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBvZmZzZXQgPCAwID8gXCIrXCIgOiBcIi1cIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycyA8IDEwID8gXCIwXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcztcblxuICAgICAgICAgICAgaWYgKGNvbG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOjAwXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t6b25lfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gZGF5c19vZl93ZWVrWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9kYXlzWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t3ZGF5fSArIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3dkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzBdLnRvX3Mucmp1c3QoMiwgJzAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzFdWy0yLi4tMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3RvX2l9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWEgJWIgJWUgJVQgJVknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVtLyVkLyV5Jyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclWS0lbS0lZCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWUtJV5iLSU0WScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUk6JU06JVMgJXAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSDolTTolUycpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmdWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwY2FzZSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9bQS1aXS8sIGZ1bmN0aW9uKGMpIHsgYy50b0xvd2VyQ2FzZSgpIH0pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9bYS16XS8sIGZ1bmN0aW9uKGMpIHsgYy50b1VwcGVyQ2FzZSgpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhZCAmJiAoemVybyB8fCBibGFuaykpIHtcbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLnJqdXN0KGBpc05hTih3aWR0aCkgPyAyIDogd2lkdGhgLCBgYmxhbmsgPyBcIiBcIiA6IFwiMFwiYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN1bmRheT9cbiAgICBgI3t3ZGF5fSA9PSAwYFxuICBlbmRcblxuICBkZWYgdGh1cnNkYXk/XG4gICAgYCN7d2RheX0gPT0gNGBcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbc2VjLCBtaW4sIGhvdXIsIGRheSwgbW9udGgsIHllYXIsIHdkYXksIHlkYXksIGlzZHN0LCB6b25lXVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIGBzZWxmLmdldFRpbWUoKSAvIDEwMDBgXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgYHBhcnNlSW50KHNlbGYuZ2V0VGltZSgpIC8gMTAwMCwgMTApYFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHVlc2RheT9cbiAgICBgI3t3ZGF5fSA9PSAyYFxuICBlbmRcblxuICBhbGlhcyB0dl9zZWMgdG9faVxuXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xuXG4gIGFsaWFzIHV0Yz8gZ210P1xuXG4gIGFsaWFzIGdtdG9mZiBnbXRfb2Zmc2V0XG4gIGFsaWFzIHV0Y19vZmZzZXQgZ210X29mZnNldFxuXG4gIGRlZiB3ZGF5XG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENEYXkoKSA6IHNlbGYuZ2V0RGF5KClgXG4gIGVuZFxuXG4gIGRlZiB3ZWRuZXNkYXk/XG4gICAgYCN7d2RheX0gPT0gM2BcbiAgZW5kXG5cbiAgZGVmIHllYXJcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0Z1bGxZZWFyKCkgOiBzZWxmLmdldEZ1bGxZZWFyKClgXG4gIGVuZFxuXG4gIGRlZiBjd2Vla19jeWVhclxuICAgIGphbjAxID0gVGltZS5uZXcoeWVhciwgMSwgMSlcbiAgICBqYW4wMV93ZGF5ID0gamFuMDEud2RheVxuICAgIGZpcnN0X21vbmRheSA9IDBcbiAgICB5ZWFyID0gc2VsZi55ZWFyXG4gICAgaWYgamFuMDFfd2RheSA8PSA0ICYmIGphbjAxX3dkYXkgIT0gMFxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSAxXG4gICAgZWxzZVxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDcgLSAxXG4gICAgICBvZmZzZXQgPSAtMSBpZiBvZmZzZXQgPT0gLTggIyBBZGp1c3QgaWYgSmFuIDAxIGlzIGEgU3VuZGF5XG4gICAgZW5kXG5cbiAgICB3ZWVrID0gKCh5ZGF5ICsgb2Zmc2V0KSAvIDcuMDApLmNlaWxcblxuICAgIGlmIHdlZWsgPD0gMFxuICAgICAgIyBHZXQgdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgcmV0dXJuIFRpbWUubmV3KHNlbGYueWVhciAtIDEsIDEyLCAzMSkuY3dlZWtfY3llYXJcbiAgICBlbHNpZiB3ZWVrID09IDUzXG4gICAgICAjIEZpbmQgb3V0IHdoZXRoZXIgdGhpcyBpcyBhY3R1YWxseSB3ZWVrIDUzIG9yIGFscmVhZHkgd2VlayAwMSBvZiB0aGUgZm9sbG93aW5nIHllYXJcbiAgICAgIGRlYzMxID0gVGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXG4gICAgICBkZWMzMV93ZGF5ID0gZGVjMzEud2RheVxuICAgICAgaWYgZGVjMzFfd2RheSA8PSAzICYmIGRlYzMxX3dkYXkgIT0gMFxuICAgICAgICB3ZWVrID0gMVxuICAgICAgICB5ZWFyICs9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgW3dlZWssIHllYXJdXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0Iiwic2VsZiIsIj09PSIsInNlY29uZHMiLCJyYWlzZSIsImNvZXJjZV90byEiLCJmcmFjIiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19pIiwibmV3IiwibG9jYWwiLCJnbSIsIm5vdyIsIisiLCJvdGhlciIsIi0iLCI8PT4iLCJ0b19mIiwiciIsIm5pbD8iLCI+IiwiMCIsIi0xIiwiPCIsIjEiLCI9PSIsImFzY3RpbWUiLCJzdHJmdGltZSIsImRheSIsInlkYXkiLCJzdGFydF9vZl95ZWFyIiwieWVhciIsInN0YXJ0X29mX2RheSIsIm1vbnRoIiwib25lX2RheSIsIjg2NDAwIiwiLyIsInJvdW5kIiwiaXNkc3QiLCJkdXAiLCJjb3B5IiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJpbml0aWFsaXplX2R1cCIsImVxbD8iLCJpc19hPyIsInplcm8/IiwiZnJpZGF5PyIsIndkYXkiLCJoYXNoIiwiaG91ciIsImluc3BlY3QiLCJ1dGM/IiwibWluIiwibW9uIiwibW9uZGF5PyIsInNhdHVyZGF5PyIsInNlYyIsInN1Y2MiLCJ1c2VjIiwiem9uZSIsImdldGdtIiwiZ210aW1lIiwiZ210PyIsImdtdF9vZmZzZXQiLCJyanVzdCIsIjMiLCJsanVzdCIsImN3ZWVrX2N5ZWFyIiwiW10iLCJ0b19zIiwiMiIsIi0yIiwic3VuZGF5PyIsInRodXJzZGF5PyIsInRvX2EiLCJ0dWVzZGF5PyIsIndlZG5lc2RheT8iLCJqYW4wMSIsImphbjAxX3dkYXkiLCJmaXJzdF9tb25kYXkiLCI8PSIsIjQiLCIhPSIsIm9mZnNldCIsIjciLCItOCIsIndlZWsiLCJjZWlsIiwiMTIiLCIzMSIsIjUzIiwiZGVjMzEiLCJkZWMzMV93ZGF5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBO0FBR0YsdUJBQXlCLENBQUcsUUFBSCxFQUFVLFFBQVYsRUFBaUIsU0FBakIsRUFBeUIsV0FBekIsRUFBbUMsVUFBbkMsRUFBNEMsUUFBNUMsRUFBbUQsVUFBbkQsRUFBNEQsUUFBNUQsQ0FBb0U7QUFDN0YsdUJBQXlCLENBQUcsS0FBSCxFQUFPLEtBQVAsRUFBVyxLQUFYLEVBQWUsS0FBZixFQUFtQixLQUFuQixFQUF1QixLQUF2QixFQUEy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QUFoQixFQUFPc0UsTUFBUHRFLENBQUR1QixFQUFrQixHQUFsQkEsQ0FBRG1ELE1BQUFBLENBQUFBLENBYlA7QUFBQSxNQWVBLElBQUEsUUFBR1AsT0FBQU0sSUFBQU4sRUFBUTNELENBQVIyRCxDQUFILENBQUE7QUFBQSxRQUVFLE9BQU8sb0JBQUF2RSxLQUFBQSxDQUFTTSxVQUFBZixJQUFBK0IsTUFBQUEsQ0FBQUEsQ0FBQWhCLEVBQVlTLENBQVpULEdBQWV5RSxJQUFJQyxFQUE1QmhGLENBQUEwRCxhQUFBQSxDQUFBQTtBQUZULE1BQUEsT0FHQSxJQUFNbUIsSUFBQTdELE9BQUFBLENBQVFpRSxFQUFSakUsQ0FBTjtBQUFBO0FBRUUsUUFBQWtFLFFBQVEsb0JBQUFsRixLQUFBQSxDQUFTVCxJQUFBK0IsTUFBQUEsQ0FBQUEsR0FBV3lELElBQUlDLEVBQXhCaEYsQ0FBUjtBQUFBLFFBQ0FtRixhQUFhRCxLQUFBNUMsTUFBQUEsQ0FBQUEsQ0FEYjtBQUFBLFFBRUEsSUFBQSxRQUFHLGNBQUFpQyxPQUFBWSxVQUFBWixFQUFjZixDQUFkZSxDQUFBLElBQW1CWSxVQUFBVixPQUFBQSxDQUFjN0QsQ0FBZDZELENBQW5CLE1BQUgsQ0FBQTtBQUFBO0FBQ0UsVUFBQUksT0FBTzlELENBQVA7QUFBQSxVQUNBTyxPQXZ1QlJsQixTQXV1QlFrQixJQXZ1QlJsQixFQXV1QmdCVyxDQXZ1QmhCWCxDQXN1QlEsQ0FERixDQUZBLENBRkYsQ0FsQkE7QUFBQSxNQTRCQSxPQUFBLENBQUN5RSxJQUFELEVBQU92RCxJQUFQLENBNUJBO0FBREZvQyxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FBQUEsdUJBMXNCQTtBQURGdEUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBYyxJQUFkQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjEzODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIFN0cnVjdFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBkZWYgc2VsZi5uZXcoY29uc3RfbmFtZSwgKmFyZ3MsIGtleXdvcmRfaW5pdDogZmFsc2UsICZibG9jaylcbiAgICBpZiBjb25zdF9uYW1lXG4gICAgICBiZWdpblxuICAgICAgICBjb25zdF9uYW1lID0gT3BhbC5jb25zdF9uYW1lIShjb25zdF9uYW1lKVxuICAgICAgcmVzY3VlIFR5cGVFcnJvciwgTmFtZUVycm9yXG4gICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxuICAgICAgICBjb25zdF9uYW1lID0gbmlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFyZ3MubWFwIGRvIHxhcmd8XG4gICAgICBPcGFsLmNvZXJjZV90byEoYXJnLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgZW5kXG5cbiAgICBrbGFzcyA9IENsYXNzLm5ldyhzZWxmKSBkb1xuICAgICAgYXJncy5lYWNoIHsgfGFyZ3wgZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUoYXJnKSB9XG5cbiAgICAgIGNsYXNzIDw8IHNlbGZcbiAgICAgICAgZGVmIG5ldygqYXJncylcbiAgICAgICAgICBpbnN0YW5jZSA9IGFsbG9jYXRlXG4gICAgICAgICAgYCN7aW5zdGFuY2V9LiQkZGF0YSA9IHt9YFxuICAgICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUoKmFyZ3MpXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYWxpYXNfbWV0aG9kIDpbXSwgOm5ld1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBrbGFzcy5tb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrXG4gICAgYGtsYXNzLiQka2V5d29yZF9pbml0ID0ga2V5d29yZF9pbml0YFxuXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgU3RydWN0LmNvbnN0X3NldChjb25zdF9uYW1lLCBrbGFzcylcbiAgICBlbmRcblxuICAgIGtsYXNzXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlKG5hbWUpXG4gICAgaWYgc2VsZiA9PSBTdHJ1Y3RcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd5b3UgY2Fubm90IGRlZmluZSBhdHRyaWJ1dGVzIHRvIHRoZSBTdHJ1Y3QgY2xhc3MnXG4gICAgZW5kXG5cbiAgICBtZW1iZXJzIDw8IG5hbWVcblxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICAgIGVuZFxuXG4gICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm1lbWJlcnNcbiAgICBpZiBzZWxmID09IFN0cnVjdFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RoZSBTdHJ1Y3QgY2xhc3MgaGFzIG5vIG1lbWJlcnMnXG4gICAgZW5kXG5cbiAgICBAbWVtYmVycyB8fD0gW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxuICAgIG1lbWJlcnMgPSBAbWVtYmVyc1xuXG4gICAga2xhc3MuaW5zdGFuY2VfZXZhbCBkb1xuICAgICAgQG1lbWJlcnMgPSBtZW1iZXJzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgIGlmIGAje3NlbGYuY2xhc3N9LiQka2V5d29yZF9pbml0YFxuICAgICAga3dhcmdzID0gYXJncy5sYXN0IHx8IHt9XG5cbiAgICAgIGlmIGFyZ3MubGVuZ3RoID4gMSB8fCBgKGFyZ3MubGVuZ3RoID09PSAxICYmICFrd2FyZ3MuJCRpc19oYXNoKWBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAje2FyZ3MubGVuZ3RofSwgZXhwZWN0ZWQgMClcIlxuICAgICAgZW5kXG5cbiAgICAgIGV4dHJhID0ga3dhcmdzLmtleXMgLSBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgICAgIGlmIGV4dHJhLmFueT9cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmtub3duIGtleXdvcmRzOiAje2V4dHJhLmpvaW4oJywgJyl9XCJcbiAgICAgIGVuZFxuXG4gICAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgc2VsZltuYW1lXSA9IGt3YXJnc1tuYW1lXVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgaWYgYXJncy5sZW5ndGggPiBzZWxmLmNsYXNzLm1lbWJlcnMubGVuZ3RoXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdzdHJ1Y3Qgc2l6ZSBkaWZmZXJzJ1xuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoX3dpdGhfaW5kZXggZG8gfG5hbWUsIGluZGV4fFxuICAgICAgICBzZWxmW25hbWVdID0gYXJnc1tpbmRleF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWVtYmVyc1xuICAgIHNlbGYuY2xhc3MubWVtYmVyc1xuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIEhhc2gubmV3KGBzZWxmLiQkZGF0YWApLmhhc2hcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgaWYgSW50ZWdlciA9PT0gbmFtZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIGxhcmdlIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lID49IHNlbGYuY2xhc3MubWVtYmVycy5zaXplXG5cbiAgICAgIG5hbWUgPSBzZWxmLmNsYXNzLm1lbWJlcnNbbmFtZV1cbiAgICBlbHNpZiBTdHJpbmcgPT09IG5hbWVcbiAgICAgICV4e1xuICAgICAgICBpZighc2VsZi4kJGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7bmFtZS5jbGFzc30gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXWBcbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBpZiBJbnRlZ2VyID09PSBuYW1lXG4gICAgICByYWlzZSBJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIFN0cmluZyA9PT0gbmFtZVxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcIm5vIG1lbWJlciAnI3tuYW1lfScgaW4gc3RydWN0XCIsIG5hbWUpIHVubGVzcyBzZWxmLmNsYXNzLm1lbWJlcnMuaW5jbHVkZT8obmFtZS50b19zeW0pXG4gICAgZWxzZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IE9wYWwuY29lcmNlX3RvIShuYW1lLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShzdHJ1Y3QsIG90aGVyKSB7XG4gICAgICAgIHZhciBrZXksIGEsIGI7XG5cbiAgICAgICAgcmVjdXJzZWQxWyN7YHN0cnVjdGAuX19pZF9ffV0gPSB0cnVlO1xuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzdHJ1Y3QuJCRkYXRhKSB7XG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcbiAgICAgICAgICBiID0gb3RoZXIuJCRkYXRhW2tleV07XG5cbiAgICAgICAgICBpZiAoI3tTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgID09IGBiYH0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7U3RydWN0ID09PSBgYWB9KSB7XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkMS5oYXNPd25Qcm9wZXJ0eSgje2BhYC5fX2lkX199KSB8fCAhcmVjdXJzZWQyLmhhc093blByb3BlcnR5KCN7YGJgLl9faWRfX30pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxZXEoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCB7IHxuYW1lfCB5aWVsZCBzZWxmW25hbWVdIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3BhaXJcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfcGFpcikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggeyB8bmFtZXwgeWllbGQgW25hbWUsIHNlbGZbbmFtZV1dIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubGVuZ3RoXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHRvX2FcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMubWFwIHsgfG5hbWV8IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBhbGlhcyB2YWx1ZXMgdG9fYVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgcmVzdWx0ID0gJyM8c3RydWN0ICdcblxuICAgIGlmIFN0cnVjdCA9PT0gc2VsZiAmJiBzZWxmLmNsYXNzLm5hbWVcbiAgICAgIHJlc3VsdCArPSBcIiN7c2VsZi5jbGFzc30gXCJcbiAgICBlbmRcblxuICAgIHJlc3VsdCArPSBlYWNoX3BhaXIubWFwIGRvIHxuYW1lLCB2YWx1ZXxcbiAgICAgIFwiI3tuYW1lfT0je3ZhbHVlLmluc3BlY3R9XCJcbiAgICBlbmQuam9pbiAnLCAnXG5cbiAgICByZXN1bHQgKz0gJz4nXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5cbiAgZGVmIHRvX2hcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tgYXJnc1tpXWAuY2xhc3N9IGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7c2VsZltgYXJnc1tpXWBdfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBpZiBga2V5LiQkaXNfc3RyaW5nICYmIHNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KGtleSlgXG4gICAgICAgICAgICAgYHNlbGYuJCRkYXRhW2tleV0gfHwgbmlsYFxuICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwibmV3Iiwic2VsZiIsImNvbnN0X25hbWUiLCJjb25zdF9uYW1lISIsImFyZ3MiLCJ1bnNoaWZ0IiwibWFwIiwiY29lcmNlX3RvISIsImFyZyIsImtsYXNzIiwiZWFjaCIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwiY29uc3Rfc2V0IiwiPT0iLCJyYWlzZSIsIm1lbWJlcnMiLCI8PCIsIm5hbWUiLCJkZWZpbmVfbWV0aG9kIiwiQG1lbWJlcnMiLCJpbmhlcml0ZWQiLCJpbnN0YW5jZV9ldmFsIiwia3dhcmdzIiwibGFzdCIsIj4iLCJsZW5ndGgiLCIxIiwiZXh0cmEiLCItIiwia2V5cyIsImFueT8iLCJqb2luIiwiJHdyaXRlciIsIltdIiwiW109IiwiZWFjaF93aXRoX2luZGV4IiwiaW5kZXgiLCJoYXNoIiwiPT09IiwiPCIsInNpemUiLCItQCIsIj49IiwiaW5jbHVkZT8iLCJ0b19zeW0iLCJvdGhlciIsImluc3RhbmNlX29mPyIsIl9faWRfXyIsImVxbD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImVhY2hfcGFpciIsInRvX2EiLCJpbnNwZWN0IiwicmVzdWx0IiwiKyIsInZhbHVlIiwidG9faCIsImVhY2hfd2l0aF9vYmplY3QiLCJoIiwidmFsdWVzX2F0IiwiZmxhdHRlbiIsImRpZyIsIml0ZW0iLCJyZXNwb25kX3RvPyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxVQUFBQSxnQkFBQUEsU0FBYSxVQUFELEVBTmQs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Q0E7QUFDQSxJQW5TQTtBQUFBLE1BcVNJLElBQUEsUUFBT0EsSUFBQUMsZ0JBQUFBLENBQWlCLEtBQWpCQSxDQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRWxELE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLENBQUdpRCxJQUFBdkUsT0FBQUEsQ0FBQUEsQ0FBSCxDQUFBLEdBQUEsNEJBQWpCc0I7QUFERixNQUFBLENBclNKO0FBQUEsTUF5U0ksT0FBQWdELE1BQUFDLElBQUFELE9BQUFBLEVBQVMsVUFBQ2pDLElBQUQsQ0FBVGlDLENBelNKO0FBMFJFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUEsZUF0UkE7QUFERnRFLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMTg5MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgSU9cbiAgU0VFS19TRVQgPSAwXG4gIFNFRUtfQ1VSID0gMVxuICBTRUVLX0VORCA9IDJcblxuICBkZWYgdHR5P1xuICAgIEB0dHlcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZD9cbiAgICBAY2xvc2VkXG4gIGVuZFxuXG4gIGF0dHJfYWNjZXNzb3IgOndyaXRlX3Byb2NcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGBzZWxmLndyaXRlX3Byb2Moc3RyaW5nKWBcbiAgICBzdHJpbmcuc2l6ZVxuICBlbmRcblxuICBhdHRyX2FjY2Vzc29yIDpzeW5jLCA6dHR5XG5cbiAgZGVmIGZsdXNoXG4gICAgIyBub29wXG4gIGVuZFxuXG4gIG1vZHVsZSBXcml0YWJsZVxuICAgIGRlZiA8PChzdHJpbmcpXG4gICAgICB3cml0ZShzdHJpbmcpXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgcHJpbnQoKmFyZ3MpXG4gICAgICB3cml0ZSBhcmdzLm1hcCB7IHxhcmd8IFN0cmluZyhhcmcpIH0uam9pbigkLClcbiAgICAgIG5pbFxuICAgIGVuZFxuXG4gICAgZGVmIHB1dHMoKmFyZ3MpXG4gICAgICBuZXdsaW5lID0gJC9cbiAgICAgIGlmIGFyZ3MuZW1wdHk/XG4gICAgICAgIHdyaXRlICQvXG4gICAgICBlbHNlXG4gICAgICAgIHdyaXRlIGFyZ3MubWFwIHsgfGFyZ3wgU3RyaW5nKGFyZykuY2hvbXAgfS5jb25jYXQoW25pbF0pLmpvaW4obmV3bGluZSlcbiAgICAgIGVuZFxuICAgICAgbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBSZWFkYWJsZVxuICAgIGRlZiByZWFkYnl0ZVxuICAgICAgZ2V0Ynl0ZVxuICAgIGVuZFxuXG4gICAgZGVmIHJlYWRjaGFyXG4gICAgICBnZXRjXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZGxpbmUoc2VwID0gJC8pXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZHBhcnRpYWwoaW50ZWdlciwgb3V0YnVmID0gbmlsKVxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5TVERFUlIgPSAkc3RkZXJyID0gSU8ubmV3XG5TVERJTiAgPSAkc3RkaW4gID0gSU8ubmV3XG5TVERPVVQgPSAkc3Rkb3V0ID0gSU8ubmV3XG5cbmB2YXIgY29uc29sZSA9IE9wYWwuZ2xvYmFsLmNvbnNvbGVgXG5TVERPVVQud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZG91dCkgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRvdXQud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS5sb2cocyl9YFxuU1RERVJSLndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRlcnIpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3RkZXJyLndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUud2FybihzKX1gXG5cblNURE9VVC5leHRlbmQoSU86OldyaXRhYmxlKVxuU1RERVJSLmV4dGVuZChJTzo6V3JpdGFibGUpXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIwIiwiMSIsIjIiLCJ0dHk/IiwiQHR0eSIsImNsb3NlZD8iLCJAY2xvc2VkIiwiYXR0cl9hY2Nlc3NvciIsIndyaXRlIiwic3RyaW5nIiwic2l6ZSIsImZsdXNoIiwibW9kdWxlIiwiPDwiLCJzZWxmIiwicHJpbnQiLCJtYXAiLCJhcmdzIiwiU3RyaW5nIiwiYXJnIiwiam9pbiIsIiQsIiwicHV0cyIsIm5ld2xpbmUiLCIkLyIsImVtcHR5PyIsImNob21wIiwiY29uY2F0IiwicmVhZGJ5dGUiLCJnZXRieXRlIiwicmVhZGNoYXIiLCJnZXRjIiwicmVhZGxpbmUiLCJyYWlzZSIsInJlYWRwYXJ0aWFsIiwiJHN0ZGVyciIsIm5ldyIsIiRzdGRpbiIsIiRzdGRvdXQiLCIkd3JpdGVyIiwid3JpdGVfcHJvYz0iLCItIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsSUFBQSx3Q0FBV0MsQ0FBWCxDQUFBO0FBQUEsSUFDQSx3Q0FBV0MsQ0FBWCxDQURBO0FBQUEsSUFFQSx3Q0FBV0MsQ0FBWCxDQUZBO0FBQUE7QUFJQUMsSUFBQUEsd0JBQUFBLGlCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBQztBQURGRCxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FKQTtBQUFBO0FBUUFFLElBQUFBLDJCQUFBQSxvQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUM7QUFERkQsSUFBQUEsQ0FBQUEsK0JBQUFBLENBUkE7QUFBQSxRQVlBRSxlQUFBQSxDQUFjLFlBQWRBLENBWkE7QUFBQTtBQWNBQyxJQUFBQSx5QkFBQUEsY0FBQUEsaUJBQVUsTUFBVkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQyx1QkFBRDtBQUFBLE1BQ0EsT0FBQUMsTUFBQUMsTUFBQUEsQ0FBQUEsQ0FEQTtBQURGRixJQUFBQSxDQUFBQSx5QkFBQUEsQ0FkQTtBQUFBLFFBbUJBRCxlQUFBQSxDQUFjLFFBQU8sS0FBckJBLENBbkJBO0FBQUE7QUFxQkFJLElBQUFBLHlCQUFBQSxjQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BdkJGLE9BQUE7QUF1QkVBLElBQUFBLENBQUFBLHlCQUFBQSxDQXJCQTtBQUFBLElBeUJBQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0U7QUFBQUMsTUFBQUEsc0JBQUFBLHFCQUFBQSxTQUFPLE1BQVBBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFlBQUFMLE9BQUFBLENBQU1DLE1BQU5ELENBQUE7QUFBQSxRQUNBLE9BQUFNLElBREE7QUFERkQsTUFBQUEsQ0FBQUEsZ0NBQUFBLENBQUE7QUFBQTtBQUtBRSxNQUFBQSx5QkFBQUEsb0JBQUFBLGlCQWpDSixFQWlDSUE7QUFBQUEsUUFBQUE7QUFBQUE7O0FBQUFBO0FBakNKO0FBQUEsUUFBQSw0REFBQTtBQUFBO0FBaUNjLFFBQUEsa0JBakNkO0FBQUEsWUFrQ01QLE9BQUFBLENBQU1RLE1BQUFDLElBQUFELE9BQUFBLEVBQUFBLEVBQUFBLEVBbENaLGdCQWtDd0IsR0FsQ3hCLEVBQUE7O0FBQUE7QUFBQTtBQWtDd0IsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBbEN4QjtBQUFBLFVBa0M2QixXQUFBRSxRQUFBQSxDQUFPQyxHQUFQRCxDQWxDN0IsQ0FBQSxrQkFBQSxpQkFBQSxLQWtDWUYsQ0FBQUksTUFBQUEsQ0FBb0NDLFdBQXBDRCxDQUFOWixDQWxDTjtBQUFBLFFBbUNNLE9BQUEsR0FuQ047QUFpQ0lPLE1BQUFBLENBQUFBLGdDQUFBQSxDQUxBO0FBQUE7QUFVQU8sTUFBQUEsd0JBQUFBLG1CQUFBQSxnQkF0Q0osRUFzQ0lBO0FBQUFBLFFBQUFBO0FBQUFBOztBQUFBQTtBQXRDSjtBQUFBLFFBQUEsNERBQUE7QUFBQTtBQXNDYSxRQUFBLGtCQXRDYjtBQUFBLFFBdUNNQyxVQUFVQyxXQXZDaEI7QUFBQSxRQXdDTSxJQUFBLFFBQUdQLElBQUFRLFdBQUFBLENBQUFBLENBQUgsQ0FBQTtBQUFBLGNBQ0VqQixPQUFBQSxDQUFNZ0IsV0FBTmhCO0FBREYsUUFBQTtBQUFBLGNBR0VBLE9BQUFBLENBQU1RLE1BQUFDLElBQUFELE9BQUFBLEVBQUFBLEVBQUFBLEVBM0NkLGdCQTJDMEIsR0EzQzFCLEVBQUE7O0FBQUE7QUFBQTtBQTJDMEIsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBM0MxQjtBQUFBLFlBMkMrQixXQUFBRSxRQUFBQSxDQUFPQyxHQUFQRCxDQUFBUSxPQUFBQSxDQUFBQSxDQTNDL0IsQ0FBQSxrQkFBQSxpQkFBQSxLQTJDY1YsQ0FBQVcsUUFBQUEsQ0FBNEMsQ0FBQyxHQUFELENBQTVDQSxDQUFBUCxNQUFBQSxDQUF3REcsT0FBeERILENBQU5aO0FBSEYsUUFBQSxDQXhDTjtBQUFBLFFBNkNNLE9BQUEsR0E3Q047QUFzQ0ljLE1BQUFBLENBQUFBLCtCQUFBQSxDQVZBO0FBREZWLElBQUFBLEdBQUFBLFdBQUFBLFdBekJBO0FBQUEsSUErQ0EsT0FBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFO0FBQUFnQixNQUFBQSw0QkFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxXQUFBQyxTQUFBQSxDQUFBQTtBQURGRCxNQUFBQSxDQUFBQSxtQ0FBQUEsQ0FBQTtBQUFBO0FBSUFFLE1BQUFBLDRCQUFBQSx3QkFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLFdBQUFDLE1BQUFBLENBQUFBO0FBREZELE1BQUFBLENBQUFBLG1DQUFBQSxDQUpBO0FBQUE7QUFRQUUsTUFBQUEsNEJBQUFBLHdCQUFBQSxvQkFBYSxHQUFiQTtBQUFBQSxRQUFBQTtBQUFBQTs7QUFBQUE7QUExREo7QUEwRGlCLFFBQUE7QUFBQSxRQUFBLFFBQU1SLFdBQU47QUFBQSxRQUFBLENBMURqQjtBQUFBLFFBMkRNLFdBQUFTLE9BQUFBLENBQU0sbUNBQU5BLENBM0ROO0FBMERJRCxNQUFBQSxDQUFBQSxvQ0FBQUEsQ0FSQTtBQUFBO0FBWUFFLE1BQUFBLCtCQUFBQSwyQkFBQUEsdUJBQWdCLE9BQUQsRUFBVSxNQUF6QkE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBOURKO0FBOEQ2QixRQUFBO0FBQUEsUUFBQSxXQUFTLEdBQVQ7QUFBQSxRQUFBLENBOUQ3QjtBQUFBLFFBK0RNLFdBQUFELE9BQUFBLENBQU0sbUNBQU5BLENBL0ROO0FBOERJQyxNQUFBQSxDQUFBQSx1Q0FBQUEsQ0FaQTtBQURGdEIsSUFBQUEsR0FBQUEsV0FBQUEsV0EvQ0E7QUFERmIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FBQTtBQUFBLEVBbUVBLHNDQUFTb0MsQ0FBQUEsZ0JBQVUsa0JBQUFDLEtBQUFBLENBQUFBLENBQVZELENBQVQsQ0FuRUE7QUFBQSxFQW9FQSxxQ0FBU0UsQ0FBQUEsZUFBVSxrQkFBQUQsS0FBQUEsQ0FBQUEsQ0FBVkMsQ0FBVCxDQXBFQTtBQUFBLEVBcUVBLHNDQUFTQyxDQUFBQSxnQkFBVSxrQkFBQUYsS0FBQUEsQ0FBQUEsQ0FBVkUsQ0FBVCxDQXJFQTtBQUFBLEVBdUVDLGlDQXZFRDtBQUFBO0FBREEsRUFBQUMsVUFBQSxDQXlFcUIsd0lBekVyQixDQUFBO0FBQUEsRUF5RUFDLE1BQUEsc0JBQUFBLGVBQUFBLEVBekVBLFVBQUFELE9BQUEsQ0F5RUFDLENBekVBO0FBQUEsRUFBQUQsT0FBQSxDQUFBRSxVQUFBRixPQUFBLENBQUEsUUFBQSxDQUFBRSxFQUFBeEMsQ0FBQXdDLENBQUEsQ0FBQSxDQUNBO0FBQUE7QUFEQSxFQUFBRixVQUFBLENBMEVxQix5SUExRXJCLENBQUE7QUFBQSxFQTBFQUMsTUFBQSxzQkFBQUEsZUFBQUEsRUExRUEsVUFBQUQsT0FBQSxDQTBFQUMsQ0ExRUE7QUFBQSxFQUFBRCxPQUFBLENBQUFFLFVBQUFGLE9BQUEsQ0FBQSxRQUFBLENBQUFFLEVBQUF4QyxDQUFBd0MsQ0FBQSxDQUFBLENBQ0E7QUFBQSxFQTJFQSxzQkFBQUMsUUFBQUEsQ0FBYyxJQUFBLGtCQUFBLGFBQWRBLENBM0VBO0FBQUEsRUE0RUEsT0FBQSxzQkFBQUEsUUFBQUEsQ0FBYyxJQUFBLGtCQUFBLGFBQWRBLENBNUVBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjIwNTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21haW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiZGVmIHNlbGYudG9fc1xuICAnbWFpbidcbmVuZFxuXG5kZWYgc2VsZi5pbmNsdWRlKG1vZClcbiAgT2JqZWN0LmluY2x1ZGUgbW9kXG5lbmRcbiJdLCJuYW1lcyI6WyJ0b19zIiwic2VsZiIsImluY2x1ZGUiLCJtb2QiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEVBQUFBLFVBQUlDLElBQUpELFdBQUFBLFVBQUFBLGdCQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBO0FBREZBLEVBQUFBLENBQUFBLHFCQUFBQSxDQUFBO0FBQUEsRUFJQSxPQUFBRSxDQUFBQSxVQUFJRCxJQUFKQyxjQUFBQSxhQUFBQSxtQkFBaUIsR0FBakJBO0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUEsc0JBQUFBLFNBQUFBLENBQWVDLEdBQWZEO0FBREZBLEVBQUFBLENBQUFBLHdCQUFBQSxDQUFBQSxtQkFKQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMDc0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9kaXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRGlyXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgY2hkaXIoZGlyKVxuICAgICAgcHJldl9jd2QgPSBgT3BhbC5jdXJyZW50X2RpcmBcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3tkaXJ9YFxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3twcmV2X2N3ZH1gXG4gICAgZW5kXG5cbiAgICBkZWYgcHdkXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciB8fCAnLidgXG4gICAgZW5kXG4gICAgYWxpYXMgZ2V0d2QgcHdkXG5cbiAgICBkZWYgaG9tZVxuICAgICAgRU5WWydIT01FJ10gfHwgJy4nXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJjaGRpciIsInByZXZfY3dkIiwiZGlyIiwicHdkIiwiaG9tZSIsIltdIiwic2VsZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSx5QkFBQUEsV0FBQUEsaUJBQVUsR0FBVkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBLGVBQ0UsY0FBQTtBQUFBO0FBQUEsUUFBQUMsV0FBWSxnQkFBWjtBQUFBLFFBQ0MsbUJBQXFCQyxHQUR0QjtBQUFBLFFBRUEsT0FBQSxxQkFBQSxFQUFBLENBRkE7QUFBQSxRQUFBO0FBQUEsVUFJQyxtQkFBcUJEO0FBSnRCLFFBQUEsQ0FBQTtBQURGRCxNQUFBQSxDQUFBQSxzQkFBQUEsQ0FBQTtBQUFBO0FBUUFHLE1BQUFBLHVCQUFBQSxTQUFBQSxlQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFDLHVCQUFEO0FBREZBLE1BQUFBLENBQUFBLG9CQUFBQSxDQVJBO0FBQUEsTUFXQSxpQkFBTSxPQUFOLEVBQVksS0FBWixDQVhBO0FBQUEsTUFhQSxPQUFBQyxDQUFBQSx3QkFBQUEsVUFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUEsY0FBQSxtQkFBQUMsT0FBQUEsQ0FBSSxNQUFKQSxDQUFBLFNBQWUsR0FBZjtBQURGRCxNQUFBQSxDQUFBQSxxQkFBQUEsQ0FBQUEsZ0JBYkE7QUFERixJQUFBLDRCQUFTRSxJQUFUO0FBREZQLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjIxMTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRmlsZSA8IElPXG4gIFNlcGFyYXRvciA9IFNFUEFSQVRPUiA9ICcvJ1xuICBBTFRfU0VQQVJBVE9SID0gbmlsXG4gIFBBVEhfU0VQQVJBVE9SID0gJzonXG4gICMgQXNzdW1pbmcgY2FzZSBpbnNlbnN0aXZlIGZpbGVzeXN0ZW1cbiAgRk5NX1NZU0NBU0UgPSAwXG4gIHdpbmRvd3Nfcm9vdF9yeCA9ICVye15bYS16QS1aXTooPzpcXFxcfFxcLyl9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuZXdfcGFydHMgPSBbXVxuXG4gICAgICBwYXRoID0gcGF0aC5yZXNwb25kX3RvPyg6dG9fcGF0aCkgPyBwYXRoLnRvX3BhdGggOiBwYXRoXG4gICAgICBiYXNlZGlyIHx8PSBEaXIucHdkXG4gICAgICBwYXRoX2FicyAgICA9IGBwYXRoLnN1YnN0cigwLCBzZXAubGVuZ3RoKSA9PT0gc2VwIHx8IHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpYFxuICAgICAgYmFzZWRpcl9hYnMgPSBgYmFzZWRpci5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKWBcblxuICAgICAgaWYgcGF0aF9hYnNcbiAgICAgICAgcGFydHMgICAgICAgPSBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpID8gJycgOiAje3BhdGguc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICBhYnMgICAgICAgICA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgcGFydHMgICAgICAgPSBiYXNlZGlyLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pICsgcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKSA/ICcnIDogI3tiYXNlZGlyLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSBiYXNlZGlyX2Fic1xuICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgcGFydDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwYXJ0ID09PSBuaWwpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJycgICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSkgfHxcbiAgICAgICAgICAgIChwYXJ0ID09PSAnLicgJiYgKChuZXdfcGFydHMubGVuZ3RoID09PSAwKSB8fCBhYnMpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWJzICYmIHBhcnRzWzBdICE9PSAnLicpIHtcbiAgICAgICAgICAje25ld19wYXJ0cy51bnNoaWZ0ICcuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdfcGF0aCA9IG5ld19wYXJ0cy5qb2luKHNlcClcbiAgICAgIG5ld19wYXRoID0gbGVhZGluZ19zZXAgKyBuZXdfcGF0aCBpZiBhYnNcbiAgICAgIG5ld19wYXRoXG4gICAgZW5kXG5cbiAgICBkZWYgZXhwYW5kX3BhdGgocGF0aCwgYmFzZWRpciA9IG5pbClcbiAgICAgIHNlcCA9IFNFUEFSQVRPUlxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIGlmIGBwYXRoWzBdID09PSAnficgfHwgKGJhc2VkaXIgJiYgYmFzZWRpclswXSA9PT0gJ34nKWBcbiAgICAgICAgaG9tZSA9IERpci5ob21lXG4gICAgICAgIHJhaXNlKEFyZ3VtZW50RXJyb3IsIFwiY291bGRuJ3QgZmluZCBIT01FIGVudmlyb25tZW50IC0tIGV4cGFuZGluZyBgfidcIikgdW5sZXNzIGhvbWVcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoaG9tZSkgPyAnJyA6ICN7aG9tZS5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIHJhaXNlKEFyZ3VtZW50RXJyb3IsICdub24tYWJzb2x1dGUgaG9tZScpIHVubGVzcyBob21lLnN0YXJ0X3dpdGg/KGxlYWRpbmdfc2VwKVxuXG4gICAgICAgIGhvbWUgICAgICAgICAgICArPSBzZXBcbiAgICAgICAgaG9tZV9wYXRoX3JlZ2V4cCA9IC9eXFx+KD86I3tzZXB9fCQpL1xuICAgICAgICBwYXRoICAgICAgICAgICAgID0gcGF0aC5zdWIoaG9tZV9wYXRoX3JlZ2V4cCwgaG9tZSlcbiAgICAgICAgYmFzZWRpciAgICAgICAgICA9IGJhc2VkaXIuc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpIGlmIGJhc2VkaXJcbiAgICAgIGVuZFxuICAgICAgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyKVxuICAgIGVuZFxuICAgIGFsaWFzIHJlYWxwYXRoIGV4cGFuZF9wYXRoXG5cbiAgICAleHtcbiAgICAgIC8vIENvZXJjZSBhIGdpdmVuIHBhdGggdG8gYSBwYXRoIHN0cmluZyB1c2luZyAjdG9fcGF0aCBhbmQgI3RvX3N0clxuICAgICAgZnVuY3Rpb24gJGNvZXJjZV90b19wYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKCN7T3BhbC50cnV0aHk/KGBwYXRoYC5yZXNwb25kX3RvPyg6dG9fcGF0aCkpfSkge1xuICAgICAgICAgIHBhdGggPSBwYXRoLiR0b19wYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gI3tPcGFsLmNvZXJjZV90byEoYHBhdGhgLCBTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGEgUmVnRXhwIGNvbXBhdGlibGUgY2hhciBjbGFzc1xuICAgICAgZnVuY3Rpb24gJHNlcF9jaGFycygpIHtcbiAgICAgICAgaWYgKCN7QUxUX1NFUEFSQVRPUn0gPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiBPcGFsLmVzY2FwZV9yZWdleHAoI3tTRVBBUkFUT1J9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gT3BhbC5lc2NhcGVfcmVnZXhwKCN7U0VQQVJBVE9SICsgQUxUX1NFUEFSQVRPUn0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVmIGRpcm5hbWUocGF0aClcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBwYXRoID0gYCRjb2VyY2VfdG9fcGF0aChwYXRoKWBcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWJzb2x1dGUgPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoI3tcIl5bI3tzZXBfY2hhcnN9XVwifSkpO1xuXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlcGFyYXRvcnNcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbXiN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIGJhc2VuYW1lXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiWyN7c2VwX2NoYXJzfV0rJFwifSksICcnKTsgLy8gcmVtb3ZlIGZpbmFsIHRyYWlsaW5nIHNlcGFyYXRvcnNcblxuICAgICAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gYWJzb2x1dGUgPyAnLycgOiAnLic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBiYXNlbmFtZShuYW1lLCBzdWZmaXggPSBuaWwpXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmFtZSA9IGAkY29lcmNlX3RvX3BhdGgobmFtZSlgXG4gICAgICAleHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWZmaXggIT09IG5pbCkge1xuICAgICAgICAgIHN1ZmZpeCA9ICN7T3BhbC5jb2VyY2VfdG8hKHN1ZmZpeCwgU3RyaW5nLCA6dG9fc3RyKX1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWZmaXggPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIoLilbI3tzZXBfY2hhcnN9XSokXCJ9KSwgJyQxJyk7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiXig/Oi4qWyN7c2VwX2NoYXJzfV0pPyhbXiN7c2VwX2NoYXJzfV0rKSRcIn0pLCAnJDEnKTtcblxuICAgICAgICBpZiAoc3VmZml4ID09PSBcIi4qXCIpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9cXC5bXlxcLl0rJC8sICcnKTtcbiAgICAgICAgfSBlbHNlIGlmKHN1ZmZpeCAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1ZmZpeCA9IE9wYWwuZXNjYXBlX3JlZ2V4cChzdWZmaXgpO1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiI3tzdWZmaXh9JFwifSksICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGV4dG5hbWUocGF0aClcbiAgICAgIGBwYXRoID0gJGNvZXJjZV90b19wYXRoKHBhdGgpYFxuICAgICAgZmlsZW5hbWUgPSBiYXNlbmFtZShwYXRoKVxuICAgICAgcmV0dXJuICcnIGlmIGZpbGVuYW1lLmVtcHR5P1xuICAgICAgbGFzdF9kb3RfaWR4ID0gZmlsZW5hbWVbMS4uLTFdLnJpbmRleCgnLicpXG4gICAgICAjIGV4dGVuc2lvbiBuYW1lIG11c3QgY29udGFpbnMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciAuKHNvbWV0aGluZylcbiAgICAgIGxhc3RfZG90X2lkeC5uaWw/IHx8IGxhc3RfZG90X2lkeCArIDEgPT0gZmlsZW5hbWUubGVuZ3RoIC0gMSA/ICcnIDogZmlsZW5hbWVbKGxhc3RfZG90X2lkeCArIDEpLi4tMV1cbiAgICBlbmRcblxuICAgIGRlZiBleGlzdD8ocGF0aClcbiAgICAgIGBPcGFsLm1vZHVsZXNbI3twYXRofV0gIT0gbnVsbGBcbiAgICBlbmRcbiAgICBhbGlhcyBleGlzdHM/IGV4aXN0P1xuXG4gICAgZGVmIGRpcmVjdG9yeT8ocGF0aClcbiAgICAgIGZpbGVzID0gW11cbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgICAgI3tmaWxlc30ucHVzaChrZXkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoLmdzdWIoLyheLiN7U0VQQVJBVE9SfSt8I3tTRVBBUkFUT1J9KyQpLylcbiAgICAgIGZpbGUgPSBmaWxlcy5maW5kIHsgfGZ8IGYgPX4gL14je3BhdGh9LyB9XG4gICAgICBmaWxlXG4gICAgZW5kXG5cbiAgICBkZWYgam9pbigqcGF0aHMpXG4gICAgICBpZiBwYXRocy5lbXB0eT9cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdCA9ICcnXG4gICAgICBwYXRocyA9IHBhdGhzLmZsYXR0ZW4uZWFjaF93aXRoX2luZGV4Lm1hcCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIGlmIGluZGV4ID09IDAgJiYgaXRlbS5lbXB0eT9cbiAgICAgICAgICBTRVBBUkFUT1JcbiAgICAgICAgZWxzaWYgcGF0aHMubGVuZ3RoID09IGluZGV4ICsgMSAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaXRlbVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcGF0aHMgPSBwYXRocy5yZWplY3QoJjplbXB0eT8pXG4gICAgICBwYXRocy5lYWNoX3dpdGhfaW5kZXggZG8gfGl0ZW0sIGluZGV4fFxuICAgICAgICBuZXh0X2l0ZW0gPSBwYXRoc1tpbmRleCArIDFdXG4gICAgICAgIGlmIG5leHRfaXRlbS5uaWw/XG4gICAgICAgICAgcmVzdWx0ID0gXCIje3Jlc3VsdH0je2l0ZW19XCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgJiYgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnN1YigvI3tTRVBBUkFUT1J9KyQvLCAnJylcbiAgICAgICAgICBlbmRcbiAgICAgICAgICByZXN1bHQgPSBpZiBpdGVtLmVuZF93aXRoPyhTRVBBUkFUT1IpIHx8IG5leHRfaXRlbS5zdGFydF93aXRoPyhTRVBBUkFUT1IpXG4gICAgICAgICAgICAgICAgICAgICBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfSN7U0VQQVJBVE9SfVwiXG4gICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICByZXN1bHRcbiAgICBlbmRcblxuICAgIGRlZiBzcGxpdChwYXRoKVxuICAgICAgcGF0aC5zcGxpdChTRVBBUkFUT1IpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIwIiwid2luZG93c19yb290X3J4IiwiYWJzb2x1dGVfcGF0aCIsInNlcCIsInNlcF9jaGFycyIsIm5ld19wYXJ0cyIsInBhdGgiLCJyZXNwb25kX3RvPyIsInRvX3BhdGgiLCJiYXNlZGlyIiwicHdkIiwicGF0aF9hYnMiLCJiYXNlZGlyX2FicyIsInBhcnRzIiwic3BsaXQiLCJsZWFkaW5nX3NlcCIsInN1YiIsImFicyIsIisiLCJ1bnNoaWZ0IiwibmV3X3BhdGgiLCJqb2luIiwiZXhwYW5kX3BhdGgiLCJob21lIiwicmFpc2UiLCJzdGFydF93aXRoPyIsImhvbWVfcGF0aF9yZWdleHAiLCJ0cnV0aHk/IiwiY29lcmNlX3RvISIsImRpcm5hbWUiLCJiYXNlbmFtZSIsIm5hbWUiLCJzdWZmaXgiLCJleHRuYW1lIiwiZmlsZW5hbWUiLCJlbXB0eT8iLCJsYXN0X2RvdF9pZHgiLCJbXSIsIjEiLCItMSIsInJpbmRleCIsIm5pbD8iLCI9PSIsIi0iLCJsZW5ndGgiLCJleGlzdD8iLCJkaXJlY3Rvcnk/IiwiZmlsZXMiLCJnc3ViIiwiZmlsZSIsImZpbmQiLCJmIiwiPX4iLCJwYXRocyIsInJlc3VsdCIsIm1hcCIsImZsYXR0ZW4iLCJlYWNoX3dpdGhfaW5k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LFVBQUE7QUFBQTtBQUdFLFlBQUEsSUFBQSxRQUFHLGNBQUFLLElBQUFHLGNBQUFBLENBQWUseUJBQWZBLENBQUEsSUFBNkJELFNBQUFwQyxnQkFBQUEsQ0FBc0IseUJBQXRCQSxDQUE3QixNQUFILENBQUE7QUFBQSxjQUNFa0MsT0FBT0EsSUFBQTNDLEtBQUFBLENBQVMsaUJBQUcsaUNBQUgsR0FBa0IsRUFBM0JBLENBRFQsQ0FBQTtBQUFBLFlBR0EsT0FBQXNDLENBQUFBLFNBQVMsYUFBQSxJQUFBLFFBQUcsY0FBQUssSUFBQUcsY0FBQUEsQ0FBZSx5QkFBZkEsQ0FBQSxTQUE2QkQsU0FBQXBDLGdCQUFBQSxDQUFzQix5QkFBdEJBLENBQTdCLENBQUgsQ0FBQTtBQUFBLGNBQ0UsT0FBQSxFQUFBLEdBQUEsQ0FBRzZCLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVo7QUFERixZQUFBO0FBQUEsY0FHRSxPQUFBLEVBQUEsR0FBQSxDQUFHTCxNQUFILENBQUEsR0FBQSxDQUFZSyxJQUFaLENBQUEsR0FBQSxDQUFtQix5QkFBbkI7QUFIRixZQUFBLENBQUEsa0JBQVRMLENBSEE7QUFIRixVQUFBLENBNUxSLENBQUEsbUJBQUEsa0JBQUEsTUEwTE1HLENBMUxOO0FBQUEsUUF5TU0sT0FBQUgsTUF6TU47QUEyS0lqQyxNQUFBQSxDQUFBQSxzQkFBQUEsQ0FqS0E7QUFBQSxNQWtNQSxPQUFBUCxDQUFBQSx5QkFBQUEsWUFBQUEsaUJBQVUsSUFBVkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQVIsSUFBQVEsT0FBQUEsQ0FBVyx5QkFBWEE7QUFERkEsTUFBQUEsQ0FBQUEsdUJBQUFBLENBQUFBLGlCQWxNQTtBQURGLElBQUEsNEJBQVNpRCxJQUFULFlBUEE7QUFERmhFLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWEsa0JBQWJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjI0MjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Byb2Nlc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUHJvY2Vzc1xuICBAX19jbG9ja3NfXyA9IFtdXG4gIGRlZiBzZWxmLl9fcmVnaXN0ZXJfY2xvY2tfXyhuYW1lLCBmdW5jKVxuICAgIGNvbnN0X3NldCBuYW1lLCBAX19jbG9ja3NfXy5zaXplXG4gICAgQF9fY2xvY2tzX18gPDwgZnVuY1xuICBlbmRcblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18gOkNMT0NLX1JFQUxUSU1FLCBgZnVuY3Rpb24oKSB7IHJldHVybiBEYXRlLm5vdygpIH1gXG5cbiAgbW9ub3RvbmljID0gZmFsc2VcblxuICAleHtcbiAgICBpZiAoT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UpIHtcbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKE9wYWwuZ2xvYmFsLnByb2Nlc3MgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICAgIC8vIGxldCBub3cgYmUgdGhlIGJhc2UgdG8gZ2V0IHNtYWxsZXIgbnVtYmVyc1xuICAgICAgdmFyIGhydGltZV9iYXNlID0gcHJvY2Vzcy5ocnRpbWUoKTtcblxuICAgICAgbW9ub3RvbmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBocnRpbWUgPSBwcm9jZXNzLmhydGltZShocnRpbWVfYmFzZSk7XG4gICAgICAgIHZhciB1cyA9IChocnRpbWVbMV0gLyAxMDAwKSB8IDA7IC8vIGN1dCBiZWxvdyBtaWNyb3NlY3M7XG4gICAgICAgIHJldHVybiAoKGhydGltZVswXSAqIDEwMDApICsgKHVzIC8gMTAwMCkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18oOkNMT0NLX01PTk9UT05JQywgbW9ub3RvbmljKSBpZiBtb25vdG9uaWNcblxuICBkZWYgc2VsZi5waWRcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRpbWVzXG4gICAgdCA9IFRpbWUubm93LnRvX2ZcbiAgICBCZW5jaG1hcms6OlRtcy5uZXcodCwgdCwgdCwgdCwgdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xvY2tfZ2V0dGltZShjbG9ja19pZCwgdW5pdCA9IDpmbG9hdF9zZWNvbmQpXG4gICAgKGNsb2NrID0gQF9fY2xvY2tzX19bY2xvY2tfaWRdKSB8fCByYWlzZShFcnJubzo6RUlOVkFMLCBcImNsb2NrX2dldHRpbWUoI3tjbG9ja19pZH0pICN7QF9fY2xvY2tzX19bY2xvY2tfaWRdfVwiKVxuICAgICV4e1xuICAgICAgdmFyIG1zID0gY2xvY2soKTtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlICdmbG9hdF9zZWNvbmQnOiAgICAgIHJldHVybiAgKG1zIC8gMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYSBmbG9hdCAoZGVmYXVsdClcbiAgICAgICAgY2FzZSAnZmxvYXRfbWlsbGlzZWNvbmQnOiByZXR1cm4gIChtcyAvIDEpOyAgICAgICAgICAgIC8vIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdmbG9hdF9taWNyb3NlY29uZCc6IHJldHVybiAgKG1zICogMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhIGZsb2F0XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgICAgICAgcmV0dXJuICgobXMgLyAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgLyAxKSAgICAgICB8IDApOyAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAqIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzogICAgICAgIHJldHVybiAoKG1zICogMTAwMDAwMCkgfCAwKTsgLy8gbnVtYmVyIG9mIG5hbm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgZGVmYXVsdDogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdW5pdDogI3t1bml0fVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgU2lnbmFsXG4gIGRlZiBzZWxmLnRyYXAoKilcbiAgZW5kXG5lbmRcblxuY2xhc3MgR0NcbiAgZGVmIHNlbGYuc3RhcnRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIkBfX2Nsb2Nrc19fIiwiX19yZWdpc3Rlcl9jbG9ja19fIiwic2VsZiIsImNvbnN0X3NldCIsIm5hbWUiLCJzaXplIiwiPDwiLCJmdW5jIiwibW9ub3RvbmljIiwicGlkIiwiMCIsInRpbWVzIiwidCIsIm5vdyIsInRvX2YiLCJuZXciLCJjbG9ja19nZXR0aW1lIiwiY2xvY2siLCJbXSIsImNsb2NrX2lkIiwicmFpc2UiLCJ1bml0IiwidHJhcCIsInN0YXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsa0JBQWMsRUFBZDtBQUFBLElBQ0FDLFVBQUlDLElBQUpELHlCQUFBQSxnQ0FBQUEsOEJBQTRCLElBQUQsRUFBTyxJQUFsQ0E7QUFBQUEsTUFBQUE7QUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUUsV0FBQUEsQ0FBVUMsTUFBTUosZUFBQUssTUFBQUEsQ0FBQUEsQ0FBaEJGLENBQUE7QUFBQSxNQUNBLE9BQUFILGVBQUFNLE9BQUFBLENBQWVDLElBQWZELENBREE7QUFERkwsSUFBQUEsQ0FBQUEsMkNBQUFBLENBREE7QUFBQSxRQU1BQSxvQkFBQUEsQ0FBbUIsa0JBQWtCLGdDQUFyQ0EsQ0FOQTtBQUFBLElBUUFPLFlBQVksS0FSWjtBQUFBO0FBV0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQTFCRTtBQUFBLElBNEJBLElBQUEsUUFBbURBLFNBQW5ELENBQUE7QUFBQSxVQUFBUCxvQkFBQUEsQ0FBbUIsbUJBQWtCTyxTQUFyQ1AsQ0FBQSxDQTVCQTtBQUFBLElBOEJBUSxVQUFJUCxJQUFKTyxVQUFBQSxpQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUM7QUFERkQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBOUJBO0FBQUEsSUFrQ0FFLFVBQUlULElBQUpTLFlBQUFBLG1CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsSUFBSSxvQkFBQUMsS0FBQUEsQ0FBQUEsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0FBSjtBQUFBLE1BQ0EsT0FBQSxJQUFBLHlCQUFBLFFBQUFDLEtBQUFBLENBQW1CSCxHQUFHQSxHQUFHQSxHQUFHQSxHQUFHQSxDQUEvQkcsQ0FEQTtBQURGSixJQUFBQSxDQUFBQSw4QkFBQUEsQ0FsQ0E7QUFBQSxJQXVDQSxPQUFBSyxDQUFBQSxVQUFJZCxJQUFKYyxvQkFBQUEsMkJBQUFBLHlCQUF1QixRQUFELEVBQVcsSUFBakNBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQXpDRjtBQXlDbUMsTUFBQTtBQUFBLE1BQUEsU0FBTyxjQUFQO0FBQUEsTUFBQSxDQXpDbkM7QUFBQSxNQTBDSSxjQUFDQyxDQUFBQSxRQUFRakIsZUFBQWtCLE9BQUFBLENBQVlDLFFBQVpELENBQVJELENBQUQsYUFBbUNHLE9BQUFBLENBQU0sSUFBQSxxQkFBQSxhQUFlLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCRCxRQUFqQixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQThCbkIsZUFBQWtCLE9BQUFBLENBQVlDLFFBQVpELENBQTlCLENBQXJCRSxDQUFuQyxDQTFDSjtBQUFBO0FBNENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFtQkEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsbUJBQUEsR0FBQSxDQUFvQkMsSUFBcEIsQ0FBckJEO0FBQ25CO0FBQ0EsSUF2REE7QUF5Q0VKLElBQUFBLENBQUFBLHVDQUFBQSxDQUFBQSx5QkF2Q0E7QUFERmpCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBQUE7QUFBQSxFQTBEQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUF1QixDQUFBQSxVQUFJcEIsSUFBSm9CLFdBQUFBLGlCQUFBQSxnQkE1REYsRUE0REVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTVERjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxPQUFBLEdBQUE7QUE0REVBLElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQTtBQURGdkIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0ExREE7QUFBQSxFQStEQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQXdCLENBQUFBLFVBQUlyQixJQUFKcUIsWUFBQUEsY0FBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQWpFRixPQUFBO0FBaUVFQSxJQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQUE7QUFERnhCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBL0RBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjI1MjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSYW5kb21cbiAgYXR0cl9yZWFkZXIgOnNlZWQsIDpzdGF0ZVxuXG4gIGRlZiBpbml0aWFsaXplKHNlZWQgPSBSYW5kb20ubmV3X3NlZWQpXG4gICAgc2VlZCA9IE9wYWwuY29lcmNlX3RvIShzZWVkLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgIEBzdGF0ZSA9IHNlZWRcbiAgICByZXNlZWQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIHJlc2VlZChzZWVkKVxuICAgIEBzZWVkID0gc2VlZFxuICAgIGBzZWxmLiRybmcgPSBPcGFsLiQkcmFuZC5yZXNlZWQoc2VlZClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ld19zZWVkXG4gICAgYE9wYWwuJCRyYW5kLm5ld19zZWVkKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgREVGQVVMVC5yYW5kKGxpbWl0KVxuICBlbmRcblxuICBkZWYgc2VsZi5zcmFuZChuID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcblxuICAgIHByZXZpb3VzX3NlZWQgPSBERUZBVUxULnNlZWRcbiAgICBERUZBVUxULnJlc2VlZChuKVxuICAgIHByZXZpb3VzX3NlZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJhbmRvbShzaXplKVxuICAgIHNpemUgPSBPcGFsLmNvZXJjZV90byEoc2l6ZSwgSW50ZWdlciwgOnRvX2ludClcblxuICAgIGlmIHNpemUgPCAwXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgc3RyaW5nIHNpemUgKG9yIHNpemUgdG9vIGJpZyknXG4gICAgZW5kXG5cbiAgICBBcnJheS5uZXcoc2l6ZSkgeyByYW5kKDI1NSkuY2hyIH0uam9pbi5lbmNvZGUoJ0FTQ0lJLThCSVQnKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBSYW5kb20gPT09IG90aGVyXG5cbiAgICBzZWVkID09IG90aGVyLnNlZWQgJiYgc3RhdGUgPT0gb3RoZXIuc3RhdGVcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzKGxlbmd0aClcbiAgICBsZW5ndGggPSBPcGFsLmNvZXJjZV90byEobGVuZ3RoLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgQXJyYXkubmV3KGxlbmd0aCkgeyByYW5kKDI1NSkuY2hyIH0uam9pbi5lbmNvZGUoJ0FTQ0lJLThCSVQnKVxuICBlbmRcblxuICBkZWYgcmFuZChsaW1pdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIHJhbmRvbUZsb2F0KCkge1xuICAgICAgICBzZWxmLnN0YXRlKys7XG4gICAgICAgIHJldHVybiBPcGFsLiQkcmFuZC5yYW5kKHNlbGYuJHJuZyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJhbmRvbUludCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZG9tRmxvYXQoKSAqIGxpbWl0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmFuZG9tUmFuZ2UoKSB7XG4gICAgICAgIHZhciBtaW4gPSBsaW1pdC5iZWdpbixcbiAgICAgICAgICAgIG1heCA9IGxpbWl0LmVuZDtcblxuICAgICAgICBpZiAobWluID09PSBuaWwgfHwgbWF4ID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IG1heCAtIG1pbjtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggJSAxID09PSAwICYmIG1pbiAlIDEgPT09IDAgJiYgIWxpbWl0LmV4Y2wpIHtcbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLiRyYW5kKGxlbmd0aCkgKyBtaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpO1xuICAgICAgfSBlbHNlIGlmIChsaW1pdC4kJGlzX3JhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5kb21SYW5nZSgpO1xuICAgICAgfSBlbHNlIGlmIChsaW1pdC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCAlIDEgPT09IDApIHtcbiAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUludCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByYW5kb21GbG9hdCgpICogbGltaXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbWl0ID0gI3tPcGFsLmNvZXJjZV90byEobGltaXQsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5kb21JbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmdlbmVyYXRvcj0oZ2VuZXJhdG9yKVxuICAgIGBPcGFsLiQkcmFuZCA9ICN7Z2VuZXJhdG9yfWBcblxuICAgIGlmIGNvbnN0X2RlZmluZWQ/IDpERUZBVUxUXG4gICAgICBERUZBVUxULnJlc2VlZFxuICAgIGVsc2VcbiAgICAgIGNvbnN0X3NldCA6REVGQVVMVCwgbmV3KG5ld19zZWVkKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwibmV3X3NlZWQiLCJzZWVkIiwiY29lcmNlX3RvISIsIkBzdGF0ZSIsInJlc2VlZCIsIkBzZWVkIiwic2VsZiIsInJhbmQiLCJsaW1pdCIsInNyYW5kIiwibiIsInByZXZpb3VzX3NlZWQiLCJ1cmFuZG9tIiwic2l6ZSIsIjwiLCIwIiwicmFpc2UiLCJuZXciLCIyNTUiLCJjaHIiLCJqb2luIiwiZW5jb2RlIiwiPT0iLCI9PT0iLCJvdGhlciIsInN0YXRlIiwiYnl0ZXMiLCJsZW5ndGgiLCJnZW5lcmF0b3I9IiwiZ2VuZXJhdG9yIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9zZXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLGFBQUFBLENBQVksUUFBTyxPQUFuQkEsQ0FBQTtBQUFBO0FBRUFDLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQWUsSUFBZkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBSkY7QUFJaUIsTUFBQTtBQUFBLE1BQUEsU0FBTyxzQkFBQUMsVUFBQUEsQ0FBQUEsQ0FBUDtBQUFBLE1BQUEsQ0FKakI7QUFBQSxNQUtJQyxPQUFPLG9CQUFBQyxlQUFBQSxDQUFnQkQsTUFBTSx5QkFBUyxRQUEvQkMsQ0FMWDtBQUFBLE1BTUlDLGFBQVNGLElBTmI7QUFBQSxNQU9JLFdBQUFHLFFBQUFBLENBQU9ILElBQVBHLENBUEo7QUFJRUwsSUFBQUEsQ0FBQUEsbUNBQUFBLENBRkE7QUFBQTtBQVFBSyxJQUFBQSwwQkFBQUEsbUJBQUFBLGtCQUFXLElBQVhBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLFlBQVFKLElBQVI7QUFBQSxNQUNBLE9BQUMsb0NBQUQsQ0FEQTtBQURGRyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FSQTtBQUFBLElBYUFKLFVBQUlNLElBQUpOLGVBQUFBLHFCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxzQkFBRDtBQURGQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FiQTtBQUFBLElBaUJBTyxVQUFJRCxJQUFKQyxXQUFBQSxpQkFBQUEsZ0JBQWMsS0FBZEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbkJGLE1BQUE7QUFBQSxNQW9CSSxPQUFBLHVCQUFBQSxNQUFBQSxDQUFhQyxLQUFiRCxDQXBCSjtBQW1CRUEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBakJBO0FBQUEsSUFxQkFFLFVBQUlILElBQUpHLFlBQUFBLGtCQUFBQSxpQkFBZSxDQUFmQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUF2QkY7QUF1QmlCLE1BQUE7QUFBQSxNQUFBLE1BQUksc0JBQUFULFVBQUFBLENBQUFBLENBQUo7QUFBQSxNQUFBLENBdkJqQjtBQUFBLE1Bd0JJVSxJQUFJLG9CQUFBUixlQUFBQSxDQUFnQlEsR0FBRyx5QkFBUyxRQUE1QlIsQ0F4QlI7QUFBQSxNQTBCSVMsZ0JBQWdCLHVCQUFBVixNQUFBQSxDQUFBQSxDQTFCcEI7QUFBQSxNQTJCSSx1QkFBQUcsUUFBQUEsQ0FBZU0sQ0FBZk4sQ0EzQko7QUFBQSxNQTRCSSxPQUFBTyxhQTVCSjtBQXVCRUYsSUFBQUEsQ0FBQUEsOEJBQUFBLENBckJBO0FBQUEsSUE2QkFHLFVBQUlOLElBQUpNLGNBQUFBLG9CQUFBQSxtQkFBaUIsSUFBakJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLE9BQU8sb0JBQUFYLGVBQUFBLENBQWdCVyxNQUFNLHlCQUFTLFFBQS9CWCxDQUFQO0FBQUEsTUFFQSxJQUFBLFFBQUdZLE9BQUFELElBQUFDLEVBQU9DLENBQVBELENBQUgsQ0FBQTtBQUFBLFlBQ0VFLE9BQUFBLENBQU0sK0JBQWUsd0NBQXJCQSxDQURGLENBRkE7QUFBQSxNQU1BLE9BQUFDLE1BQUEscUJBQUFBLE9BQUFBLEVBQUFBLENBQVVKLElBQVZJLENBQUFBLEVBdENKLGdCQUFBLEVBQUE7O0FBQUEsTUFzQ3NCLFdBQUFWLE1BQUFBLENBQUtXLEdBQUxYLENBQUFZLEtBQUFBLENBQUFBLENBdEN0QixrQkFBQSxpQkFBQSxLQXNDSUYsQ0FBQUcsTUFBQUEsQ0FBQUEsQ0FBQUMsUUFBQUEsQ0FBOEMsWUFBOUNBLENBTkE7QUFERlQsSUFBQUEsQ0FBQUEsK0JBQUFBLENBN0JBO0FBQUE7QUF1Q0FVLElBQUFBLHNCQUFBQSxtQkFBQUEsU0FBTyxLQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQUEsUUFBb0Isc0JBQUFDLFFBQUFBLENBQVdDLEtBQVhELENBQXBCLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPO0FBQVAsTUFBQSxDQUFBO0FBQUEsTUFFQSxPQUFBLFdBQUF0QixNQUFBQSxDQUFBQSxDQUFBcUIsT0FBQUEsQ0FBUUUsS0FBQXZCLE1BQUFBLENBQUFBLENBQVJxQixDQUFBLFFBQXNCRyxPQUFBQSxDQUFBQSxDQUFBSCxPQUFBQSxDQUFTRSxLQUFBQyxPQUFBQSxDQUFBQSxDQUFUSCxDQUF0QixPQUFBckIsTUFBQUEsQ0FBQUEsQ0FBQXFCLE9BQUFBLENBQVFFLEtBQUF2QixNQUFBQSxDQUFBQSxDQUFScUIsQ0FBQSxDQUZBO0FBREZBLElBQUFBLENBQUFBLDhCQUFBQSxDQXZDQTtBQUFBO0FBNkNBSSxJQUFBQSx5QkFBQUEsa0JBQUFBLGlCQUFVLE1BQVZBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLFNBQVMsb0JBQUF6QixlQUFBQSxDQUFnQnlCLFFBQVEseUJBQVMsUUFBakN6QixDQUFUO0FBQUEsTUFFQSxPQUFBZSxNQUFBLHFCQUFBQSxPQUFBQSxFQUFBQSxDQUFVVSxNQUFWVixDQUFBQSxFQWxESixpQkFBQSxFQUFBOztBQUFBLE1Ba0R3QixXQUFBVixNQUFBQSxDQUFLVyxHQUFMWCxDQUFBWSxLQUFBQSxDQUFBQSxDQWxEeEIsbUJBQUEsa0JBQUEsTUFrRElGLENBQUFHLE1BQUFBLENBQUFBLENBQUFDLFFBQUFBLENBQWdELFlBQWhEQSxDQUZBO0FBREZLLElBQUFBLENBQUFBLDZCQUFBQSxDQTdDQTtBQUFBO0FBbURBbkIsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBUyxLQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFyREYsTUFBQTtBQUFBO0FBdURBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBWVMsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEscUJBQUEsR0FBQSxDQUFzQlIsS0FBdEIsQ0FBckJRO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBa0Isb0JBQUFkLGVBQUFBLENBQWdCTSxPQUFPLHlCQUFTLFFBQWhDTixDQUF5Qzs7QUFFM0Q7QUFDQSxjQUFZYyxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxxQkFBQSxHQUFBLENBQXNCUixLQUF0QixDQUFyQlE7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsSUFqSEE7QUFxREVULElBQUFBLENBQUFBLDhCQUFBQSxDQW5EQTtBQUFBLElBa0hBLE9BQUFxQixDQUFBQSxVQUFJdEIsSUFBSnNCLGlCQUFBQSwwQkFBQUEsU0FBb0IsU0FBcEJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUMsY0FBZ0JDLFNBQWpCO0FBQUEsTUFFQSxJQUFBLFlBQUdDLG1CQUFBQSxDQUFlLFNBQWZBLENBQUgsQ0FBQTtBQUFBLFFBQ0UsT0FBQSx1QkFBQTFCLFFBQUFBLENBQUFBO0FBREYsTUFBQTtBQUFBLFFBR0UsV0FBQTJCLFdBQUFBLENBQVUsZUFBVWQsS0FBQUEsS0FBSWpCLFVBQUFBLENBQUFBLENBQUppQixDQUFwQmM7QUFIRixNQUFBLENBRkE7QUFERkgsSUFBQUEsQ0FBQUEscUNBQUFBLENBQUFBLHNCQWxIQTtBQURGL0IsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMjcwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL01lcnNlbm5lVHdpc3Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuVGhpcyBpcyBiYXNlZCBvbiBhbiBhZGFwdGF0aW9uIG9mIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEncyBjb2RlXG5kb25lIGJ5IFNlYW4gTWNDdWxsb3VnaCA8YmFua3NlYW5AZ21haWwuY29tPiBhbmQgRGF2ZSBIZWl0em1hblxuPGRhdmVoZWl0em1hbkB5YWhvby5jb20+LCBzdWJzZXF1ZW50bHkgcmVhZGFwdGVkIGZyb20gYW4gdXBkYXRlZCB2ZXJzaW9uIG9mXG5ydWJ5J3MgcmFuZG9tLmMgKHJldiBjMzhhMTgzMDMyYTc4MjZkZjFhZGFiZDhhYTA3MjVjNzEzZDUzZTFjKS5cblxuVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZnJvbSByYW5kb20uYyBmb2xsb3dzLlxuXG4gIFRoaXMgaXMgYmFzZWQgb24gdHJpbW1lZCB2ZXJzaW9uIG9mIE1UMTk5MzcuICBUbyBnZXQgdGhlIG9yaWdpbmFsIHZlcnNpb24sXG4gIGNvbnRhY3QgPGh0dHA6Ly93d3cubWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAvfm0tbWF0L01UL2VtdC5odG1sPi5cblxuICBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IG5vdGljZSBmb2xsb3dzLlxuXG4gICAgIEEgQy1wcm9ncmFtIGZvciBNVDE5OTM3LCB3aXRoIGluaXRpYWxpemF0aW9uIGltcHJvdmVkIDIwMDIvMi8xMC5cbiAgICAgQ29kZWQgYnkgVGFrdWppIE5pc2hpbXVyYSBhbmQgTWFrb3RvIE1hdHN1bW90by5cbiAgICAgVGhpcyBpcyBhIGZhc3RlciB2ZXJzaW9uIGJ5IHRha2luZyBTaGF3biBDb2t1cydzIG9wdGltaXphdGlvbixcbiAgICAgTWF0dGhlIEJlbGxldydzIHNpbXBsaWZpY2F0aW9uLCBJc2FrdSBXYWRhJ3MgcmVhbCB2ZXJzaW9uLlxuXG4gICAgIEJlZm9yZSB1c2luZywgaW5pdGlhbGl6ZSB0aGUgc3RhdGUgYnkgdXNpbmcgaW5pdF9nZW5yYW5kKG10LCBzZWVkKVxuICAgICBvciBpbml0X2J5X2FycmF5KG10LCBpbml0X2tleSwga2V5X2xlbmd0aCkuXG5cbiAgICAgQ29weXJpZ2h0IChDKSAxOTk3IC0gMjAwMiwgTWFrb3RvIE1hdHN1bW90byBhbmQgVGFrdWppIE5pc2hpbXVyYSxcbiAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgIGFyZSBtZXQ6XG5cbiAgICAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAgICAzLiBUaGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlXG4gICAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXG4gICAgICAgICAgcGVybWlzc2lvbi5cblxuICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gICAgIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAgICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gICAgIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuICAgICBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAgICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICAgICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAgICAgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cblxuICAgICBBbnkgZmVlZGJhY2sgaXMgdmVyeSB3ZWxjb21lLlxuICAgICBodHRwOi8vd3d3Lm1hdGgua2Vpby5hYy5qcC9tYXR1bW90by9lbXQuaHRtbFxuICAgICBlbWFpbDogbWF0dW1vdG9AbWF0aC5rZWlvLmFjLmpwXG4qL1xudmFyIE1lcnNlbm5lVHdpc3RlciA9IChmdW5jdGlvbigpIHtcbiAgLyogUGVyaW9kIHBhcmFtZXRlcnMgKi9cbiAgdmFyIE4gPSA2MjQ7XG4gIHZhciBNID0gMzk3O1xuICB2YXIgTUFUUklYX0EgPSAweDk5MDhiMGRmOyAgICAgIC8qIGNvbnN0YW50IHZlY3RvciBhICovXG4gIHZhciBVTUFTSyA9IDB4ODAwMDAwMDA7ICAgICAgICAgLyogbW9zdCBzaWduaWZpY2FudCB3LXIgYml0cyAqL1xuICB2YXIgTE1BU0sgPSAweDdmZmZmZmZmOyAgICAgICAgIC8qIGxlYXN0IHNpZ25pZmljYW50IHIgYml0cyAqL1xuICB2YXIgTUlYQklUUyA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKCAoKHUpICYgVU1BU0spIHwgKCh2KSAmIExNQVNLKSApOyB9O1xuICB2YXIgVFdJU1QgPSBmdW5jdGlvbih1LHYpIHsgcmV0dXJuIChNSVhCSVRTKCh1KSwodikpID4+PiAxKSBeICgodiAmIDB4MSkgPyBNQVRSSVhfQSA6IDB4MCk7IH07XG5cbiAgZnVuY3Rpb24gaW5pdChzKSB7XG4gICAgdmFyIG10ID0ge2xlZnQ6IDAsIG5leHQ6IE4sIHN0YXRlOiBuZXcgQXJyYXkoTil9O1xuICAgIGluaXRfZ2VucmFuZChtdCwgcyk7XG4gICAgcmV0dXJuIG10O1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZXMgbXRbTl0gd2l0aCBhIHNlZWQgKi9cbiAgZnVuY3Rpb24gaW5pdF9nZW5yYW5kKG10LCBzKSB7XG4gICAgdmFyIGosIGk7XG4gICAgbXQuc3RhdGVbMF0gPSBzID4+PiAwO1xuICAgIGZvciAoaj0xOyBqPE47IGorKykge1xuICAgICAgbXQuc3RhdGVbal0gPSAoMTgxMjQzMzI1MyAqICgobXQuc3RhdGVbai0xXSBeIChtdC5zdGF0ZVtqLTFdID4+IDMwKSA+Pj4gMCkpICsgaik7XG4gICAgICAvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cbiAgICAgIC8qIEluIHRoZSBwcmV2aW91cyB2ZXJzaW9ucywgTVNCcyBvZiB0aGUgc2VlZCBhZmZlY3QgICAqL1xuICAgICAgLyogb25seSBNU0JzIG9mIHRoZSBhcnJheSBzdGF0ZVtdLiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cbiAgICAgIG10LnN0YXRlW2pdICY9IDB4ZmZmZmZmZmY7ICAvKiBmb3IgPjMyIGJpdCBtYWNoaW5lcyAqL1xuICAgIH1cbiAgICBtdC5sZWZ0ID0gMTtcbiAgICBtdC5uZXh0ID0gTjtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlIE4gd29yZHMgYXQgb25lIHRpbWUgKi9cbiAgZnVuY3Rpb24gbmV4dF9zdGF0ZShtdCkge1xuICAgIHZhciBwID0gMCwgX3AgPSBtdC5zdGF0ZTtcbiAgICB2YXIgajtcblxuICAgIG10LmxlZnQgPSBOO1xuICAgIG10Lm5leHQgPSAwO1xuXG4gICAgZm9yIChqPU4tTSsxOyAtLWo7IHArKylcbiAgICAgIF9wW3BdID0gX3BbcCsoTSldIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgZm9yIChqPU07IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbcCsoMSldKTtcblxuICAgIF9wW3BdID0gX3BbcCsoTS1OKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wWzBdKTtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cbiAgZnVuY3Rpb24gZ2VucmFuZF9pbnQzMihtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgeTtcblxuICAgIGlmICgtLW10LmxlZnQgPD0gMCkgbmV4dF9zdGF0ZShtdCk7XG4gICAgeSA9IG10LnN0YXRlW210Lm5leHQrK107XG5cbiAgICAvKiBUZW1wZXJpbmcgKi9cbiAgICB5IF49ICh5ID4+PiAxMSk7XG4gICAgeSBePSAoeSA8PCA3KSAmIDB4OWQyYzU2ODA7XG4gICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgIHkgXj0gKHkgPj4+IDE4KTtcblxuICAgIHJldHVybiB5ID4+PiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYikge1xuICAgIGEgPj4+PSA1O1xuICAgIGIgPj4+PSA2O1xuICAgIHJldHVybihhKjY3MTA4ODY0LjArYikqKDEuMC85MDA3MTk5MjU0NzQwOTkyLjApO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKSB3aXRoIDUzLWJpdCByZXNvbHV0aW9uXG4gIGZ1bmN0aW9uIGdlbnJhbmRfcmVhbChtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgYSA9IGdlbnJhbmRfaW50MzIobXQpLCBiID0gZ2VucmFuZF9pbnQzMihtdCk7XG4gICAgcmV0dXJuIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpO1xuICB9XG5cbiAgcmV0dXJuIHsgZ2VucmFuZF9yZWFsOiBnZW5yYW5kX3JlYWwsIGluaXQ6IGluaXQgfTtcbn0pKCk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3JhbmRvbS9NZXJzZW5uZVR3aXN0ZXIuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVFO0FBQ0E7O0FBRUE7O0FBRUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFRTtBQUNHOztBQUVIO0FBQ0c7QUFDQTs7QUFFSDtBQUNHO0FBQ0E7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0w7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVGO0FBQ0U7O0FBRUY7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0EifX0seyJvZmZzZXQiOnsibGluZSI6MjI4NDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS9tZXJzZW5uZV90d2lzdGVyLmpzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL01lcnNlbm5lVHdpc3RlcidcblxuY2xhc3MgUmFuZG9tXG4gIGB2YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE1hdGgucG93KDIsIDUzKSAtIDFgXG5cbiAgTUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IgPSBge1xuICAgIG5ld19zZWVkOiBmdW5jdGlvbigpIHsgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE1BWF9JTlQpOyB9LFxuICAgIHJlc2VlZDogZnVuY3Rpb24oc2VlZCkgeyByZXR1cm4gTWVyc2VubmVUd2lzdGVyLmluaXQoc2VlZCk7IH0sXG4gICAgcmFuZDogZnVuY3Rpb24obXQpIHsgcmV0dXJuIE1lcnNlbm5lVHdpc3Rlci5nZW5yYW5kX3JlYWwobXQpOyB9XG4gIH1gXG5cbiAgc2VsZi5nZW5lcmF0b3IgPSBNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUlxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiJHdyaXRlciIsImdlbmVyYXRvcj0iLCJzZWxmIiwiLSIsIjEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsZ0NBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLDREQUFEO0FBQUEsSUFFQSwwREFBOEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FKRSxDQUZBO0FBQUE7QUFKRixJQUFBQyxVQUFBLENBWW1CLDBDQVpuQixDQUFBO0FBQUEsSUFZRUMsTUFBQUMsSUFBQUQsY0FBQUEsRUFaRixVQUFBRCxPQUFBLENBWUVDLENBWkY7QUFBQSxJQUFBLE9BQUFELE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBSUU7QUFERkosRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyODcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi91bnN1cHBvcnRlZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgdmFyIHdhcm5pbmdzID0ge307XG5cbiAgZnVuY3Rpb24gaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUobWVzc2FnZSkge1xuICAgIHN3aXRjaCAoT3BhbC5jb25maWcudW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHkpIHtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICAje0tlcm5lbC5yYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgbWVzc2FnZWB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHdhcm4obWVzc2FnZSlcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIGlnbm9yZVxuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oc3RyaW5nKSB7XG4gICAgaWYgKHdhcm5pbmdzW3N0cmluZ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nc1tzdHJpbmddID0gdHJ1ZTtcbiAgICAje3dhcm4oYHN0cmluZ2ApfTtcbiAgfVxufVxuXG5jbGFzcyBTdHJpbmdcbiAgYHZhciBFUlJPUiA9IFwiU3RyaW5nIyVzIG5vdCBzdXBwb3J0ZWQuIE11dGFibGUgU3RyaW5nIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gT3BhbC5cImBcblxuICBkZWYgPDwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJzw8J1xuICBlbmRcblxuICBkZWYgY2FwaXRhbGl6ZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NhcGl0YWxpemUhJ1xuICBlbmRcblxuICBkZWYgY2hvbXAhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdjaG9tcCEnXG4gIGVuZFxuXG4gIGRlZiBjaG9wISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnY2hvcCEnXG4gIGVuZFxuXG4gIGRlZiBkb3duY2FzZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2Rvd25jYXNlISdcbiAgZW5kXG5cbiAgZGVmIGdzdWIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdnc3ViISdcbiAgZW5kXG5cbiAgZGVmIGxzdHJpcCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2xzdHJpcCEnXG4gIGVuZFxuXG4gIGRlZiBuZXh0ISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnbmV4dCEnXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncmV2ZXJzZSEnXG4gIGVuZFxuXG4gIGRlZiBzbGljZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3NsaWNlISdcbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzcXVlZXplISdcbiAgZW5kXG5cbiAgZGVmIHN0cmlwISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3RyaXAhJ1xuICBlbmRcblxuICBkZWYgc3ViISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3ViISdcbiAgZW5kXG5cbiAgZGVmIHN1Y2MhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzdWNjISdcbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3dhcGNhc2UhJ1xuICBlbmRcblxuICBkZWYgdHIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd0ciEnXG4gIGVuZFxuXG4gIGRlZiB0cl9zISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndHJfcyEnXG4gIGVuZFxuXG4gIGRlZiB1cGNhc2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd1cGNhc2UhJ1xuICBlbmRcblxuICBkZWYgcHJlcGVuZCgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncHJlcGVuZCdcbiAgZW5kXG5cbiAgZGVmIFtdPSgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnW109J1xuICBlbmRcblxuICBkZWYgY2xlYXIoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NsZWFyJ1xuICBlbmRcblxuICBkZWYgZW5jb2RlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnZW5jb2RlISdcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndW5pY29kZV9ub3JtYWxpemUhJ1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCBmcmVlemluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgZnJlZXplXG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCB0YWludGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgdGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVudGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRhaW50ZWQ/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgZGVmIHB1YmxpYygqbWV0aG9kcylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBwcml2YXRlIHB1YmxpY1xuXG4gIGFsaWFzIHByb3RlY3RlZCBwdWJsaWNcblxuICBhbGlhcyBuZXN0aW5nIHB1YmxpY1xuXG4gIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZCgqKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgcHVibGljX2NsYXNzX21ldGhvZCBwcml2YXRlX2NsYXNzX21ldGhvZFxuXG4gIGRlZiBwcml2YXRlX21ldGhvZF9kZWZpbmVkPyhvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfY29uc3RhbnQoKilcbiAgZW5kXG5cbiAgYWxpYXMgcHJvdGVjdGVkX21ldGhvZF9kZWZpbmVkPyBwcml2YXRlX21ldGhvZF9kZWZpbmVkP1xuXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2RzIGluc3RhbmNlX21ldGhvZHNcblxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kIGluc3RhbmNlX21ldGhvZFxuXG4gIGFsaWFzIHB1YmxpY19tZXRob2RfZGVmaW5lZD8gbWV0aG9kX2RlZmluZWQ/XG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgcHJpdmF0ZV9tZXRob2RzKCopXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgcHJpdmF0ZV9pbnN0YW5jZV9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIGV2YWwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9ibG9iLyN7UlVCWV9FTkdJTkVfVkVSU0lPTn0vZG9jcy9vcGFsX3BhcnNlci5tZCBmb3IgZGV0YWlscy5cIlxuICBlbmRcbmVuZFxuXG5kZWYgc2VsZi5wdWJsaWMoKilcbiAgIyBzdHViXG5lbmRcblxuZGVmIHNlbGYucHJpdmF0ZSgqKVxuICAjIHN0dWJcbmVuZFxuIl0sIm5hbWVzIjpbInJhaXNlIiwid2FybiIsImNsYXNzIiwiPDwiLCIlIiwiY2FwaXRhbGl6ZSEiLCJjaG9tcCEiLCJjaG9wISIsImRvd25jYXNlISIsImdzdWIhIiwibHN0cmlwISIsIm5leHQhIiwicmV2ZXJzZSEiLCJzbGljZSEiLCJzcXVlZXplISIsInN0cmlwISIsInN1YiEiLCJzdWNjISIsInN3YXBjYXNlISIsInRyISIsInRyX3MhIiwidXBjYXNlISIsInByZXBlbmQiLCJbXT0iLCJjbGVhciIsImVuY29kZSEiLCJ1bmljb2RlX25vcm1hbGl6ZSEiLCJtb2R1bGUiLCJmcmVlemUiLCJzZWxmIiwiZnJvemVuPyIsInRhaW50IiwidW50YWludCIsInRhaW50ZWQ/IiwicHVibGljIiwicHJpdmF0ZV9jbGFzc19tZXRob2QiLCJwcml2YXRlX21ldGhvZF9kZWZpbmVkPyIsInByaXZhdGVfY29uc3RhbnQiLCJwcml2YXRlX21ldGhvZHMiLCJldmFsIiwicHJpdmF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFRLHNCQUFBQSxPQUFBQSxDQUFhLHFDQUFzQixPQUFuQ0E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTUMsTUFBQUEsQ0FBTSxNQUFOQSxDQUFlO0FBQ3JCO0FBdkJBO0FBQUEsRUEwQkFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLHdGQUFEO0FBQUE7QUFFQUMsSUFBQUEsc0JBQUFBLG1CQUFBQSxTQTlCRixFQThCRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOUJGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQStCSSxXQUFBSCxPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxJQUFWQSxDQUEzQkosQ0EvQko7QUE4QkVHLElBQUFBLENBQUFBLCtCQUFBQSxDQUZBO0FBQUE7QUFNQUUsSUFBQUEsK0JBQUFBLDRCQUFBQSxTQWxDRixFQWtDRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbENGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQW1DSSxXQUFBTCxPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxhQUFWQSxDQUEzQkosQ0FuQ0o7QUFrQ0VLLElBQUFBLENBQUFBLHdDQUFBQSxDQU5BO0FBQUE7QUFVQUMsSUFBQUEsMEJBQUFBLHVCQUFBQSxTQXRDRixFQXNDRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBdENGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQXVDSSxXQUFBTixPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxRQUFWQSxDQUEzQkosQ0F2Q0o7QUFzQ0VNLElBQUFBLENBQUFBLG1DQUFBQSxDQVZBO0FBQUE7QUFjQUMsSUFBQUEseUJBQUFBLHNCQUFBQSxTQTFDRixFQTBDRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBMUNGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQTJDSSxXQUFBUCxPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxPQUFWQSxDQUEzQkosQ0EzQ0o7QUEwQ0VPLElBQUFBLENBQUFBLGtDQUFBQSxDQWRBO0FBQUE7QUFrQkFDLElBQUFBLDZCQUFBQSwwQkFBQUEsU0E5Q0YsRUE4Q0VBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTlDRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUErQ0ksV0FBQVIsT0FBQUEsQ0FBTSxxQ0FBcUIsQ0FBQyxLQUFELENBQUFJLE1BQUFBLENBQVUsV0FBVkEsQ0FBM0JKLENBL0NKO0FBOENFUSxJQUFBQSxDQUFBQSxzQ0FBQUEsQ0FsQkE7QUFBQTtBQXNCQUMsSUFBQUEseUJBQUFBLHNCQUFBQSxTQWxERixFQWtERUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbERGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQW1ESSxXQUFBVCxPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxPQUFWQSxDQUEzQkosQ0FuREo7QUFrREVTLElBQUFBLENBQUFBLGtDQUFBQSxDQXRCQTtBQUFBO0FBMEJBQyxJQUFBQSwyQkFBQUEsd0JBQUFBLFNBdERGLEVBc0RFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUF0REY7QUFBQSxNQUFBLDREQUFBO0FBQUEsTUFBQTtBQUFBLE1BdURJLFdBQUFWLE9BQUFBLENBQU0scUNBQXFCLENBQUMsS0FBRCxDQUFBSSxNQUFBQSxDQUFVLFNBQVZBLENBQTNCSixDQXZESjtBQXNERVUsSUFBQUEsQ0FBQUEsb0NBQUFBLENBMUJBO0FBQUE7QUE4QkFDLElBQUFBLHlCQUFBQSxzQkFBQUEsU0ExREYsRUEwREVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTFERjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUEyREksV0FBQVgsT0FBQUEsQ0FBTSxxQ0FBcUIsQ0FBQyxLQUFELENBQUFJLE1BQUFBLENBQVUsT0FBVkEsQ0FBM0JKLENBM0RKO0FBMERFVyxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0E5QkE7QUFBQTtBQWtDQUMsSUFBQUEsNEJBQUFBLHlCQUFBQSxTQTlERixFQThERUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOURGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQStESSxXQUFBWixPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxVQUFWQSxDQUEzQkosQ0EvREo7QUE4REVZLElBQUFBLENBQUFBLHFDQUFBQSxDQWxDQTtBQUFBO0FBc0NBQyxJQUFBQSwwQkFBQUEsd0JBQUFBLFNBbEVGLEVBa0VFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFsRUY7QUFBQSxNQUFBLDREQUFBO0FBQUEsTUFBQTtBQUFBLE1BbUVJLFdBQUFiLE9BQUFBLENBQU0scUNBQXFCLENBQUMsS0FBRCxDQUFBSSxNQUFBQSxDQUFVLFFBQVZBLENBQTNCSixDQW5FSjtBQWtFRWEsSUFBQUEsQ0FBQUEsb0NBQUFBLENBdENBO0FBQUE7QUEwQ0FDLElBQUFBLDRCQUFBQSwwQkFBQUEsU0F0RUYsRUFzRUVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXRFRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUF1RUksV0FBQWQsT0FBQUEsQ0FBTSxxQ0FBcUIsQ0FBQyxLQUFELENBQUFJLE1BQUFBLENBQVUsVUFBVkEsQ0FBM0JKLENBdkVKO0FBc0VFYyxJQUFBQSxDQUFBQSxzQ0FBQUEsQ0ExQ0E7QUFBQTtBQThDQUMsSUFBQUEsMEJBQUFBLHdCQUFBQSxTQTFFRixFQTBFRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBMUVGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQTJFSSxXQUFBZixPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxRQUFWQSxDQUEzQkosQ0EzRUo7QUEwRUVlLElBQUFBLENBQUFBLG9DQUFBQSxDQTlDQTtBQUFBO0FBa0RBQyxJQUFBQSx3QkFBQUEsc0JBQUFBLFNBOUVGLEVBOEVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE5RUY7QUFBQSxNQUFBLDREQUFBO0FBQUEsTUFBQTtBQUFBLE1BK0VJLFdBQUFoQixPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxNQUFWQSxDQUEzQkosQ0EvRUo7QUE4RUVnQixJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FsREE7QUFBQTtBQXNEQUMsSUFBQUEseUJBQUFBLHVCQUFBQSxTQWxGRixFQWtGRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbEZGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQW1GSSxXQUFBakIsT0FBQUEsQ0FBTSxxQ0FBcUIsQ0FBQyxLQUFELENBQUFJLE1BQUFBLENBQVUsT0FBVkEsQ0FBM0JKLENBbkZKO0FBa0ZFaUIsSUFBQUEsQ0FBQUEsbUNBQUFBLENBdERBO0FBQUE7QUEwREFDLElBQUFBLDZCQUFBQSwyQkFBQUEsU0F0RkYsRUFzRkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXRGRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUF1RkksV0FBQWxCLE9BQUFBLENBQU0scUNBQXFCLENBQUMsS0FBRCxDQUFBSSxNQUFBQSxDQUFVLFdBQVZBLENBQTNCSixDQXZGSjtBQXNGRWtCLElBQUFBLENBQUFBLHVDQUFBQSxDQTFEQTtBQUFBO0FBOERBQyxJQUFBQSx1QkFBQUEscUJBQUFBLFNBMUZGLEVBMEZFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUExRkY7QUFBQSxNQUFBLDREQUFBO0FBQUEsTUFBQTtBQUFBLE1BMkZJLFdBQUFuQixPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxLQUFWQSxDQUEzQkosQ0EzRko7QUEwRkVtQixJQUFBQSxDQUFBQSxpQ0FBQUEsQ0E5REE7QUFBQTtBQWtFQUMsSUFBQUEseUJBQUFBLHVCQUFBQSxTQTlGRixFQThGRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOUZGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQStGSSxXQUFBcEIsT0FBQUEsQ0FBTSxxQ0FBcUIsQ0FBQyxLQUFELENBQUFJLE1BQUFBLENBQVUsT0FBVkEsQ0FBM0JKLENBL0ZKO0FBOEZFb0IsSUFBQUEsQ0FBQUEsbUNBQUFBLENBbEVBO0FBQUE7QUFzRUFDLElBQUFBLDJCQUFBQSx5QkFBQUEsU0FsR0YsRUFrR0VBO0FBQUFBLE1BQUFBOztBQUFBQTtBQWxHRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFtR0ksV0FBQXJCLE9BQUFBLENBQU0scUNBQXFCLENBQUMsS0FBRCxDQUFBSSxNQUFBQSxDQUFVLFNBQVZBLENBQTNCSixDQW5HSjtBQWtHRXFCLElBQUFBLENBQUFBLHFDQUFBQSxDQXRFQTtBQUFBO0FBMEVBQyxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQXRHRixFQXNHRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBdEdGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQXVHSSxXQUFBdEIsT0FBQUEsQ0FBTSxxQ0FBcUIsQ0FBQyxLQUFELENBQUFJLE1BQUFBLENBQVUsU0FBVkEsQ0FBM0JKLENBdkdKO0FBc0dFc0IsSUFBQUEsQ0FBQUEsaUNBQUFBLENBMUVBO0FBQUE7QUE4RUFDLElBQUFBLHVCQUFBQSxtQkFBQUEsU0ExR0YsRUEwR0VBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTFHRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUEyR0ksV0FBQXZCLE9BQUFBLENBQU0scUNBQXFCLENBQUMsS0FBRCxDQUFBSSxNQUFBQSxDQUFVLEtBQVZBLENBQTNCSixDQTNHSjtBQTBHRXVCLElBQUFBLENBQUFBLCtCQUFBQSxDQTlFQTtBQUFBO0FBa0ZBQyxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQTlHRixFQThHRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOUdGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQStHSSxXQUFBeEIsT0FBQUEsQ0FBTSxxQ0FBcUIsQ0FBQyxLQUFELENBQUFJLE1BQUFBLENBQVUsT0FBVkEsQ0FBM0JKLENBL0dKO0FBOEdFd0IsSUFBQUEsQ0FBQUEsK0JBQUFBLENBbEZBO0FBQUE7QUFzRkFDLElBQUFBLDJCQUFBQSx5QkFBQUEsU0FsSEYsRUFrSEVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQWxIRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFtSEksV0FBQXpCLE9BQUFBLENBQU0scUNBQXFCLENBQUMsS0FBRCxDQUFBSSxNQUFBQSxDQUFVLFNBQVZBLENBQTNCSixDQW5ISjtBQWtIRXlCLElBQUFBLENBQUFBLHFDQUFBQSxDQXRGQTtBQUFBLElBMEZBLE9BQUFDLENBQUFBLHNDQUFBQSxvQ0FBQUEsU0F0SEYsRUFzSEVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXRIRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUF1SEksV0FBQTFCLE9BQUFBLENBQU0scUNBQXFCLENBQUMsS0FBRCxDQUFBSSxNQUFBQSxDQUFVLG9CQUFWQSxDQUEzQkosQ0F2SEo7QUFzSEUwQixJQUFBQSxDQUFBQSxnREFBQUEsQ0FBQUEsOEJBMUZBO0FBREZ4QixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQTFCQTtBQUFBLEVBMEhBeUI7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsc0RBQUQ7QUFBQTtBQUVBQyxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFDLGlDQUFEO0FBQUEsTUFDQSxPQUFBQyxJQURBO0FBREZELElBQUFBLENBQUFBLCtCQUFBQSxDQUZBO0FBQUE7QUFPQUUsSUFBQUEsMkJBQUFBLHlCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFDLGlDQUFEO0FBQUEsTUFDQSxPQUFBLEtBREE7QUFERkEsSUFBQUEsQ0FBQUEsb0NBQUFBLENBUEE7QUFERkgsRUFBQUEsR0FBQUEsV0FBQUEsV0ExSEE7QUFBQSxFQXdJQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsc0RBQUQ7QUFBQTtBQUVBSSxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFDLGlDQUFEO0FBQUEsTUFDQSxPQUFBRixJQURBO0FBREZFLElBQUFBLENBQUFBLDhCQUFBQSxDQUZBO0FBQUE7QUFPQUMsSUFBQUEsMkJBQUFBLHFCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQyxpQ0FBRDtBQUFBLE1BQ0EsT0FBQUgsSUFEQTtBQURGRyxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FQQTtBQUFBO0FBWUFDLElBQUFBLDRCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQyxpQ0FBRDtBQUFBLE1BQ0EsT0FBQSxLQURBO0FBREZBLElBQUFBLENBQUFBLHFDQUFBQSxDQVpBO0FBREZOLEVBQUFBLEdBQUFBLFdBQUFBLFdBeElBO0FBQUEsRUEySkF6QjtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFBQWdDLElBQUFBLDBCQUFBQSxvQkFBQUEsU0E3SkYsRUE2SkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTdKRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQTZKYSxNQUFBLHFCQTdKYjtBQUFBO0FBK0pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBcEtBO0FBNkpFQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FBQTtBQUFBLElBVUEsaUJBQU0sU0FBTixFQUFjLFFBQWQsQ0FWQTtBQUFBLElBWUEsaUJBQU0sV0FBTixFQUFnQixRQUFoQixDQVpBO0FBQUEsSUFjQSxpQkFBTSxTQUFOLEVBQWMsUUFBZCxDQWRBO0FBQUE7QUFnQkFDLElBQUFBLHdDQUFBQSxrQ0FBQUEsZ0NBN0tGLEVBNktFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE3S0Y7QUFBQSxNQUFBLDREQUFBO0FBQUEsTUFBQTtBQUFBLE1BOEtJLE9BQUFOLElBOUtKO0FBNktFTSxJQUFBQSxDQUFBQSw4Q0FBQUEsQ0FoQkE7QUFBQSxJQW9CQSxpQkFBTSxxQkFBTixFQUEwQixzQkFBMUIsQ0FwQkE7QUFBQTtBQXNCQUMsSUFBQUEsMkNBQUFBLHlDQUFBQSxTQUE0QixHQUE1QkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSxvREFBQUEsQ0F0QkE7QUFBQTtBQTBCQUMsSUFBQUEsb0NBQUFBLDhCQUFBQSw0QkF2TEYsRUF1TEVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXZMRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxPQUFBLEdBQUE7QUF1TEVBLElBQUFBLENBQUFBLDBDQUFBQSxDQTFCQTtBQUFBLElBNkJBLGlCQUFNLDJCQUFOLEVBQWdDLHlCQUFoQyxDQTdCQTtBQUFBLElBK0JBLGlCQUFNLHlCQUFOLEVBQThCLGtCQUE5QixDQS9CQTtBQUFBLElBaUNBLGlCQUFNLHdCQUFOLEVBQTZCLGlCQUE3QixDQWpDQTtBQUFBLElBbUNBLE9BQUEsaUJBQU0sd0JBQU4sRUFBNkIsaUJBQTdCLENBbkNBO0FBREZuQyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQTNKQTtBQUFBLEVBa01BeUI7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQUFXLElBQUFBLG1DQUFBQSw2QkFBQUEsMkJBcE1GLEVBb01FQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFwTUY7QUFBQSxNQUFBLDREQUFBO0FBQUEsTUFBQTtBQUFBLE1BcU1JLE9BQUEsRUFyTUo7QUFvTUVBLElBQUFBLENBQUFBLHlDQUFBQSxDQUFBO0FBQUEsSUFJQSxpQkFBTSwwQkFBTixFQUErQixpQkFBL0IsQ0FKQTtBQURGWCxFQUFBQSxHQUFBQSxXQUFBQSxXQWxNQTtBQUFBLEVBME1BQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0VZLElBQUFBLHdCQUFBQSxrQkFBQUEsU0E1TUYsRUE0TUVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTVNRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUE2TUksV0FBQXZDLE9BQUFBLENBQU0scUNBQXFCLEVBQUEsR0FBQSw0REFBQSxHQUFBLENBQ0EsRUFBQSxHQUFBLHdDQUFBLEdBQUEsQ0FBeUMsbUNBQXpDLENBQUEsR0FBQSxtQ0FEQSxDQUEzQkEsQ0E3TUo7QUE0TUV1QyxJQUFBQSxDQUFBQSw4QkFBQUE7QUFERlosRUFBQUEsR0FBQUEsV0FBQUEsV0ExTUE7QUFBQSxFQWlOQU8sVUFBSUwsSUFBSkssYUFBQUEsYUFBQUEsU0FsTkEsRUFrTkFBO0FBQUFBLElBQUFBOztBQUFBQTtBQWxOQTtBQUFBLElBQUEsNERBQUE7QUFBQSxJQUFBO0FBQUEsSUFBQSxPQUFBLEdBQUE7QUFrTkFBLEVBQUFBLENBQUFBLHlCQUFBQSxDQWpOQTtBQUFBLEVBcU5BLE9BQUFNLENBQUFBLFVBQUlYLElBQUpXLGNBQUFBLGNBQUFBLFNBdE5BLEVBc05BQTtBQUFBQSxJQUFBQTs7QUFBQUE7QUF0TkE7QUFBQSxJQUFBLDREQUFBO0FBQUEsSUFBQTtBQUFBLElBQUEsT0FBQSxHQUFBO0FBc05BQSxFQUFBQSxDQUFBQSwwQkFBQUEsQ0FBQUEsbUJBck5BOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjMzMDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29wYWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnb3BhbC9iYXNlJ1xucmVxdWlyZSAnb3BhbC9taW5pJ1xuXG5yZXF1aXJlICdjb3JlbGliL2tlcm5lbC9mb3JtYXQnXG5yZXF1aXJlICdjb3JlbGliL3N0cmluZy9lbmNvZGluZydcbnJlcXVpcmUgJ2NvcmVsaWIvbWF0aCdcbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleCdcbnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwnXG5yZXF1aXJlICdjb3JlbGliL3RpbWUnXG5yZXF1aXJlICdjb3JlbGliL3N0cnVjdCdcbnJlcXVpcmUgJ2NvcmVsaWIvaW8nXG5yZXF1aXJlICdjb3JlbGliL21haW4nXG5yZXF1aXJlICdjb3JlbGliL2RpcidcbnJlcXVpcmUgJ2NvcmVsaWIvZmlsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcHJvY2VzcydcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tJ1xucmVxdWlyZSAnY29yZWxpYi9yYW5kb20vbWVyc2VubmVfdHdpc3Rlci5qcydcblxucmVxdWlyZSAnY29yZWxpYi91bnN1cHBvcnRlZCdcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFdBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLFdBQVJBLENBREE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLHVCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSx5QkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FMQTtBQUFBLE1BTUFBLFNBQUFBLENBQVEsaUJBQVJBLENBTkE7QUFBQSxNQU9BQSxTQUFBQSxDQUFRLGtCQUFSQSxDQVBBO0FBQUEsTUFRQUEsU0FBQUEsQ0FBUSxjQUFSQSxDQVJBO0FBQUEsTUFTQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FUQTtBQUFBLE1BVUFBLFNBQUFBLENBQVEsWUFBUkEsQ0FWQTtBQUFBLE1BV0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FYQTtBQUFBLE1BWUFBLFNBQUFBLENBQVEsYUFBUkEsQ0FaQTtBQUFBLE1BYUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FiQTtBQUFBLE1BY0FBLFNBQUFBLENBQVEsaUJBQVJBLENBZEE7QUFBQSxNQWVBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWZBO0FBQUEsTUFnQkFBLFNBQUFBLENBQVEsb0NBQVJBLENBaEJBO0FBQUEsRUFrQkEsV0FBQUEsU0FBQUEsQ0FBUSxxQkFBUkEsQ0FsQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzMzMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vbmF0aXZlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgUHJvdmlkZXMgYSBjb21wbGV0ZSBzZXQgb2YgdG9vbHMgdG8gd3JhcCBuYXRpdmUgSmF2YVNjcmlwdFxuIyBpbnRvIG5pY2UgUnVieSBvYmplY3RzLlxuI1xuIyBAZXhhbXBsZVxuI1xuIyAgICQkLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3AnKS5jbGFzc0xpc3QuYWRkKCdibHVlJylcbiMgICAjID0+IGFkZHMgXCJibHVlXCIgY2xhc3MgdG8gPHA+XG4jXG4jICAgJCQubG9jYXRpb24uaHJlZiA9ICdodHRwczovL2dvb2dsZS5jb20nXG4jICAgIyA9PiBjaGFuZ2VzIHBhZ2UgbG9jYXRpb25cbiNcbiMgICBkb19sYXRlciA9ICQkWzpzZXRUaW1lb3V0XSAjIEFjY2Vzc2luZyB0aGUgXCJzZXRUaW1lb3V0XCIgcHJvcGVydHlcbiMgICBkb19sYXRlci5jYWxsKC0+eyBwdXRzIDpoZWxsb30sIDUwMClcbiNcbiMgYCQkYCBhbmQgYCRnbG9iYWxgIHdyYXAgYE9wYWwuZ2xvYmFsYCwgd2hpY2ggdGhlIE9wYWwgSlMgcnVudGltZVxuIyBzZXRzIHRvIHRoZSBnbG9iYWwgYHRoaXNgIG9iamVjdC5cbiNcbm1vZHVsZSBOYXRpdmVcbiAgZGVmIHNlbGYuaXNfYT8ob2JqZWN0LCBrbGFzcylcbiAgICAleHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAje29iamVjdH0gaW5zdGFuY2VvZiAje3RyeV9jb252ZXJ0KGtsYXNzKX07XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydCh2YWx1ZSwgZGVmYXVsdCA9IG5pbClcbiAgICAleHtcbiAgICAgIGlmICgje25hdGl2ZT8odmFsdWUpfSkge1xuICAgICAgICByZXR1cm4gI3t2YWx1ZX07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/IDp0b19ufSkge1xuICAgICAgICByZXR1cm4gI3t2YWx1ZS50b19ufTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tkZWZhdWx0fTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnZlcnQodmFsdWUpXG4gICAgJXh7XG4gICAgICBpZiAoI3tuYXRpdmU/KHZhbHVlKX0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWV9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fbn0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWUudG9fbn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7dmFsdWUuaW5zcGVjdH0gaXNuJ3QgbmF0aXZlXCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2FsbChvYmosIGtleSwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBwcm9wID0gI3tvYmp9WyN7a2V5fV07XG5cbiAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGNvbnZlcnRlZCA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gYXJnc1tpXSxcbiAgICAgICAgICAgICAgY29udiA9ICN7dHJ5X2NvbnZlcnQoYGl0ZW1gKX07XG5cbiAgICAgICAgICBjb252ZXJ0ZWRbaV0gPSBjb252ID09PSBuaWwgPyBpdGVtIDogY29udjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgY29udmVydGVkLnB1c2goYmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBwcm9wLmFwcGx5KCN7b2JqfSwgY29udmVydGVkKWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tOYXRpdmUoYHByb3BgKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5wcm9jKCZibG9jaylcbiAgICByYWlzZSBMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgIDo6S2VybmVsLnByb2MgeyB8KmFyZ3N8XG4gICAgICBhcmdzLm1hcCEgeyB8YXJnfCBOYXRpdmUoYXJnKSB9XG4gICAgICBpbnN0YW5jZSA9IE5hdGl2ZShgdGhpc2ApXG5cbiAgICAgICV4e1xuICAgICAgICAvLyBpZiBnbG9iYWwgaXMgY3VycmVudCBzY29wZSwgcnVuIHRoZSBibG9jayBpbiB0aGUgc2NvcGUgaXQgd2FzIGRlZmluZWRcbiAgICAgICAgaWYgKHRoaXMgPT09IE9wYWwuZ2xvYmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KHNlbGYsICN7YXJnc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGZfID0gYmxvY2suJCRzO1xuICAgICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmFwcGx5KCN7aW5zdGFuY2V9LCAje2FyZ3N9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBibG9jay4kJHMgPSBzZWxmXztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIEhlbHBlcnNcbiAgICAjIEV4cG9zZXMgYSBuYXRpdmUgSmF2YVNjcmlwdCBtZXRob2QgdG8gUnVieVxuICAgICNcbiAgICAjXG4gICAgIyBAcGFyYW0gbmV3IFtTdHJpbmddXG4gICAgIyAgICAgICBUaGUgbmFtZSBvZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXRob2QuXG4gICAgI1xuICAgICMgQHBhcmFtIG9sZCBbU3RyaW5nXVxuICAgICMgICAgICAgVGhlIG5hbWUgb2YgdGhlIG5hdGl2ZSBKYXZhU2NyaXB0IG1ldGhvZCB0byBiZSBleHBvc2VkLlxuICAgICMgICAgICAgSWYgdGhlIG5hbWUgZW5kcyB3aXRoIFwiPVwiIChlLmcuIGBmb289YCkgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhc1xuICAgICMgICAgICAgYSBwcm9wZXJ0eSBzZXR0ZXIuIChkZWZhdWx0OiB0aGUgdmFsdWUgb2YgXCJuZXdcIilcbiAgICAjXG4gICAgIyBAcGFyYW0gYXMgW0NsYXNzXVxuICAgICMgICAgICAgSWYgcHJvdmlkZWQgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgb3JpZ2luYWwgbWV0aG9kIHdpbGwgYmVcbiAgICAjICAgICAgIHJldHVybmVkIGFzIGluc3RhbmNlcyBvZiB0aGUgcGFzc2VkIGNsYXNzLiBUaGUgY2xhc3MgcGFzc2VkIHRvIFwiYXNcIlxuICAgICMgICAgICAgaXMgZXhwZWN0ZWQgdG8gYWNjZXB0IGEgbmF0aXZlIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgI1xuICAgICMgQGV4YW1wbGVcbiAgICAjXG4gICAgIyAgIGNsYXNzIEVsZW1lbnRcbiAgICAjICAgICBleHRlbmQgTmF0aXZlOjpIZWxwZXJzXG4gICAgI1xuICAgICMgICAgIGFsaWFzX25hdGl2ZSA6YWRkX2NsYXNzLCA6YWRkQ2xhc3NcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOnNob3dcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOmhpZGVcbiAgICAjXG4gICAgIyAgICAgZGVmIGluaXRpYWxpemUoc2VsZWN0b3IpXG4gICAgIyAgICAgICBAbmF0aXZlID0gYCQoI3tzZWxlY3Rvcn0pYFxuICAgICMgICAgIGVuZFxuICAgICMgICBlbmRcbiAgICAjXG4gICAgIyAgIHRpdGxlcyA9IEVsZW1lbnQubmV3KCdoMScpXG4gICAgIyAgIHRpdGxlcy5hZGRfY2xhc3MgOmZvb1xuICAgICMgICB0aXRsZXMuaGlkZVxuICAgICMgICB0aXRsZXMuc2hvd1xuICAgICNcbiAgICBkZWYgYWxpYXNfbmF0aXZlKG5ldywgb2xkID0gbmV3LCBhczogbmlsKVxuICAgICAgaWYgb2xkLmVuZF93aXRoPyAnPSdcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfHZhbHVlfFxuICAgICAgICAgIGAje0BuYXRpdmV9WyN7b2xkWzAuLi0yXX1dID0gI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9YFxuXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBhc1xuICAgICAgICBkZWZpbmVfbWV0aG9kIG5ldyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICAgICB2YWx1ZSA9IE5hdGl2ZS5jYWxsKEBuYXRpdmUsIG9sZCwgKmFyZ3MsICZibG9jaylcbiAgICAgICAgICBpZiB2YWx1ZVxuICAgICAgICAgICAgYXMubmV3KHZhbHVlLnRvX24pXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBkZWZpbmVfbWV0aG9kIG5ldyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICAgICBOYXRpdmUuY2FsbChAbmF0aXZlLCBvbGQsICphcmdzLCAmYmxvY2spXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbmF0aXZlX3JlYWRlcigqbmFtZXMpXG4gICAgICBuYW1lcy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG9cbiAgICAgICAgICBOYXRpdmUoYCN7QG5hdGl2ZX1bbmFtZV1gKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIG5hdGl2ZV93cml0ZXIoKm5hbWVzKVxuICAgICAgbmFtZXMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgICAgIE5hdGl2ZShgI3tAbmF0aXZlfVtuYW1lXSA9IHZhbHVlYClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBuYXRpdmVfYWNjZXNzb3IoKm5hbWVzKVxuICAgICAgbmF0aXZlX3JlYWRlcigqbmFtZXMpXG4gICAgICBuYXRpdmVfd3JpdGVyKCpuYW1lcylcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIFdyYXBwZXJcbiAgICBkZWYgaW5pdGlhbGl6ZShuYXRpdmUpXG4gICAgICB1bmxlc3MgOjpLZXJuZWwubmF0aXZlPyhuYXRpdmUpXG4gICAgICAgIDo6S2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tuYXRpdmUuaW5zcGVjdH0gaXNuJ3QgbmF0aXZlXCJcbiAgICAgIGVuZFxuXG4gICAgICBAbmF0aXZlID0gbmF0aXZlXG4gICAgZW5kXG5cbiAgICAjIFJldHVybnMgdGhlIGludGVybmFsIG5hdGl2ZSBKYXZhU2NyaXB0IHZhbHVlXG4gICAgZGVmIHRvX25cbiAgICAgIEBuYXRpdmVcbiAgICBlbmRcblxuICAgIGRlZiBzZWxmLmluY2x1ZGVkKGtsYXNzKVxuICAgICAga2xhc3MuZXh0ZW5kIEhlbHBlcnNcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5jbHVkZWQoYmFzZSlcbiAgICB3YXJuICdJbmNsdWRpbmcgOjpOYXRpdmUgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyIGluc3RlYWQuJ1xuICAgIGJhc2UuaW5jbHVkZSBXcmFwcGVyXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIG5hdGl2ZT8odmFsdWUpXG4gICAgYHZhbHVlID09IG51bGwgfHwgIXZhbHVlLiQkY2xhc3NgXG4gIGVuZFxuXG4gICMgV3JhcHMgYSBuYXRpdmUgSmF2YVNjcmlwdCB3aXRoIGBOYXRpdmU6Ok9iamVjdC5uZXdgXG4gICNcbiAgIyBAcmV0dXJuIFtOYXRpdmU6Ok9iamVjdF0gVGhlIHdyYXBwZWQgb2JqZWN0IGlmIGl0IGlzIG5hdGl2ZVxuICAjIEByZXR1cm4gW25pbF0gZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgIyBAcmV0dXJuIFtvYmpdIFRoZSBvYmplY3QgaXRzZWxmIGlmIGl0J3Mgbm90IG5hdGl2ZVxuICBkZWYgTmF0aXZlKG9iailcbiAgICBpZiBgI3tvYmp9ID09IG51bGxgXG4gICAgICBuaWxcbiAgICBlbHNpZiBuYXRpdmU/KG9iailcbiAgICAgIE5hdGl2ZTo6T2JqZWN0Lm5ldyhvYmopXG4gICAgZWxzaWYgb2JqLmlzX2E/KEFycmF5KVxuICAgICAgb2JqLm1hcCBkbyB8b3xcbiAgICAgICAgTmF0aXZlKG8pXG4gICAgICBlbmRcbiAgICBlbHNpZiBvYmouaXNfYT8oUHJvYylcbiAgICAgIHByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgIE5hdGl2ZShvYmouY2FsbCgqYXJncywgJmJsb2NrKSlcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIG9ialxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBfQXJyYXkgQXJyYXlcblxuICAjIFdyYXBzIGFycmF5LWxpa2UgSmF2YVNjcmlwdCBvYmplY3RzIGluIE5hdGl2ZTo6QXJyYXlcbiAgZGVmIEFycmF5KG9iamVjdCwgKmFyZ3MsICZibG9jaylcbiAgICBpZiBuYXRpdmU/KG9iamVjdClcbiAgICAgIHJldHVybiBOYXRpdmU6OkFycmF5Lm5ldyhvYmplY3QsICphcmdzLCAmYmxvY2spLnRvX2FcbiAgICBlbmRcbiAgICBfQXJyYXkob2JqZWN0KVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOYXRpdmU6Ok9iamVjdCA8IEJhc2ljT2JqZWN0XG4gIGluY2x1ZGUgOjpOYXRpdmU6OldyYXBwZXJcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYCN7QG5hdGl2ZX0gPT09ICN7OjpOYXRpdmUudHJ5X2NvbnZlcnQob3RoZXIpfWBcbiAgZW5kXG5cbiAgZGVmIGhhc19rZXk/KG5hbWUpXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbCgje0BuYXRpdmV9LCAje25hbWV9KWBcbiAgZW5kXG5cbiAgYWxpYXMga2V5PyBoYXNfa2V5P1xuICBhbGlhcyBpbmNsdWRlPyBoYXNfa2V5P1xuICBhbGlhcyBtZW1iZXI/IGhhc19rZXk/XG5cbiAgZGVmIGVhY2goKmFyZ3MpXG4gICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluICN7QG5hdGl2ZX0pIHtcbiAgICAgICAgICAje3lpZWxkIGBrZXlgLCBgI3tAbmF0aXZlfVtrZXldYH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmXG4gICAgZWxzZVxuICAgICAgbWV0aG9kX21pc3NpbmcoOmVhY2gsICphcmdzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW10oa2V5KVxuICAgICV4e1xuICAgICAgdmFyIHByb3AgPSAje0BuYXRpdmV9W2tleV07XG5cbiAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7OjpOYXRpdmUuY2FsbChAbmF0aXZlLCBrZXkpfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShrZXksIHZhbHVlKVxuICAgIG5hdGl2ZSA9IDo6TmF0aXZlLnRyeV9jb252ZXJ0KHZhbHVlKVxuXG4gICAgaWYgYCN7bmF0aXZlfSA9PT0gbmlsYFxuICAgICAgYCN7QG5hdGl2ZX1ba2V5XSA9ICN7dmFsdWV9YFxuICAgIGVsc2VcbiAgICAgIGAje0BuYXRpdmV9W2tleV0gPSAje25hdGl2ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSEob3RoZXIpXG4gICAgJXh7XG4gICAgICBvdGhlciA9ICN7OjpOYXRpdmUuY29udmVydChvdGhlcil9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG90aGVyKSB7XG4gICAgICAgICN7QG5hdGl2ZX1bcHJvcF0gPSBvdGhlcltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvPyhuYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIDo6S2VybmVsLmluc3RhbmNlX21ldGhvZCg6cmVzcG9uZF90bz8pLmJpbmQoc2VsZikuY2FsbChuYW1lLCBpbmNsdWRlX2FsbClcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBgT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKCN7QG5hdGl2ZX0sICN7bmFtZX0pYFxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcobWlkLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKG1pZC5jaGFyQXQobWlkLmxlbmd0aCAtIDEpID09PSAnPScpIHtcbiAgICAgICAgcmV0dXJuICN7c2VsZlttaWQuc2xpY2UoMCwgbWlkLmxlbmd0aCAtIDEpXSA9IGFyZ3NbMF19O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjezo6TmF0aXZlLmNhbGwoQG5hdGl2ZSwgbWlkLCAqYXJncywgJmJsb2NrKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICBgT3BhbC5pc19hKHNlbGYsIGtsYXNzKWBcbiAgZW5kXG5cbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgIGBzZWxmLiQkY2xhc3MgPT09IGtsYXNzYFxuICBlbmRcblxuICBkZWYgY2xhc3NcbiAgICBgc2VsZi4kJGNsYXNzYFxuICBlbmRcblxuICBkZWYgdG9fYShvcHRpb25zID0ge30sICZibG9jaylcbiAgICA6Ok5hdGl2ZTo6QXJyYXkubmV3KEBuYXRpdmUsIG9wdGlvbnMsICZibG9jaykudG9fYVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxOYXRpdmU6I3tgU3RyaW5nKCN7QG5hdGl2ZX0pYH0+XCJcbiAgZW5kXG5lbmRcblxuY2xhc3MgTmF0aXZlOjpBcnJheVxuICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBkZWYgaW5pdGlhbGl6ZShuYXRpdmUsIG9wdGlvbnMgPSB7fSwgJmJsb2NrKVxuICAgIHN1cGVyKG5hdGl2ZSlcblxuICAgIEBnZXQgICAgPSBvcHRpb25zWzpnZXRdIHx8IG9wdGlvbnNbOmFjY2Vzc11cbiAgICBAbmFtZWQgID0gb3B0aW9uc1s6bmFtZWRdXG4gICAgQHNldCAgICA9IG9wdGlvbnNbOnNldF0gfHwgb3B0aW9uc1s6YWNjZXNzXVxuICAgIEBsZW5ndGggPSBvcHRpb25zWzpsZW5ndGhdIHx8IDpsZW5ndGhcbiAgICBAYmxvY2sgID0gYmxvY2tcblxuICAgIGlmIGAje2xlbmd0aH0gPT0gbnVsbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBsZW5ndGggZm91bmQgb24gdGhlIGFycmF5LWxpa2Ugb2JqZWN0J1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoIHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gI3tsZW5ndGh9OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssICN7c2VsZltgaWBdfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgW10oaW5kZXgpXG4gICAgcmVzdWx0ID0gY2FzZSBpbmRleFxuICAgICAgICAgICAgIHdoZW4gU3RyaW5nLCBTeW1ib2xcbiAgICAgICAgICAgICAgIEBuYW1lZCA/IGAje0BuYXRpdmV9WyN7QG5hbWVkfV0oI3tpbmRleH0pYCA6IGAje0BuYXRpdmV9WyN7aW5kZXh9XWBcbiAgICAgICAgICAgICB3aGVuIEludGVnZXJcbiAgICAgICAgICAgICAgIEBnZXQgPyBgI3tAbmF0aXZlfVsje0BnZXR9XSgje2luZGV4fSlgIDogYCN7QG5hdGl2ZX1bI3tpbmRleH1dYFxuICAgICAgICAgICAgIGVuZFxuXG4gICAgaWYgcmVzdWx0XG4gICAgICBpZiBAYmxvY2tcbiAgICAgICAgQGJsb2NrLmNhbGwocmVzdWx0KVxuICAgICAgZWxzZVxuICAgICAgICBOYXRpdmUocmVzdWx0KVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBbXT0oaW5kZXgsIHZhbHVlKVxuICAgIGlmIEBzZXRcbiAgICAgIGAje0BuYXRpdmV9WyN7QHNldH1dKCN7aW5kZXh9LCAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX0pYFxuICAgIGVsc2VcbiAgICAgIGAje0BuYXRpdmV9WyN7aW5kZXh9XSA9ICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxhc3QoY291bnQgPSBuaWwpXG4gICAgaWYgY291bnRcbiAgICAgIGluZGV4ICA9IGxlbmd0aCAtIDFcbiAgICAgIHJlc3VsdCA9IFtdXG5cbiAgICAgIHdoaWxlIGluZGV4ID49IDBcbiAgICAgICAgcmVzdWx0IDw8IHNlbGZbaW5kZXhdXG4gICAgICAgIGluZGV4ICAtPSAxXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0XG4gICAgZWxzZVxuICAgICAgc2VsZltsZW5ndGggLSAxXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYCN7QG5hdGl2ZX1bI3tAbGVuZ3RofV1gXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2FyeSB0b19hXG5cbiAgZGVmIGluc3BlY3RcbiAgICB0b19hLmluc3BlY3RcbiAgZW5kXG5lbmRcblxuY2xhc3MgTnVtZXJpY1xuICAjIEByZXR1cm4gdGhlIGludGVybmFsIEphdmFTY3JpcHQgdmFsdWUgKHdpdGggYHZhbHVlT2ZgKS5cbiAgZGVmIHRvX25cbiAgICBgc2VsZi52YWx1ZU9mKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFByb2NcbiAgIyBAcmV0dXJuIGl0c2VsZiAoYW4gaW5zdGFuY2Ugb2YgYEZ1bmN0aW9uYClcbiAgZGVmIHRvX25cbiAgICBzZWxmXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICAjIEByZXR1cm4gdGhlIGludGVybmFsIEphdmFTY3JpcHQgdmFsdWUgKHdpdGggYHZhbHVlT2ZgKS5cbiAgZGVmIHRvX25cbiAgICBgc2VsZi52YWx1ZU9mKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFJlZ2V4cFxuICAjIEByZXR1cm4gdGhlIGludGVybmFsIEphdmFTY3JpcHQgdmFsdWUgKHdpdGggYHZhbHVlT2ZgKS5cbiAgZGVmIHRvX25cbiAgICBgc2VsZi52YWx1ZU9mKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE1hdGNoRGF0YVxuICAjIEByZXR1cm4gdGhlIGFycmF5IG9mIG1hdGNoZXNcbiAgZGVmIHRvX25cbiAgICBAbWF0Y2hlc1xuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJ1Y3RcbiAgIyBAcmV0dXJuIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGUgbWVtYmVycyBhcyBrZXlzIGFuZCB0aGVpclxuICAjIHZhbHVlcyBhcyB2YWx1ZXMuXG4gIGRlZiB0b19uXG4gICAgcmVzdWx0ID0gYHt9YFxuXG4gICAgZWFjaF9wYWlyIGRvIHxuYW1lLCB2YWx1ZXxcbiAgICAgIGAje3Jlc3VsdH1bI3tuYW1lfV0gPSAje05hdGl2ZS50cnlfY29udmVydCh2YWx1ZSwgdmFsdWUpfWBcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcbmVuZFxuXG5jbGFzcyBBcnJheVxuICAjIFJldHVucyBhIGNvcHkgb2YgaXRzZWxmIHRyeWluZyB0byBjYWxsICN0b19uIG9uIGVhY2ggbWVtYmVyLlxuICBkZWYgdG9fblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb2JqID0gc2VsZltpXTtcblxuICAgICAgICByZXN1bHQucHVzaCgje05hdGl2ZS50cnlfY29udmVydChgb2JqYCwgYG9iamApfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcbmVuZFxuXG5jbGFzcyBCb29sZWFuXG4gICMgQHJldHVybiB0aGUgaW50ZXJuYWwgSmF2YVNjcmlwdCB2YWx1ZSAod2l0aCBgdmFsdWVPZmApLlxuICBkZWYgdG9fblxuICAgIGBzZWxmLnZhbHVlT2YoKWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgVGltZVxuICAjIEByZXR1cm4gaXRzZWxmIChhbiBpbnN0YW5jZSBvZiBgRGF0ZWApLlxuICBkZWYgdG9fblxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuY2xhc3MgTmlsQ2xhc3NcbiAgIyBAcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIEphdmFTY3JpcHQgdmFsdWUgKGBudWxsYCkuXG4gIGRlZiB0b19uXG4gICAgYG51bGxgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEhhc2hcbiAgYWxpYXMgX2luaXRpYWxpemUgaW5pdGlhbGl6ZVxuXG4gIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoZGVmYXVsdHMgIT0gbnVsbCAmJlxuICAgICAgICAgICAoZGVmYXVsdHMuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgIGRlZmF1bHRzLmNvbnN0cnVjdG9yID09PSBPYmplY3QpKSB7XG4gICAgICAgIHZhciBzbWFwID0gc2VsZi4kJHNtYXAsXG4gICAgICAgICAgICBrZXlzID0gc2VsZi4kJGtleXMsXG4gICAgICAgICAgICBrZXksIHZhbHVlO1xuXG4gICAgICAgIGZvciAoa2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0c1trZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICAgICAodmFsdWUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICAgICAgc21hcFtrZXldID0gI3tIYXNoLm5ldyhgdmFsdWVgKX07XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgIGlmIChpdGVtICYmXG4gICAgICAgICAgICAgICAgICAgKGl0ZW0uY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAje0hhc2gubmV3KGBpdGVtYCl9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBpdGVtYCl9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzbWFwW2tleV0gPSB2YWx1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbWFwW2tleV0gPSAje05hdGl2ZShgdmFsdWVgKX07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7X2luaXRpYWxpemUoZGVmYXVsdHMsICZibG9jayl9O1xuICAgIH1cbiAgZW5kXG5cbiAgIyBAcmV0dXJuIGEgSmF2YVNjcmlwdCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGJ1dCBjYWxsaW5nICN0b19uIG9uXG4gICMgYWxsIHZhbHVlcy5cbiAgZGVmIHRvX25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgICBrZXlzID0gc2VsZi4kJGtleXMsXG4gICAgICAgICAgc21hcCA9IHNlbGYuJCRzbWFwLFxuICAgICAgICAgIGtleSwgdmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRba2V5XSA9ICN7TmF0aXZlLnRyeV9jb252ZXJ0KGB2YWx1ZWAsIGB2YWx1ZWApfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuZW5kXG5cbmNsYXNzIE1vZHVsZVxuICAjIEV4cG9zZXMgdGhlIGN1cnJlbnQgbW9kdWxlIGFzIGEgcHJvcGVydHkgb2ZcbiAgIyB0aGUgZ2xvYmFsIG9iamVjdCAoZS5nLiBgd2luZG93YCkuXG4gIGRlZiBuYXRpdmVfbW9kdWxlXG4gICAgYE9wYWwuZ2xvYmFsWyN7bmFtZX1dID0gI3tzZWxmfWBcbiAgZW5kXG5lbmRcblxuY2xhc3MgQ2xhc3NcbiAgZGVmIG5hdGl2ZV9hbGlhcyhuZXdfanNpZCwgZXhpc3RpbmdfbWlkKVxuICAgICV4e1xuICAgICAgdmFyIGFsaWFzZWQgPSAje3NlbGZ9LnByb3RvdHlwZVsnJCcgKyAje2V4aXN0aW5nX21pZH1dO1xuICAgICAgaWYgKCFhbGlhc2VkKSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7ZXhpc3RpbmdfbWlkfScgZm9yIGNsYXNzIGAje2luc3BlY3R9J1wiLCBleGlzdGluZ19taWQpfTtcbiAgICAgIH1cbiAgICAgICN7c2VsZn0ucHJvdG90eXBlWyN7bmV3X2pzaWR9XSA9IGFsaWFzZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmF0aXZlX2NsYXNzXG4gICAgbmF0aXZlX21vZHVsZVxuICAgIGBzZWxmW1wibmV3XCJdID0gc2VsZi4kbmV3YFxuICBlbmRcbmVuZFxuXG4jIEV4cG9zZXMgdGhlIGdsb2JhbCB2YWx1ZSAod291bGQgYmUgYHdpbmRvd2AgaW5zaWRlIGEgYnJvd3NlcilcbiQkID0gJGdsb2JhbCA9IE5hdGl2ZShgT3BhbC5nbG9iYWxgKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImlzX2E/Iiwic2VsZiIsIm9iamVjdCIsInRyeV9jb252ZXJ0Iiwia2xhc3MiLCJuYXRpdmU/IiwidmFsdWUiLCJyZXNwb25kX3RvPyIsInRvX24iLCJkZWZhdWx0JCIsImNvbnZlcnQiLCJyYWlzZSIsImluc3BlY3QiLCJjYWxsIiwib2JqIiwia2V5IiwiTmF0aXZlIiwicHJvYyIsImJsb2NrIiwibWFwISIsImFyZ3MiLCJhcmciLCJpbnN0YW5jZSIsImFsaWFzX25hdGl2ZSIsIm5ldyQiLCJvbGQiLCJlbmRfd2l0aD8iLCJkZWZpbmVfbWV0aG9kIiwiQG5hdGl2ZSIsIltdIiwiMCIsIi0yIiwiYXMiLCJuZXciLCJuYXRpdmVfcmVhZGVyIiwiZWFjaCIsIm5hbWVzIiwibmFtZSIsIm5hdGl2ZV93cml0ZXIiLCJuYXRpdmVfYWNjZXNzb3IiLCJpbml0aWFsaXplIiwibmF0aXZlJCIsImluY2x1ZGVkIiwiZXh0ZW5kIiwid2FybiIsImJhc2UiLCJpbmNsdWRlIiwibWFwIiwibyIsIkFycmF5IiwidG9fYSIsIl9BcnJheSIsImNsYXNzIiwiPT0iLCJvdGhlciIsImhhc19rZXk/IiwiYmxvY2tfZ2l2ZW4/IiwibWV0aG9kX21pc3NpbmciLCJbXT0iLCJtZXJnZSEiLCJpbnN0YW5jZV9tZXRob2QiLCJiaW5kIiwiaW5jbHVkZV9hbGwiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiJHdyaXRlciIsIm1pZCIsInNsaWNlIiwiLSIsImxlbmd0aCIsIjEiLCJuaWw/IiwiaW5zdGFuY2Vfb2Y/Iiwib3B0aW9ucyIsIkBnZXQiLCJAbmFtZWQiLCJAc2V0IiwiQGxlbmd0aCIsIkBibG9jayIsImVudW1fZm9yIiwicmVzdWx0IiwiaW5kZXgiLCJsYXN0IiwiY291bnQiLCI+PSIsIjw8IiwiQG1hdGNoZXMiLCJlYWNoX3BhaXIiLCJfaW5pdGlhbGl6ZSIsImRlZmF1bHRzIiwibmF0aXZlX21vZHVsZSIsIm5hdGl2ZV9hbGlhcyIsImV4aXN0aW5nX21pZCIsIm5ld19qc2lkIiwibmF0aXZlX2NsYXNzIiwiJCQiLCIkZ2xvYmFsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFpQkEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUFDLFVBQUlDLElBQUpELFlBQUFBLHNCQUFBQSxTQUFlLE1BQUQsRUFBUyxLQUF2QkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQSxlQUFpQkUsTUFBTyxnQkFBY0MsYUFBQUEsQ0FBWUMsS0FBWkQsQ0FBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJFSCxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0FBQTtBQUFBLElBV0FHLFVBQUlGLElBQUpFLGtCQUFBQSx3QkFBQUEsdUJBQXFCLEtBQUQsRUFBUSxRQUE1QkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOUJGO0FBOEI4QixNQUFBO0FBQUEsTUFBQSxhQUFVLEdBQVY7QUFBQSxNQUFBLENBOUI5QjtBQUFBO0FBZ0NBLGNBQVlFLFlBQUFBLENBQVFDLEtBQVJELENBQWU7QUFDM0IsZUFBaUJDLEtBQU07QUFDdkI7QUFDQSxlQUFpQkEsS0FBQUMsZ0JBQUFBLENBQWtCLE1BQWxCQSxDQUF3QjtBQUN6QyxlQUFpQkQsS0FBQUUsTUFBQUEsQ0FBQUEsQ0FBVztBQUM1QjtBQUNBO0FBQ0EsZUFBaUJDLFFBQVE7QUFDekI7QUFDQSxJQXpDQTtBQThCRU4sSUFBQUEsQ0FBQUEsb0NBQUFBLENBWEE7QUFBQSxJQXlCQU8sVUFBSVQsSUFBSlMsY0FBQUEsb0JBQUFBLG1CQUFpQixLQUFqQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUYsY0FBWUwsWUFBQUEsQ0FBUUMsS0FBUkQsQ0FBZTtBQUMzQixlQUFpQkMsS0FBTTtBQUN2QjtBQUNBLGVBQWlCQSxLQUFBQyxnQkFBQUEsQ0FBa0IsTUFBbEJBLENBQXdCO0FBQ3pDLGVBQWlCRCxLQUFBRSxNQUFB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QTs7QUFBQUE7QUFDRSxVQUFBSixlQUFBQSxDQUFBQSxDQUFBO0FBQUEsTUFDQSxPQUFDLHVCQUFELENBREE7QUFERkksSUFBQUEsQ0FBQUEsb0NBQUFBLENBQUFBLHdCQVZBO0FBREZ6QyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQWpsQkE7QUFBQSxFQW1tQkEsT0FBQTBDLENBQUFBLFdBQUtDLENBQUFBLG9CQUFVL0UsUUFBQUEsQ0FBUSxXQUFSQSxDQUFWK0UsQ0FBTEQsQ0FubUJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQyNjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vdXRpbHMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW9cblxubW9kdWxlIFV0aWxzXG4gIGRlZiBzZWxmLmhlcmVkb2Moc3RyaW5nKVxuICAgIGluZGVudCA9IHN0cmluZy5zY2FuKC9eWyBcXHRdKig/PVxcUykvKS5taW4uc2l6ZSByZXNjdWUgMFxuXG4gICAgc3RyaW5nLmdzdWIoL15bIFxcdF17I3tpbmRlbnR9fS8sICcnKVxuICBlbmRcblxuICBkZWYgc2VsZi5kZWVwX21lcmdlKGEsIGIpXG4gICAgbWVyZ2VyID0gcHJvYyB7fGtleSwgdjEsIHYyfFxuICAgICAgaWYgSGFzaCA9PT0gdjEgJiYgSGFzaCA9PT0gdjJcbiAgICAgICAgdjEubWVyZ2UodjIsICZtZXJnZXIpXG4gICAgICBlbHNlXG4gICAgICAgIHYyXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICBhLm1lcmdlKGIsICZtZXJnZXIpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmRlZXBfbWVyZ2UhKGEsIGIpXG4gICAgbWVyZ2VyID0gcHJvYyB7fGtleSwgdjEsIHYyfFxuICAgICAgaWYgSGFzaCA9PT0gdjEgJiYgSGFzaCA9PT0gdjJcbiAgICAgICAgdjEubWVyZ2UhKHYyLCAmbWVyZ2VyKVxuICAgICAgICB2MVxuICAgICAgZWxzZVxuICAgICAgICB2MlxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgYS5tZXJnZSEoYiwgJm1lcmdlcilcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJtb2R1bGUiLCJoZXJlZG9jIiwic2VsZiIsImluZGVudCIsInN0cmluZyIsInNjYW4iLCJtaW4iLCJzaXplIiwiMCIsImdzdWIiLCJkZWVwX21lcmdlIiwibWVyZ2VyIiwicHJvYyIsIj09PSIsInYxIiwidjIiLCJtZXJnZSIsImEiLCJiIiwiZGVlcF9tZXJnZSEiLCJtZXJnZSEiXSwibWFwcGluZ3MiOiI7Ozs7O0VBVUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUVBLE9BQUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBQyxVQUFJQyxJQUFKRCxjQUFBQSxtQkFBQUEsbUJBQWlCLE1BQWpCQTtBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBRSxTQUFTLGNBQUE7QUFBQSxVQUFBLE9BQUFDLE1BQUFDLE1BQUFBLENBQVksZUFBWkEsQ0FBQUMsS0FBQUEsQ0FBQUEsQ0FBQUMsTUFBQUEsQ0FBQUE7QUFBQSxRQUFBO0FBQUEsVUFBc0MscURBQUE7QUFBQSxZQUFBO0FBQUEsY0FBTyxPQUFBQztBQUFQLFlBQUE7QUFBQSxVQUFBLENBQXRDO0FBQUEsUUFBQSxDQUFBLElBQVQ7QUFBQSxRQUVBLE9BQUFKLE1BQUFLLE1BQUFBLENBQVksOEJBQVVOLGFBQVYsR0FBcUIsRUFBakNNLENBRkE7QUFERlIsTUFBQUEsQ0FBQUEsOEJBQUFBLENBQUE7QUFBQSxNQU1BUyxVQUFJUixJQUFKUSxpQkFBQUEsc0JBQUFBLHNCQUFvQixDQUFELEVBQUksQ0FBdkJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFNBQVNDLFVBQUFBLFFBQUFBLEVBQUFBLEVBQUFBLEVBckJiLGdCQXFCb0IsR0FBRCxFQUFNLEVBQU4sRUFBVSxFQXJCN0IsRUFBQTs7QUFBQTtBQUFBO0FBcUJvQixVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0FyQnBCO0FBQUE7QUFxQnlCLFVBQUE7QUFBQSxVQUFBO0FBQUEsVUFBQSxDQXJCekI7QUFBQTtBQXFCNkIsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBckI3QjtBQUFBLFVBc0JNLElBQUEsUUFBRyxjQUFBLG9CQUFBQyxRQUFBQSxDQUFTQyxFQUFURCxDQUFBLElBQWUsb0JBQUFBLFFBQUFBLENBQVNFLEVBQVRGLENBQWYsTUFBSCxDQUFBO0FBQUEsWUFDRSxPQUFBRyxNQUFBRixFQUFBRSxTQUFBQSxFQUFBQSxDQUFTRCxFQUFUQyxDQUFBQSxFQUFjTCxpQkFBZEs7QUFERixVQUFBO0FBQUEsWUFHRSxPQUFBRDtBQUhGLFVBQUEsQ0F0Qk4sQ0FBQSxrQkFBQSxpQkFBQSxLQXFCYUgsQ0FBVDtBQUFBLFFBUUEsT0FBQUksTUFBQUMsQ0FBQUQsU0FBQUEsRUFBQUEsQ0FBUUUsQ0FBUkYsQ0FBQUEsRUFBWUwsaUJBQVpLLENBUkE7QUFERk4sTUFBQUEsQ0FBQUEsaUNBQUFBLENBTkE7QUFBQSxNQWtCQVMsVUFBSWpCLElBQUppQixrQkFBQUEsMkJBQUFBLFNBQXFCLENBQUQsRUFBSSxDQUF4QkE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQVIsU0FBU0MsVUFBQUEsUUFBQUEsRUFBQUEsRUFBQUEsRUFqQ2IsZ0JBaUNvQixHQUFELEVBQU0sRUFBTixFQUFVLEVBakM3QixFQUFBOztBQUFBO0FBQUE7QUFpQ29CLFVBQUE7QUFBQSxVQUFBO0FBQUEsVUFBQSxDQWpDcEI7QUFBQTtBQWlDeUIsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBakN6QjtBQUFBO0FBaUM2QixVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0FqQzdCO0FBQUEsVUFrQ00sSUFBQSxRQUFHLGNBQUEsb0JBQUFDLFFBQUFBLENBQVNDLEVBQVRELENBQUEsSUFBZSxvQkFBQUEsUUFBQUEsQ0FBU0UsRUFBVEYsQ0FBZixNQUFILENBQUE7QUFBQTtBQUNFLFlBQUFPLE1BQUFOLEVBQUFNLFVBQUFBLEVBQUFBLENBQVVMLEVBQVZLLENBQUFBLEVBQWVULGlCQUFmUyxDQUFBO0FBQUEsWUFDQSxPQUFBTixFQURBO0FBREYsVUFBQTtBQUFBLFlBSUUsT0FBQUM7QUFKRixVQUFBLENBbENOLENBQUEsa0JBQUEsaUJBQUEsS0FpQ2FILENBQVQ7QUFBQSxRQVNBLE9BQUFRLE1BQUFILENBQUFHLFVBQUFBLEVBQUFBLENBQVNGLENBQVRFLENBQUFBLEVBQWFULGlCQUFiUyxDQVRBO0FBREZELE1BQUFBLENBQUFBLHNDQUFBQSxDQWxCQTtBQURGbkIsSUFBQUEsR0FBQUEsV0FBQUE7QUFGQUQsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDM1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2hlbHBlcnMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcbiAgZGVmIHNlbGYuZGVmaGVscGVyKG5hbWUsICZibG9jaylcbiAgICBkZWZpbmVfbWV0aG9kIG5hbWUgZG8gfCphcmdzLCAmYm9keXxcbiAgICAgIGluc3RhbmNlX2V4ZWMoKmFyZ3MsICZibG9jaylcblxuICAgICAgc2VsZi5kbygmYm9keSkgaWYgYm9keVxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5kZWZoZWxwZXIhKG5hbWUsIGF0dHJpYnV0ZSA9IG5hbWUpXG4gICAgZGVmaGVscGVyIFwiI3tuYW1lfSFcIiBkb1xuICAgICAgQGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHRydWVcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImRlZmhlbHBlciIsInNlbGYiLCJkZWZpbmVfbWV0aG9kIiwibmFtZSIsImluc3RhbmNlX2V4ZWMiLCJhcmdzIiwiYmxvY2siLCJib2R5IiwiZG8iLCJkZWZoZWxwZXIhIiwiJHdyaXRlciIsImF0dHJpYnV0ZSIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiLSIsIjEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBVUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFjLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFZCxPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsVUFBSUMsSUFBSkQsZ0JBQUFBLHVCQUFBQSxxQkFBbUIsSUFBbkJBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUFBQTtBQUFBQTtBQWRGO0FBYzJCLFVBQUEsMkNBZDNCO0FBQUEsVUFlSSxPQUFBRSxVQUFBQSxpQkFBQUEsRUFBQUEsQ0FBY0MsSUFBZEQsQ0FBQUEsRUFmSixnQkFBQSxFQUFBLEVBQUE7O0FBQUE7QUFBQTtBQWVrQyxZQUFBLDBCQWZsQztBQUFBO0FBQUEsWUFBQSw0REFBQTtBQUFBO0FBZTJCLFlBQUEsa0JBZjNCO0FBQUEsWUFnQk1FLFVBQUFBLGlCQUFBQSxFQUFjLFVBQUNDLElBQUQsQ0FBZEQsRUFBc0JFLGdCQUF0QkYsQ0FoQk47QUFBQSxZQWtCTSxJQUFBLFFBQWtCRyxJQUFsQixDQUFBO0FBQUEsY0FBQUMsTUFBQVAsSUFBQU8sTUFBQUEsRUFBQUEsRUFBQUEsRUFBU0QsZUFBVEMsQ0FBQSxDQWxCTjtBQUFBLFlBbUJNLE9BQUFQLElBbkJOLENBQUEsa0JBQUEsa0JBQUEsS0FlSUMsQ0FmSjtBQWNFRixRQUFBQSxDQUFBQSxrQ0FBQUEsQ0FBQTtBQUFBLFFBU0EsT0FBQVMsQ0FBQUEsVUFBSVIsSUFBSlEsaUJBQUFBLDRCQUFBQSxTQUFvQixJQUFELEVBQU8sU0FBMUJBO0FBQUFBLFVBQUFBOztBQUFBQTtBQXZCRjtBQXVCNEIsVUFBQTtBQUFBLFVBQUEsY0FBWU4sSUFBWjtBQUFBLFVBQUEsQ0F2QjVCO0FBQUEsVUF3QkksT0FBQUgsVUFBQUEsYUFBQUEsRUFBQUEsQ0FBVSxFQUFBLEdBQUEsQ0FBR0csSUFBSCxDQUFBLEdBQUEsR0FBVkgsQ0FBQUEsRUF4QkosZ0JBQUEsRUFBQTtBQUFBOztBQUFBO0FBQUEsWUFBQVUsVUFBQSxDQXlCa0JDLFNBekJsQixFQXlCK0IsSUF6Qi9CLENBQUE7QUFBQSxZQXlCTUMsTUFBQUMsZUFBQUQsT0FBQUEsRUF6Qk4sVUFBQUYsT0FBQSxDQXlCTUUsQ0F6Qk47QUFBQSxZQUFBLE9BQUFGLE9BQUEsQ0FBQUksVUFBQUosT0FBQSxDQUFBLFFBQUEsQ0FBQUksRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsa0JBQUEsaUJBQUEsS0F3QklkLENBeEJKO0FBdUJFUyxRQUFBQSxDQUFBQSx3Q0FBQUEsQ0FBQUEsc0JBVEE7QUFERlYsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IsMkJBQWhCQTtBQUZjQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFhLDJCQUFiQTtBQUFkQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NDIzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9hLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBBIDwgc2VsZlxuICB7IGhyZWY6IDpocmVmLFxuICAgIHVybDogIDpocmVmLFxuXG4gICAgcmVsOiAgICAgIDpyZWwsXG4gICAgcmVsYXRpdmU6IDpyZWwsXG5cbiAgICB0YXJnZXQ6IDp0YXJnZXQsXG5cbiAgICB0eXBlOiA6dHlwZSxcblxuICAgIGxhbmc6ICAgICA6aHJlZmxhbmcsXG4gICAgbGFuZ3VhZ2U6IDpocmVmbGFuZyxcblxuICAgIG1lZGlhOiA6bWVkaWEsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWUudG9fc1xuICAgIGVuZFxuICB9XG5cbiAgZGVmaGVscGVyISA6ZG93bmxvYWRcbiAgZGVmaGVscGVyISA6cGluZ1xuXG4gIGRlZmhlbHBlciA6dGV4dCBkbyB8c3RyaW5nfFxuICAgIHNlbGYgPDwgc3RyaW5nXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImVhY2giLCJkZWZoZWxwZXIiLCJuYW1lIiwiJHdyaXRlciIsImF0dHJpYnV0ZSIsInZhbHVlIiwidG9fcyIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiLSIsIjEiLCJkZWZoZWxwZXIhIiwic2VsZiIsIjw8Iiwic3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztFQVVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBYyxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQTBCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFFeEMsT0FBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUNFLFVBQUFDLE1BQUEsMkZBQUEsUUFBUSxNQUFSLEVBQUEsT0FDUSxNQURSLEVBQUEsT0FHWSxLQUhaLEVBQUEsWUFJWSxLQUpaLEVBQUEsVUFNVSxRQU5WLEVBQUEsUUFRUSxNQVJSLEVBQUEsUUFVWSxVQVZaLEVBQUEsWUFXWSxVQVhaLEVBQUEsU0FhUyxPQWJULEVBQUFBLFFBQUFBLEVBQUFBLEVBQUFBLEVBZEYsaUJBNEJXLElBQUQsRUFBTyxTQTVCakIsRUFBQTs7QUFBQTtBQUFBO0FBNEJXLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQTVCWDtBQUFBO0FBNEJpQixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0E1QmpCO0FBQUEsWUE2QkksT0FBQUMsVUFBQUEsYUFBQUEsRUFBQUEsQ0FBVUMsSUFBVkQsQ0FBQUEsRUE3QkosZ0JBNkJ1QixLQTdCdkIsRUFBQTtBQUFBOztBQUFBO0FBQUE7QUE2QnVCLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQTdCdkI7QUFBQSxjQUFBRSxVQUFBLENBOEJrQkMsU0E5QmxCLEVBOEIrQkMsS0FBQUMsTUFBQUEsQ0FBQUEsQ0E5Qi9CLENBQUE7QUFBQSxjQThCTUMsTUFBQUMsZUFBQUQsT0FBQUEsRUE5Qk4sVUFBQUosT0FBQSxDQThCTUksQ0E5Qk47QUFBQSxjQUFBLE9BQUFKLE9BQUEsQ0FBQU0sVUFBQU4sT0FBQSxDQUFBLFFBQUEsQ0FBQU0sRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsa0JBQUEsaUJBQUEsS0E2QklSLENBN0JKLENBQUEsbUJBQUEsa0JBQUEsTUFjRUQsQ0FBQTtBQUFBLGNBb0JBVyxlQUFBQSxDQUFXLFVBQVhBLENBcEJBO0FBQUEsY0FxQkFBLGVBQUFBLENBQVcsTUFBWEEsQ0FyQkE7QUFBQSxVQXVCQSxPQUFBVixVQUFBQSxhQUFBQSxFQUFBQSxDQUFVLE1BQVZBLENBQUFBLEVBckNGLGlCQXFDc0IsTUFyQ3RCLEVBQUE7O0FBQUE7QUFBQTtBQXFDc0IsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBckN0QjtBQUFBLFlBc0NJLE9BQUFXLElBQUFDLE9BQUFBLENBQVFDLE1BQVJELENBdENKLENBQUEsbUJBQUEsa0JBQUEsTUFxQ0VaLENBdkJBO0FBREZGLFFBQUFBLEdBQUFBLFdBQUFBLEVBQVVhLElBQVZiO0FBRndDQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQiwyQkFBaEJBO0FBQTFCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFhLDJCQUFiQTtBQUFkQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NDkwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBCYXNlIDwgc2VsZlxuICB7IGhyZWY6IDpocmVmLFxuICAgIHVybDogIDpocmVmLFxuXG4gICAgdGFyZ2V0OiA6dGFyZ2V0LFxuICB9LmVhY2gge3xuYW1lLCBhdHRyaWJ1dGV8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlLnRvX3NcbiAgICBlbmRcbiAgfVxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImVhY2giLCJkZWZoZWxwZXIiLCJuYW1lIiwiJHdyaXRlciIsImF0dHJpYnV0ZSIsInZhbHVlIiwidG9fcyIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiLSIsIjEiLCJzZWxmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztFQVVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBYyxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQTBCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFFeEMsT0FBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUFDLE1BQUEsbUNBQUEsUUFBUSxNQUFSLEVBQUEsT0FDUSxNQURSLEVBQUEsVUFHVSxRQUhWLEVBQUFBLFFBQUFBLEVBQUFBLEVBQUFBLEVBZEYsb0JBa0JXLElBQUQsRUFBTyxTQWxCakIsRUFBQTs7QUFBQTtBQUFBO0FBa0JXLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQWxCWDtBQUFBO0FBa0JpQixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0FsQmpCO0FBQUEsWUFtQkksT0FBQUMsVUFBQUEsYUFBQUEsRUFBQUEsQ0FBVUMsSUFBVkQsQ0FBQUEsRUFuQkosZ0JBbUJ1QixLQW5CdkIsRUFBQTtBQUFBOztBQUFBO0FBQUE7QUFtQnVCLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQW5CdkI7QUFBQSxjQUFBRSxVQUFBLENBb0JrQkMsU0FwQmxCLEVBb0IrQkMsS0FBQUMsTUFBQUEsQ0FBQUEsQ0FwQi9CLENBQUE7QUFBQSxjQW9CTUMsTUFBQUMsZUFBQUQsT0FBQUEsRUFwQk4sVUFBQUosT0FBQSxDQW9CTUksQ0FwQk47QUFBQSxjQUFBLE9BQUFKLE9BQUEsQ0FBQU0sVUFBQU4sT0FBQSxDQUFBLFFBQUEsQ0FBQU0sRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsa0JBQUEsaUJBQUEsS0FtQklSLENBbkJKLENBQUEsc0JBQUEscUJBQUEsU0FjRUQ7QUFERkQsUUFBQUEsR0FBQUEsV0FBQUEsRUFBYVksSUFBYlo7QUFGd0NBLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWdCLDJCQUFoQkE7QUFBMUJBLElBQUFBLEdBQUFBLFdBQUFBLEVBQWEsMkJBQWJBO0FBQWRBLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ1NDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L2Jsb2NrcXVvdGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEJsb2NrcXVvdGUgPCBzZWxmXG4gIGRlZmhlbHBlciA6Y2l0ZSBkbyB8dmFsdWV8XG4gICAgQGF0dHJpYnV0ZXNbOmNpdGVdID0gdmFsdWUudG9fc1xuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJkZWZoZWxwZXIiLCIkd3JpdGVyIiwidmFsdWUiLCJ0b19zIiwiW109IiwiQGF0dHJpYnV0ZXMiLCItIiwiMSIsInNlbGYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBVUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFjLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBMEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUV4QyxPQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQUMsVUFBQUEsYUFBQUEsRUFBQUEsQ0FBVSxNQUFWQSxDQUFBQSxFQWRGLDBCQWNzQixLQWR0QixFQUFBO0FBQUE7O0FBQUE7QUFBQTtBQWNzQixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0FkdEI7QUFBQSxZQUFBQyxVQUFBLENBZWdCLE1BZmhCLEVBZXlCQyxLQUFBQyxNQUFBQSxDQUFBQSxDQWZ6QixDQUFBO0FBQUEsWUFlSUMsTUFBQUMsZUFBQUQsT0FBQUEsRUFmSixVQUFBSCxPQUFBLENBZUlHLENBZko7QUFBQSxZQUFBLE9BQUFILE9BQUEsQ0FBQUssVUFBQUwsT0FBQSxDQUFBLFFBQUEsQ0FBQUssRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsNEJBQUEsMkJBQUEsZUFjRU47QUFERkQsUUFBQUEsR0FBQUEsV0FBQUEsRUFBbUJTLElBQW5CVDtBQUZ3Q0EsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IsMkJBQWhCQTtBQUExQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYSwyQkFBYkE7QUFBZEEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDU5MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvYnV0dG9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBIVE1MIDwgQmFzaWNPYmplY3Q7IGNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBCdXR0b24gPCBzZWxmXG4gIHsgZm9ybTogIDpmb3JtLFxuICAgIG5hbWU6ICA6bmFtZSxcbiAgICB0eXBlOiAgOnR5cGUsXG4gICAgdmFsdWU6IDp2YWx1ZSxcblxuICAgIGFjdGlvbjogICA6Zm9ybWFjdGlvbixcbiAgICBlbmNvZGluZzogOmZvcm1lbmN0eXBlLFxuICAgIG1ldGhvZDogICA6Zm9ybW1ldGhvZCxcbiAgICB0YXJnZXQ6ICAgOmZvcm10YXJnZXQsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXN8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlLnRvX3NcbiAgICBlbmRcbiAgfVxuXG4gIGRlZmhlbHBlciEgOmF1dG9mb2N1c1xuICBkZWZoZWxwZXIhIDpkaXNhYmxlZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImVhY2giLCJkZWZoZWxwZXIiLCJuYW1lIiwiJHdyaXRlciIsImF0dHJpYnV0ZSIsInZhbHVlIiwidG9fcyIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiLSIsIjEiLCJkZWZoZWxwZXIhIiwic2VsZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7RUFVQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWMsT0FBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUEwQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRXhDLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFDRSxVQUFBQyxNQUFBLHFGQUFBLFFBQVMsTUFBVCxFQUFBLFFBQ1MsTUFEVCxFQUFBLFFBRVMsTUFGVCxFQUFBLFNBR1MsT0FIVCxFQUFBLFVBS1ksWUFMWixFQUFBLFlBTVksYUFOWixFQUFBLFVBT1ksWUFQWixFQUFBLFVBUVksWUFSWixFQUFBQSxRQUFBQSxFQUFBQSxFQUFBQSxFQWRGLHNCQXVCVyxJQUFELEVBQU8sVUF2QmpCLEVBQUE7O0FBQUE7QUFBQTtBQXVCVyxZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0F2Qlg7QUFBQTtBQXVCaUIsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBdkJqQjtBQUFBLFlBd0JJLE9BQUFDLFVBQUFBLGFBQUFBLEVBQUFBLENBQVVDLElBQVZELENBQUFBLEVBeEJKLGdCQXdCdUIsS0F4QnZCLEVBQUE7QUFBQTs7QUFBQTtBQUFBO0FBd0J1QixjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0F4QnZCO0FBQUEsY0FBQUUsVUFBQSxLQXlCa0JDLFdBQUFBLENBQUFBLENBekJsQixFQXlCK0JDLEtBQUFDLE1BQUFBLENBQUFBLENBekIvQixDQUFBO0FBQUEsY0F5Qk1DLE1BQUFDLGVBQUFELE9BQUFBLEVBekJOLFVBQUFKLE9BQUEsQ0F5Qk1JLENBekJOO0FBQUEsY0FBQSxPQUFBSixPQUFBLENBQUFNLFVBQUFOLE9BQUEsQ0FBQSxRQUFBLENBQUFNLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQUFBLGtCQUFBLGlCQUFBLEtBd0JJUixDQXhCSixDQUFBLHdCQUFBLHVCQUFBLFdBY0VELENBQUE7QUFBQSxjQWVBVyxlQUFBQSxDQUFXLFdBQVhBLENBZkE7QUFBQSxVQWdCQSxXQUFBQSxlQUFBQSxDQUFXLFVBQVhBLENBaEJBO0FBREZaLFFBQUFBLEdBQUFBLFdBQUFBLEVBQWVhLElBQWZiO0FBRndDQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQiwyQkFBaEJBO0FBQTFCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFhLDJCQUFiQTtBQUFkQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NjUwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9jYW52YXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIENhbnZhcyA8IHNlbGZcbiAgeyB3aWR0aDogIDp3aWR0aCxcbiAgICBoZWlnaHQ6IDpoZWlnaHRcbiAgfS5lYWNoIHt8bmFtZSwgYXR0cmlidXRlfFxuICAgIGRlZmhlbHBlciBuYW1lIGRvIHx2YWx1ZXxcbiAgICAgIEBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZS50b19zXG4gICAgZW5kXG4gIH1cbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJlYWNoIiwiZGVmaGVscGVyIiwibmFtZSIsIiR3cml0ZXIiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsInRvX3MiLCJbXT0iLCJAYXR0cmlidXRlcyIsIi0iLCIxIiwic2VsZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7RUFVQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWMsT0FBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUEwQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRXhDLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBQyxNQUFBLDZCQUFBLFNBQVUsT0FBVixFQUFBLFVBQ1UsUUFEVixFQUFBQSxRQUFBQSxFQUFBQSxFQUFBQSxFQWRGLHNCQWdCVyxJQUFELEVBQU8sU0FoQmpCLEVBQUE7O0FBQUE7QUFBQTtBQWdCVyxZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0FoQlg7QUFBQTtBQWdCaUIsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBaEJqQjtBQUFBLFlBaUJJLE9BQUFDLFVBQUFBLGFBQUFBLEVBQUFBLENBQVVDLElBQVZELENBQUFBLEVBakJKLGdCQWlCdUIsS0FqQnZCLEVBQUE7QUFBQTs7QUFBQTtBQUFBO0FBaUJ1QixjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0FqQnZCO0FBQUEsY0FBQUUsVUFBQSxDQWtCa0JDLFNBbEJsQixFQWtCK0JDLEtBQUFDLE1BQUFBLENBQUFBLENBbEIvQixDQUFBO0FBQUEsY0FrQk1DLE1BQUFDLGVBQUFELE9BQUFBLEVBbEJOLFVBQUFKLE9BQUEsQ0FrQk1JLENBbEJOO0FBQUEsY0FBQSxPQUFBSixPQUFBLENBQUFNLFVBQUFOLE9BQUEsQ0FBQSxRQUFBLENBQUFNLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQUFBLGtCQUFBLGlCQUFBLEtBaUJJUixDQWpCSixDQUFBLHdCQUFBLHVCQUFBLFdBY0VEO0FBREZELFFBQUFBLEdBQUFBLFdBQUFBLEVBQWVZLElBQWZaO0FBRndDQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQiwyQkFBaEJBO0FBQTFCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFhLDJCQUFiQTtBQUFkQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NzA2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC9pbWcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEltZyA8IHNlbGZcbiAgeyBzcmM6IDpzcmMsXG4gICAgdXJsOiA6c3JjLFxuXG4gICAgYWx0OiAgICAgICAgIDphbHQsXG4gICAgZGVzY3JpcHRpb246IDphbHQsXG5cbiAgICBoZWlnaHQ6IDpoZWlnaHQsXG4gICAgd2lkdGg6ICA6d2lkdGgsXG5cbiAgICBtYXA6IDp1c2VtYXAsXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWUudG9fc1xuICAgIGVuZFxuICB9XG5cbiAgZGVmaGVscGVyIDptYXAhIGRvXG4gICAgQGF0dHJpYnV0ZXNbOmlzbWFwXSA9IHRydWVcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiZWFjaCIsImRlZmhlbHBlciIsIm5hbWUiLCIkd3JpdGVyIiwiYXR0cmlidXRlIiwidmFsdWUiLCJ0b19zIiwiW109IiwiQGF0dHJpYnV0ZXMiLCItIiwiMSIsInNlbGYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBVUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFjLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBMEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUV4QyxPQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUMsTUFBQSx3RUFBQSxPQUFPLEtBQVAsRUFBQSxPQUNPLEtBRFAsRUFBQSxPQUdlLEtBSGYsRUFBQSxlQUllLEtBSmYsRUFBQSxVQU1VLFFBTlYsRUFBQSxTQU9VLE9BUFYsRUFBQSxPQVNPLFFBVFAsRUFBQUEsUUFBQUEsRUFBQUEsRUFBQUEsRUFkRixtQkF3QlcsSUFBRCxFQUFPLFNBeEJqQixFQUFBOztBQUFBO0FBQUE7QUF3QlcsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBeEJYO0FBQUE7QUF3QmlCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQXhCakI7QUFBQSxZQXlCSSxPQUFBQyxVQUFBQSxhQUFBQSxFQUFBQSxDQUFVQyxJQUFWRCxDQUFBQSxFQXpCSixnQkF5QnVCLEtBekJ2QixFQUFBO0FBQUE7O0FBQUE7QUFBQTtBQXlCdUIsY0FBQTtBQUFBLGNBQUE7QUFBQSxjQUFBLENBekJ2QjtBQUFBLGNBQUFFLFVBQUEsQ0EwQmtCQyxTQTFCbEIsRUEwQitCQyxLQUFBQyxNQUFBQSxDQUFBQSxDQTFCL0IsQ0FBQTtBQUFBLGNBMEJNQyxNQUFBQyxlQUFBRCxPQUFBQSxFQTFCTixVQUFBSixPQUFBLENBMEJNSSxDQTFCTjtBQUFBLGNBQUEsT0FBQUosT0FBQSxDQUFBTSxVQUFBTixPQUFBLENBQUEsUUFBQSxDQUFBTSxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0FBQSxrQkFBQSxpQkFBQSxLQXlCSVIsQ0F6QkosQ0FBQSxxQkFBQSxvQkFBQSxRQWNFRCxDQUFBO0FBQUEsVUFnQkEsT0FBQUMsVUFBQUEsYUFBQUEsRUFBQUEsQ0FBVSxNQUFWQSxDQUFBQSxFQTlCRixtQkFBQSxFQUFBO0FBQUE7O0FBQUE7QUFBQSxZQUFBRSxVQUFBLENBK0JnQixPQS9CaEIsRUErQjBCLElBL0IxQixDQUFBO0FBQUEsWUErQklJLE1BQUFDLGVBQUFELE9BQUFBLEVBL0JKLFVBQUFKLE9BQUEsQ0ErQklJLENBL0JKO0FBQUEsWUFBQSxPQUFBSixPQUFBLENBQUFNLFVBQUFOLE9BQUEsQ0FBQSxRQUFBLENBQUFNLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQUFBLHFCQUFBLG9CQUFBLFFBOEJFUixDQWhCQTtBQURGRixRQUFBQSxHQUFBQSxXQUFBQSxFQUFZWSxJQUFaWjtBQUZ3Q0EsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IsMkJBQWhCQTtBQUExQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYSwyQkFBYkE7QUFBZEEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDc3MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvaW5wdXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIElucHV0IDwgc2VsZlxuICB7IHR5cGU6ICAgICAgICAgOnR5cGUsXG4gICAgbmFtZTogICAgICAgICA6bmFtZSxcbiAgICB2YWx1ZTogICAgICAgIDp2YWx1ZSxcbiAgICBzaXplOiAgICAgICAgIDpzaXplLFxuICAgIHBsYWNlX2hvbGRlcjogOnBsYWNlaG9sZGVyLFxuICAgIHJlYWRfb25seTogICAgOnJlYWRvbmx5LFxuICAgIHJlcXVpcmVkOiAgICAgOnJlcXVpcmVkLFxuICB9LmVhY2gge3xuYW1lLCBhdHRyaWJ1dGV8XG4gICAgZGVmaGVscGVyIG5hbWUgZG8gfHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlXG4gICAgZW5kXG4gIH1cbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJlYWNoIiwiZGVmaGVscGVyIiwibmFtZSIsIiR3cml0ZXIiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiLSIsIjEiLCJzZWxmIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztFQVVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBYyxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQTBCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFFeEMsT0FBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUFDLE1BQUEsb0ZBQUEsUUFBZ0IsTUFBaEIsRUFBQSxRQUNnQixNQURoQixFQUFBLFNBRWdCLE9BRmhCLEVBQUEsUUFHZ0IsTUFIaEIsRUFBQSxnQkFJZ0IsYUFKaEIsRUFBQSxhQUtnQixVQUxoQixFQUFBLFlBTWdCLFVBTmhCLEVBQUFBLFFBQUFBLEVBQUFBLEVBQUFBLEVBZEYscUJBcUJXLElBQUQsRUFBTyxTQXJCakIsRUFBQTs7QUFBQTtBQUFBO0FBcUJXLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQXJCWDtBQUFBO0FBcUJpQixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0FyQmpCO0FBQUEsWUFzQkksT0FBQUMsVUFBQUEsYUFBQUEsRUFBQUEsQ0FBVUMsSUFBVkQsQ0FBQUEsRUF0QkosZ0JBc0J1QixLQXRCdkIsRUFBQTtBQUFBOztBQUFBO0FBQUE7QUFzQnVCLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQXRCdkI7QUFBQSxjQUFBRSxVQUFBLENBdUJrQkMsU0F2QmxCLEVBdUIrQkMsS0F2Qi9CLENBQUE7QUFBQSxjQXVCTUMsTUFBQUMsZUFBQUQsT0FBQUEsRUF2Qk4sVUFBQUgsT0FBQSxDQXVCTUcsQ0F2Qk47QUFBQSxjQUFBLE9BQUFILE9BQUEsQ0FBQUssVUFBQUwsT0FBQSxDQUFBLFFBQUEsQ0FBQUssRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsa0JBQUEsaUJBQUEsS0FzQklQLENBdEJKLENBQUEsdUJBQUEsc0JBQUEsVUFjRUQ7QUFERkQsUUFBQUEsR0FBQUEsV0FBQUEsRUFBY1csSUFBZFg7QUFGd0NBLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWdCLDJCQUFoQkE7QUFBMUJBLElBQUFBLEdBQUFBLFdBQUFBLEVBQWEsMkJBQWJBO0FBQWRBLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ4MjYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC9lbGVtZW50L29iamVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0OyBjbGFzcyBFbGVtZW50IDwgQmFzaWNPYmplY3RcblxuY2xhc3MgT2JqZWN0IDwgc2VsZlxuICB7IHR5cGU6IDp0eXBlLFxuICAgIGRhdGE6IDpkYXRhLFxuICAgIG5hbWU6IDpuYW1lLFxuXG4gICAgaGVpZ2h0OiA6aGVpZ2h0LFxuICAgIHdpZHRoOiAgOndpZHRoXG4gIH0uZWFjaCB7fG5hbWUsIGF0dHJpYnV0ZXxcbiAgICBkZWZoZWxwZXIgbmFtZSBkbyB8dmFsdWV8XG4gICAgICBAYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWVcbiAgICBlbmRcbiAgfVxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImVhY2giLCJkZWZoZWxwZXIiLCJuYW1lIiwiJHdyaXRlciIsImF0dHJpYnV0ZSIsInZhbHVlIiwiW109IiwiQGF0dHJpYnV0ZXMiLCItIiwiMSIsInNlbGYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBVUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFjLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBMEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUV4QyxPQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQUMsTUFBQSxxREFBQSxRQUFRLE1BQVIsRUFBQSxRQUNRLE1BRFIsRUFBQSxRQUVRLE1BRlIsRUFBQSxVQUlVLFFBSlYsRUFBQSxTQUtVLE9BTFYsRUFBQUEsUUFBQUEsRUFBQUEsRUFBQUEsRUFkRixzQkFvQlcsSUFBRCxFQUFPLFNBcEJqQixFQUFBOztBQUFBO0FBQUE7QUFvQlcsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBcEJYO0FBQUE7QUFvQmlCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQXBCakI7QUFBQSxZQXFCSSxPQUFBQyxVQUFBQSxhQUFBQSxFQUFBQSxDQUFVQyxJQUFWRCxDQUFBQSxFQXJCSixnQkFxQnVCLEtBckJ2QixFQUFBO0FBQUE7O0FBQUE7QUFBQTtBQXFCdUIsY0FBQTtBQUFBLGNBQUE7QUFBQSxjQUFBLENBckJ2QjtBQUFBLGNBQUFFLFVBQUEsQ0FzQmtCQyxTQXRCbEIsRUFzQitCQyxLQXRCL0IsQ0FBQTtBQUFBLGNBc0JNQyxNQUFBQyxlQUFBRCxPQUFBQSxFQXRCTixVQUFBSCxPQUFBLENBc0JNRyxDQXRCTjtBQUFBLGNBQUEsT0FBQUgsT0FBQSxDQUFBSyxVQUFBTCxPQUFBLENBQUEsUUFBQSxDQUFBSyxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0FBQSxrQkFBQSxpQkFBQSxLQXFCSVAsQ0FyQkosQ0FBQSx3QkFBQSx1QkFBQSxXQWNFRDtBQURGRCxRQUFBQSxHQUFBQSxXQUFBQSxFQUFlVyxJQUFmWDtBQUZ3Q0EsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IsMkJBQWhCQTtBQUExQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYSwyQkFBYkE7QUFBZEEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDg4MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9odG1sL2VsZW1lbnQvdGQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5jbGFzcyBQYWdnaW87IGNsYXNzIEhUTUwgPCBCYXNpY09iamVjdDsgY2xhc3MgRWxlbWVudCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIFRkIDwgc2VsZlxuICBkZWZoZWxwZXIgOmNvbHVtbnMgZG8gfHZhbHVlfFxuICAgIEBhdHRyaWJ1dGVzWzpjb2xzcGFuXSA9IHZhbHVlLnRvX3NcbiAgZW5kXG5cbiAgZGVmaGVscGVyIDpyb3dzIGRvIHx2YWx1ZXxcbiAgICBAYXR0cmlidXRlc1s6cm93c3Bhbl0gPSB2YWx1ZS50b19zXG4gIGVuZFxuXG4gIGRlZmhlbHBlciA6aGVhZGVycyBkbyB8KmFyZ3N8XG4gICAgQGF0dHJpYnV0ZXNbOmhlYWRlcnNdID0gYXJncy5qb2luKCcgJylcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiZGVmaGVscGVyIiwiJHdyaXRlciIsInZhbHVlIiwidG9fcyIsIltdPSIsIkBhdHRyaWJ1dGVzIiwiLSIsIjEiLCJhcmdzIiwiam9pbiIsInNlbGYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBVUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFjLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBMEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUV4QyxPQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUMsVUFBQUEsYUFBQUEsRUFBQUEsQ0FBVSxTQUFWQSxDQUFBQSxFQWRGLGtCQWN5QixLQWR6QixFQUFBO0FBQUE7O0FBQUE7QUFBQTtBQWN5QixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0FkekI7QUFBQSxZQUFBQyxVQUFBLENBZWdCLFNBZmhCLEVBZTRCQyxLQUFBQyxNQUFBQSxDQUFBQSxDQWY1QixDQUFBO0FBQUEsWUFlSUMsTUFBQUMsZUFBQUQsT0FBQUEsRUFmSixVQUFBSCxPQUFBLENBZUlHLENBZko7QUFBQSxZQUFBLE9BQUFILE9BQUEsQ0FBQUssVUFBQUwsT0FBQSxDQUFBLFFBQUEsQ0FBQUssRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsb0JBQUEsbUJBQUEsT0FjRU4sQ0FBQTtBQUFBLFVBSUFBLFVBQUFBLGFBQUFBLEVBQUFBLENBQVUsTUFBVkEsQ0FBQUEsRUFsQkYsa0JBa0JzQixLQWxCdEIsRUFBQTtBQUFBOztBQUFBO0FBQUE7QUFrQnNCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQWxCdEI7QUFBQSxZQUFBQyxVQUFBLENBbUJnQixTQW5CaEIsRUFtQjRCQyxLQUFBQyxNQUFBQSxDQUFBQSxDQW5CNUIsQ0FBQTtBQUFBLFlBbUJJQyxNQUFBQyxlQUFBRCxPQUFBQSxFQW5CSixVQUFBSCxPQUFBLENBbUJJRyxDQW5CSjtBQUFBLFlBQUEsT0FBQUgsT0FBQSxDQUFBSyxVQUFBTCxPQUFBLENBQUEsUUFBQSxDQUFBSyxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0FBQSxvQkFBQSxtQkFBQSxPQWtCRU4sQ0FKQTtBQUFBLFVBUUEsT0FBQUEsVUFBQUEsYUFBQUEsRUFBQUEsQ0FBVSxTQUFWQSxDQUFBQSxFQXRCRixrQkFBQSxFQUFBLEVBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsWUFBQSw0REFBQTtBQUFBO0FBc0J5QixZQUFBLGtCQXRCekI7QUFBQSxZQUFBQyxVQUFBLENBdUJnQixTQXZCaEIsRUF1QjRCTyxJQUFBQyxNQUFBQSxDQUFVLEdBQVZBLENBdkI1QixDQUFBO0FBQUEsWUF1QklMLE1BQUFDLGVBQUFELE9BQUFBLEVBdkJKLFVBQUFILE9BQUEsQ0F1QklHLENBdkJKO0FBQUEsWUFBQSxPQUFBSCxPQUFBLENBQUFLLFVBQUFMLE9BQUEsQ0FBQSxRQUFBLENBQUFLLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQUFBLG9CQUFBLG9CQUFBLE9Bc0JFTixDQVJBO0FBREZELFFBQUFBLEdBQUFBLFdBQUFBLEVBQVdXLElBQVhYO0FBRndDQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQiwyQkFBaEJBO0FBQTFCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFhLDJCQUFiQTtBQUFkQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0OTUwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2h0bWwvZWxlbWVudC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvYSdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvYmFzZSdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvYmxvY2txdW90ZSdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvYnV0dG9uJ1xucmVxdWlyZSAncGFnZ2lvL2h0bWwvZWxlbWVudC9jYW52YXMnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L2ltZydcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvaW5wdXQnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50L29iamVjdCdcbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2VsZW1lbnQvdGQnXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0XG5cbmNsYXNzIEVsZW1lbnQgPCBCYXNpY09iamVjdFxuICBkZWYgc2VsZi5uZXcob3duZXIsIG5hbWUsIGF0dHJpYnV0ZXMgPSB7fSlcbiAgICByZXR1cm4gc3VwZXIgdW5sZXNzIHNlbGYgPT0gRWxlbWVudFxuXG4gICAgY29uc3QgPSBuYW1lLmNhcGl0YWxpemVcblxuICAgIGlmIGNvbnN0X2RlZmluZWQ/KGNvbnN0KVxuICAgICAgY29uc3RfZ2V0KGNvbnN0KS5uZXcob3duZXIsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUob3duZXIsIG5hbWUsIGF0dHJpYnV0ZXMgPSB7fSlcbiAgICBAb3duZXIgICAgICAgPSBvd25lclxuICAgIEBuYW1lICAgICAgICA9IG5hbWVcbiAgICBAYXR0cmlidXRlcyAgPSBhdHRyaWJ1dGVzXG4gICAgQGNoaWxkcmVuICAgID0gW11cbiAgICBAY2xhc3NfbmFtZXMgPSBbXVxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgQGNoaWxkcmVuLmVhY2goJmJsb2NrKVxuICBlbmRcblxuICBkZWYgPDwod2hhdClcbiAgICBAY2hpbGRyZW4gPDwgd2hhdFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcobmFtZSwgY29udGVudCA9IG5pbCwgJmJsb2NrKVxuICAgIGlmIGNvbnRlbnRcbiAgICAgIHNlbGYgPDwgOjpQYWdnaW86OlV0aWxzLmhlcmVkb2MoY29udGVudC50b19zKVxuICAgIGVuZFxuXG4gICAgaWYgbmFtZS50b19zLmVuZF93aXRoPyA/IVxuICAgICAgQGF0dHJpYnV0ZXNbOmlkXSA9IG5hbWVbMCAuLiAtMl1cbiAgICBlbHNlXG4gICAgICBAbGFzdCA9IG5hbWVcbiAgICAgIEBjbGFzc19uYW1lcy5wdXNoKG5hbWUpXG4gICAgZW5kXG5cbiAgICBAb3duZXIuZXh0ZW5kIShzZWxmLCAmYmxvY2spIGlmIGJsb2NrXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXSgqbmFtZXMpXG4gICAgcmV0dXJuIHVubGVzcyBAbGFzdFxuXG4gICAgQGNsYXNzX25hbWVzLnBvcFxuICAgIEBjbGFzc19uYW1lcy5wdXNoKFtAbGFzdCwgKm5hbWVzXS5qb2luKCctJykpXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkbygmYmxvY2spXG4gICAgQG93bmVyLmV4dGVuZCEoc2VsZiwgJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWZoZWxwZXIgOnN0eWxlIGRvIHxoYXNofFxuICAgIEBhdHRyaWJ1dGVzWzpzdHlsZV0gPSBoYXNoLm1hcCB7fG5hbWUsIHZhbHVlfFxuICAgICAgXCIje25hbWV9OiAje3ZhbHVlfVwiXG4gICAgfS5qb2luKCc7JylcbiAgZW5kXG5cbiAgZGVmaGVscGVyIDpkYXRhIGRvIHxoYXNofFxuICAgIGhhc2guZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgQGF0dHJpYnV0ZXNbXCJkYXRhLSN7bmFtZX1cIl0gPSB2YWx1ZS50b19zXG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGlmIEBjaGlsZHJlbi5lbXB0eT9cbiAgICAgIFwiIzxIVE1MOjpFbGVtZW50KCN7QG5hbWUudXBjYXNlfSk+XCJcbiAgICBlbHNlXG4gICAgICBcIiM8SFRNTDo6RWxlbWVudCgje0BuYW1lLnVwY2FzZX0pOiAje0BjaGlsZHJlbi5pbnNwZWN0WzEgLi4gLTJdfT5cIlxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsIm5ldyIsInNlbGYiLCI9PSIsImNvbnN0JCIsIm5hbWUiLCJjYXBpdGFsaXplIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9nZXQiLCJvd25lciIsImF0dHJpYnV0ZXMiLCJpbml0aWFsaXplIiwiQG93bmVyIiwiQG5hbWUiLCJAYXR0cmlidXRlcyIsIkBjaGlsZHJlbiIsIkBjbGFzc19uYW1lcyIsImVhY2giLCJibG9jayIsIjw8Iiwid2hhdCIsIm1ldGhvZF9taXNzaW5nIiwiY29udGVudCIsImhlcmVkb2MiLCJ0b19zIiwiZW5kX3dpdGg/IiwiJHdyaXRlciIsIltdIiwiMCIsIi0yIiwiW109IiwiLSIsIjEiLCJAbGFzdCIsInB1c2giLCJleHRlbmQhIiwicG9wIiwibmFtZXMiLCJqb2luIiwiZG8iLCJkZWZoZWxwZXIiLCJtYXAiLCJoYXNoIiwidmFsdWUiLCJpbnNwZWN0IiwiZW1wdHk/IiwidXBjYXNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFVQSxNQUFBQSxTQUFBQSxDQUFRLHVCQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FEQTtBQUFBLE1BRUFBLFNBQUFBLENBQVEsZ0NBQVJBLENBRkE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLDRCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSw0QkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEseUJBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLDJCQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSw0QkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsd0JBQVJBLENBUkE7QUFBQSxFQVVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBYyxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWQsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELFVBQUFBLGlCQUFBQSxTQUFhLEtBQUQsRUFBUSxJQUFSLEVBQWMsVUFBMUJBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQTtBQXhCRjtBQXdCNEIsVUFBQTtBQUFBLFVBQUEsZUFBYSxZQUFBLEVBQWI7QUFBQSxVQUFBLENBeEI1QjtB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QSxZQThGTU0sTUFBQWhCLGVBQUFnQixPQUFBQSxFQTlGTixVQUFBSixPQUFBLENBOEZNSSxDQTlGTjtBQUFBLFlBQUEsT0FBQUosT0FBQSxDQUFBSyxVQUFBTCxPQUFBLENBQUEsUUFBQSxDQUFBSyxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0FBQSxtQkFBQSxrQkFBQSxNQTZGSWQsQ0E3RkosQ0FBQSwwQkFBQSx5QkFBQSxhQTRGRXVCLENBcEVBO0FBQUEsUUEwRUEsT0FBQUksQ0FBQUEsMkJBQUFBLHNCQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsSUFBQSxRQUFHN0IsYUFBQThCLFdBQUFBLENBQUFBLENBQUgsQ0FBQTtBQUFBLFlBQ0UsT0FBQSxFQUFBLEdBQUEsa0JBQUEsR0FBQSxDQUFtQmhDLFNBQUFpQyxRQUFBQSxDQUFBQSxDQUFuQixDQUFBLEdBQUE7QUFERixVQUFBO0FBQUEsWUFHRSxPQUFBLEVBQUEsR0FBQSxrQkFBQSxHQUFBLENBQW1CakMsU0FBQWlDLFFBQUFBLENBQUFBLENBQW5CLENBQUEsR0FBQSxLQUFBLEdBQUEsQ0FBcUMvQixhQUFBNkIsU0FBQUEsQ0FBQUEsQ0FBQWpCLE9BQUFBLENBQWtCLE9BQUFLLENBQUEsRUFBS0gsRUFBTCxRQUFsQkYsQ0FBckMsQ0FBQSxHQUFBO0FBSEYsVUFBQTtBQURGaUIsUUFBQUEsQ0FBQUEsaUNBQUFBLENBQUFBLG1CQTFFQTtBQURGNUMsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IsMkJBQWhCQTtBQUZjQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFhLDJCQUFiQTtBQUFkQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQVZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjUxNTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vaHRtbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbnJlcXVpcmUgJ3BhZ2dpby9odG1sL2hlbHBlcnMnXG5yZXF1aXJlICdwYWdnaW8vaHRtbC9lbGVtZW50J1xuXG5jbGFzcyBQYWdnaW9cblxuY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0XG4gIGF0dHJfcmVhZGVyIDp2ZXJzaW9uXG5cbiAgZGVmIGluaXRpYWxpemUodmVyc2lvbiA9IDUsICZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICBAdmVyc2lvbiA9IHZlcnNpb25cbiAgICBAcm9vdHMgICA9IFtdXG4gICAgQGN1cnJlbnQgPSBuaWxcblxuICAgIGlmIGJsb2NrLmFyaXR5ID09IDBcbiAgICAgIGluc3RhbmNlX2V4ZWMoJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIGJsb2NrLmNhbGwoc2VsZilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw8KHdoYXQpXG4gICAgKEBjdXJyZW50IHx8IEByb290cykgPDwgd2hhdFxuICBlbmRcblxuICBkZWYgcm9vdCFcbiAgICBAcm9vdHMuZmlyc3RcbiAgZW5kXG5cbiAgZGVmIHJvb3RzIVxuICAgIEByb290c1xuICBlbmRcblxuICBkZWYgZWxlbWVudCFcbiAgICBAY3VycmVudFxuICBlbmRcblxuICBkZWYgZXh0ZW5kIShlbGVtZW50ID0gbmlsLCAmYmxvY2spXG4gICAgb2xkLCBAY3VycmVudCA9IEBjdXJyZW50LCBlbGVtZW50XG5cbiAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYpXG5cbiAgICBpZiA6OlN0cmluZyA9PT0gcmVzdWx0XG4gICAgICBAY3VycmVudC5pbnN0YW5jZV9ldmFsIHsgQGlubmVyX2h0bWwgPSByZXN1bHQgfVxuICAgIGVuZFxuXG4gICAgQGN1cnJlbnQgPSBvbGRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIEByb290cy5lYWNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsICphcmdzLCAmYmxvY2spXG4gICAgaWYgbmFtZS50b19zLmVuZF93aXRoPyA/IVxuICAgICAgcmV0dXJuIHN1cGVyXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgYXJncy5lbXB0eT8gfHwgOjpIYXNoID09PSBhcmdzLmZpcnN0XG4gICAgICBjb250ZW50ID0gOjpQYWdnaW86OlV0aWxzLmhlcmVkb2MoYXJncy5zaGlmdC50b19zKVxuICAgIGVuZFxuXG4gICAgZWxlbWVudCA9IEVsZW1lbnQubmV3KHNlbGYsIG5hbWUsICphcmdzKVxuICAgIGVsZW1lbnQgPDwgY29udGVudCBpZiBjb250ZW50XG5cbiAgICBpZiBibG9ja1xuICAgICAgcGFyZW50ICAgPSBAY3VycmVudFxuICAgICAgQGN1cnJlbnQgPSBlbGVtZW50XG4gICAgICByZXN1bHQgICA9IGJsb2NrLmNhbGwoc2VsZilcbiAgICAgIEBjdXJyZW50ID0gcGFyZW50XG5cbiAgICAgIGlmIDo6U3RyaW5nID09PSByZXN1bHRcbiAgICAgICAgZWxlbWVudC5pbnN0YW5jZV9ldmFsIHsgQGlubmVyX2h0bWwgPSByZXN1bHQgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBzZWxmIDw8IGVsZW1lbnRcblxuICAgIGVsZW1lbnRcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpZiBAcm9vdHMuZW1wdHk/XG4gICAgICBcIiM8SFRNTCgjQHZlcnNpb24pPlwiXG4gICAgZWxzZVxuICAgICAgXCIjPEhUTUwoI0B2ZXJzaW9uKTogI3tAcm9vdHMuaW5zcGVjdFsxIC4uIC0yXX0+XCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiNSIsImJsb2NrIiwicmFpc2UiLCJAdmVyc2lvbiIsInZlcnNpb24iLCJAcm9vdHMiLCJAY3VycmVudCIsImFyaXR5IiwiPT0iLCIwIiwiaW5zdGFuY2VfZXhlYyIsImNhbGwiLCJzZWxmIiwiPDwiLCJ3aGF0Iiwicm9vdCEiLCJmaXJzdCIsInJvb3RzISIsImVsZW1lbnQhIiwiZXh0ZW5kISIsImVsZW1lbnQiLCJvbGQiLCJyZXN1bHQiLCI9PT0iLCJpbnN0YW5jZV9ldmFsIiwiQGlubmVyX2h0bWwiLCJlYWNoIiwibWV0aG9kX21pc3NpbmciLCJuYW1lIiwidG9fcyIsImVuZF93aXRoPyIsImFyZ3MiLCJlbXB0eT8iLCJjb250ZW50IiwiaGVyZWRvYyIsInNoaWZ0IiwibmV3IiwicGFyZW50IiwiaW5zcGVjdCIsIltdIiwiMSIsIi0yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFVQSxNQUFBQSxTQUFBQSxDQUFRLHFCQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSxxQkFBUkEsQ0FEQTtBQUFBLEVBR0EsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUVBLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxVQUFBQyxhQUFBQSxDQUFZLFNBQVpBLENBQUE7QUFBQTtBQUVBQyxNQUFBQSw4QkFBQUEscUJBQUFBLHNCQUFlLE9BQWZBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQTtBQW5CRjtBQW1COEIsUUFBQSx5Q0FuQjlCO0FBQUE7QUFtQmlCLFFBQUE7QUFBQSxRQUFBLFlBQVVDLENBQVY7QUFBQSxRQUFBLENBbkJqQjtBQUFBLFFBb0JJLElBQUEsUUFBd0RDLEtBQXhELENBQUE7QUFBQSxRQUFBO0FBQUEsVUFBQSxJQUFBLElBQUEsV0FBQUMsT0FBQUEsQ0FBZSxJQUFBLElBQUEsb0JBQWlCLGdCQUFoQ0E7QUFBQSxRQUFBLENBcEJKO0FBQUEsUUFzQklDLGVBQVdDLE9BdEJmO0FBQUEsUUF1QklDLGFBQVcsRUF2QmY7QUFBQSxRQXdCSUMsZUFBVyxHQXhCZjtBQUFBLFFBMEJJLElBQUdMLEtBQUFNLE9BQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWVDLENBQWZELENBQUg7QUFBQSxVQUNFLE9BQUFFLFVBQUFBLGlCQUFBQSxFQUFBQSxFQUFBQSxFQUFlVCxnQkFBZlM7QUFERixRQUFBO0FBQUEsVUFHRSxPQUFBVCxLQUFBVSxNQUFBQSxDQUFXQyxJQUFYRDtBQUhGLFFBQUEsQ0ExQko7QUFtQkVaLE1BQUFBLENBQUFBLGlDQUFBQSxDQUZBO0FBQUE7QUFnQkFjLE1BQUFBLHNCQUFBQSxpQkFBQUEsU0FBTyxJQUFQQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFDLGNBQUFQLFlBQUEsU0FBWUQsVUFBWixDQUFEUSxPQUFBQSxDQUF3QkMsSUFBeEJEO0FBREZBLE1BQUFBLENBQUFBLDRCQUFBQSxDQWhCQTtBQUFBO0FBb0JBRSxNQUFBQSx5QkFBQUEsb0JBQUFBLFNBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUFWLFVBQUFXLE9BQUFBLENBQUFBO0FBREZELE1BQUFBLENBQUFBLCtCQUFBQSxDQXBCQTtBQUFBO0FBd0JBRSxNQUFBQSwwQkFBQUEscUJBQUFBLFNBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUFaO0FBREZZLE1BQUFBLENBQUFBLGdDQUFBQSxDQXhCQTtBQUFBO0FBNEJBQyxNQUFBQSw0QkFBQUEsdUJBQUFBLFNBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUFaO0FBREZZLE1BQUFBLENBQUFBLGtDQUFBQSxDQTVCQTtBQUFBO0FBZ0NBQyxNQUFBQSwyQkFBQUEsc0JBQUFBLFNBQVksT0FBWkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBO0FBakRGO0FBaUQ2QixRQUFBLDBDQWpEN0I7QUFBQTtBQWlEYyxRQUFBO0FBQUEsUUFBQSxZQUFVLEdBQVY7QUFBQSxRQUFBLENBakRkO0FBQUEsUUFrREksS0FBZ0IsQ0FBQWIsWUFBQSxFQUFVYyxPQUFWLENBQWhCLEVBQUFDLENBQUFBLFdBQUFBLENBQUEsRUFBS2YsQ0FBQUEsb0JBQUFBLENBQUwsSUFsREo7QUFBQSxRQW9ESWdCLFNBQVNyQixLQUFBVSxNQUFBQSxDQUFXQyxJQUFYRCxDQXBEYjtBQUFBLFFBc0RJLElBQUEsUUFBRyxJQUFBLElBQUEsV0FBQVksUUFBQUEsQ0FBYUQsTUFBYkMsQ0FBSCxDQUFBO0FBQUEsVUFDRUMsTUFBQWxCLFlBQUFrQixpQkFBQUEsRUFBQUEsRUFBQUEsRUF2RE4sZ0JBQUEsRUFBQTs7QUFBQSxVQXVEK0IsT0FBQUMsQ0FBQUEsa0JBQWNILE1BQWRHLENBdkQvQixrQkFBQSxpQkFBQSxLQXVETUQsQ0FERixDQXRESjtBQUFBLFFBMERJbEIsZUFBV2UsR0ExRGY7QUFBQSxRQTRESSxPQUFBVCxJQTVESjtBQWlERU8sTUFBQUEsQ0FBQUEsa0NBQUFBLENBaENBO0FBQUE7QUE4Q0FPLE1BQUFBLHdCQUFBQSxlQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBO0FBL0RGO0FBK0RXLFFBQUEsbUNBL0RYO0FBQUEsUUFnRUksT0FBQUEsTUFBQXJCLFVBQUFxQixRQUFBQSxFQUFBQSxFQUFBQSxFQUFhekIsZ0JBQWJ5QixDQWhFSjtBQStERUEsTUFBQUEsQ0FBQUEsMEJBQUFBLENBOUNBO0FBQUE7QUFrREFDLE1BQUFBLGtDQUFBQSx5QkFBQUEsMEJBQW1CLElBQUQsRUFuRXBCLEVBbUVFQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFBQUE7QUFBQUEsUUFBQUE7QUFBQUEsUUFBQUE7QUFBQUEsUUFBQUE7QUFBQUEsUUFBQUE7QUFBQUE7QUFuRUY7QUFtRWtDLFFBQUEsNkNBbkVsQztBQUFBO0FBQUEsUUFBQSw0REFBQTtBQUFBO0FBbUUyQixRQUFBLGtCQW5FM0I7QUFBQSxRQW9FSSxJQUFBLFFBQUdDLElBQUFDLE1BQUFBLENBQUFBLENBQUFDLGNBQUFBLENBQW9CLEdBQXBCQSxDQUFILENBQUE7QUFBQSxVQUNFLE9BQU8sVUFBQSxFQUFBLGlGQUFBLFFBQUEsT0FBQSxDQURULENBcEVKO0FBQUEsUUF3RUksSUFBQSxRQUFPLGNBQUFDLElBQUFDLFdBQUFBLENBQUFBLENBQUEsU0FBZSxJQUFBLElBQUEsU0FBQVQsUUFBQUEsQ0FBV1EsSUFBQWYsT0FBQUEsQ0FBQUEsQ0FBWE8sQ0FBZixDQUFQLENBQUE7QUFBQSxRQUFBO0FBQUEsVUFDRVUsVUFBVSxJQUFBLElBQUEsSUFBQSxXQUFBLFVBQUFDLFNBQUFBLENBQXdCSCxJQUFBSSxPQUFBQSxDQUFBQSxDQUFBTixNQUFBQSxDQUFBQSxDQUF4Qks7QUFEWixRQUFBLENBeEVKO0FBQUEsUUE0RUlkLFVBQVVnQixNQUFBLHVCQUFBQSxPQUFBQSxHQUFZeEIsTUFBTWdCLGFBQU0sVUFBQ0csSUFBRCxFQUF4QkssQ0E1RWQ7QUFBQSxRQTZFSSxJQUFBLFFBQXNCSCxPQUF0QixDQUFBO0FBQUEsVUFBQWIsT0FBQVAsT0FBQUEsQ0FBV29CLE9BQVhwQixDQUFBLENBN0VKO0FBQUEsUUErRUksSUFBQSxRQUFHWixLQUFILENBQUE7QUFBQTtBQUNFLFVBQUFvQyxTQUFXL0IsWUFBWDtBQUFBLFVBQ0FBLGVBQVdjLE9BRFg7QUFBQSxVQUVBRSxTQUFXckIsS0FBQVUsTUFBQUEsQ0FBV0MsSUFBWEQsQ0FGWDtBQUFBLFVBR0FMLGVBQVcrQixNQUhYO0FBQUEsVUFLQSxJQUFBLFFBQUcsSUFBQSxJQUFBLFdBQUFkLFFBQUFBLENBQWFELE1BQWJDLENBQUgsQ0FBQTtBQUFBLFlBQ0VDLE1BQUFKLE9BQUFJLGlCQUFBQSxFQUFBQSxFQUFBQSxFQXRGUixpQkFBQSxFQUFBOztBQUFBLFlBc0ZnQyxPQUFBQyxDQUFBQSxrQkFBY0gsTUFBZEcsQ0F0RmhDLG1CQUFBLGtCQUFBLE1Bc0ZRRCxDQURGLENBTEEsQ0FERixDQS9FSjtBQUFBLFFBMEZJWixJQUFBQyxPQUFBQSxDQUFRTyxPQUFSUCxDQTFGSjtBQUFBLFFBNEZJLE9BQUFPLE9BNUZKO0FBbUVFTyxNQUFBQSxDQUFBQSxxQ0FBQUEsQ0FsREE7QUFBQSxNQThFQSxPQUFBVyxDQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxJQUFBLFFBQUdqQyxVQUFBMkIsV0FBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUEsVUFDRSxPQUFBLEVBQUEsR0FBQSxTQUFBLEdBQUEsQ0FBUzdCLFlBQVQsQ0FBQSxHQUFBO0FBREYsUUFBQTtBQUFBLFVBR0UsT0FBQSxFQUFBLEdBQUEsU0FBQSxHQUFBLENBQVNBLFlBQVQsQ0FBQSxHQUFBLEtBQUEsR0FBQSxDQUFzQkUsVUFBQWlDLFNBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWUsT0FBQUMsQ0FBQSxFQUFLQyxFQUFMLFFBQWZGLENBQXRCLENBQUEsR0FBQTtBQUhGLFFBQUE7QUFERkQsTUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLG1CQTlFQTtBQURGekMsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYSwyQkFBYkE7QUFGQUEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FIQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MzA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFnZ2lvL2Nzcy91bml0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBDU1MgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBVbml0XG4gIFRZUEVTICAgICAgPSAld1tlbSBleCBjaCByZW0gdmggdncgdm1pbiB2bWF4IHB4IG1tIGNtIGluIHB0IHBjIHMgZGVnXS5tYXAoJjp0b19zeW0pXG4gIENPTVBBVElCTEUgPSAld1tpbiBwdCBtbSBjbSBweCBwY10ubWFwKCY6dG9fc3ltKVxuXG4gIGF0dHJfcmVhZGVyIDp0eXBlLCA6bnVtYmVyXG5cbiAgZGVmIGluaXRpYWxpemUobnVtYmVyLCB0eXBlKVxuICAgIEBudW1iZXIgPSBudW1iZXJcbiAgICBAdHlwZSAgID0gdHlwZVxuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIHJldHVybiBzZWxmLCBvdGhlclxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgdW5sZXNzIFVuaXQgPT09IG90aGVyXG4gICAgICB1bmxlc3Mgb3RoZXIucmVzcG9uZF90bz8gOnRvX3VcbiAgICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tvdGhlci5jbGFzc30gaW50byBVbml0XCJcbiAgICAgIGVuZFxuXG4gICAgICBvdGhlciA9IG90aGVyLnRvX3VcbiAgICBlbmRcblxuICAgIHVubGVzcyBVbml0ID09PSBvdGhlclxuICAgICAgb3RoZXIgPSBVbml0Lm5ldyhvdGhlciwgQHR5cGUpXG4gICAgZW5kXG5cbiAgICBAbnVtYmVyID09IGNvbnZlcnQob3RoZXIsIEB0eXBlKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIEB0eXBlID09IG90aGVyLnR5cGUgJiYgQG51bWJlciA9PSBvdGhlci5udW1iZXJcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBoYXNoXG4gICAgW0BudW1iZXIsIEB0eXBlXS5oYXNoXG4gIGVuZFxuXG4gIFRZUEVTLmVhY2gge3xuYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgVW5pdC5uZXcoY29udmVydChzZWxmLCBuYW1lKSwgbmFtZSlcbiAgICBlbmRcbiAgfVxuXG4gIGRlZiArKG90aGVyKVxuICAgIHJldHVybiBVbml0Lm5ldyhAbnVtYmVyICsgb3RoZXIsIEB0eXBlKSB1bmxlc3MgVW5pdCA9PT0gb3RoZXJcblxuICAgIGlmIEB0eXBlID09IG90aGVyLnR5cGVcbiAgICAgIFVuaXQubmV3KEBudW1iZXIgKyBvdGhlci5udW1iZXIsIEB0eXBlKVxuICAgIGVsc2lmIGNvbXBhdGlibGU/KHNlbGYpIGFuZCBjb21wYXRpYmxlPyhvdGhlcilcbiAgICAgIFVuaXQubmV3KEBudW1iZXIgKyBjb252ZXJ0KG90aGVyLCBAdHlwZSksIEB0eXBlKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tvdGhlci50eXBlfSBpc24ndCBjb21wYXRpYmxlIHdpdGggI3tAdHlwZX1cIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICByZXR1cm4gVW5pdC5uZXcoQG51bWJlciAtIG90aGVyLCBAdHlwZSkgdW5sZXNzIFVuaXQgPT09IG90aGVyXG5cbiAgICBpZiBAdHlwZSA9PSBvdGhlci50eXBlXG4gICAgICBVbml0Lm5ldyhAbnVtYmVyIC0gb3RoZXIubnVtYmVyLCBAdHlwZSlcbiAgICBlbHNpZiBjb21wYXRpYmxlPyhzZWxmKSBhbmQgY29tcGF0aWJsZT8ob3RoZXIpXG4gICAgICBVbml0Lm5ldyhAbnVtYmVyIC0gY29udmVydChvdGhlciwgQHR5cGUpLCBAdHlwZSlcbiAgICBlbHNlXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7b3RoZXIudHlwZX0gaXNuJ3QgY29tcGF0aWJsZSB3aXRoICN7QHR5cGV9XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgcmV0dXJuIFVuaXQubmV3KEBudW1iZXIgKiBvdGhlciwgQHR5cGUpIHVubGVzcyBVbml0ID09PSBvdGhlclxuXG4gICAgaWYgQHR5cGUgPT0gb3RoZXIudHlwZVxuICAgICAgVW5pdC5uZXcoQG51bWJlciAqIG90aGVyLm51bWJlciwgQHR5cGUpXG4gICAgZWxzaWYgY29tcGF0aWJsZT8oc2VsZikgYW5kIGNvbXBhdGlibGU/KG90aGVyKVxuICAgICAgVW5pdC5uZXcoQG51bWJlciAqIGNvbnZlcnQob3RoZXIsIEB0eXBlKSwgQHR5cGUpXG4gICAgZWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCIje290aGVyLnR5cGV9IGlzbid0IGNvbXBhdGlibGUgd2l0aCAje0B0eXBlfVwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgIHJldHVybiBVbml0Lm5ldyhAbnVtYmVyIC8gb3RoZXIsIEB0eXBlKSB1bmxlc3MgVW5pdCA9PT0gb3RoZXJcblxuICAgIGlmIEB0eXBlID09IG90aGVyLnR5cGVcbiAgICAgIFVuaXQubmV3KEBudW1iZXIgLyBvdGhlci5udW1iZXIsIEB0eXBlKVxuICAgIGVsc2lmIGNvbXBhdGlibGU/KHNlbGYpIGFuZCBjb21wYXRpYmxlPyhvdGhlcilcbiAgICAgIFVuaXQubmV3KEBudW1iZXIgLyBjb252ZXJ0KG90aGVyLCBAdHlwZSksIEB0eXBlKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tvdGhlci50eXBlfSBpc24ndCBjb21wYXRpYmxlIHdpdGggI3tAdHlwZX1cIlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBVbml0Lm5ldyhAbnVtYmVyICogLTEsIEB0eXBlKVxuICBlbmRcblxuICBkZWYgK0BcbiAgICBVbml0Lm5ldyhAbnVtYmVyLCBAdHlwZSlcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBAbnVtYmVyLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBAbnVtYmVyLnRvX2ZcbiAgZW5kXG5cbiAgZGVmIHRvX3VcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIjQG51bWJlciNAdHlwZVwiXG4gIGVuZFxuXG4gIGFsaWFzIHRvX3N0ciB0b19zXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuXG5wcml2YXRlXG4gIGRlZiBjb21wYXRpYmxlPyh1bml0KVxuICAgIENPTVBBVElCTEUuaW5jbHVkZT8odW5pdC50eXBlKVxuICBlbmRcblxuICBkZWYgY29udmVydCh1bml0LCB0eXBlKVxuICAgIHZhbHVlID0gdW5pdC5udW1iZXJcblxuICAgIHJldHVybiB2YWx1ZSBpZiB1bml0LnR5cGUgPT0gdHlwZVxuXG4gICAgcHggPSBjYXNlIHVuaXQudHlwZVxuICAgIHdoZW4gOmluIHRoZW4gdmFsdWUgKiA5NlxuICAgIHdoZW4gOnB0IHRoZW4gdmFsdWUgKiA0LjAgLyAzLjBcbiAgICB3aGVuIDpwYyB0aGVuIHZhbHVlIC8gMTIgKiA0LjAgLyAzLjBcbiAgICB3aGVuIDptbSB0aGVuIHZhbHVlICogMy43Nzk1M1xuICAgIHdoZW4gOmNtIHRoZW4gdmFsdWUgKiAxMCAqIDMuNzc5NTNcbiAgICB3aGVuIDpweCB0aGVuIHZhbHVlXG4gICAgZW5kXG5cbiAgICBjYXNlIHR5cGVcbiAgICB3aGVuIDppbiB0aGVuIHB4IC8gOTYuMFxuICAgIHdoZW4gOnB0IHRoZW4gcHggLyA0LjAgLyAzLjBcbiAgICB3aGVuIDpwYyB0aGVuIHB4ICogMTIgLyA0LjAgLyAzLjBcbiAgICB3aGVuIDptbSB0aGVuIHB4IC8gMy43Nzk1M1xuICAgIHdoZW4gOmNtIHRoZW4gcHggLyAxMCAvIDMuNzc5NTNcbiAgICB3aGVuIDpweCB0aGVuIHB4XG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG5cbmNsYXNzIE51bWVyaWNcbiAgUGFnZ2lvOjpDU1M6OlVuaXQ6OlRZUEVTLmVhY2gge3xuYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgUGFnZ2lvOjpDU1M6OlVuaXQubmV3KHNlbGYsIG5hbWUpXG4gICAgZW5kXG4gIH1cblxuICBkZWYgdG9fdVxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuW0ZpeG51bSwgRmxvYXRdLmVhY2gge3xrbGFzc3xcbiAga2xhc3MuY2xhc3NfZXZhbCB7XG4gICAgYWxpYXMgb2xkX3BlcmNlbnQgJVxuXG4gICAgZGVmICUob3RoZXIgPSBuaWwpXG4gICAgICBpZiBvdGhlclxuICAgICAgICBvbGRfcGVyY2VudChvdGhlcilcbiAgICAgIGVsc2VcbiAgICAgICAgUGFnZ2lvOjpDU1M6OlVuaXQubmV3KHNlbGYsIDolKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIH1cbn1cblxuY2xhc3MgU3RyaW5nXG4gIGRlZiB0b191XG4gICAgaWYgbWF0Y2hlcyA9IG1hdGNoKC9eKFtcXGQrLl0rKSguKyk/JC8pXG4gICAgICB2YWx1ZSA9IG1hdGNoZXNbMV0udG9fZlxuXG4gICAgICBpZiB1bml0ID0gbWF0Y2hlc1syXVxuICAgICAgICB2YWx1ZS5fX3NlbmRfXyh1bml0LmRvd25jYXNlKVxuICAgICAgZWxzZVxuICAgICAgICB2YWx1ZVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgMFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBOaWxDbGFzc1xuICBkZWYgdG9fdVxuICAgIDBcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIm1hcCIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkBudW1iZXIiLCJudW1iZXIiLCJAdHlwZSIsInR5cGUiLCJjb2VyY2UiLCJzZWxmIiwib3RoZXIiLCI9PSIsIj09PSIsInJlc3BvbmRfdG8/IiwicmFpc2UiLCJ0b191IiwibmV3IiwiY29udmVydCIsImhhc2giLCJlYWNoIiwiZGVmaW5lX21ldGhvZCIsIm5hbWUiLCIrIiwiY29tcGF0aWJsZT8iLCItIiwiKiIsIi8iLCItQCIsIi0xIiwiK0AiLCJ0b19pIiwidG9fZiIsInRvX3MiLCJwcml2YXRlIiwiaW5jbHVkZT8iLCJ1bml0IiwidmFsdWUiLCJweCIsIjk2IiwiMTIiLCIxMCIsImNsYXNzX2V2YWwiLCJrbGFzcyIsIiUiLCJvbGRfcGVyY2VudCIsIm1hdGNoZXMiLCJtYXRjaCIsIltdIiwiMSIsIjIiLCJfX3NlbmRfXyIsImRvd25jYXNlIiwiMCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFjLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFZCxPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsUUFBQSxxQ0FBYUMsTUFBQSxDQUFHLElBQUgsRUFBTSxJQUFOLEVBQVMsSUFBVCxFQUFZLEtBQVosRUFBZ0IsSUFBaEIsRUFBbUIsSUFBbkIsRUFBc0IsTUFBdEIsRUFBMkIsTUFBM0IsRUFBZ0MsSUFBaEMsRUFBbUMsSUFBbkMsRUFBc0MsSUFBdEMsRUFBeUMsSUFBekMsRUFBNEMsSUFBNUMsRUFBK0MsSUFBL0MsRUFBa0QsR0FBbEQsRUFBb0QsS0FBcEQsQ0FBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBOEQsbUJBQTlEQSxDQUFiLENBQUE7QUFBQSxRQUNBLDBDQUFhQSxNQUFBLENBQUcsSUFBSCxFQUFNLElBQU4sRUFBUyxJQUFULEVBQVksSUFBWixFQUFlLElBQWYsRUFBa0IsSUFBbEIsQ0FBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBMkIsbUJBQTNCQSxDQUFiLENBREE7QUFBQSxZQUdBQyxhQUFBQSxDQUFZLFFBQU8sUUFBbkJBLENBSEE7QUFBQTtBQUtBQyxRQUFBQSw4QkFBQUEscUJBQUFBLHNCQUFlLE1BQUQsRUFBUyxJQUF2QkE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUMsY0FBVUMsTUFBVjtBQUFBLFVBQ0EsT0FBQUMsQ0FBQUEsWUFBVUMsSUFBVkQsQ0FEQTtBQURGSCxRQUFBQSxDQUFBQSxnQ0FBQUEs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LElBQ0UsT0FBQWUsQ0FBQUEsd0JBQUFBLGtCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQUFHOEIsQ0FBQUEsY0FBVUMsT0FBQUEsQ0FBTSxrQkFBTkEsQ0FBVkQsQ0FBSCxDQUFBO0FBQUE7QUFDRSxRQUFBVCxRQUFRUyxPQUFBRSxPQUFBQSxDQUFRQyxDQUFSRCxDQUFBaEIsTUFBQUEsQ0FBQUEsQ0FBUjtBQUFBLFFBRUEsSUFBQSxRQUFHSSxDQUFBQSxPQUFPVSxPQUFBRSxPQUFBQSxDQUFRRSxDQUFSRixDQUFQWixDQUFILENBQUE7QUFBQSxVQUNFLE9BQUFDLEtBQUFjLFVBQUFBLENBQWVmLElBQUFnQixVQUFBQSxDQUFBQSxDQUFmRDtBQURGLFFBQUE7QUFBQSxVQUdFLE9BQUFkO0FBSEYsUUFBQSxDQUZBO0FBREYsTUFBQTtBQUFBLFFBU0UsT0FBQWdCO0FBVEYsTUFBQTtBQURGckMsSUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBO0FBREZmLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBdExBO0FBQUEsRUFzTUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUFlLENBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFxQztBQURGckMsSUFBQUEsQ0FBQUEsK0JBQUFBLENBQUFBO0FBREZmLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBdE1BOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjU2MjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vY3NzL2NvbG9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxuY2xhc3MgUGFnZ2lvOyBjbGFzcyBDU1MgPCBCYXNpY09iamVjdFxuXG5jbGFzcyBDb2xvclxuICBkZWYgaW5pdGlhbGl6ZSh2YWx1ZSwgdHlwZSlcbiAgICBAaW50ZXJuYWwgPSB2YWx1ZVxuICAgIEB0eXBlICAgICA9IHR5cGVcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcblxuY2xhc3MgU3RyaW5nXG4gICV3W3JnYiByZ2JhIGhzbCBoc2xhXS5tYXAoJjp0b19zeW0pLmVhY2gge3xuYW1lfFxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgUGFnZ2lvOjpDU1M6OkNvbG9yLm5ldyhzZWxmLCBuYW1lKVxuICAgIGVuZFxuICB9XG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgJXdbcmdiIHJnYmEgaHNsIGhzbGFdLm1hcCgmOnRvX3N5bSkuZWFjaCB7fG5hbWV8XG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBQYWdnaW86OkNTUzo6Q29sb3IubmV3KHNlbGYsIG5hbWUpXG4gICAgZW5kXG4gIH1cbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiaW5pdGlhbGl6ZSIsIkBpbnRlcm5hbCIsInZhbHVlIiwiQHR5cGUiLCJ0eXBlIiwiZWFjaCIsIm1hcCIsImRlZmluZV9tZXRob2QiLCJuYW1lIiwibmV3Iiwic2VsZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBVUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFjLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFZCxPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQUMsQ0FBQUEsOEJBQUFBLHNCQUFBQSxzQkFBZSxLQUFELEVBQVEsSUFBdEJBO0FBQUFBLFVBQUFBOztBQUFBQTtBQUNFLFVBQUFDLGdCQUFZQyxLQUFaO0FBQUEsVUFDQSxPQUFBQyxDQUFBQSxZQUFZQyxJQUFaRCxDQURBO0FBREZILFFBQUFBLENBQUFBLGlDQUFBQSxDQUFBQTtBQURGRCxNQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUZjQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFZLDJCQUFaQTtBQUFkQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUFBO0FBQUEsRUFXQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUFNLE1BQUFDLE1BQUEsQ0FBRyxLQUFILEVBQU8sTUFBUCxFQUFZLEtBQVosRUFBZ0IsTUFBaEIsQ0FBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBMkIsbUJBQTNCQSxDQUFBRCxRQUFBQSxFQUFBQSxFQUFBQSxFQXZCRixzQkF1QjZDLElBdkI3QyxFQUFBOztBQUFBO0FBQUE7QUF1QjZDLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQXZCN0M7QUFBQSxNQXdCSSxPQUFBRSxVQUFBQSxpQkFBQUEsRUFBQUEsQ0FBY0MsSUFBZEQsQ0FBQUEsRUF4QkosZ0JBQUEsRUFBQTs7QUFBQSxNQXlCTSxPQUFBLElBQUEsSUFBQSxzQkFBQSxRQUFBLFVBQUFFLEtBQUFBLENBQXVCQyxNQUFNRixJQUE3QkMsQ0F6Qk4sa0JBQUEsaUJBQUEsS0F3QklGLENBeEJKLENBQUEsd0JBQUEsdUJBQUEsV0F1QkVGO0FBREZOLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBWEE7QUFBQSxFQW1CQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQU0sTUFBQUMsTUFBQSxDQUFHLEtBQUgsRUFBTyxNQUFQLEVBQVksS0FBWixFQUFnQixNQUFoQixDQUFBQSxPQUFBQSxFQUFBQSxFQUFBQSxFQUEyQixtQkFBM0JBLENBQUFELFFBQUFBLEVBQUFBLEVBQUFBLEVBL0JGLHFCQStCNkMsSUEvQjdDLEVBQUE7O0FBQUE7QUFBQTtBQStCNkMsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLENBL0I3QztBQUFBLE1BZ0NJLE9BQUFFLFVBQUFBLGlCQUFBQSxFQUFBQSxDQUFjQyxJQUFkRCxDQUFBQSxFQWhDSixnQkFBQSxFQUFBOztBQUFBLE1BaUNNLE9BQUEsSUFBQSxJQUFBLHNCQUFBLFFBQUEsVUFBQUUsS0FBQUEsQ0FBdUJDLE1BQU1GLElBQTdCQyxDQWpDTixrQkFBQSxpQkFBQSxLQWdDSUYsQ0FoQ0osQ0FBQSx1QkFBQSxzQkFBQSxVQStCRUY7QUFERk4sRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FuQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTY4OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9jc3MvZGVmaW5pdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbmNsYXNzIFBhZ2dpbzsgY2xhc3MgQ1NTIDwgQmFzaWNPYmplY3RcblxuY2xhc3MgRGVmaW5pdGlvbiA8IEJhc2ljT2JqZWN0XG4gIFN0eWxlID0gOjpTdHJ1Y3QubmV3KDpuYW1lLCA6dmFsdWUsIDppbXBvcnRhbnQpXG5cbiAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgIEBzdHlsZSA9IFtdXG5cbiAgICBpZiBibG9jay5hcml0eSA9PSAwXG4gICAgICBpbnN0YW5jZV9leGVjKCZibG9jaylcbiAgICBlbHNlXG4gICAgICBibG9jay5jYWxsKHNlbGYpXG4gICAgZW5kIGlmIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBlbXB0eT9cbiAgICBAc3R5bGUuZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICBAc3R5bGUuZWFjaCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBncmFkaWVudCgqYXJncylcbiAgICBHcmFkaWVudC5uZXcoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiB1cmwoYXJnKVxuICAgIFwidXJsKCN7YXJnLmluc3BlY3R9KVwiXG4gIGVuZFxuXG4gIGRlZiBiYWNrZ3JvdW5kKCphcmdzKVxuICAgIGlmIEdyYWRpZW50ID09PSBhcmdzLmZpcnN0XG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IDFcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgXCJtdWx0aXBsZSBncmFkaWVudHMgbm90IGltcGxlbWVudGVkIHlldFwiXG4gICAgICBlbmRcblxuICAgICAgYXJncy5maXJzdC5lYWNoIHt8c3xcbiAgICAgICAgc3R5bGUgcy5uYW1lIHx8ICdiYWNrZ3JvdW5kLWltYWdlJywgcy52YWx1ZVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGlmIDo6SGFzaCA9PT0gYXJncy5maXJzdFxuICAgICAgICBhcmdzLmZpcnN0LmVhY2gge3xzdWIsIHZhbHVlfFxuICAgICAgICAgIHN0eWxlIFwiYmFja2dyb3VuZC0je3N1Yn1cIiwgdmFsdWVcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBzdHlsZSA6YmFja2dyb3VuZCwgYXJnc1xuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBib3JkZXIoKmFyZ3MpXG4gICAgaWYgOjpIYXNoID09PSBhcmdzLmZpcnN0XG4gICAgICBpZiBhcmdzLmxlbmd0aCA9PSAxXG4gICAgICAgIG9wdGlvbnMgPSBhcmdzLmZpcnN0XG4gICAgICBlbmRcblxuICAgICAgb3B0aW9ucy5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICAgIGNhc2UgbmFtZVxuICAgICAgICB3aGVuIDpyYWRpdXNcbiAgICAgICAgICBpZiA6Okhhc2ggPT09IHZhbHVlXG4gICAgICAgICAgICB2YWx1ZS5lYWNoIHt8aG9yaXpvbnRhbCwgdmFsdWV8XG4gICAgICAgICAgICAgIHZhbHVlLmVhY2gge3x2ZXJ0aWNhbCwgdmFsdWV8XG4gICAgICAgICAgICAgICAgc3R5bGUgXCItbW96LWJvcmRlci1yYWRpdXMtI3tob3Jpem9udGFsfSN7dmVydGljYWx9XCIsIHZhbHVlXG4gICAgICAgICAgICAgICAgc3R5bGUgXCItd2Via2l0LWJvcmRlci0je2hvcml6b250YWx9LSN7dmVydGljYWx9LXJhZGl1c1wiLCB2YWx1ZVxuICAgICAgICAgICAgICAgIHN0eWxlIFwiYm9yZGVyLSN7aG9yaXpvbnRhbH0tI3t2ZXJ0aWNhbH0tcmFkaXVzXCIsIHZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdHlsZSAnLW1vei1ib3JkZXItcmFkaXVzJywgdmFsdWVcbiAgICAgICAgICAgIHN0eWxlICctd2Via2l0LWJvcmRlci1yYWRpdXMnLCB2YWx1ZVxuICAgICAgICAgICAgc3R5bGUgJ2JvcmRlci1yYWRpdXMnLCB2YWx1ZVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgIHdoZW4gOmNvbG9yXG4gICAgICAgICAgaWYgOjpIYXNoID09PSB2YWx1ZVxuICAgICAgICAgICAgdmFsdWUuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgICAgICAgICBzdHlsZSBcImJvcmRlci0je25hbWV9LWNvbG9yXCIsIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3R5bGUgJ2JvcmRlci1jb2xvcicsIHZhbHVlXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0eWxlIFwiYm9yZGVyLSN7bmFtZX1cIiwgdmFsdWVcbiAgICAgICAgZW5kXG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3R5bGUgOmJvcmRlciwgYXJnc1xuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYm94KG9wdGlvbnMpXG4gICAgaWYgOjpIYXNoID09PSBvcHRpb25zXG4gICAgICBvcHRpb25zLmVhY2gge3xuYW1lLCB2YWx1ZXxcbiAgICAgICAgY2FzZSBuYW1lXG4gICAgICAgIHdoZW4gOnNoYWRvd1xuICAgICAgICAgIGlmIDo6QXJyYXkgPT09IHZhbHVlXG4gICAgICAgICAgICBpZiA6OkFycmF5ID09PSB2YWx1ZVswXVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCB7IHx2fCB2LmpvaW4gJyAnIH0uam9pbignLCAnKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmpvaW4gJyAnXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHN0eWxlICctbW96LWJveC1zaGFkb3cnLCB2YWx1ZVxuICAgICAgICAgIHN0eWxlICctd2Via2l0LWJveC1zaGFkb3cnLCB2YWx1ZVxuICAgICAgICAgIHN0eWxlICdib3gtc2hhZG93JywgdmFsdWVcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgc3R5bGUgXCJib3gtI3tuYW1lfVwiLCB2YWx1ZVxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzdHlsZSA6Ym94LCBvcHRpb25zXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBvcGFjaXR5KHZhbHVlKVxuICAgIHN0eWxlICdvcGFjaXR5JywgdmFsdWVcbiAgICBzdHlsZSAnLW1vei1vcGFjaXR5JywgdmFsdWVcblxuICAgIHN0eWxlICctbXMtZmlsdGVyJywgJVF7XCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT0jeyh2YWx1ZSAqIDEwMCkudG9faX0pXCJ9XG4gICAgc3R5bGUgJ2ZpbHRlcicsIFwiYWxwaGEob3BhY2l0eT0jeyh2YWx1ZSAqIDEwMCkudG9faX0pXCJcbiAgZW5kXG5cbiAgZGVmIGFuaW1hdGlvbigqYXJncylcbiAgICBzdHlsZSAnYW5pbWF0aW9uJywgYXJnc1xuICAgIHN0eWxlICctd2Via2l0LWFuaW1hdGlvbicsIGFyZ3NcbiAgZW5kXG5cbiAgZGVmIHRyYW5zaXRpb24oKmFyZ3MpXG4gICAgc3R5bGUgJ3RyYW5zaXRpb24nLCBhcmdzXG4gICAgc3R5bGUgJy13ZWJraXQtdHJhbnNpdGlvbicsIGFyZ3NcbiAgICBzdHlsZSAnLW1vei10cmFuc2l0aW9uJywgYXJnc1xuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcobmFtZSwgKmFyZ3MsICZibG9jaylcbiAgICBuYW1lICAgICAgPSBuYW1lLnRvX3NcbiAgICBpbXBvcnRhbnQgPSBuYW1lLmVuZF93aXRoPyA/IVxuICAgIG5hbWUgICAgICA9IG5hbWVbMCAuLiAtMl0gaWYgaW1wb3J0YW50XG5cbiAgICBAaW1wb3J0YW50ID0gdHJ1ZSBpZiBpbXBvcnRhbnRcblxuICAgIGlmIGltcG9ydGFudCAmJiByZXNwb25kX3RvPyhuYW1lKVxuICAgICAgX19zZW5kX18gbmFtZSwgKmFyZ3MsICZibG9ja1xuICAgICAgQGltcG9ydGFudCA9IGZhbHNlXG5cbiAgICAgIHJldHVyblxuICAgIGVuZFxuXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMVxuICAgICAgYXJndW1lbnQgPSBhcmdzLmZpcnN0XG5cbiAgICAgIGlmIDo6SGFzaCA9PT0gYXJndW1lbnRcbiAgICAgICAgYXJndW1lbnQuZWFjaCB7fHN1YiwgdmFsdWV8XG4gICAgICAgICAgc3R5bGUgXCIje25hbWV9LSN7c3VifVwiLCB2YWx1ZVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0eWxlIG5hbWUsIGFyZ3VtZW50XG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdHlsZSBuYW1lLCBhcmdzLmpvaW4oJyAnKVxuICAgIGVuZFxuXG4gICAgQGltcG9ydGFudCA9IGZhbHNlXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzdHlsZShuYW1lLCB2YWx1ZSA9IG5pbCwgaW1wb3J0YW50ID0gQGltcG9ydGFudClcbiAgICBpZiA6OkFycmF5ID09PSB2YWx1ZVxuICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luICcgJ1xuICAgIGVuZFxuXG4gICAgaWYgU3R5bGUgPT09IG5hbWVcbiAgICAgIEBzdHlsZSA8PCBuYW1lXG4gICAgZWxzZVxuICAgICAgQHN0eWxlIDw8IFN0eWxlLm5ldyhuYW1lLCB2YWx1ZSwgaW1wb3J0YW50KVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc3R5bGUhKG5hbWUsIHZhbHVlID0gbmlsKVxuICAgIHN0eWxlKG5hbWUsIHZhbHVlLCB0cnVlKVxuICBlbmRcblxuICBjbGFzcyBHcmFkaWVudFxuICAgICMgVE9ETzogYWxsIG9mIGl0LCBzZXJpb3VzbHlcbiAgICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAgIG9wdGlvbnMgPSA6Okhhc2ggPT09IGFyZ3MubGFzdCA/IGFyZ3MucG9wIDoge31cblxuICAgICAgQHRvICAgPSBvcHRpb25zWzp0b11cbiAgICAgIEBmcm9tID0gb3B0aW9uc1s6ZnJvbV1cblxuICAgICAgaWYgQHRvICYmICFAZnJvbVxuICAgICAgICBAZnJvbSA9IG90aGVyKEB0bylcbiAgICAgIGVsc2lmIEBmcm9tICYmICFAdG9cbiAgICAgICAgQHRvID0gb3RoZXIoQGZyb20pXG4gICAgICBlbmRcblxuICAgICAgQHN0YXJ0ID0gYXJncy5zaGlmdFxuICAgICAgQGVuZCAgID0gYXJncy5zaGlmdFxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2goJmJsb2NrKVxuICAgICAgYmxvY2suY2FsbCBzdHlsZShcIi1tb3otbGluZWFyLWdyYWRpZW50KCNAdG8sICNAc3RhcnQgMCUsICNAZW5kIDEwMCUpXCIpXG5cbiAgICAgIGlmIGhvcml6b250YWw/XG4gICAgICAgIGJsb2NrLmNhbGwgc3R5bGUoXCItd2Via2l0LWdyYWRpZW50KGxpbmVhciwgI0Bmcm9tIHRvcCwgI0B0byB0b3AsIGNvbG9yLXN0b3AoMCUsICNAc3RhcnQpLCBjb2xvci1zdG9wKDEwMCUsICNAZW5kKSlcIilcbiAgICAgIGVsc2VcbiAgICAgICAgYmxvY2suY2FsbCBzdHlsZShcIi13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0ICNAZnJvbSwgbGVmdCAjQHRvLCBjb2xvci1zdG9wKDAlLCAjQHN0YXJ0KSwgY29sb3Itc3RvcCgxMDAlLCAjQGVuZCkpXCIpXG4gICAgICBlbmRcblxuICAgICAgYmxvY2suY2FsbCBzdHlsZShcIi13ZWJraXQtbGluZWFyLWdyYWRpZW50KCNAdG8sICNAc3RhcnQgMCUsICNAZW5kIDEwMCUpXCIpXG4gICAgICBibG9jay5jYWxsIHN0eWxlKFwiLW8tbGluZWFyLWdyYWRpZW50KCNAdG8sICNAc3RhcnQgMCUsICNAZW5kIDEwMCUpXCIpXG4gICAgICBibG9jay5jYWxsIHN0eWxlKFwiLW1zLWxpbmVhci1ncmFkaWVudCgjQHRvLCAjQHN0YXJ0IDAlLCAjQGVuZCAxMDAlKVwiKVxuICAgICAgYmxvY2suY2FsbCBzdHlsZShcImxpbmVhci1ncmFkaWVudCh0byAjQHRvLCAjQHN0YXJ0IDAlLCAjQGVuZCAxMDAlKVwiKVxuICAgIGVuZFxuXG4gICAgZGVmIGhvcml6b250YWw/XG4gICAgICBAdG8gPT0gOmxlZnQgfHwgQHRvID09IDpyaWdodFxuICAgIGVuZFxuXG4gICAgZGVmIHZlcnRpY2FsP1xuICAgICAgQHRvID09IDp0b3AgfHwgQHRvID09IDpib3R0b21cbiAgICBlbmRcblxuICBwcml2YXRlXG4gICAgZGVmIG90aGVyKHNpZGUpXG4gICAgICBjYXNlIHNpZGVcbiAgICAgIHdoZW4gOmxlZnQgICB0aGVuIDpyaWdodFxuICAgICAgd2hlbiA6cmlnaHQgIHRoZW4gOmxlZnRcbiAgICAgIHdoZW4gOnRvcCAgICB0aGVuIDpib3R0b21cbiAgICAgIHdoZW4gOmJvdHRvbSB0aGVuIDp0b3BcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBGSVhNRTogdXNlIGRlZmF1bHQgYXJnc1xuICAgIGRlZiBzdHlsZSgqYXJncylcbiAgICAgIGlmIGFyZ3MubGVuZ3RoID09IDFcbiAgICAgICAgU3R5bGUubmV3KG5pbCwgYXJncy5maXJzdClcbiAgICAgIGVsc2VcbiAgICAgICAgU3R5bGUubmV3KCphcmdzKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJuZXciLCJpbml0aWFsaXplIiwiQHN0eWxlIiwiYmxvY2siLCJhcml0eSIsIj09IiwiMCIsImluc3RhbmNlX2V4ZWMiLCJjYWxsIiwic2VsZiIsImVtcHR5PyIsImVhY2giLCJncmFkaWVudCIsImFyZ3MiLCJ1cmwiLCJhcmciLCJpbnNwZWN0IiwiYmFja2dyb3VuZCIsIj09PSIsImZpcnN0IiwiPiIsImxlbmd0aCIsIjEiLCJyYWlzZSIsInN0eWxlIiwicyIsIm5hbWUiLCJ2YWx1ZSIsInN1YiIsImJvcmRlciIsIm9wdGlvbnMiLCJob3Jpem9udGFsIiwidmVydGljYWwiLCJib3giLCJbXSIsIm1hcCIsInYiLCJqb2luIiwib3BhY2l0eSIsIioiLCIxMDAiLCJ0b19pIiwiYW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsIm1ldGhvZF9taXNzaW5nIiwidG9fcyIsImltcG9ydGFudCIsImVuZF93aXRoPyIsIi0yIiwiQGltcG9ydGFudCIsInJlc3BvbmRfdG8/IiwiX19zZW5kX18iLCJhcmd1bWVudCIsIjw8Iiwic3R5bGUhIiwibGFzdCIsInBvcCIsIkB0byIsIkBmcm9tIiwiISIsIm90aGVyIiwiQHN0YXJ0Iiwic2hpZnQiLCJAZW5kIiwiaG9yaXpvbnRhbD8iLCJ2ZXJ0aWNhbD8iLCJwcml2YXRlIiwic2lkZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFVQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWMsT0FBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVkLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxRQUFBLHFDQUFRLElBQUEsSUFBQSxXQUFBQyxLQUFBQSxDQUFhLFFBQU8sU0FBUSxXQUE1QkEsQ0FBUixDQUFBO0FBQUE7QUFFQUMsUUFBQUEsOEJBQUFBLDJCQUFBQSxzQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQUFBO0FBQUFBO0FBaEJGO0FBZ0JpQixVQUFBLCtDQWhCakI7QUFBQSxVQWlCSUMsYUFBUyxFQWpCYjtBQUFBLFVBbUJJLElBQUEsUUFJT0MsS0FKUCxDQUFBO0FBQUEsWUFBQSxJQUFHQSxLQUFBQyxPQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFlQyxDQUFmRCxDQUFIO0FBQUEsY0FDRSxPQUFBRSxVQUFBQSxpQkFBQUEsRUFBQUEsRUFBQUEsRUFBZUosZ0JBQWZJO0FBREYsWUFBQTtBQUFBLGNBR0UsT0FBQUosS0FBQUssTUFBQUEsQ0FBV0MsSUFBWEQ7QUFIRixZQUFBO0FBQUEsVUFBQTtBQUFBO0FBQUEsVUFBQSxDQW5CSjtBQWdCRVAsUUFBQUEsQ0FBQUEsc0NBQUFBLENBRkE7QUFBQTtBQVlBUyxRQUFBQSwwQkFBQUEsMkJBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUFSLFVBQUFRLFdBQUFBLENBQUFBO0FBREZBLFFBQUFBLENBQUFBLHNDQUFBQSxDQVpBO0FBQUE7QUFnQkFDLFFBQUFBLHdCQUFBQSxxQkFBQUEsZ0JBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUFBQTtBQUFBQTtBQTlCRjtBQThCVyxVQUFBLHlDQTlCWDtBQUFBLFVBK0JJLE9BQUFBLE1BQUFULFVBQUFTLFFBQUFBLEVBQUFBLEVBQUFBLEVBQWFSLGdCQUFiUSxDQS9CSjtBQThCRUEsUUFBQUEsQ0FBQUEsZ0NBQUFBLENBaEJBO0FBQUE7QUFvQkFDLFFBQUFBLDRCQUFBQSx5QkFBQUEsb0JBbENGLEVBa0NFQTtBQUFBQSxVQUFBQTs7QUFBQUE7QUFsQ0Y7QUFBQSxVQUFBLDREQUFBO0FBQUE7QUFrQ2UsVUFBQSxrQkFsQ2Y7QUFBQSxVQW1DSSxPQUFBWixNQUFBLHdCQUFBQSxPQUFBQSxFQUFhLFVBQUNhLElBQUQsQ0FBYmIsQ0FuQ0o7QUFrQ0VZLFFBQUFBLENBQUFBLHFDQUFBQSxDQXBCQTtBQUFBO0FBd0JBRSxRQUFBQSx1QkFBQUEsb0JBQUFBLGVBQVEsR0FBUkE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSxFQUFBLEdBQUEsTUFBQSxHQUFBLENBQU9DLEdBQUFDLFNBQUFBLENBQUFBLENBQVAsQ0FBQSxHQUFBO0FBREZGLFFBQUFBLENBQUFBLCtCQUFBQSxDQXhCQTtBQUFBO0FBNEJBRyxRQUFBQSw4QkFBQUEsMkJBQUFBLHNCQTFDRixFQTBDRUE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBMUNGO0FBQUEsVUFBQSw0REFBQTtBQUFBO0FBMENpQixVQUFBLGtCQTFDakI7QUFBQSxVQTJDSSxJQUFBLFFBQUcsd0JBQUFDLFFBQUFBLENBQWFMLElBQUFNLE9BQUFBLENBQUFBLENBQWJELENBQUgsQ0FBQTtBQUFBO0FBQ0UsWUFBQSxJQUFBLFFBQUdFLE9BQUFQLElBQUFRLFFBQUFBLENBQUFBLENBQUFELEVBQWNFLENBQWRGLENBQUgsQ0FBQTtBQUFBLGtCQUNFRyxPQUFBQSxDQUFNLHFDQUFxQix3Q0FBM0JBLENBREYsQ0FBQTtBQUFBLFlBSUEsT0FBQVosTUFBQUUsSUFBQU0sT0FBQUEsQ0FBQUEsQ0FBQVIsUUFBQUEsRUFBQUEsRUFBQUEsRUFoRE4sZ0JBZ0R3QixDQWhEeEIsRUFBQTs7QUFBQTtBQUFBO0FBZ0R3QixjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0FoRHhCO0FBQUEsY0FpRFEsV0FBQWEsT0FBQUEsQ0FBTSxjQUFBQyxDQUFBQyxNQUFBQSxDQUFBQSxDQUFBLFNBQVUsa0JBQVYsR0FBOEJELENBQUFFLE9BQUFBLENBQUFBLENBQXBDSCxDQWpEUixDQUFBLGtCQUFBLGlCQUFBLEtBZ0RNYixDQUpBO0FBREYsVUFBQSxPQVNFLElBQUEsUUFBRyxJQUFBLElBQUEsU0FBQU8sUUFBQUEsQ0FBV0wsSUFBQU0sT0FBQUEsQ0FBQUEsQ0FBWEQsQ0FBSCxDQUFBO0FBQUEsWUFDRSxPQUFBUCxNQUFBRSxJQUFBTSxPQUFBQSxDQUFBQSxDQUFBUixRQUFBQSxFQUFBQSxFQUFBQSxFQXJEUixnQkFxRDBCLEdBQUQsRUFBTSxLQXJEL0IsRUFBQTs7QUFBQTtBQUFBO0FBcUQwQixjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0FyRDFCO0FBQUE7QUFxRCtCLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQXJEL0I7QUFBQSxjQXNEVSxXQUFBYSxPQUFBQSxDQUFNLEVBQUEsR0FBQSxhQUFBLEdBQUEsQ0FBY0ksR0FBZCxHQUFxQkQsS0FBM0JILENBdERWLENBQUEsa0JBQUEsaUJBQUEsS0FxRFFiO0FBREYsVUFBQTtBQUFBLFlBS0UsV0FBQWEsT0FBQUEsQ0FBTSxjQUFhWCxJQUFuQlc7QUFMRixVQUFBLENBcEROO0FBMENFUCxRQUFBQSxDQUFBQSx1Q0FBQUEsQ0E1QkE7QUFBQTtBQWdEQVksUUFBQUEsMEJBQUFBLHVCQUFBQSxrQkE5REYsRUE4REVBO0FBQUFBLFVBQUFBOztBQUFBQTtBQTlERjtBQUFBLFVBQUEsNERBQUE7QUFBQTtBQThEYSxVQUFBLGtCQTlEYjtBQUFBLFVBK0RJLElBQUEsUUFBRyxJQUFBLElBQUEsU0FBQVgsUUFBQUEsQ0FBV0wsSUFBQU0sT0FBQUEsQ0FBQUEsQ0FBWEQsQ0FBSCxDQUFBO0FBQUE7QUFDRSxZQUFBLElBQUdMLElBQUFRLFFBQUFBLENBQUFBLENBQUFoQixPQUFBQSxDQUFlaUIsQ0FBZmpCLENBQUg7QUFBQSxjQUNFeUIsVUFBVWpCLElBQUFNLE9BQUFBLENBQUFBLENBRFosQ0FBQTtBQUFBLFlBSUEsT0FBQVIsTUFBQW1CLE9BQUFuQixRQUFBQSxFQUFBQSxFQUFBQSxFQXBFTixpQkFvRXFCLElBQUQsRUFBTyxLQXBFM0IsRUFBQTs7QUFBQTtBQUFBO0FBb0VxQixjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0FwRXJCO0FBQUE7QUFvRTJCLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQXBFM0I7QUFBQSxjQXFFUSxPQUFBLGFBQUEsUUFBS2UsSUFBTDtBQUFBLGNBQ0EsSUFBSyx1QkFBTCxHQUNFLElBQUEsUUFBRyxJQUFBLElBQUEsU0FBQVIsUUFBQUEsQ0FBV1MsS0FBWFQsQ0FBSCxDQUFBO0FBQUEsZ0JBQ0UsT0FBQVAsTUFBQWdCLEtBQUFoQixRQUFBQSxFQUFBQSxFQUFBQSxFQXhFWixpQkF3RXlCLFVBQUQsRUFBYSxLQXhFckMsRUFBQTs7QUFBQTtBQUFBO0FBd0V5QixrQkFBQTtBQUFBLGtCQUFBO0FBQUEsa0JBQUEsQ0F4RXpCO0FBQUE7QUF3RXFDLGtCQUFBO0FBQUEsa0JBQUE7QUFBQSxrQkFBQSxDQXhFckM7QUFBQSxrQkF5RWMsT0FBQUEsTUFBQWdCLEtBQUFoQixRQUFBQSxFQUFBQSxFQUFBQSxFQXpFZCxpQkF5RTJCLFFBQUQsRUFBVyxLQXpFckMsRUFBQTs7QUFBQTtBQUFBO0FBeUUyQixvQkFBQTtBQUFBLG9CQUFBO0FBQUEsb0JBQUEsQ0F6RTNCO0FBQUE7QUF5RXFDLG9CQUFBO0FBQUEsb0JBQUE7QUFBQSxvQkFBQSxDQXpFckM7QUFBQSx3QkEwRWdCYSxPQUFBQSxDQUFNLEVBQUEsR0FBQSxxQkFBQSxHQUFBLENBQXNCTyxVQUF0QixDQUFBLEdBQUEsQ0FBbUNDLFFBQW5DLEdBQStDTCxLQUFyREgsQ0ExRWhCO0FBQUEsd0JBMkVnQkEsT0FBQUEsQ0FBTSxFQUFBLEdBQUEsaUJBQUEsR0FBQSxDQUFrQk8sVUFBbEIsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFnQ0MsUUFBaEMsQ0FBQSxHQUFBLFdBQW1ETCxLQUF6REgsQ0EzRWhCO0FBQUEsb0JBNEVnQixXQUFBQSxPQUFBQSxDQUFNLEVBQUEsR0FBQSxTQUFBLEdBQUEsQ0FBVU8sVUFBVixDQUFBLEdBQUEsR0FBQSxHQUFBLENBQXdCQyxRQUF4QixDQUFBLEdBQUEsV0FBMkNMLEtBQWpESCxDQTVFaEIsQ0FBQSxtQkFBQSxrQkFBQSxNQXlFY2IsQ0F6RWQsQ0FBQSxtQkFBQSxrQkFBQSxNQXdFWUE7QUFERixjQUFBO0FBQUE7QUFTRSxvQkFBQWEsT0FBQUEsQ0FBTSxzQkFBc0JHLEtBQTVCSCxDQUFBO0FBQUEsb0JBQ0FBLE9BQUFBLENBQU0seUJBQXlCRyxLQUEvQkgsQ0FEQTtBQUFBLGdCQUVBLFdBQUFBLE9BQUFBLENBQU0saUJBQWlCRyxLQUF2QkgsQ0FGQTtBQVRGLGNBQUEsQ0FERjtBQURBLGNBQUEsS0FnQkEsSUFBSyxzQkFBTCxHQUNFLElBQUEsUUFBRyxJQUFBLElBQUEsU0FBQU4sUUFBQUEsQ0FBV1MsS0FBWFQsQ0FBSCxDQUFBO0FBQUEsZ0JBQ0UsT0FBQVAsTUFBQWdCLEtBQUFoQixRQUFBQSxFQUFBQSxFQUFBQSxFQXZGWixpQkF1RnlCLElBQUQsRUFBTyxLQXZGL0IsRUFBQTs7QUFBQTtBQUFBO0FBdUZ5QixrQkFBQTtBQUFBLGtCQUFBO0FBQUEsa0JBQUEsQ0F2RnpCO0FBQUE7QUF1RitCLGtCQUFBO0FBQUEsa0JBQUE7QUFBQSxrQkFBQSxDQXZGL0I7QUFBQSxrQkF3RmMsV0FBQWEsT0FBQUEsQ0FBTSxFQUFBLEdBQUEsU0FBQSxHQUFBLENBQVVFLElBQVYsQ0FBQSxHQUFBLFVBQXdCQyxLQUE5QkgsQ0F4RmQsQ0FBQSxtQkFBQSxrQkFBQSxNQXVGWWI7QUFERixjQUFBO0FBQUEsZ0JBS0UsV0FBQWEsT0FBQUEsQ0FBTSxnQkFBZ0JHLEtBQXRCSDtBQUxGLGNBQUEsQ0FERjtBQWhCQSxjQUFBLE1BMEJFLFdBQUFBLE9BQUFBLENBQU0sRUFBQSxHQUFBLFNBQUEsR0FBQSxDQUFVRSxJQUFWLEdBQWtCQyxLQUF4QkgsQ0ExQkYsQ0FBQSxJQXJFUixDQUFBLG1CQUFBLGtCQUFBLE1Bb0VNYixDQUpBO0FBREYsVUFBQTtBQUFBLFlBb0NFLFdBQUFhLE9BQUFBLENBQU0sVUFBU1gsSUFBZlc7QUFwQ0YsVUFBQSxDQS9ESjtBQThERUssUUFBQUEsQ0FBQUEsbUNBQUFBLENBaERBO0FBQUE7QUF5RkFJLFFBQUFBLHVCQUFBQSxxQkFBQUEsZUFBUSxPQUFSQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxJQUFBLFFBQUcsSUFBQSxJQUFBLFNBQUFmLFFBQUFBLENBQVdZLE9BQVhaLENBQUgsQ0FBQTtBQUFBLFlBQ0UsT0FBQVAsTUFBQW1CLE9BQUFuQixRQUFBQSxFQUFBQSxFQUFBQSxFQXpHTixpQkF5R3FCLElBQUQsRUFBTyxLQXpHM0IsRUFBQTs7QUFBQTtBQUFBO0FBeUdxQixjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0F6R3JCO0FBQUE7QUF5RzJCLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQXpHM0I7QUFBQSxjQTBHUSxPQUFBLGFBQUEsUUFBS2UsSUFBTDtBQUFBLGNBQ0EsSUFBSyx1QkFBTDtBQUNFLGNBQUEsSUFBQSxRQUFHLElBQUEsSUFBQSxVQUFBUixRQUFBQSxDQUFZUyxLQUFaVCxDQUFILENBQUE7QUFBQSxnQkFDRSxJQUFBLFFBQUcsSUFBQSxJQUFBLFVBQUFBLFFBQUFBLENBQVlTLEtBQUFPLE9BQUFBLENBQU01QixDQUFONEIsQ0FBWmhCLENBQUgsQ0FBQTtBQUFBLGtCQUNFUyxRQUFRUSxNQUFBUixLQUFBUSxPQUFBQSxFQUFBQSxFQUFBQSxFQTlHdEIsaUJBOEdtQyxDQTlHbkMsRUFBQTs7QUFBQTtBQUFBO0FBOEdtQyxvQkFBQTtBQUFBLG9CQUFBO0FBQUEsb0JBQUEsQ0E5R25DO0FBQUEsb0JBOEdzQyxPQUFBQyxDQUFBQyxNQUFBQSxDQUFPLEdBQVBBLENBOUd0QyxDQUFBLG1CQUFBLGtCQUFBLE1BOEdzQkYsQ0FBQUUsTUFBQUEsQ0FBa0MsSUFBbENBO0FBRFYsZ0JBQUE7QUFBQSxrQkFHRVYsUUFBUUEsS0FBQVUsTUFBQUEsQ0FBVyxHQUFYQTtBQUhWLGdCQUFBLENBREYsQ0FBQTtBQUFBLGtCQVFBYixPQUFBQSxDQUFNLG1CQUFtQkcsS0FBekJILENBUkE7QUFBQSxrQkFTQUEsT0FBQUEsQ0FBTSxzQkFBc0JHLEtBQTVCSCxDQVRBO0FBQUEsY0FVQSxXQUFBQSxPQUFBQSxDQUFNLGNBQWNHLEtBQXBCSCxDQVZBLENBREY7QUFEQSxjQUFBLE1BZUUsV0FBQUEsT0FBQUEsQ0FBTSxFQUFBLEdBQUEsTUFBQSxHQUFBLENBQU9FLElBQVAsR0FBZUMsS0FBckJILENBZkYsQ0FBQSxJQTFHUixDQUFBLG1CQUFBLGtCQUFBLE1BeUdNYjtBQURGLFVBQUE7QUFBQSxZQXFCRSxXQUFBYSxPQUFBQSxDQUFNLE9BQU1NLE9BQVpOO0FBckJGLFVBQUE7QUFERlMsUUFBQUEsQ0FBQUEsZ0NBQUFBLENBekZBO0FBQUE7QUFtSEFLLFFBQUFBLDJCQUFBQSx5QkFBQUEsbUJBQVksS0FBWkE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQ0UsY0FBQWQsT0FBQUEsQ0FBTSxXQUFXRyxLQUFqQkgsQ0FBQTtBQUFBLGNBQ0FBLE9BQUFBLENBQU0sZ0JBQWdCRyxLQUF0QkgsQ0FEQTtBQUFBLGNBR0FBLE9BQUFBLENBQU0sY0FBYyxFQUFBLEdBQUEsb0RBQUEsR0FBQSxDQUF1RGUsVUFBQVosS0FBQVksRUFBUUMsR0FBUkQsQ0FBREUsTUFBQUEsQ0FBQUEsQ0FBdEQsQ0FBQSxHQUFBLEtBQXBCakIsQ0FIQTtBQUFBLFVBSUEsV0FBQUEsT0FBQUEsQ0FBTSxVQUFVLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWtCZSxVQUFBWixLQUFBWSxFQUFRQyxHQUFSRCxDQUFERSxNQUFBQSxDQUFBQSxDQUFqQixDQUFBLEdBQUEsR0FBaEJqQixDQUpBO0FBREZjLFFBQUFBLENBQUFBLG9DQUFBQSxDQW5IQTtBQUFBO0FBMkhBSSxRQUFBQSw2QkFBQUEsMkJBQUFBLHFCQXpJRixFQXlJRUE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBeklGO0FBQUEsVUFBQSw0REFBQTtBQUFBO0FBeUlnQixVQUFBLGtCQXpJaEI7QUFBQSxjQTBJSWxCLE9BQUFBLENBQU0sYUFBYVgsSUFBbkJXLENBMUlKO0FBQUEsVUEySUksV0FBQUEsT0FBQUEsQ0FBTSxxQkFBcUJYLElBQTNCVyxDQTNJSjtBQXlJRWtCLFFBQUFBLENBQUFBLHVDQUFBQSxDQTNIQTtBQUFBO0FBZ0lBQyxRQUFBQSw4QkFBQUEsNEJBQUFBLHNCQTlJRixFQThJRUE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBOUlGO0FBQUEsVUFBQSw0REFBQTtBQUFBO0FBOElpQixVQUFBLGtCQTlJakI7QUFBQSxjQStJSW5CLE9BQUFBLENBQU0sY0FBY1gsSUFBcEJXLENBL0lKO0FBQUEsY0FnSklBLE9BQUFBLENBQU0sc0JBQXNCWCxJQUE1QlcsQ0FoSko7QUFBQSxVQWlKSSxXQUFBQSxPQUFBQSxDQUFNLG1CQUFtQlgsSUFBekJXLENBakpKO0FBOElFbUIsUUFBQUEsQ0FBQUEsd0NBQUFBLENBaElBO0FBQUE7QUFzSUFDLFFBQUFBLGtDQUFBQSxnQ0FBQUEsMEJBQW1CLElBQUQsRUFwSnBCLEVBb0pFQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFBQUE7QUFBQUE7QUFwSkY7QUFvSmtDLFVBQUEsb0RBcEpsQztBQUFBO0FBQUEsVUFBQSw0REFBQTtBQUFBO0FBb0oyQixVQUFBLGtCQXBKM0I7QUFBQSxVQXFKSWxCLE9BQVlBLElBQUFtQixNQUFBQSxDQUFBQSxDQXJKaEI7QUFBQSxVQXNKSUMsWUFBWXBCLElBQUFxQixjQUFBQSxDQUFlLEdBQWZBLENBdEpoQjtBQUFBLFVBdUpJLElBQUEsUUFBNkJELFNBQTdCLENBQUE7QUFBQSxZQUFBcEIsT0FBWUEsSUFBQVEsT0FBQUEsQ0FBSyxPQUFBNUIsQ0FBQSxFQUFLMEMsRUFBTCxRQUFMZCxDQUFaLENBdkpKO0FBQUEsVUF5SkksSUFBQSxRQUFxQlksU0FBckIsQ0FBQTtBQUFBLFlBQUFHLGlCQUFhLElBQWIsQ0F6Sko7QUFBQSxVQTJKSSxJQUFBLFFBQUcsY0FBQUgsU0FBQSxRQUFhSSxnQkFBQUEsQ0FBWXhCLElBQVp3QixDQUFiLE1BQUgsQ0FBQTtBQUFBO0FBQ0UsWUFBQUMsVUFBQUEsWUFBQUEsR0FBU3pCLGFBQU0sVUFBQ2IsSUFBRCxFQUFmc0MsRUFBdUJoRCxnQkFBdkJnRCxDQUFBO0FBQUEsWUFDQUYsaUJBQWEsS0FEYjtBQUFBLFlBR0EsVUFIQSxDQURGLENBM0pKO0FBQUEsVUFrS0ksSUFBR3BDLElBQUFRLFFBQUFBLENBQUFBLENBQUFoQixPQUFBQSxDQUFlaUIsQ0FBZmpCLENBQUg7QUFBQTtBQUNFLFlBQUErQyxXQUFXdkMsSUFBQU0sT0FBQUEsQ0FBQUEsQ0FBWDtBQUFBLFlBRUEsSUFBQSxRQUFHLElBQUEsSUFBQSxTQUFBRCxRQUFBQSxDQUFXa0MsUUFBWGxDLENBQUgsQ0FBQTtBQUFBLGNBQ0VQLE1BQUF5QyxRQUFBekMsUUFBQUEsRUFBQUEsRUFBQUEsRUF0S1IsaUJBc0t3QixHQUFELEVBQU0sS0F0SzdCLEVBQUE7O0FBQUE7QUFBQTtBQXNLd0IsZ0JBQUE7QUFBQSxnQkFBQTtBQUFBLGdCQUFBLENBdEt4QjtBQUFBO0FBc0s2QixnQkFBQTtBQUFBLGdCQUFBO0FBQUEsZ0JBQUEsQ0F0SzdCO0FBQUEsZ0JBdUtVLFdBQUFhLE9BQUFBLENBQU0sRUFBQSxHQUFBLENBQUdFLElBQUgsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFXRSxHQUFYLEdBQWtCRCxLQUF4QkgsQ0F2S1YsQ0FBQSxtQkFBQSxrQkFBQSxNQXNLUWI7QUFERixZQUFBO0FBQUEsa0JBS0VhLE9BQUFBLENBQU1FLE1BQU0wQixRQUFaNUI7QUFMRixZQUFBLENBRkE7QUFERixVQUFBO0FBQUEsZ0JBV0VBLE9BQUFBLENBQU1FLE1BQU1iLElBQUF3QixNQUFBQSxDQUFVLEdBQVZBLENBQVpiO0FBWEYsVUFBQSxDQWxLSjtBQUFBLFVBZ0xJeUIsaUJBQWEsS0FoTGpCO0FBQUEsVUFrTEksT0FBQXhDLElBbExKO0FBb0pFbUMsUUFBQUEsQ0FBQUEsNENBQUFBLENBdElBO0FBQUE7QUF1S0FwQixRQUFBQSx5QkFBQUEsdUJBQUFBLGlCQUFVLElBQUQsRUFBTyxLQUFQLEVBQW9CLFNBQTdCQTtBQUFBQSxVQUFBQTs7QUFBQUE7QUFyTEY7QUFxTGtCLFVBQUE7QUFBQSxVQUFBLFVBQVEsR0FBUjtBQUFBLFVBQUEsQ0FyTGxCO0FBQUE7QUFxTCtCLFVBQUE7QUFBQSxVQUFBLGNBQVl5QixjQUFaO0FBQUEsVUFBQSxDQXJML0I7QUFBQSxVQXNMSSxJQUFBLFFBQUcsSUFBQSxJQUFBLFVBQUEvQixRQUFBQSxDQUFZUyxLQUFaVCxDQUFILENBQUE7QUFBQSxZQUNFUyxRQUFRQSxLQUFBVSxNQUFBQSxDQUFXLEdBQVhBLENBRFYsQ0F0TEo7QUFBQSxVQTBMSSxJQUFBLFFBQUcscUJBQUFuQixRQUFBQSxDQUFVUSxJQUFWUixDQUFILENBQUE7QUFBQSxZQUNFLE9BQUFoQixVQUFBbUQsT0FBQUEsQ0FBVTNCLElBQVYyQjtBQURGLFVBQUE7QUFBQSxZQUdFLE9BQUFuRCxVQUFBbUQsT0FBQUEsQ0FBVSxxQkFBQXJELEtBQUFBLENBQVUwQixNQUFNQyxPQUFPbUIsU0FBdkI5QyxDQUFWcUQ7QUFIRixVQUFBLENBMUxKO0FBcUxFN0IsUUFBQUEsQ0FBQUEsbUNBQUFBLENBdktBO0FBQUE7QUFtTEE4QixRQUFBQSwwQkFBQUEsNEJBQUFBLFNBQVcsSUFBRCxFQUFPLEtBQWpCQTtBQUFBQSxVQUFBQTs7QUFBQUE7QUFqTUY7QUFpTW1CLFVBQUE7QUFBQSxVQUFBLFVBQVEsR0FBUjtBQUFBLFVBQUEsQ0FqTW5CO0FBQUEsVUFrTUksV0FBQTlCLE9BQUFBLENBQU1FLE1BQU1DLE9BQU8sSUFBbkJILENBbE1KO0FBaU1FOEIsUUFBQUEsQ0FBQUEsd0NBQUFBLENBbkxBO0FBQUEsUUF1TEEsT0FBQXZEO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFFRTtBQUFBRSxVQUFBQSw4QkFBQUEsMEJBQUFBLHNCQXZNSixFQXVNSUE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBdk1KO0FBQUEsWUFBQSw0REFBQTtBQUFBO0FBdU1tQixZQUFBLGtCQXZNbkI7QUFBQSxZQXdNTTZCLFVBQVUsYUFBQSxJQUFBLFFBQUEsSUFBQSxJQUFBLFNBQUFaLFFBQUFBLENBQVdMLElBQUEwQyxNQUFBQSxDQUFBQSxDQUFYckMsQ0FBQSxDQUFBO0FBQUEsY0FBdUIsT0FBQUwsSUFBQTJDLEtBQUFBLENBQUFBO0FBQXZCLFlBQUE7QUFBQSxjQUFrQyxPQUFBLFlBQUE7QUFBbEMsWUFBQSxDQUFBLGtCQXhNaEI7QUFBQSxZQTBNTUMsVUFBUTNCLE9BQUFJLE9BQUFBLENBQVEsSUFBUkEsQ0ExTWQ7QUFBQSxZQTJNTXdCLFlBQVE1QixPQUFBSSxPQUFBQSxDQUFRLE1BQVJBLENBM01kO0FBQUEsWUE2TU0sSUFBQSxRQUFHLGNBQUF1QixPQUFBLElBQVFDLFNBQURDLE1BQUFBLENBQUFBLENBQVAsTUFBSCxDQUFBO0FBQUEsY0FDRUQsZ0JBQVFFLE9BQUFBLENBQU1ILE9BQU5HO0FBRFYsWUFBQSxPQUVBLElBQUEsUUFBTSxjQUFBRixTQUFBLElBQVVELE9BQURFLE1BQUFBLENBQUFBLENBQVQsTUFBTixDQUFBO0FBQUEsY0FDRUYsY0FBTUcsT0FBQUEsQ0FBTUYsU0FBTkUsQ0FEUixDQS9NTjtBQUFBLFlBbU5NQyxhQUFTaEQsSUFBQWlELE9BQUFBLENBQUFBLENBbk5mO0FBQUEsWUFvTk0sT0FBQUMsQ0FBQUEsV0FBU2xELElBQUFpRCxPQUFBQSxDQUFBQSxDQUFUQyxDQXBOTjtBQXVNSTlELFVBQUFBLENBQUFBLHNDQUFBQSxDQUFBO0FBQUE7QUFnQkFVLFVBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUFBQTtBQUFBQTtBQXZOSjtBQXVOYSxZQUFBLHdDQXZOYjtBQUFBLFlBd05NUixLQUFBSyxNQUFBQSxLQUFXZ0IsT0FBQUEsQ0FBTSxFQUFBLEdBQUEsdUJBQUEsR0FBQSxDQUF1QmlDLE9BQXZCLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBNkJJLFVBQTdCLENBQUEsR0FBQSxPQUFBLEdBQUEsQ0FBeUNFLFFBQXpDLENBQUEsR0FBQSxRQUFOdkMsQ0FBWGhCLENBeE5OO0FBQUEsWUEwTk0sSUFBQSxZQUFHd0QsZ0JBQUFBLENBQUFBLENBQUgsQ0FBQTtBQUFBLGNBQ0U3RCxLQUFBSyxNQUFBQSxLQUFXZ0IsT0FBQUEsQ0FBTSxFQUFBLEdBQUEsMkJBQUEsR0FBQSxDQUEyQmtDLFNBQTNCLENBQUEsR0FBQSxRQUFBLEdBQUEsQ0FBdUNELE9BQXZDLENBQUEsR0FBQSx1QkFBQSxHQUFBLENBQWdFSSxVQUFoRSxDQUFBLEdBQUEsc0JBQUEsR0FBQSxDQUEyRkUsUUFBM0YsQ0FBQSxHQUFBLElBQU52QyxDQUFYaEI7QUFERixZQUFBO0FBQUEsY0FHRUwsS0FBQUssTUFBQUEsS0FBV2dCLE9BQUFBLENBQU0sRUFBQSxHQUFBLGdDQUFBLEdBQUEsQ0FBZ0NrQyxTQUFoQyxDQUFBLEdBQUEsU0FBQSxHQUFBLENBQTZDRCxPQUE3QyxDQUFBLEdBQUEsbUJBQUEsR0FBQSxDQUFrRUksVUFBbEUsQ0FBQSxHQUFBLHNCQUFBLEdBQUEsQ0FBNkZFLFFBQTdGLENBQUEsR0FBQSxJQUFOdkMsQ0FBWGhCO0FBSEYsWUFBQSxDQTFOTjtBQUFBLFlBZ09NTCxLQUFBSyxNQUFBQSxLQUFXZ0IsT0FBQUEsQ0FBTSxFQUFBLEdBQUEsMEJBQUEsR0FBQSxDQUEwQmlDLE9BQTFCLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBZ0NJLFVBQWhDLENBQUEsR0FBQSxPQUFBLEdBQUEsQ0FBNENFLFFBQTVDLENBQUEsR0FBQSxRQUFOdkMsQ0FBWGhCLENBaE9OO0FBQUEsWUFpT01MLEtBQUFLLE1BQUFBLEtBQVdnQixPQUFBQSxDQUFNLEVBQUEsR0FBQSxxQkFBQSxHQUFBLENBQXFCaUMsT0FBckIsQ0FBQSxHQUFBLElBQUEsR0FBQSxDQUEyQkksVUFBM0IsQ0FBQSxHQUFBLE9BQUEsR0FBQSxDQUF1Q0UsUUFBdkMsQ0FBQSxHQUFBLFFBQU52QyxDQUFYaEIsQ0FqT047QUFBQSxZQWtPTUwsS0FBQUssTUFBQUEsS0FBV2dCLE9BQUFBLENBQU0sRUFBQSxHQUFBLHNCQUFBLEdBQUEsQ0FBc0JpQyxPQUF0QixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQTRCSSxVQUE1QixDQUFBLEdBQUEsT0FBQSxHQUFBLENBQXdDRSxRQUF4QyxDQUFBLEdBQUEsUUFBTnZDLENBQVhoQixDQWxPTjtBQUFBLFlBbU9NLE9BQUFMLEtBQUFLLE1BQUFBLEtBQVdnQixPQUFBQSxDQUFNLEVBQUEsR0FBQSxxQkFBQSxHQUFBLENBQXFCaUMsT0FBckIsQ0FBQSxHQUFBLElBQUEsR0FBQSxDQUEyQkksVUFBM0IsQ0FBQSxHQUFBLE9BQUEsR0FBQSxDQUF1Q0UsUUFBdkMsQ0FBQSxHQUFBLFFBQU52QyxDQUFYaEIsQ0FuT047QUF1TklHLFVBQUFBLENBQUFBLCtCQUFBQSxDQWhCQTtBQUFBO0FBK0JBcUQsVUFBQUEsK0JBQUFBLCtCQUFBQSxTQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFBLGNBQUFQLE9BQUFwRCxPQUFBQSxDQUFPLE1BQVBBLENBQUEsU0FBZ0JvRCxPQUFBcEQsT0FBQUEsQ0FBTyxPQUFQQSxDQUFoQjtBQURGMkQsVUFBQUEsQ0FBQUEsMENBQUFBLENBL0JBO0FBQUE7QUFtQ0FDLFVBQUFBLDZCQUFBQSw2QkFBQUEsU0FBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBQSxjQUFBUixPQUFBcEQsT0FBQUEsQ0FBTyxLQUFQQSxDQUFBLFNBQWVvRCxPQUFBcEQsT0FBQUEsQ0FBTyxRQUFQQSxDQUFmO0FBREY0RCxVQUFBQSxDQUFBQSx3Q0FBQUEsQ0FuQ0E7QUFBQSxjQXVDRkMsU0FBQUEsQ0FBQUEsQ0F2Q0U7QUFBQTtBQXdDQU4sVUFBQUEseUJBQUFBLHFCQUFBQSxpQkFBVSxJQUFWQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFBLGFBQUEsUUFBS08sSUFBTDtBQUFBLFlBQ0EsSUFBSyxxQkFBTCxHQUFrQixPQUFBLE9BQWxCO0FBREEsWUFBQSxLQUVBLElBQUssc0JBQUwsR0FBa0IsT0FBQSxNQUFsQjtBQUZBLFlBQUEsS0FHQSxJQUFLLG9CQUFMLEdBQWtCLE9BQUEsUUFBbEI7QUFIQSxZQUFBLEtBSUEsSUFBSyx1QkFBTCxHQUFrQixPQUFBLEtBQWxCO0FBSkEsWUFBQSxtQkFBQTtBQURGUCxVQUFBQSxDQUFBQSxnQ0FBQUEsQ0F4Q0E7QUFBQSxVQWtEQSxPQUFBcEMsQ0FBQUEseUJBQUFBLHFCQUFBQSxpQkF6UEosRUF5UElBO0FBQUFBLFlBQUFBOztBQUFBQTtBQXpQSjtBQUFBLFlBQUEsNERBQUE7QUFBQTtBQXlQYyxZQUFBLGtCQXpQZDtBQUFBLFlBMFBNLElBQUdYLElBQUFRLFFBQUFBLENBQUFBLENBQUFoQixPQUFBQSxDQUFlaUIsQ0FBZmpCLENBQUg7QUFBQSxjQUNFLE9BQUEscUJBQUFMLEtBQUFBLENBQVUsS0FBS2EsSUFBQU0sT0FBQUEsQ0FBQUEsQ0FBZm5CO0FBREYsWUFBQTtBQUFBLGNBR0UsT0FBQUEsTUFBQSxxQkFBQUEsT0FBQUEsRUFBVSxVQUFDYSxJQUFELENBQVZiO0FBSEYsWUFBQSxDQTFQTjtBQXlQSXdCLFVBQUFBLENBQUFBLGlDQUFBQSxDQUFBQSxpQkFsREE7QUFGRnpCLFFBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBdkxBO0FBREZBLE1BQUFBLEdBQUFBLFdBQUFBLEVBQW1CLDJCQUFuQkE7QUFGY0EsSUFBQUEsR0FBQUEsV0FBQUEsRUFBWSwyQkFBWkE7QUFBZEEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjEzMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInBhZ2dpby9jc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIy0tXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLCBEZWNlbWJlciAyMDA0XG4jXG4jICAgICAgICAgICAgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTyBQVUJMSUMgTElDRU5TRVxuIyAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBDT1BZSU5HLCBESVNUUklCVVRJT04gQU5EIE1PRElGSUNBVElPTlxuI1xuIyAgMC4gWW91IGp1c3QgRE8gV0hBVCBUSEUgRlVDSyBZT1UgV0FOVCBUTy5cbiMrK1xuXG5yZXF1aXJlICdwYWdnaW8vY3NzL3VuaXQnXG5yZXF1aXJlICdwYWdnaW8vY3NzL2NvbG9yJ1xucmVxdWlyZSAncGFnZ2lvL2Nzcy9kZWZpbml0aW9uJ1xuXG5jbGFzcyBQYWdnaW9cblxuY2xhc3MgQ1NTIDwgQmFzaWNPYmplY3RcbiAgUnVsZSA9IDo6U3RydWN0Lm5ldyg6c2VsZWN0b3IsIDpkZWZpbml0aW9uKVxuXG4gIGRlZiBzZWxmLnNlbGVjdG9yKGxpc3QpXG4gICAgcmVzdWx0ID0gJydcblxuICAgIGxpc3QuZWFjaCB7fHBhcnR8XG4gICAgICBpZiBwYXJ0LnN0YXJ0X3dpdGg/KCcmJylcbiAgICAgICAgcmVzdWx0ICs9IHBhcnRbMSAuLiAtMV1cbiAgICAgIGVsc2VcbiAgICAgICAgcmVzdWx0ICs9IFwiIFwiICsgcGFydFxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgaWYgcmVzdWx0WzBdID09IFwiIFwiXG4gICAgICByZXN1bHRbMSAuLiAtMV1cbiAgICBlbHNlXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOnJ1bGVzXG5cbiAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgIEBzZWxlY3RvciA9IFtdXG4gICAgQGN1cnJlbnQgID0gW11cbiAgICBAcnVsZXMgICAgPSBbXVxuXG4gICAgaWYgYmxvY2suYXJpdHkgPT0gMFxuICAgICAgaW5zdGFuY2VfZXhlYygmYmxvY2spXG4gICAgZWxzZVxuICAgICAgYmxvY2suY2FsbChzZWxmKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcnVsZSgqbmFtZXMsICZibG9jaylcbiAgICByZXR1cm4gdW5sZXNzIGJsb2NrXG5cbiAgICBpZiBuYW1lcy5hbnk/IHsgfG58IG4uaW5jbHVkZT8gJywnIH1cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3NlbGVjdG9ycyBjYW5ub3QgY29udGFpbiBjb21tYXMnXG4gICAgZW5kXG5cbiAgICBuYW1lcy5lYWNoIHt8bmFtZXxcbiAgICAgIEBzZWxlY3RvciA8PCBuYW1lXG4gICAgICBAY3VycmVudCAgPDwgUnVsZS5uZXcoQ1NTLnNlbGVjdG9yKEBzZWxlY3RvciksIERlZmluaXRpb24ubmV3KVxuXG4gICAgICBibG9jay5jYWxsKHNlbGYpXG5cbiAgICAgIEBzZWxlY3Rvci5wb3BcbiAgICAgIEBydWxlcyA8PCBAY3VycmVudC5wb3BcbiAgICB9XG4gIGVuZFxuXG4gICMgdGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgbWV0aG9kcyBpbnNpZGUgdGhlIHJ1bGUgYmxvY2tzIGFyZSBhY3R1YWxseVxuICAjIGNhbGxlZCBvbiB0aGUgQ1NTIG9iamVjdFxuICBkZWYgbWV0aG9kX21pc3NpbmcobmFtZSwgKmFyZ3MsICZibG9jaylcbiAgICBAY3VycmVudC5sYXN0LmRlZmluaXRpb24uX19zZW5kX18obmFtZSwgKmFyZ3MsICZibG9jaylcbiAgZW5kXG5lbmRcblxuY2xhc3MgSFRNTCA8IEJhc2ljT2JqZWN0XG4gIGRlZiBzdHlsZSgmYmxvY2spXG4gICAgKEBjdXJyZW50IHx8IEByb290cykgPDwgQ1NTLm5ldygmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsIm5ldyIsInNlbGVjdG9yIiwic2VsZiIsInJlc3VsdCIsImVhY2giLCJsaXN0IiwicGFydCIsInN0YXJ0X3dpdGg/IiwiKyIsIltdIiwiMSIsIi0xIiwiMCIsIj09IiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiYmxvY2siLCJyYWlzZSIsIkBzZWxlY3RvciIsIkBjdXJyZW50IiwiQHJ1bGVzIiwiYXJpdHkiLCJpbnN0YW5jZV9leGVjIiwiY2FsbCIsInJ1bGUiLCJhbnk/IiwibmFtZXMiLCJuIiwiaW5jbHVkZT8iLCI8PCIsIm5hbWUiLCJwb3AiLCJtZXRob2RfbWlzc2luZyIsIl9fc2VuZF9fIiwibGFzdCIsImRlZmluaXRpb24iLCJhcmdzIiwic3R5bGUiLCJAcm9vdHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQVVBLE1BQUFBLFNBQUFBLENBQVEsaUJBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGtCQUFSQSxDQURBO0FBQUEsTUFFQUEsU0FBQUEsQ0FBUSx1QkFBUkEsQ0FGQTtBQUFBLEVBSUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUVBLElBQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxNQUFBLG9DQUFPLElBQUEsSUFBQSxXQUFBQyxLQUFBQSxDQUFhLFlBQVcsWUFBeEJBLENBQVAsQ0FBQTtBQUFBLE1BRUFDLFVBQUlDLElBQUpELGVBQUFBLGtCQUFBQSxvQkFBa0IsSUFBbEJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFFLFNBQVMsRUFBVDtBQUFBLFFBRUFDLE1BQUFDLElBQUFELFFBQUFBLEVBQUFBLEVBQUFBLEVBdkJKLGdCQXVCZ0IsSUF2QmhCLEVBQUE7O0FBQUE7QUFBQTtBQXVCZ0IsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBdkJoQjtBQUFBLFVBd0JNLElBQUEsUUFBR0UsSUFBQUMsZ0JBQUFBLENBQWlCLEdBQWpCQSxDQUFILENBQUE7QUFBQSxZQUNFLE9BQUFKLENBQUFBLFNBekJSSyxTQXlCUUwsTUF6QlJLLEVBeUJrQkYsSUFBQUcsT0FBQUEsQ0FBSyxPQUFBQyxDQUFBLEVBQUtDLEVBQUwsUUFBTEYsQ0F6QmxCRCxDQXlCUUw7QUFERixVQUFBO0FBQUEsWUFHRSxPQUFBQSxDQUFBQSxTQTNCUkssU0EyQlFMLE1BM0JSSyxFQTJCa0JBLFNBQUEsR0FBQUEsRUFBTUYsSUFBTkUsQ0Ez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QUEsQ0FwQ0E7QUFBQSxNQXdEQSxPQUFBUSxDQUFBQSxrQ0FBQUEsd0JBQUFBLDBCQUFtQixJQUFELEVBMUVwQixFQTBFRUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBO0FBMUVGO0FBMEVrQyxRQUFBLDRDQTFFbEM7QUFBQTtBQUFBLFFBQUEsNERBQUE7QUFBQTtBQTBFMkIsUUFBQSxrQkExRTNCO0FBQUEsUUEyRUksT0FBQUMsTUFBQWQsWUFBQWUsTUFBQUEsQ0FBQUEsQ0FBQUMsWUFBQUEsQ0FBQUEsQ0FBQUYsWUFBQUEsR0FBa0NILGFBQU0sVUFBQ00sSUFBRCxFQUF4Q0gsRUFBZ0RqQixnQkFBaERpQixDQTNFSjtBQTBFRUQsTUFBQUEsQ0FBQUEsb0NBQUFBLENBQUFBLDBCQXhEQTtBQURGakMsSUFBQUEsR0FBQUEsV0FBQUEsRUFBWSwyQkFBWkEsV0FBQTtBQUFBLElBOERBLE9BQUFBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUEsTUFDRSxPQUFBc0MsQ0FBQUEseUJBQUFBLGdCQUFBQSxpQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBO0FBaEZGO0FBZ0ZZLFFBQUEsb0NBaEZaO0FBQUEsUUFpRkksT0FBQyxjQUFBbEIsWUFBQSxTQUFZbUIsVUFBWixDQUFEVCxPQUFBQSxDQUF3QjdCLE1BQUEsbUJBQUFBLE9BQUFBLEVBQUFBLEVBQUFBLEVBQVNnQixnQkFBVGhCLENBQXhCNkIsQ0FqRko7QUFnRkVRLE1BQUFBLENBQUFBLDJCQUFBQSxDQUFBQTtBQURGdEMsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYSwyQkFBYkEsV0E5REE7QUFGQUEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FKQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2Mjc4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9zdHJpbmdpby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBTdHJpbmdJTyA8IElPXG4gIGluY2x1ZGUgSU86OlJlYWRhYmxlXG4gIGluY2x1ZGUgSU86OldyaXRhYmxlXG5cbiAgZGVmIHNlbGYub3BlbihzdHJpbmcgPSBcIlwiLCBtb2RlID0gbmlsLCAmYmxvY2spXG4gICAgaW8gID0gbmV3KHN0cmluZywgbW9kZSlcbiAgICByZXMgPSBibG9jay5jYWxsKGlvKVxuICAgIGlvLmNsb3NlXG5cbiAgICByZXNcbiAgZW5kXG5cbiAgYXR0cl9hY2Nlc3NvciA6c3RyaW5nXG5cbiAgZGVmIGluaXRpYWxpemUoc3RyaW5nID0gXCJcIiwgbW9kZSA9ICdydycpXG4gICAgQHN0cmluZyAgID0gc3RyaW5nXG4gICAgQHBvc2l0aW9uID0gc3RyaW5nLmxlbmd0aFxuXG4gICAgaWYgbW9kZS5pbmNsdWRlPygncicpIGFuZCBub3QgbW9kZS5pbmNsdWRlPygndycpXG4gICAgICBAY2xvc2VkID0gOndyaXRlXG4gICAgZWxzaWYgbW9kZS5pbmNsdWRlPygndycpIGFuZCBub3QgbW9kZS5pbmNsdWRlPygncicpXG4gICAgICBAY2xvc2VkID0gOnJlYWRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVvZj9cbiAgICBjaGVja19yZWFkYWJsZVxuXG4gICAgQHBvc2l0aW9uID09IEBzdHJpbmcubGVuZ3RoXG4gIGVuZFxuXG4gIGFsaWFzIGVvZiBlb2Y/XG5cbiAgZGVmIHNlZWsocG9zLCB3aGVuY2UgPSBJTzo6U0VFS19TRVQpXG4gICAgY2FzZSB3aGVuY2VcbiAgICB3aGVuIElPOjpTRUVLX1NFVFxuICAgICAgcmFpc2UgRXJybm86OkVJTlZBTCB1bmxlc3MgcG9zID49IDBcblxuICAgICAgQHBvc2l0aW9uID0gcG9zXG5cbiAgICB3aGVuIElPOjpTRUVLX0NVUlxuICAgICAgaWYgQHBvc2l0aW9uICsgcG9zID4gQHN0cmluZy5sZW5ndGhcbiAgICAgICAgQHBvc2l0aW9uID0gQHN0cmluZy5sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgQHBvc2l0aW9uICs9IHBvc1xuICAgICAgZW5kXG5cbiAgICB3aGVuIElPOjpTRUVLX0VORFxuICAgICAgaWYgcG9zID4gQHN0cmluZy5sZW5ndGhcbiAgICAgICAgQHBvc2l0aW9uID0gMFxuICAgICAgZWxzZVxuICAgICAgICBAcG9zaXRpb24gLT0gcG9zXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIDBcbiAgZW5kXG5cbiAgZGVmIHRlbGxcbiAgICBAcG9zaXRpb25cbiAgZW5kXG5cbiAgYWxpYXMgcG9zIHRlbGxcblxuICBhbGlhcyBwb3M9IHNlZWtcblxuICBkZWYgcmV3aW5kXG4gICAgc2VlayAwXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9ieXRlIHVubGVzcyBibG9ja1xuXG4gICAgY2hlY2tfcmVhZGFibGVcblxuICAgIGkgPSBAcG9zaXRpb25cbiAgICB1bnRpbCBlb2Y/XG4gICAgICBibG9jay5jYWxsKEBzdHJpbmdbaV0ub3JkKVxuICAgICAgaSArPSAxXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9jaGFyIHVubGVzcyBibG9ja1xuXG4gICAgY2hlY2tfcmVhZGFibGVcblxuICAgIGkgPSBAcG9zaXRpb25cbiAgICB1bnRpbCBlb2Y/XG4gICAgICBibG9jay5jYWxsKEBzdHJpbmdbaV0pXG4gICAgICBpICs9IDFcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2goc2VwYXJhdG9yID0gJC8pXG4gICAgcmV0dXJuIGVudW1fZm9yIDplYWNoX2xpbmUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgIGNoZWNrX3JlYWRhYmxlXG4gICAgY2hvbXBfbGluZXMgPSBmYWxzZVxuICAgIGlmIDo6SGFzaCA9PT0gc2VwYXJhdG9yXG4gICAgICBzZXBhcmF0b3IgPSAoY2hvbXBfbGluZXMgPSBzZXBhcmF0b3JbOmNob21wXSkgPyAvXFxyP1xcbi8gOiAkL1xuICAgIGVsc2lmIHNlcGFyYXRvclxuICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yLnRvX3N0clxuICAgIGVsc2VcbiAgICAgIHNlcGFyYXRvciA9IGB1bmRlZmluZWRgXG4gICAgZW5kXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZi5zdHJpbmcsIHN0cmluZ0xlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICBpZiAoc2VsZi5wb3NpdGlvbiA8IHN0cmluZ0xlbmd0aCkgc3RyID0gc3RyLnN1YnN0cihzZWxmLnBvc2l0aW9uKTtcbiAgICAgIGlmIChzZXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGNob21wZWQgPSAje2BzdHJgLmNob21wfSwgdHJhaWxpbmcgPSBzdHIubGVuZ3RoICE9PSBjaG9tcGVkLmxlbmd0aCwgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzcGxpdHRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBsaW5lID0gY2hvbXBfbGluZXMgPyBzcGxpdHRlZFtpXSA6IChpIDwgbGVuIC0gMSB8fCB0cmFpbGluZyA/IHNwbGl0dGVkW2ldICsgc2VwYXJhdG9yIDogc3BsaXR0ZWRbaV0pO1xuICAgICAgICAgICN7eWllbGQgYGxpbmVgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAje3lpZWxkIGBzdHJgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtLCByZSA9IC8oLisoPzpcXG5cXG58JCkpXFxuKi9nO1xuICAgICAgICB3aGlsZSAoKG0gPSByZS5leGVjKHN0cikpKSAje3lpZWxkIGBtWzFdYH07XG4gICAgICB9XG4gICAgICBzZWxmLnBvc2l0aW9uID0gc3RyaW5nTGVuZ3RoO1xuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGVhY2hfbGluZSBlYWNoXG5cbiAgZGVmIHdyaXRlKHN0cmluZylcbiAgICBjaGVja193cml0YWJsZVxuXG4gICAgc3RyaW5nID0gU3RyaW5nKHN0cmluZylcblxuICAgIGlmIEBzdHJpbmcubGVuZ3RoID09IEBwb3NpdGlvblxuICAgICAgQHN0cmluZyAgICs9IHN0cmluZ1xuICAgICAgQHBvc2l0aW9uICs9IHN0cmluZy5sZW5ndGhcbiAgICBlbHNlXG4gICAgICBiZWZvcmUgPSBAc3RyaW5nWzAgLi4gQHBvc2l0aW9uIC0gMV1cbiAgICAgIGFmdGVyICA9IEBzdHJpbmdbQHBvc2l0aW9uICsgc3RyaW5nLmxlbmd0aCAuLiAtMV1cblxuICAgICAgQHN0cmluZyAgID0gYmVmb3JlICsgc3RyaW5nICsgYWZ0ZXJcbiAgICAgIEBwb3NpdGlvbiArPSBzdHJpbmcubGVuZ3RoXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZWFkKGxlbmd0aCA9IG5pbCwgb3V0YnVmID0gbmlsKVxuICAgIGNoZWNrX3JlYWRhYmxlXG5cbiAgICByZXR1cm4gaWYgZW9mP1xuXG4gICAgc3RyaW5nID0gaWYgbGVuZ3RoXG4gICAgICBzdHIgPSBAc3RyaW5nW0Bwb3NpdGlvbiwgbGVuZ3RoXVxuICAgICAgQHBvc2l0aW9uICs9IGxlbmd0aFxuICAgICAgc3RyXG4gICAgZWxzZVxuICAgICAgc3RyID0gQHN0cmluZ1tAcG9zaXRpb24gLi4gLTFdXG4gICAgICBAcG9zaXRpb24gPSBAc3RyaW5nLmxlbmd0aFxuICAgICAgc3RyXG4gICAgZW5kXG5cbiAgICBpZiBvdXRidWZcbiAgICAgIG91dGJ1Zi53cml0ZShzdHJpbmcpXG4gICAgZWxzZVxuICAgICAgc3RyaW5nXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjbG9zZVxuICAgIEBjbG9zZWQgPSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VfcmVhZFxuICAgIGlmIEBjbG9zZWQgPT0gOndyaXRlXG4gICAgICBAY2xvc2VkID0gOmJvdGhcbiAgICBlbHNlXG4gICAgICBAY2xvc2VkID0gOnJlYWRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNsb3NlX3dyaXRlXG4gICAgaWYgQGNsb3NlZCA9PSA6cmVhZFxuICAgICAgQGNsb3NlZCA9IDpib3RoXG4gICAgZWxzZVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2VkP1xuICAgIEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZF9yZWFkP1xuICAgIEBjbG9zZWQgPT0gOnJlYWQgfHwgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VkX3dyaXRlP1xuICAgIEBjbG9zZWQgPT0gOndyaXRlIHx8IEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNoZWNrX3dyaXRhYmxlXG4gICAgaWYgY2xvc2VkX3dyaXRlP1xuICAgICAgcmFpc2UgSU9FcnJvciwgXCJub3Qgb3BlbmVkIGZvciB3cml0aW5nXCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNoZWNrX3JlYWRhYmxlXG4gICAgaWYgY2xvc2VkX3JlYWQ/XG4gICAgICByYWlzZSBJT0Vycm9yLCBcIm5vdCBvcGVuZWQgZm9yIHJlYWRpbmdcIlxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiaW5jbHVkZSIsIm9wZW4iLCJzZWxmIiwiaW8iLCJuZXciLCJzdHJpbmciLCJtb2RlIiwicmVzIiwiYmxvY2siLCJjYWxsIiwiY2xvc2UiLCJhdHRyX2FjY2Vzc29yIiwiaW5pdGlhbGl6ZSIsIkBzdHJpbmciLCJAcG9zaXRpb24iLCJsZW5ndGgiLCJpbmNsdWRlPyIsIiEiLCJAY2xvc2VkIiwiZW9mPyIsImNoZWNrX3JlYWRhYmxlIiwiPT0iLCJzZWVrIiwid2hlbmNlIiwiPj0iLCJwb3MiLCIwIiwicmFpc2UiLCI+IiwiKyIsIi0iLCJ0ZWxsIiwicmV3aW5kIiwiZWFjaF9ieXRlIiwiZW51bV9mb3IiLCJpIiwiW10iLCJvcmQiLCIxIiwiZWFjaF9jaGFyIiwiZWFjaCIsIiQvIiwiYmxvY2tfZ2l2ZW4/IiwiY2hvbXBfbGluZXMiLCI9PT0iLCJzZXBhcmF0b3IiLCJ0b19zdHIiLCJjaG9tcCIsIndyaXRlIiwiY2hlY2tfd3JpdGFibGUiLCJTdHJpbmciLCJiZWZvcmUiLCJhZnRlciIsIi0xIiwicmVhZCIsInN0ciIsIm91dGJ1ZiIsImNsb3NlX3JlYWQiLCJjbG9zZV93cml0ZSIsImNsb3NlZD8iLCJjbG9zZWRfcmVhZD8iLCJjbG9zZWRfd3JpdGU/Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxRQUFBQyxTQUFBQSxDQUFRLElBQUEsa0JBQUEsYUFBUkEsQ0FBQTtBQUFBLFFBQ0FBLFNBQUFBLENBQVEsSUFBQSxrQkFBQSxhQUFSQSxDQURBO0FBQUEsSUFHQUMsVUFBSUMsSUFBSkQsV0FBQUEsbUJBQUFBLGdCQUFjLE1BQUQsRUFBYyxJQUEzQkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBTEY7QUFLeUMsTUFBQSx1Q0FMekM7QUFBQTtBQUtnQixNQUFBO0FBQUEsTUFBQSxXQUFTLEVBQVQ7QUFBQSxNQUFBLENBTGhCO0FBQUE7QUFLNkIsTUFBQTtBQUFBLE1BQUEsU0FBTyxHQUFQO0FBQUEsTUFBQSxDQUw3QjtBQUFBLE1BTUlFLFNBQU1DLEtBQUFBLENBQUlDLFFBQVFDLElBQVpGLENBTlY7QUFBQSxNQU9JRyxNQUFNQyxLQUFBQyxNQUFBQSxDQUFXTixFQUFYTSxDQVBWO0FBQUEsTUFRSU4sRUFBQU8sT0FBQUEsQ0FBQUEsQ0FSSjtBQUFBLE1BVUksT0FBQUgsR0FWSjtBQUtFTixJQUFBQSxDQUFBQSwrQkFBQUEsQ0FIQTtBQUFBLFFBV0FVLGVBQUFBLENBQWMsUUFBZEEsQ0FYQTtBQUFBO0FBYUFDLElBQUFBLDhCQUFBQSx5QkFBQUEsc0JBQWUsTUFBRCxFQUFjLElBQTVCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFmRjtBQWVpQixNQUFBO0FBQUEsTUFBQSxXQUFTLEVB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SCxXQUFBRyxPQUFBQSxDQUFXLE1BQVhBLENBQXJCO0FBREZ3QyxJQUFBQSxDQUFBQSw0Q0FBQUEsQ0FyTUE7QUFBQTtBQXlNQVosSUFBQUEsa0NBQUFBLDhCQUFBQSwwQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxZQUFHWSxrQkFBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUEsUUFDRSxXQUFBbEMsT0FBQUEsQ0FBTSx5QkFBUyx3QkFBZkE7QUFERixNQUFBO0FBQUE7QUFBQSxNQUFBO0FBREZzQixJQUFBQSxDQUFBQSx5Q0FBQUEsQ0F6TUE7QUFBQSxJQStNQSxPQUFBN0IsQ0FBQUEsa0NBQUFBLDhCQUFBQSwwQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxZQUFHd0MsaUJBQUFBLENBQUFBLENBQUgsQ0FBQTtBQUFBLFFBQ0UsV0FBQWpDLE9BQUFBLENBQU0seUJBQVMsd0JBQWZBO0FBREYsTUFBQTtBQUFBO0FBQUEsTUFBQTtBQURGUCxJQUFBQSxDQUFBQSx5Q0FBQUEsQ0FBQUEsMEJBL01BO0FBREZyQixFQUFBQSxHQUFBQSxXQUFBQSxFQUFpQixrQkFBakJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjY2MDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYWdnaW8vZm9ybWF0dGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMtLVxuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMiwgRGVjZW1iZXIgMjAwNFxuI1xuIyAgICAgICAgICAgIERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8gUFVCTElDIExJQ0VOU0VcbiMgICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgQ09QWUlORywgRElTVFJJQlVUSU9OIEFORCBNT0RJRklDQVRJT05cbiNcbiMgIDAuIFlvdSBqdXN0IERPIFdIQVQgVEhFIEZVQ0sgWU9VIFdBTlQgVE8uXG4jKytcblxucmVxdWlyZSAnc3RyaW5naW8nXG5cbmNsYXNzIFBhZ2dpb1xuXG5jbGFzcyBGb3JtYXR0ZXJcbiAgZGVmIHNlbGYudG9faFxuICAgIEBmb3JtYXR0ZXJzIHx8PSB7fVxuICBlbmRcblxuICBkZWYgc2VsZi5mb3Ioa2xhc3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgdG9faFtrbGFzc10gPSBibG9ja1xuICAgIGVsc2VcbiAgICAgIHRvX2hba2xhc3NdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm9wdGlvbnMob3B0aW9ucywgJmJsb2NrKVxuICAgIG9sZCA9IE9QVElPTlMuZHVwXG4gICAgVXRpbHMuZGVlcF9tZXJnZSEoT1BUSU9OUywgb3B0aW9ucylcblxuICAgIHJlc3VsdCA9IGJsb2NrLmNhbGxcblxuICAgIE9QVElPTlMucmVwbGFjZShvbGQpXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgT1BUSU9OUyA9IHtcbiAgICBpbmRlbnQ6IHtcbiAgICAgIGxldmVsOiAwLFxuICAgICAgd2l0aDogIFwiXFx0XCJcbiAgICB9XG4gIH1cblxuICBkZWYgaW5pdGlhbGl6ZShpbyA9IG5pbCwgb3B0aW9ucyA9IHt9KVxuICAgIGlmIEhhc2ggPT09IGlvXG4gICAgICBAaW8gICAgICA9IFN0cmluZ0lPLm5ld1xuICAgICAgQG9wdGlvbnMgPSBpb1xuICAgIGVsc2VcbiAgICAgIEBpbyAgICAgID0gaW8gfHwgU3RyaW5nSU8ubmV3XG4gICAgICBAb3B0aW9ucyA9IG9wdGlvbnNcbiAgICBlbmRcblxuICAgIEBvcHRpb25zID0gT1BUSU9OUy5tZXJnZShAb3B0aW9ucylcbiAgZW5kXG5cbiAgZGVmIGZvcm1hdChpdGVtKVxuICAgIEZvcm1hdHRlci50b19oLmVhY2gge3xrbGFzcywgYmxvY2t8XG4gICAgICBpZiBrbGFzcyA9PT0gaXRlbVxuICAgICAgICBibG9jay5jYWxsKHNlbGYsIGl0ZW0pXG4gICAgICAgIGJyZWFrXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgQGlvLnN0cmluZ1xuICBlbmRcblxuICBkZWYgaW5kZW50PygmYmxvY2spXG4gICAgQG9wdGlvbnNbOmluZGVudF1bOmxldmVsXVxuICByZXNjdWVcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5kZW50KCZibG9jaylcbiAgICBpZiBpbmRlbnQ/XG4gICAgICBAb3B0aW9uc1s6aW5kZW50XVs6bGV2ZWxdICs9IDFcbiAgICAgIGJsb2NrLmNhbGxcbiAgICAgIEBvcHRpb25zWzppbmRlbnRdWzpsZXZlbF0gLT0gMVxuICAgIGVsc2VcbiAgICAgIGJsb2NrLmNhbGxcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHByaW50KHRleHQpXG4gICAgaWYgbGV2ZWwgPSBpbmRlbnQ/XG4gICAgICB0ZXh0LmxpbmVzLmVhY2gge3xsaW5lfFxuICAgICAgICBAaW8ucHV0cyBcIiN7QG9wdGlvbnNbOmluZGVudF1bOndpdGhdICogbGV2ZWx9I3tsaW5lLmNob21wfVwiXG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgQGlvLnByaW50IHRleHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVzY2FwZShzdHJpbmcpXG4gICAgc3RyaW5nLnRvX3MuZ3N1YigvW1wiPjwnXXwmKD8hKFthLXpBLVpdK3woI1xcZCspKTspLywge1xuICAgICAgJyYnID0+ICcmYW1wOycsXG4gICAgICAnPicgPT4gJyZndDsnLFxuICAgICAgJzwnID0+ICcmbHQ7JyxcbiAgICAgICdcIicgPT4gJyZxdW90OycsXG4gICAgICBcIidcIiA9PiAnJiMzOTsnIH0pXG4gIGVuZFxuZW5kXG5cbkZvcm1hdHRlci5mb3IgSFRNTCBkbyB8ZiwgaXRlbXxcbiAgY2FzZSBpdGVtLnZlcnNpb25cbiAgd2hlbiA1XG4gICAgZi5wcmludCAnPCFET0NUWVBFIGh0bWw+J1xuICBlbmRcblxuICBmLnByaW50ICc8aHRtbD4nXG4gIGYuaW5kZW50IHtcbiAgICBpdGVtLmVhY2gge3xyb290fFxuICAgICAgZi5mb3JtYXQocm9vdClcbiAgICB9XG4gIH1cbiAgZi5wcmludCAnPC9odG1sPidcbmVuZFxuXG5Gb3JtYXR0ZXIuZm9yIEhUTUw6OkVsZW1lbnQgZG8gfGYsIGl0ZW18XG4gIG5hbWUsIGF0dHJpYnV0ZXMsIGNsYXNzX25hbWVzID0gaXRlbS5pbnN0YW5jZV9ldmFsIHtcbiAgICBbQG5hbWUsIEBhdHRyaWJ1dGVzLCBAY2xhc3NfbmFtZXNdXG4gIH1cblxuICBpZiBhdHRyaWJ1dGVzLmVtcHR5PyAmJiBjbGFzc19uYW1lcy5lbXB0eT9cbiAgICBmLnByaW50IFwiPCN7bmFtZX0+XCJcbiAgZWxzZVxuICAgIGF0dHJzID0gYXR0cmlidXRlcy5tYXAge3xrZXksIHZhbHVlfFxuICAgICAgJVF7I3tmLmVzY2FwZShrZXkpfT1cIiN7Zi5lc2NhcGUodmFsdWUpfVwifVxuICAgIH1cblxuICAgIHVubGVzcyBjbGFzc19uYW1lcy5lbXB0eT9cbiAgICAgIGF0dHJzIDw8ICVRe2NsYXNzPVwiI3tmLmVzY2FwZShjbGFzc19uYW1lcy5qb2luKCcgJykpfVwifVxuICAgIGVuZFxuXG4gICAgZi5wcmludCBcIjwje25hbWV9ICN7YXR0cnMuam9pbignICcpfT5cIlxuICBlbmRcblxuICBmLmluZGVudCB7XG4gICAgaWYgaW5uZXIgPSBpdGVtLmluc3RhbmNlX2V2YWwgeyBAaW5uZXJfaHRtbCB9XG4gICAgICBmLnByaW50IGlubmVyXG4gICAgZWxzZVxuICAgICAgaXRlbS5lYWNoIHt8Y2hpbGR8XG4gICAgICAgIGNhc2UgY2hpbGRcbiAgICAgICAgd2hlbiBTdHJpbmdcbiAgICAgICAgICBmLnByaW50IGYuZXNjYXBlKGNoaWxkKVxuXG4gICAgICAgIHdoZW4gQ1NTXG4gICAgICAgICAgZi5wcmludCAnPHN0eWxlPidcbiAgICAgICAgICBmLmluZGVudCB7XG4gICAgICAgICAgICBmLmZvcm1hdChjaGlsZClcbiAgICAgICAgICB9XG4gICAgICAgICAgZi5wcmludCAnPC9zdHlsZT4nXG5cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGYuZm9ybWF0KGNoaWxkKVxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICBlbmRcbiAgfVxuXG4gIGYucHJpbnQgXCI8LyN7bmFtZX0+XCJcbmVuZFxuXG5Gb3JtYXR0ZXIuZm9yIENTUyBkbyB8ZiwgaXRlbXxcbiAgaXRlbS5ydWxlcy5yZXZlcnNlLmVhY2gge3xydWxlfFxuICAgIG5leHQgaWYgcnVsZS5kZWZpbml0aW9uLmVtcHR5P1xuXG4gICAgZi5wcmludCBcIiN7cnVsZS5zZWxlY3Rvcn0ge1wiXG4gICAgZi5pbmRlbnQge1xuICAgICAgcnVsZS5kZWZpbml0aW9uLmVhY2gge3xzdHlsZXxcbiAgICAgICAgZi5wcmludCBcIiN7c3R5bGUubmFtZX06ICN7c3R5bGUudmFsdWV9I3snICFpbXBvcnRhbnQnIGlmIHN0eWxlLmltcG9ydGFudH07XCJcbiAgICAgIH1cbiAgICB9XG4gICAgZi5wcmludCAnfSdcbiAgfVxuZW5kXG5cbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsInRvX2giLCJzZWxmIiwiQGZvcm1hdHRlcnMiLCJmb3IiLCJibG9jayIsIiR3cml0ZXIiLCJrbGFzcyIsIltdPSIsIi0iLCIxIiwiW10iLCJvcHRpb25zIiwib2xkIiwiZHVwIiwiZGVlcF9tZXJnZSEiLCJyZXN1bHQiLCJjYWxsIiwicmVwbGFjZSIsIjAiLCJpbml0aWFsaXplIiwiPT09IiwiaW8iLCJAaW8iLCJuZXciLCJAb3B0aW9ucyIsIm1lcmdlIiwiZm9ybWF0IiwiZWFjaCIsIml0ZW0iLCJ0b19zIiwic3RyaW5nIiwiaW5kZW50PyIsImluZGVudCIsIiRiaW5hcnlfb3BfcmVjdnJfdG1wXzEiLCIrIiwiJGJpbmFyeV9vcF9yZWN2cl90bXBfMiIsInByaW50IiwibGV2ZWwiLCJ0ZXh0IiwibGluZXMiLCJwdXRzIiwiKiIsImxpbmUiLCJjaG9tcCIsImVzY2FwZSIsImdzdWIiLCJ2ZXJzaW9uIiwiNSIsImYiLCJyb290IiwiaW5zdGFuY2VfZXZhbCIsIkBuYW1lIiwiQGF0dHJpYnV0ZXMiLCJAY2xhc3NfbmFtZXMiLCJuYW1lIiwiYXR0cmlidXRlcyIsImNsYXNzX25hbWVzIiwiZW1wdHk/IiwiYXR0cnMiLCJtYXAiLCJrZXkiLCJ2YWx1ZSIsIjw8Iiwiam9pbiIsImlubmVyIiwiQGlubmVyX2h0bWwiLCJjaGlsZCIsInJ1bGVzIiwicmV2ZXJzZSIsInJ1bGUiLCJkZWZpbml0aW9uIiwic2VsZWN0b3IiLCJzdHlsZSIsImltcG9ydGFudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBVUEsTUFBQUEsU0FBQUEsQ0FBUSxVQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBRUEsSUFBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUFBQTtBQUNFLE1BQUFDLFVBQUlDLElBQUpELFdBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7QUFBQUE7O0FBQUFBLFFBQ0UsT0FBQUUsQ0FBQUEsa0JBakJKLGNBaUJJQSxlQWpCSixTQWlCb0IsWUFBQSxFQWpCcEIsQ0FpQklBO0FBREZGLE1BQUFBLENBQUFBLCtCQUFBQSxDQUFBO0FBQUEsTUFJQUcsVUFBSUYsSUFBSkUsVUFBQUEsbUJBQUFBLFNBQWEsS0FBYkE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQUFBO0FBQUFBO0FBcEJGO0FBb0JzQixRQUFBLHVDQXBCdEI7QUFBQSxRQXFCSSxJQUFBLFFBQUdDLEtBQUgsQ0FBQTtBQUFBO0FBckJKLFVBQUFDLFVBQUEsQ0FzQldDLEtBdEJYLEVBc0JvQkYsS0F0QnBCLENBQUE7QUFBQSxVQXNCTUcsVUFBQVAsTUFBQUEsQ0FBQUEsQ0FBQU8sT0FBQUEsRUF0Qk4sVUFBQUYsT0FBQSxDQXNCTUUsQ0F0Qk47QUFBQSxVQUFBLE9BQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBO0FBcUJJLFFBQUE7QUFBQSxVQUdFLFdBQUFSLE1BQUFBLENBQUFBLENBQUFVLE9BQUFBLENBQUtKLEtBQUxJO0FBSEYsUUFBQSxDQXJCSjtBQW9CRVAsTUFBQUEsQ0FBQUEsOEJBQUFBLENBSkE7QUFBQSxNQVlBUSxVQUFJVixJQUFKVSxjQUFBQSx1QkFBQUEsbUJBQWlCLE9BQWpCQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFBQUE7QUFBQUE7QUE1QkY7QUE0QjRCLFFBQUEsMkNBNUI1QjtBQUFBLFFBNkJJQyxNQUFNLHVCQUFBQyxLQUFBQSxDQUFBQSxDQTdCVjtBQUFBLFFBOEJJLHFCQUFBQyxnQkFBQUEsQ0FBa0IseUJBQVNILE9BQTNCRyxDQTlCSjtBQUFBLFFBZ0NJQyxTQUFTWCxLQUFBWSxNQUFBQSxDQUFBQSxDQWhDYjtBQUFBLFFBa0NJLHVCQUFBQyxTQUFBQSxDQUFnQkwsR0FBaEJLLENBbENKO0FBQUEsUUFvQ0ksT0FBQUYsTUFwQ0o7QUE0QkVKLE1BQUFBLENBQUFBLGtDQUFBQSxDQVpBO0FBQUEsTUF1QkEsdUNBQVUsb0JBQUEsVUFDQSwyQkFBQSxTQUNDTyxDQURELEVBQUEsUUFFQyxJQUZELEVBREEsRUFBVixDQXZCQTtBQUFBO0FBOEJBQyxNQUFBQSw4QkFBQUEsMEJBQUFBLHNCQUFlLEVBQUQsRUFBVyxPQUF6QkE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBOUNGO0FBOENpQixRQUFBO0FBQUEsUUFBQSxPQUFLLEdBQUw7QUFBQSxRQUFBLENBOUNqQjtBQUFBO0FBOEMyQixRQUFBO0FBQUEsUUFBQSxZQUFVLFlBQUEsRUFBVjtBQUFBLFFBQUEsQ0E5QzNCO0FBQUEsUUErQ0ksSUFBQSxRQUFHLG9CQUFBQyxRQUFBQSxDQUFTQyxFQUFURCxDQUFILENBQUE7QUFBQTtBQUNFLFVBQUFFLFVBQVcsd0JBQUFDLEtBQUFBLENBQUFBLENBQVg7QUFBQSxVQUNBQyxlQUFXSCxFQURYO0FBREYsUUFBQTtBQUFBO0FBSUUsVUFBQUMsVUFBVyxjQUFBRCxFQUFBLFNBQU0sd0JBQUFFLEtBQUFBLENBQUFBLENBQU4sQ0FBWDtBQUFBLFVBQ0FDLGVBQVdiLE9BRFg7QUFKRixRQUFBLENBL0NKO0FBQUEsUUF1REksT0FBQWEsQ0FBQUEsZUFBVyx1QkFBQUMsT0FBQUEsQ0FBY0QsWUFBZEMsQ0FBWEQsQ0F2REo7QUE4Q0VMLE1BQUFBLENBQUFBLHNDQUFBQSxDQTlCQTtBQUFBO0FBMENBTyxNQUFBQSwwQkFBQUEsc0JBQUFBLGtCQUFXLElBQVhBO0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFDLDRDQUFBQSxPQUFBQSxNQUFBLHlCQUFBM0IsTUFBQUEsQ0FBQUEsQ0FBQTJCLFFBQUFBLEVBQUFBLEVBQUFBLEVBM0RKLGdCQTJEMEIsS0FBRCxFQUFRLEtBM0RqQyxFQUFBOztBQUFBO0FBQUE7QUEyRDBCLFVBQUE7QUFBQSxVQUFBO0FBQUEsVUFBQSxDQTNEMUI7QUFBQTtBQTJEaUMsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBM0RqQztBQUFBLFVBNERNLElBQUEsUUFBR3JCLEtBQUFjLFFBQUFBLENBQVVRLElBQVZSLENBQUgsQ0FBQTtBQUFBO0FBQ0UsWUFBQWhCLEtBQUFZLE1BQUFBLENBQVdmLE1BQU0yQixJQUFqQlosQ0FBQTtBQUFBO0FBQ0EsWUFBQSxZQUFBLE9BREE7QUFERixVQUFBO0FBQUE7QUFBQSxVQUFBLENBNUROLENBQUEsa0JBQUEsa0JBQUEsaUJBQUEsS0EyRElXO0FBQUFBLFFBQUFBLDRFQUFBO0FBQUEsUUFPQSxPQUFBMUIsSUFQQTtBQURGeUIsTUFBQUEsQ0FBQUEsaUNBQUFBLENBMUNBO0FBQUE7QUFxREFHLE1BQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUFQLE9BQUFRLFFBQUFBLENBQUFBO0FBREZELE1BQUFBLENBQUFBLCtCQUFBQSxDQXJEQTtBQUFBO0FBeURBRSxNQUFBQSwyQkFBQUEsMkJBQUFBLFNBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQTtBQXpFRjtBQXlFYyxRQUFBLCtDQXpFZDtBQUFBLFFBMEVJO0FBQUEsVUFBQSxPQUFBUCxZQUFBZCxPQUFBQSxDQUFTLFFBQVRBLENBQUFBLE9BQUFBLENBQWtCLE9BQWxCQTtBQUFBLFFBQUE7QUFBQSxVQUNGLHFEQUFBO0FBQUEsWUFBQTtBQUFBLGNBQ0UsT0FBQTtBQURGLFlBQUE7QUFBQSxVQUFBLENBREU7QUFBQSxRQUFBLENBMUVKO0FBeUVFcUIsTUFBQUEsQ0FBQUEsc0NBQUFBLENBekRBO0FBQUE7QUErREFDLE1BQUFBLDBCQUFBQSxzQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQTtBQS9FRjtBQStFYSxRQUFBLDBDQS9FYjtBQUFBLFFBZ0ZJLElBQUEsWUFBR0QsWUFBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUE7QUFDRTtBQWpGTixVQUFBRSx5QkFpRk1ULFlBQUFkLE9BQUFBLENBQVMsUUFBVEEsQ0FqRk47QUFBQTtBQUFBLFVBQUFMLFVBQUEsQ0FpRndCLE9BakZ4QixFQUFBNkIsU0FBQSxzQkFpRk14QixPQUFBQSxDQUFrQixPQUFsQkEsQ0FqRk53QixFQWlGbUN6QixDQWpGbkN5QixDQUFBLENBQUE7QUFBQSxVQWlGTTNCLE1BakZOLHNCQWlGTUEsT0FBQUEsRUFqRk4sVUFBQUYsT0FBQSxDQWlGTUUsQ0FqRk47QUFBQSxVQUFBRixPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQUFBLENBaUZNO0FBQUEsVUFDQUosS0FBQVksTUFBQUEsQ0FBQUEsQ0FEQTtBQUFBO0FBakZOLFVBQUFtQix5QkFtRk1YLFlBQUFkLE9BQUFBLENBQVMsUUFBVEEsQ0FuRk47QUFBQTtBQUFBLFVBQUFMLFVBQUEsQ0FtRndCLE9BbkZ4QixFQUFBRyxVQUFBLHNCQW1GTUUsT0FBQUEsQ0FBa0IsT0FBbEJBLENBbkZORixFQW1GbUNDLENBbkZuQ0QsQ0FBQSxDQUFBO0FBQUEsVUFtRk1ELE1BbkZOLHNCQW1GTUEsT0FBQUEsRUFuRk4sVUFBQUYsT0FBQSxDQW1GTUUsQ0FuRk47QUFBQSxVQUFBLE9BQUFGLE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBLFFBQUEsQ0FBQUcsRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsQ0FpRk07QUFERixRQUFBO0FBQUEsVUFLRSxPQUFBSixLQUFBWSxNQUFBQSxDQUFBQTtBQUxGLFFBQUEsQ0FoRko7QUErRUVnQixNQUFBQSxDQUFBQSxpQ0FBQUEsQ0EvREE7QUFBQTtBQXlFQUksTUFBQUEseUJBQUFBLHNCQUFBQSxpQkFBVSxJQUFWQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxJQUFBLFFBQUdDLENBQUFBLFlBQVFOLFlBQUFBLENBQUFBLENBQVJNLENBQUgsQ0FBQTtBQUFBLFVBQ0UsT0FBQVYsTUFBQVcsSUFBQUMsT0FBQUEsQ0FBQUEsQ0FBQVosUUFBQUEsRUFBQUEsRUFBQUEsRUEzRk4saUJBMkZ3QixJQTNGeEIsRUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQTJGd0IsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBM0Z4QjtBQUFBLFlBNEZRLE9BQUFMLE9BQUFrQixNQUFBQSxDQUFTLEVBQUEsR0FBQSxDQUFHQyxVQUFBakIsWUFBQWQsT0FBQUEsQ0FBUyxRQUFUQSxDQUFBQSxPQUFBQSxDQUFrQixNQUFsQkEsQ0FBQStCLEVBQTJCSixLQUEzQkksQ0FBSCxDQUFBLEdBQUEsQ0FBc0NDLElBQUFDLE9BQUFBLENBQUFBLENBQXRDLENBQVRILENBNUZSLENBQUEsbUJBQUEsa0JBQUEsTUEyRk1iO0FBREYsUUFBQTtBQUFBLFVBS0UsT0FBQUwsT0FBQWMsT0FBQUEsQ0FBVUUsSUFBVkY7QUFMRixRQUFBO0FBREZBLE1BQUFBLENBQUFBLGlDQUFBQSxDQXpFQTtBQUFBLE1BbUZBLE9BQUFRLENBQUFBLDBCQUFBQSx1QkFBQUEsa0JBQVcsTUFBWEE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQWQsTUFBQUQsTUFBQUEsQ0FBQUEsQ0FBQWdCLE1BQUFBLENBQWlCLG1DQUFtQyxvQ0FBQSxLQUMzQyxPQUQyQyxFQUFBLEtBRTNDLE1BRjJDLEVBQUEsS0FHM0MsTUFIMkMsRUFBQSxNQUkzQyxRQUoyQyxFQUFBLEtBSzNDLE9BTDJDLEVBQXBEQTtBQURGRCxNQUFBQSxDQUFBQSxrQ0FBQUEsQ0FBQUEsa0JBbkZBO0FBREY3QyxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUFBO0FBQUEsSUE4RkFJLE1BQUEseUJBQUFBLE9BQUFBLEVBQUFBLENBQWMsb0JBQWRBLENBQUFBLEVBN0dBLHVCQTZHdUIsQ0FBRCxFQUFJLElBN0cxQixFQUFBOztBQUFBO0FBQUE7QUE2R3VCLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQTdHdkI7QUFBQTtBQTZHMEIsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLENBN0cxQjtBQUFBLE1BOEdFLFFBQUt5QixJQUFBa0IsU0FBQUEsQ0FBQUEsQ0FBTDtBQUFBLE1BQ0EsSUFBS0MsQ0FBQUEsQ0FBQUEsZ0JBQUwsR0FDRUMsQ0FBQVosT0FBQUEsQ0FBUSxpQkFBUkEsQ0FERixDQS9HRjtBQUFBLE1BbUhFWSxDQUFBWixPQUFBQSxDQUFRLFFBQVJBLENBbkhGO0FBQUEsTUFvSEVKLE1BQUFnQixDQUFBaEIsVUFBQUEsRUFBQUEsRUFBQUEsRUFwSEYsaUJBQUEsRUFBQTs7QUFBQSxNQXFISSxPQUFBTCxNQUFBQyxJQUFBRCxRQUFBQSxFQUFBQSxFQUFBQSxFQXJISixpQkFxSGdCLElBckhoQixFQUFBOztBQUFBO0FBQUE7QUFxSGdCLFVBQUE7QUFBQSxVQUFBO0FBQUEsVUFBQSxDQXJIaEI7QUFBQSxVQXNITSxPQUFBcUIsQ0FBQXRCLFFBQUFBLENBQVN1QixJQUFUdkIsQ0F0SE4sQ0FBQSxtQkFBQSxrQkFBQSxNQXFISUMsQ0FySEosbUJBQUEsa0JBQUEsTUFvSEVLLENBcEhGO0FBQUEsTUF5SEUsT0FBQWdCLENBQUFaLE9BQUFBLENBQVEsU0FBUkEsQ0F6SEYsQ0FBQSx5QkFBQSx3QkFBQSxZQTZHQWpDLENBOUZBO0FBQUEsSUE2R0FBLE1BQUEseUJBQUFBLE9BQUFBLEVBQUFBLENBQWMsSUFBQSxvQkFBQSxZQUFkQSxDQUFBQSxFQTVIQSx1QkE0SGdDLENBQUQsRUFBSSxJQTVIbkMsRUFBQTs7QUFBQTtBQUFBO0FBNEhnQyxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsQ0E1SGhDO0FBQUE7QUE0SG1DLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQTVIbkM7QUFBQSxNQTZIRSxLQUFnQytDLE1BQUF0QixJQUFBc0IsaUJBQUFBLEVBQUFBLEVBQUFBLEVBN0hsQyxpQkFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBLE1BOEhJLE9BQUEsQ0FBQ0MsU0FBRCxFQUFRQyxlQUFSLEVBQXFCQyxnQkFBckIsQ0E5SEosbUJBQUEsa0JBQUEsTUE2SGtDSCxDQUFoQyxzQkFBQSxFQUFBSSxDQUFBQSxvQ0FBQUEsQ0FBQSxFQUFNQyxDQUFBQSwwQ0FBQUEsQ0FBTixFQUFrQkMsQ0FBQUEsMkNBQUFBLENBQWxCLElBN0hGO0FBQUEsTUFpSUUsSUFBQSxRQUFHLGNBQUFELFVBQUFFLFdBQUFBLENBQUFBLENBQUEsSUFBcUJELFdBQUFDLFdBQUFBLENBQUFBLENBQXJCLE1BQUgsQ0FBQTtBQUFBLFFBQ0VULENBQUFaLE9BQUFBLENBQVEsRUFBQSxHQUFBLEdBQUEsR0FBQSxDQUFJa0IsSUFBSixDQUFBLEdBQUEsR0FBUmxCO0FBREYsTUFBQTtBQUFBO0FBR0UsUUFBQXNCLFFBQVFDLE1BQUFKLFVBQUFJLE9BQUFBLEVBQUFBLEVBQUFBLEVBcElaLGlCQW9JNkIsR0FBRCxFQUFNLEtBcElsQyxFQUFBOztBQUFBO0FBQUE7QUFvSTZCLFVBQUE7QUFBQSxVQUFBO0FBQUEsVUFBQSxDQXBJN0I7QUFBQTtBQW9Ja0MsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBcElsQztBQUFBLFVBcUlNLE9BQUEsRUFBQSxHQUFBLENBQUtYLENBQUFKLFFBQUFBLENBQVNnQixHQUFUaEIsQ0FBTCxDQUFBLEdBQUEsS0FBQSxHQUFBLENBQXVCSSxDQUFBSixRQUFBQSxDQUFTaUIsS0FBVGpCLENBQXZCLENBQUEsR0FBQSxJQXJJTixDQUFBLG1CQUFBLGtCQUFBLE1Bb0lZZSxDQUFSO0FBQUEsUUFJQSxJQUFBLFFBQU9ILFdBQUFDLFdBQUFBLENBQUFBLENBQVAsQ0FBQTtBQUFBLFFBQUE7QUFBQSxVQUNFQyxLQUFBSSxPQUFBQSxDQUFTLEVBQUEsR0FBQSxVQUFBLEdBQUEsQ0FBWWQsQ0FBQUosUUFBQUEsQ0FBU1ksV0FBQU8sTUFBQUEsQ0FBaUIsR0FBakJBLENBQVRuQixDQUFaLENBQUEsR0FBQSxJQUFUa0I7QUFERixRQUFBLENBSkE7QUFBQSxRQVFBZCxDQUFBWixPQUFBQSxDQUFRLEVBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBSWtCLElBQUosQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFZSSxLQUFBSyxNQUFBQSxDQUFXLEdBQVhBLENBQVosQ0FBQSxHQUFBLEdBQVIzQixDQVJBO0FBSEYsTUFBQSxDQWpJRjtBQUFBLE1BK0lFSixNQUFBZ0IsQ0FBQWhCLFVBQUFBLEVBQUFBLEVBQUFBLEVBL0lGLGlCQUFBLEVBQUE7O0FBQUEsTUFnSkksSUFBQSxRQUFHZ0MsQ0FBQUEsUUFBUWQsTUFBQXRCLElBQUFzQixpQkFBQUEsRUFBQUEsRUFBQUEsRUFoSmYsaUJBQUEsRUFBQTtBQUFBOztBQUFBLFFBZ0pvQyxPQUFBZSxlQWhKcEMsbUJBQUEsa0JBQUEsTUFnSmVmLENBQVJjLENBQUgsQ0FBQTtBQUFBLFVBQ0UsT0FBQWhCLENBQUFaLE9BQUFBLENBQVE0QixLQUFSNUI7QUFERixRQUFBO0FBQUEsVUFHRSxPQUFBVCxNQUFBQyxJQUFBRCxRQUFBQSxFQUFBQSxFQUFBQSxFQW5KTixpQkFtSmtCLEtBbkpsQixFQUFBOztBQUFBO0FBQUE7QUFtSmtCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQW5KbEI7QUFBQSxZQW9KUSxPQUFBLGFBQUEsUUFBS3VDLEtBQUw7QUFBQSxZQUNBLElBQUsscUNBQUwsR0FDRSxPQUFBbEIsQ0FBQVosT0FBQUEsQ0FBUVksQ0FBQUosUUFBQUEsQ0FBU3NCLEtBQVR0QixDQUFSUixDQURGO0FBREEsWUFBQSxLQUlBLElBQUssa0NBQUw7QUFDRSxZQUFBWSxDQUFBWixPQUFBQSxDQUFRLFNBQVJBLENBQUE7QUFBQSxZQUNBSixNQUFBZ0IsQ0FBQWhCLFVBQUFBLEVBQUFBLEVBQUFBLEVBMUpWLGlCQUFBLEVBQUE7O0FBQUEsWUEySlksT0FBQWdCLENBQUF0QixRQUFBQSxDQUFTd0MsS0FBVHhDLENBM0paLG1CQUFBLGtCQUFBLE1BMEpVTSxDQURBO0FBQUEsWUFJQSxPQUFBZ0IsQ0FBQVosT0FBQUEsQ0FBUSxVQUFSQSxDQUpBLENBREY7QUFKQSxZQUFBLE1BWUUsT0FBQVksQ0FBQXRCLFFBQUFBLENBQVN3QyxLQUFUeEMsQ0FaRixDQUFBLElBcEpSLENBQUEsbUJBQUEsa0JBQUEsTUFtSk1DO0FBSEYsUUFBQSxDQWhKSixtQkFBQSxrQkFBQSxNQStJRUssQ0EvSUY7QUFBQSxNQXNLRSxPQUFBZ0IsQ0FBQVosT0FBQUEsQ0FBUSxFQUFBLEdBQUEsSUFBQSxHQUFBLENBQUtrQixJQUFMLENBQUEsR0FBQSxHQUFSbEIsQ0F0S0YsQ0FBQSx5QkFBQSx3QkFBQSxZQTRIQWpDLENBN0dBO0FBQUEsSUEwSkEsT0FBQUEsTUFBQSx5QkFBQUEsT0FBQUEsRUFBQUEsQ0FBYyxtQkFBZEEsQ0FBQUEsRUF6S0EsdUJBeUtzQixDQUFELEVBQUksSUF6S3pCLEVBQUE7O0FBQUE7QUFBQTtBQXlLc0IsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLENBekt0QjtBQUFBO0FBeUt5QixNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsQ0F6S3pCO0FBQUEsTUEwS0UsT0FBQXdCLE1BQUFDLElBQUF1QyxPQUFBQSxDQUFBQSxDQUFBQyxTQUFBQSxDQUFBQSxDQUFBekMsUUFBQUEsRUFBQUEsRUFBQUEsRUExS0YsaUJBMEs0QixJQTFLNUIsRUFBQTs7QUFBQTtBQUFBO0FBMEs0QixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0ExSzVCO0FBQUEsUUEyS0ksSUFBQSxRQUFRMEMsSUFBQUMsWUFBQUEsQ0FBQUEsQ0FBQWIsV0FBQUEsQ0FBQUEsQ0FBUixDQUFBO0FBQUEsVUFBQSxVQUFBLENBQUEsQ0EzS0o7QUFBQSxRQTZLSVQsQ0FBQVosT0FBQUEsQ0FBUSxFQUFBLEdBQUEsQ0FBR2lDLElBQUFFLFVBQUFBLENBQUFBLENBQUgsQ0FBQSxHQUFBLElBQVJuQyxDQTdLSjtBQUFBLFFBOEtJSixNQUFBZ0IsQ0FBQWhCLFVBQUFBLEVBQUFBLEVBQUFBLEVBOUtKLGlCQUFBLEVBQUE7O0FBQUEsUUErS00sT0FBQUwsTUFBQTBDLElBQUFDLFlBQUFBLENBQUFBLENBQUEzQyxRQUFBQSxFQUFBQSxFQUFBQSxFQS9LTixpQkErSzZCLEtBL0s3QixFQUFBOztBQUFBO0FBQUE7QUErSzZCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQS9LN0I7QUFBQSxZQWdMUSxPQUFBcUIsQ0FBQVosT0FBQUEsQ0FBUSxFQUFBLEdBQUEsQ0FBR29DLEtBQUFsQixNQUFBQSxDQUFBQSxDQUFILENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBa0JrQixLQUFBWCxPQUFBQSxDQUFBQSxDQUFsQixDQUFBLEdBQUEsQ0FBZ0MsYUFBQSxJQUFBLFFBQWlCVyxLQUFBQyxXQUFBQSxDQUFBQSxDQUFqQixDQUFBO0FBQUEsY0FBQSxPQUFBO0FBQUEsWUFBQTtBQUFBO0FBQUEsWUFBQSxDQUFBLGtCQUFoQyxDQUFBLEdBQUEsR0FBUnJDLENBaExSLENBQUEsbUJBQUEsa0JBQUEsTUErS01ULENBL0tOLG1CQUFBLGtCQUFBLE1BOEtJSyxDQTlLSjtBQUFBLFFBbUxJLE9BQUFnQixDQUFBWixPQUFBQSxDQUFRLEdBQVJBLENBbkxKLENBQUEsbUJBQUEsa0JBQUEsTUEwS0VULENBMUtGLENBQUEseUJBQUEsd0JBQUEsWUF5S0F4QixDQTFKQTtBQUZBSixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjY5MjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL3BhZ2dpby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjLS1cbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIsIERlY2VtYmVyIDIwMDRcbiNcbiMgICAgICAgICAgICBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPIFBVQkxJQyBMSUNFTlNFXG4jICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIENPUFlJTkcsIERJU1RSSUJVVElPTiBBTkQgTU9ESUZJQ0FUSU9OXG4jXG4jICAwLiBZb3UganVzdCBETyBXSEFUIFRIRSBGVUNLIFlPVSBXQU5UIFRPLlxuIysrXG5cbnJlcXVpcmUgJ3BhZ2dpby91dGlscydcbnJlcXVpcmUgJ3BhZ2dpby9odG1sJ1xucmVxdWlyZSAncGFnZ2lvL2NzcydcbnJlcXVpcmUgJ3BhZ2dpby9mb3JtYXR0ZXInXG5cbmNsYXNzIFBhZ2dpb1xuICBkZWYgc2VsZi5vcHRpb25zKG9wdGlvbnMsICZibG9jaylcbiAgICBGb3JtYXR0ZXIub3B0aW9ucyhvcHRpb25zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluZGVudChvcHRpb25zLCAmYmxvY2spXG4gICAgb3B0aW9ucyhpbmRlbnQ6IG9wdGlvbnMsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY3NzKCphcmdzLCAmYmxvY2spXG4gICAgRm9ybWF0dGVyLm5ldy5mb3JtYXQoQ1NTLm5ldygqYXJncywgJmJsb2NrKSkudG9fc1xuICBlbmRcblxuICBkZWYgc2VsZi5odG1sKCphcmdzLCAmYmxvY2spXG4gICAgRm9ybWF0dGVyLm5ldy5mb3JtYXQoSFRNTC5uZXcoKmFyZ3MsICZibG9jaykpLnRvX3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaHRtbCEoJmJsb2NrKVxuICAgIEZvcm1hdHRlci5uZXcudGFwIHt8ZnxcbiAgICAgIEhUTUwubmV3KCZibG9jaykuZWFjaCB7fHJvb3R8XG4gICAgICAgIGYuZm9ybWF0IHJvb3RcbiAgICAgIH1cbiAgICB9LnRvX3NcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJvcHRpb25zIiwic2VsZiIsImJsb2NrIiwiaW5kZW50IiwiY3NzIiwibmV3IiwiZm9ybWF0IiwiYXJncyIsInRvX3MiLCJodG1sIiwiaHRtbCEiLCJ0YXAiLCJlYWNoIiwiZiIsInJvb3QiXSwibWFwcGluZ3MiOiI7Ozs7OztBQVVBLE1BQUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FBQTtBQUFBLE1BQ0FBLFNBQUFBLENBQVEsYUFBUkEsQ0FEQTtBQUFBLE1BRUFBLFNBQUFBLENBQVEsWUFBUkEsQ0FGQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsa0JBQVJBLENBSEE7QUFBQSxFQUtBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBQyxVQUFJQyxJQUFKRCxjQUFBQSxvQkFBQUEsbUJBQWlCLE9BQWpCQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFqQkY7QUFpQjRCLE1BQUEsd0NBakI1QjtBQUFBLE1Ba0JJLE9BQUFBLE1BQUEseUJBQUFBLFdBQUFBLEVBQUFBLENBQWtCQSxPQUFsQkEsQ0FBQUEsRUFBNEJFLGdCQUE1QkYsQ0FsQko7QUFpQkVBLElBQUFBLENBQUFBLCtCQUFBQSxDQUFBO0FBQUEsSUFJQUcsVUFBSUYsSUFBSkUsYUFBQUEsbUJBQUFBLGtCQUFnQixPQUFoQkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBckJGO0FBcUIyQixNQUFBLHVDQXJCM0I7QUFBQSxNQXNCSSxPQUFBSCxVQUFBQSxXQUFBQSxFQUFBQSxDQUFRLG9CQUFBLFVBQVFBLE9BQVIsRUFBUkEsQ0FBQUEsRUFBMEJFLGdCQUExQkYsQ0F0Qko7QUFxQkVHLElBQUFBLENBQUFBLDhCQUFBQSxDQUpBO0FBQUEsSUFRQUMsVUFBSUgsSUFBSkcsVUFBQUEsZ0JBQUFBLGVBekJGLEVBeUJFQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUF6QkY7QUF5QnNCLE1BQUEsb0NBekJ0QjtBQUFBO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBeUJlLE1BQUEsa0JBekJmO0FBQUEsTUEwQkksT0FBQSx5QkFBQUMsS0FBQUEsQ0FBQUEsQ0FBQUMsUUFBQUEsQ0FBcUJELE1BQUEsbUJBQUFBLE9BQUFBLEVBQVEsVUFBQ0UsSUFBRCxDQUFSRixFQUFnQkgsZ0JBQWhCRyxDQUFyQkMsQ0FBQUUsTUFBQUEsQ0FBQUEsQ0ExQko7QUF5QkVKLElBQUFBLENBQUFBLDRCQUFBQSxDQVJBO0FBQUEsSUFZQUssVUFBSVIsSUFBSlEsV0FBQUEsaUJBQUFBLGdCQTdCRixFQTZCRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBN0JGO0FBNkJ1QixNQUFBLHFDQTdCdkI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQTZCZ0IsTUFBQSxrQkE3QmhCO0FBQUEsTUE4QkksT0FBQSx5QkFBQUosS0FBQUEsQ0FBQUEsQ0FBQUMsUUFBQUEsQ0FBcUJELE1BQUEsb0JBQUFBLE9BQUFBLEVBQVMsVUFBQ0UsSUFBRCxDQUFURixFQUFpQkgsZ0JBQWpCRyxDQUFyQkMsQ0FBQUUsTUFBQUEsQ0FBQUEsQ0E5Qko7QUE2QkVDLElBQUFBLENBQUFBLDZCQUFBQSxDQVpBO0FBQUEsSUFnQkEsT0FBQUMsQ0FBQUEsVUFBSVQsSUFBSlMsWUFBQUEsc0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQWpDRjtBQWlDaUIsTUFBQSwwQ0FqQ2pCO0FBQUEsTUFrQ0ksT0FBQUMsTUFBQSx5QkFBQU4sS0FBQUEsQ0FBQUEsQ0FBQU0sT0FBQUEsRUFBQUEsRUFBQUEsRUFsQ0osZ0JBa0N3QixDQWxDeEIsRUFBQTs7QUFBQTtBQUFBO0FBa0N3QixRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0FsQ3hCO0FBQUEsUUFtQ00sT0FBQUMsTUFBQVAsTUFBQSxvQkFBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBVUgsZ0JBQVZHLENBQUFPLFFBQUFBLEVBQUFBLEVBQUFBLEVBbkNOLGdCQW1DOEIsSUFuQzlCLEVBQUE7O0FBQUE7QUFBQTtBQW1DOEIsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBbkM5QjtBQUFBLFVBb0NRLE9BQUFDLENBQUFQLFFBQUFBLENBQVNRLElBQVRSLENBcENSLENBQUEsa0JBQUEsaUJBQUEsS0FtQ01NLENBbkNOLENBQUEsa0JBQUEsaUJBQUEsS0FrQ0lELENBQUFILE1BQUFBLENBQUFBLENBbENKO0FBaUNFRSxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0FBQUEsaUJBaEJBO0FBREZYLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBTEE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzAxNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvdmVyc2lvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlclxuICBWRVJTSU9OID0gJzAuMi4wJ1xuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLHVDQUFVLE9BQVY7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzAyNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvdXRpbHMucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcbiAgU2l6ZSAgICAgPSBTdHJ1Y3QubmV3KDp3aWR0aCwgOmhlaWdodClcbiAgUG9zaXRpb24gPSBTdHJ1Y3QubmV3KDp4LCA6eSlcblxuICAjIHtCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyfSBpcyBhIHNwZWNpYWwgY2FzZSBvZiB7TmF0aXZlOjpXcmFwcGVyfS5cbiAgI1xuICAjIFdoYXQgdGhpcyBtb2R1bGUgZG9lcyBpcyBpdCBtYWtlcyBzdXJlIHRoYXQgeW91ciBSdWJ5IG9iamVjdHNcbiAgIyBhcmUgbWFwcGVkIDE6MSB0byB5b3VyIEphdmFzY3JpcHQgb2JqZWN0cy4gU28gdGhhdCBmb3IgaW5zdGFuY2VcbiAgIyB5b3VyIGAkZG9jdW1lbnQuYXRfY3NzKCdib2R5JylgIGlzIGFsd2F5cyB0aGUgc2FtZSBSdWJ5IG9iamVjdC5cbiAgI1xuICAjIFlvdSBjYW4gb25seSB1c2UgaXQgaWYgeW91ciBmaW5hbCBgLm5ld2AgaXMgb2YgdGhlIHNpZ25hdHVyZVxuICAjIGAubmV3KG5hdGl2ZSlgIGFuZCB5b3VyIG5hdGl2ZSAocHJvYmFibHkgRE9NKSBvYmplY3QgcGVyc2lzdHMgYW5kXG4gICMgZG9lc24ndCBtaW5kIGFyYml0cmFyeSBwcm9wZXJ0aWVzLlxuICAjXG4gICMgVGhlIHJ1bGUgb2YgdGh1bWIgaXM6IGlmIGl0IGRvZXMgb3ZlcmxvYWQgYCNpbml0aWFsaXplYCdzIHNpZ25hdHVyZVxuICAjIGFuZCBub3QgYC5uZXdgJ3MgLSBpdCB3b24ndCB3b3JrLiBVc2Uge05hdGl2ZTo6V3JhcHBlcn0gaW4gdGhpcyBjYXNlLlxuICBtb2R1bGUgTmF0aXZlQ2FjaGVkV3JhcHBlclxuICAgIGRlZiBzZWxmLmluY2x1ZGVkKGtsYXNzKVxuICAgICAga2xhc3MuaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcbiAgICAgIGtsYXNzLmV4dGVuZCBOYXRpdmVDYWNoZWRXcmFwcGVyQ2xhc3NNZXRob2RzXG4gICAgZW5kXG5cbiAgICBkZWYgcmVzdHJpY3RlZD9cbiAgICAgICEhQHJlc3RyaWN0ZWRcbiAgICBlbmRcblxuICAgICMgQ2hhbmdlIGEgbmF0aXZlIHJlZmVyZW5jZSBhbmQgbWFrZSBzdXJlIHRoZSBjaGFuZ2UgaXMgcmVmbGVjdGVkIG9uIEpTXG4gICAgIyBzaWRlIGFzIHdlbGwuIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgTm9kZSNpbml0aWFsaXplX2NvcHkuIFBsZWFzZSBkb24ndFxuICAgICMgdXNlIHRoaXMgbWV0aG9kIG91dHNpZGUgb2YgdGhlIGNsb25pbmcgc2VtYW50aWMuXG4gICAgZGVmIHNldF9uYXRpdmVfcmVmZXJlbmNlKG5hdGl2ZSlcbiAgICAgIGAje25hdGl2ZX0uJCRvcGFsX25hdGl2ZV9jYWNoZWQgPSAje3NlbGZ9YFxuICAgICAgQG5hdGl2ZSA9IG5hdGl2ZVxuICAgIGVuZFxuICBlbmRcblxuICBtb2R1bGUgTmF0aXZlQ2FjaGVkV3JhcHBlckNsYXNzTWV0aG9kc1xuICAgICMgQ2hlY2sgaWYgd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gYXJiaXRyYXJ5IHByb3BlcnRpZXMgb2YgYSAocHJlc3VtYWJseSlcbiAgICAjIG5hdGl2ZSBvYmplY3QuXG4gICAgcHJpdmF0ZSBkZWYgcmVzdHJpY3RlZD8obmF0aXZlKVxuICAgICAgJXh7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHlwZW9mKCN7bmF0aXZlfS4kJHRyeV9yZXN0cmljdGVkX2FjY2Vzcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09ICdTZWN1cml0eUVycm9yJykgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIG5ldyhuYXRpdmUpXG4gICAgICAjIFdlIGNhbid0IGFjY2VzcyBhcmJpdHJhcnkgcHJvcGVydGllcyBpZiBhbiBlbGVtZW50IGlzIHJlc3RyaWN0ZWRcbiAgICAgICMgaS5lLiB0aGUgRE9NIGVsZW1lbnQgaXMgYW4gaXRlbSB3ZSBjYW4ndCBmdWxseSBhY2Nlc3MgZHVlIHRvIENPUlMuXG4gICAgICBpZiByZXN0cmljdGVkPyhuYXRpdmUpXG4gICAgICAgICMgTGV0J3MgdHJ5IHRvIGJ5cGFzcyBhbnkgZnVydGhlciBpbml0aWFsaXplcnMuLi4gbWF5IGJlIHVnbHksIGJ1dFxuICAgICAgICAjIHdvcmtzLlxuICAgICAgICBvYmogPSBhbGxvY2F0ZVxuICAgICAgICBvYmouaW5zdGFuY2VfdmFyaWFibGVfc2V0IDpAbmF0aXZlLCBuYXRpdmVcbiAgICAgICAgb2JqLmluc3RhbmNlX3ZhcmlhYmxlX3NldCA6QHJlc3RyaWN0ZWQsIHRydWVcbiAgICAgICAgcmV0dXJuIG9ialxuICAgICAgZW5kXG5cbiAgICAgICMgSXQncyBub3QgYSBuYXRpdmUgZWxlbWVudD8gV2VpcmQsIGJldHRlciB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yIGlmICFuYXRpdmU/KG5hdGl2ZSlcblxuICAgICAgaWYgZGVmaW5lZD8gYCN7bmF0aXZlfS4kJG9wYWxfbmF0aXZlX2NhY2hlZGBcbiAgICAgICAgYCN7bmF0aXZlfS4kJG9wYWxfbmF0aXZlX2NhY2hlZGBcbiAgICAgIGVsc2VcbiAgICAgICAgYCN7bmF0aXZlfS4kJG9wYWxfbmF0aXZlX2NhY2hlZCA9ICN7c3VwZXIobmF0aXZlKX1gXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuY2xhc3MgT2JqZWN0XG4gICMgRW5jb2RlIGFzIFVSSS5cbiAgI1xuICAjIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgRm9ybURhdGEuZW5jb2RlX3VyaVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHtPYmplY3QjdG9fc30gZW5jb2RlZCBmb3IgdXNhZ2UgYXMgVVJJXG4gIGRlZiBlbmNvZGVfdXJpXG4gICAgd2FybiBcIm9wYWwtYnJvd3NlcjogT2JqZWN0I2VuY29kZV91cmkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGb3JtRGF0YS5lbmNvZGVfdXJpXCJcbiAgICBGb3JtRGF0YS5lbmNvZGVfdXJpKHRvX3MpXG4gIGVuZFxuXG4gICMgRW5jb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICNcbiAgIyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEZvcm1EYXRhLmVuY29kZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHtPYmplY3QjdG9fc30gZW5jb2RlZCBmb3IgdXNhZ2UgYXMgVVJJIGNvbXBvbmVudFxuICBkZWYgZW5jb2RlX3VyaV9jb21wb25lbnRcbiAgICB3YXJuIFwib3BhbC1icm93c2VyOiBPYmplY3QjZW5jb2RlX3VyaV9jb21wb25lbnQgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGb3JtRGF0YS5lbmNvZGVcIlxuICAgIEZvcm1EYXRhLmVuY29kZSh0b19zKVxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgIyBFbmNvZGUgYXMgVVJJIGNvbXBvbmVudC5cbiAgI1xuICAjIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgRm9ybURhdGEuZW5jb2RlXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGVuY29kZWQgZm9yIHVzYWdlIGFzIFVSSSBjb21wb25lbnRcbiAgZGVmIGVuY29kZV91cmlfY29tcG9uZW50XG4gICAgd2FybiBcIm9wYWwtYnJvd3NlcjogU3RyaW5nI2VuY29kZV91cmlfY29tcG9uZW50IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRm9ybURhdGEuZW5jb2RlXCJcbiAgICBGb3JtRGF0YS5lbmNvZGUoc2VsZilcbiAgZW5kXG5cbiAgIyBFbmNvZGUgYXMgVVJJLlxuICAjXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBGb3JtRGF0YS5lbmNvZGVfdXJpXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGVuY29kZWQgYXMgVVJJXG4gIGRlZiBlbmNvZGVfdXJpXG4gICAgd2FybiBcIm9wYWwtYnJvd3NlcjogU3RyaW5nI2VuY29kZV91cmkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGb3JtRGF0YS5lbmNvZGVfdXJpXCJcbiAgICBGb3JtRGF0YS5lbmNvZGVfdXJpKHNlbGYpXG4gIGVuZFxuXG4gICMgRGVjb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICNcbiAgIyBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIEZvcm1EYXRhLmRlY29kZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBkZWNvZGVkIGFzIFVSSSBjb21wb25lbnRcbiAgZGVmIGRlY29kZV91cmlfY29tcG9uZW50XG4gICAgd2FybiBcIm9wYWwtYnJvd3NlcjogU3RyaW5nI2RlY29kZV91cmlfY29tcG9uZW50IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRm9ybURhdGEuZGVjb2RlXCJcbiAgICBGb3JtRGF0YS5kZWNvZGUoc2VsZilcbiAgZW5kXG5cbiAgIyBEZWNvZGUgYXMgVVJJLlxuICAjXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBGb3JtRGF0YS5kZWNvZGVfdXJpXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGRlY29kZWQgYXMgVVJJXG4gIGRlZiBkZWNvZGVfdXJpXG4gICAgd2FybiBcIm9wYWwtYnJvd3NlcjogU3RyaW5nI2RlY29kZV91cmkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGb3JtRGF0YS5kZWNvZGVfdXJpXCJcbiAgICBGb3JtRGF0YS5kZWNvZGVfdXJpKHNlbGYpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEhhc2hcbiAgIyBEZWNvZGUgYW4gVVJMIGVuY29kZWQgZm9ybSB0byBhIHtIYXNofS5cbiAgI1xuICAjIEBwYXJhbSBzdHJpbmcgW1N0cmluZ10gdGhlIFVSTCBlbmNvZGVkIGZvcm1cbiAgI1xuICAjIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgRm9ybURhdGEucGFyc2VfcXVlcnlcbiAgIyBAcmV0dXJuIFtIYXNoXVxuICBkZWYgc2VsZi5kZWNvZGVfdXJpKHN0cmluZylcbiAgICB3YXJuIFwib3BhbC1icm93c2VyOiBIYXNoLmRlY29kZV91cmkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBGb3JtRGF0YS5wYXJzZV9xdWVyeVwiXG4gICAgRm9ybURhdGEucGFyc2VfcXVlcnkoc3RyaW5nKVxuICBlbmRcblxuICAjIEVuY29kZSB0aGUgSGFzaCB0byBhbiBVUkwgZm9ybS5cbiAgI1xuICAjIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgRm9ybURhdGEuYnVpbGRfcXVlcnlcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBVUkwgZW5jb2RlZCBmb3JtXG4gIGRlZiBlbmNvZGVfdXJpXG4gICAgd2FybiBcIm9wYWwtYnJvd3NlcjogSGFzaCNlbmNvZGVfdXJpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgRm9ybURhdGEuYnVpbGRfcXVlcnlcIlxuICAgIEZvcm1EYXRhLmJ1aWxkX3F1ZXJ5KHNlbGYpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwibmV3IiwiaW5jbHVkZWQiLCJzZWxmIiwia2xhc3MiLCJpbmNsdWRlIiwiZXh0ZW5kIiwicmVzdHJpY3RlZD8iLCJAcmVzdHJpY3RlZCIsIiEiLCJzZXRfbmF0aXZlX3JlZmVyZW5jZSIsIm5hdGl2ZSQiLCJAbmF0aXZlIiwicHJpdmF0ZSIsIm9iaiIsImFsbG9jYXRlIiwiaW5zdGFuY2VfdmFyaWFibGVfc2V0IiwibmF0aXZlPyIsInJhaXNlIiwiY2xhc3MiLCJlbmNvZGVfdXJpIiwid2FybiIsInRvX3MiLCJlbmNvZGVfdXJpX2NvbXBvbmVudCIsImVuY29kZSIsImRlY29kZV91cmlfY29tcG9uZW50IiwiZGVjb2RlIiwiZGVjb2RlX3VyaSIsInBhcnNlX3F1ZXJ5Iiwic3RyaW5nIiwiYnVpbGRfcXVlcnkiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBLG9DQUFXLHNCQUFBQyxLQUFBQSxDQUFXLFNBQVEsUUFBbkJBLENBQVgsQ0FBQTtBQUFBLElBQ0Esd0NBQVcsc0JBQUFBLEtBQUFBLENBQVcsS0FBSSxHQUFmQSxDQUFYLENBREE7QUFBQSxJQWVBRDtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUUsVUFBSUMsSUFBSkQsZUFBQUEsa0NBQUFBLG9CQUFrQixLQUFsQkE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUUsS0FBQUMsU0FBQUEsQ0FBYyxJQUFBLHNCQUFBLFlBQWRBLENBQUE7QUFBQSxRQUNBLE9BQUFELEtBQUFFLFFB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Q0FBQUEsaUNBQUFBLENBQUE7QUFBQSxJQVNBLE9BQUFQLENBQUFBLDhCQUFBQSxzQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLFVBQUFDLE1BQUFBLENBQUssOEVBQUxBLENBQUE7QUFBQSxNQUNBLE9BQUEsd0JBQUFTLGFBQUFBLENBQXFCM0IsSUFBckIyQixDQURBO0FBREZWLElBQUFBLENBQUFBLGlDQUFBQSxDQUFBQSxzQkFUQTtBQVBGRCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQW5JQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3MTkzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9mb3JtX2RhdGEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXJcblxuY2xhc3MgRm9ybURhdGFcbiAgaW5jbHVkZSBOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgbW9kdWxlIENvbnZlcnRlclxuICAgICMgRW5jb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGVuY29kZWQgZm9yIHVzYWdlIGFzIFVSSSBjb21wb25lbnRcbiAgICBkZWYgZW5jb2RlKHN0cmluZylcbiAgICAgIGBlbmNvZGVVUklDb21wb25lbnQoI3tzdHJpbmd9KWBcbiAgICBlbmRcblxuICAgICMgRGVjb2RlIGFzIFVSSSBjb21wb25lbnQuXG4gICAgI1xuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgc3RyaW5nIGRlY29kZWQgYXMgVVJJIGNvbXBvbmVudFxuICAgIGRlZiBkZWNvZGUoc3RyaW5nKVxuICAgICAgYGRlY29kZVVSSUNvbXBvbmVudCgje3N0cmluZ30pYFxuICAgIGVuZFxuXG4gICAgIyBFbmNvZGUgYXMgVVJJLlxuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBlbmNvZGVkIGFzIFVSSVxuICAgIGRlZiBlbmNvZGVfdXJpKHN0cmluZylcbiAgICAgIGBlbmNvZGVVUkkoI3tzdHJpbmd9KWBcbiAgICBlbmRcblxuICAgICMgRGVjb2RlIGFzIFVSSS5cbiAgICAjXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdHJpbmcgZGVjb2RlZCBhcyBVUklcbiAgICBkZWYgZGVjb2RlX3VyaShzdHJpbmcpXG4gICAgICBgZGVjb2RlVVJJKCN7c3RyaW5nfSlgXG4gICAgZW5kXG5cbiAgICAjIEZsYXR0ZW5zIGEgaGFzaCB0byBidWlsZCBhIGZsYXQgYXJyYXksIGxhdGVyIHRvIGJlIGZvcm1hdHRlZCB0b1xuICAgICMgcHJvZHVjZSBhIG5lc3RlZCBxdWVyeS5cbiAgICAjXG4gICAgIyBUaGlzIGNvZGUgc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aCB3aGF0IFJhY2s6OlV0aWxzI2J1aWxkX25lc3RlZF9xdWVyeSBbMV1cbiAgICAjIGRvZXMuXG4gICAgI1xuICAgICMgWzFdIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWNrL3JhY2svYmxvYi9tYXN0ZXIvbGliL3JhY2svdXRpbHMucmJcbiAgICBkZWYgZmxhdHRlbih2YWx1ZSwga2V5PVwiXCIpXG4gICAgICBjYXNlIHZhbHVlXG4gICAgICB3aGVuIEhhc2hcbiAgICAgICAgb3V0ID0gW11cbiAgICAgICAgdmFsdWUuZWFjaCBkbyB8ayx2fFxuICAgICAgICAgIGsgPSBcIiN7a2V5fVsje2t9XVwiIGlmIGtleSAhPSAnJ1xuICAgICAgICAgIG91dCArPSBmbGF0dGVuKHYsaylcbiAgICAgICAgZW5kXG4gICAgICAgIG91dFxuICAgICAgd2hlbiBBcnJheVxuICAgICAgICBvdXQgPSBbXVxuICAgICAgICB2YWx1ZS5lYWNoIGRvIHx2fFxuICAgICAgICAgIGsgPSBcIiN7a2V5fVtdXCJcbiAgICAgICAgICBvdXQgKz0gZmxhdHRlbih2LGspXG4gICAgICAgIGVuZFxuICAgICAgICBvdXRcbiAgICAgIGVsc2VcbiAgICAgICAgW1trZXksdmFsdWVdXVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIENvbnZlcnRzIGEgZmxhdCBhcnJheSB0byBhIEhhc2guXG4gICAgI1xuICAgICMgVGhpcyBjb2RlIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGggd2hhdCBSYWNrOjpVdGlscyNwYXJzZV9uZXN0ZWRfcXVlcnkgWzFdXG4gICAgIyBkb2VzLlxuICAgICNcbiAgICAjIFsxXSBodHRwczovL2dpdGh1Yi5jb20vcmFjay9yYWNrL2Jsb2IvbWFzdGVyL2xpYi9yYWNrL3V0aWxzLnJiXG4gICAgZGVmIHVuZmxhdHRlbihhcnJheSlcbiAgICAgIG91dCA9IHt9XG4gICAgICBhcnJheS5lYWNoIGRvIHxrLHZ8XG4gICAgICAgIHBhdGggPSBbay5zcGxpdChcIltcIikuZmlyc3RdICsgay5zY2FuKC9cXFsoLio/KVxcXS8pLmZsYXR0ZW5cbiAgICAgICAgYyA9IG91dFxuXG4gICAgICAgIHNldCA9IHByb2MgeyB8dix3ZWFrfCB9ICMgRG8gbm90aGluZyBmb3IgdGhlIGZpcnN0IGxldmVsXG5cbiAgICAgICAgcGF0aC5lYWNoIGRvIHxpfFxuICAgICAgICAgIGNhc2UgaVxuICAgICAgICAgIHdoZW4gXCJcIiAjIEFycmF5XG4gICAgICAgICAgICBzZXQuKFtdLCB0cnVlKVxuICAgICAgICAgICAgc2V0ID0gcHJvYyBkbyB8dix3ZWFrfFxuICAgICAgICAgICAgICBjIDw8IHZcbiAgICAgICAgICAgICAgYyA9IGMubGFzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSAjIEhhc2hcbiAgICAgICAgICAgIHNldC4oe30sIHRydWUpXG4gICAgICAgICAgICBzZXQgPSBwcm9jIGRvIHx2LHdlYWt8XG4gICAgICAgICAgICAgIGNbaV0gfHw9IHZcbiAgICAgICAgICAgICAgY1tpXSA9IHYgaWYgIXdlYWtcbiAgICAgICAgICAgICAgYyA9IGNbaV1cbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgICAgc2V0Lih2LCBmYWxzZSlcblxuICAgICAgZW5kXG4gICAgICBvdXRcbiAgICBlbmRcblxuICAgICMgQ2hlY2tzIGlmIGEgcXVlcnkgSGFzaCBjb250YWlucyBhbnkgZmlsZXMuXG4gICAgZGVmIGNvbnRhaW5fZmlsZXM/KGhhc2gpXG4gICAgICBmbGF0dGVuKGhhc2gpLmFueT8geyB8ayx2fCBbRmlsZSwgQmxvYl0uaW5jbHVkZT8odi5jbGFzcykgfVxuICAgIGVuZFxuXG4gICAgIyBDb252ZXJ0IGEgcXVlcnkgSGFzaCB0byBhIHF1ZXJ5IHN0cmluZ1xuICAgICNcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHN0cmluZyBlbmNvZGVkIGFzIFVSSVxuICAgIGRlZiBidWlsZF9xdWVyeShoYXNoLCBzZXA9PyYpXG4gICAgICBmbGF0dGVuKGhhc2gpLm1hcCB7IHxrLHZ8IGVuY29kZShrKSArID89ICsgZW5jb2RlKHYudG9fcykgfS5qb2luKHNlcClcbiAgICBlbmRcblxuICAgICMgQ29udmVydCBhIHF1ZXJ5IEhhc2ggdG8gYSBGb3JtRGF0YSBpbnN0YW5jZVxuICAgICNcbiAgICAjIEByZXR1cm4gW0Zvcm1EYXRhXSB0aGUgaW5zdGFuY2Ugb2YgRm9ybURhdGFcbiAgICBkZWYgYnVpbGRfZm9ybV9kYXRhKGhhc2gpXG4gICAgICBmZCA9IEZvcm1EYXRhLmNyZWF0ZVxuICAgICAgZmxhdHRlbihoYXNoKS5lYWNoIHsgfGssdnwgZmQgPDwgW2ssdl0gfVxuICAgICAgZmRcbiAgICBlbmRcblxuICAgICMgQ29udmVydCBhIHF1ZXJ5IHN0cmluZyB0byBhIHF1ZXJ5IEhhc2hcbiAgICAjXG4gICAgIyBAcmV0dXJuIFtIYXNoXSB0aGUgcXVlcnkgaGFzaFxuICAgIGRlZiBwYXJzZV9xdWVyeShzdHJpbmcsIHNlcD0/JilcbiAgICAgIHVuZmxhdHRlbihzdHJpbmcuc3BsaXQoc2VwKS5tYXAgeyB8c3wgcy5zcGxpdCg/PSkubWFwKCZtZXRob2QoOmRlY29kZSkpIH0pXG4gICAgZW5kXG4gIGVuZFxuICBleHRlbmQgQ29udmVydGVyXG5cbiAgIyBDcmVhdGUgYSBuZXcgRm9ybURhdGEgaW5zdGFuY2VcbiAgZGVmIHNlbGYuY3JlYXRlKGhhc2g9bmlsKVxuICAgIGlmIEhhc2ggPT09IGhhc2hcbiAgICAgIEZvcm1EYXRhLmJ1aWxkX2Zvcm1fZGF0YShoYXNoKVxuICAgIGVsc2lmIERPTTo6RWxlbWVudDo6Rm9ybSA9PT0gaGFzaFxuICAgICAgbmV3KGBuZXcgRm9ybURhdGEoI3toYXNoLnRvX259KWApXG4gICAgZWxzZVxuICAgICAgbmV3KGBuZXcgRm9ybURhdGEoKWApXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQXBwZW5kIGEgdHVwbGUgdG8gdGhpcyBGb3JtRGF0YSBpbnN0YW5jZVxuICAjXG4gICMgQHBhcmFtIHR1cGxlIFtBcnJheShTdHJpbmcsIFN0cmluZyksIEFycmF5KFN0cmluZywgQmxvYiksIEFycmF5KFN0cmluZywgRmlsZSksXG4gICMgICAgICAgICAgICAgICBBcnJheShTdHJpbmcsIEJsb2IsIFN0cmluZyksIEFycmF5KFN0cmluZywgRmlsZSwgU3RyaW5nKV1cbiAgIyAgICAgICAgYSB0dXBsZSBvZiBhIGtleSwgdmFsdWUgYW5kIHBvc3NpYmx5IGEgZmlsZW5hbWVcbiAgZGVmIDw8KHR1cGxlKVxuICAgIGtleSwgdmFsdWUsIGZpbGVuYW1lID0gdHVwbGVcblxuICAgIHVubGVzcyBmaWxlbmFtZVxuICAgICAgYCNAbmF0aXZlLmFwcGVuZCgje2tleX0sICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfSlgXG4gICAgZWxzZVxuICAgICAgYCNAbmF0aXZlLmFwcGVuZCgje2tleX0sICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfSwgI3tmaWxlbmFtZX0pYFxuICAgIGVuZFxuICBlbmRcblxuICAjIEdldCBhIGZpZWxkIGZyb20gdGhpcyBGb3JtRGF0YSBpbnN0YW5jZSB3aXRoIGEgZ2l2ZW4gbmFtZVxuICBkZWYgW10oa2V5KVxuICAgIE5hdGl2ZShgI0BuYXRpdmUuZ2V0KCN7a2V5fSlgKVxuICBlbmRcblxuICAjIFNldCBhIGZpZWxkIGluIHRoaXMgRm9ybURhdGEgaW5zdGFuY2Ugd2l0aCBhIGdpdmVuIG5hbWVcbiAgZGVmIHNldChrZXksIHZhbHVlLCBmaWxlbmFtZSA9IG5pbClcbiAgICB1bmxlc3MgZmlsZW5hbWVcbiAgICAgIGAjQG5hdGl2ZS5zZXQoI3trZXl9LCAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX0pYFxuICAgIGVsc2VcbiAgICAgIGAjQG5hdGl2ZS5zZXQoI3trZXl9LCAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX0sICN7ZmlsZW5hbWV9KWBcbiAgICBlbmRcbiAgZW5kXG4gIGFsaWFzIFtdPSBzZXRcblxuICAjIENoZWNrcyBpZiBhIGZpZWxkIG9mIHRoaXMgbmFtZSBleGlzdHMgaW4gdGhpcyBGb3JtRGF0YSBpbnN0YW5jZVxuICBkZWYgaW5jbHVkZT8oa2V5KVxuICAgIGAjQG5hdGl2ZS5oYXMoI3trZXl9KWBcbiAgZW5kXG5cbiAgIyBEZWxldGUgYSBmaWVsZCBmcm9tIHRoaXMgRm9ybURhdGEgaW5zdGFuY2VcbiAgZGVmIGRlbGV0ZShrZXkpXG4gICAgYCNAbmF0aXZlLmRlbGV0ZSgje2tleX0pYFxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImluY2x1ZGUiLCJlbmNvZGUiLCJzdHJpbmciLCJkZWNvZGUiLCJlbmNvZGVfdXJpIiwiZGVjb2RlX3VyaSIsImZsYXR0ZW4iLCJ2YWx1ZSIsIm91dCIsImVhY2giLCJrZXkiLCIhPSIsImsiLCIrIiwidiIsInVuZmxhdHRlbiIsImFycmF5IiwicGF0aCIsInNwbGl0IiwiZmlyc3QiLCJzY2FuIiwiYyIsInNldCIsInByb2MiLCJpIiwiY2FsbCIsIjw8IiwibGFzdCIsIltdIiwiJHdyaXRlciIsIltdPSIsIi0iLCIxIiwid2VhayIsIiEiLCJjb250YWluX2ZpbGVzPyIsImFueT8iLCJoYXNoIiwiaW5jbHVkZT8iLCJidWlsZF9xdWVyeSIsIm1hcCIsInRvX3MiLCJqb2luIiwic2VwIiwiYnVpbGRfZm9ybV9kYXRhIiwiZmQiLCJjcmVhdGUiLCJwYXJzZV9xdWVyeSIsInMiLCJtZXRob2QiLCJleHRlbmQiLCJzZWxmIiwiPT09IiwibmV3IiwidG9fbiIsInR1cGxlIiwiZmlsZW5hbWUiLCJAbmF0aXZlIiwiY29udmVydCIsIk5hdGl2ZSIsImRlbGV0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBRUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxVQUFBQyxTQUFBQSxDQUFRLG1DQUFSQSxDQUFBO0FBQUEsTUFFQUY7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUlFO0FBQUFHLFFBQUFBLDBCQUFBQSxzQkFBQUEsa0JBQVcsTUFBWEE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQyxtQkFBcUJDLE1BQU87QUFEL0JELFFBQUFBLENBQUFBLGlDQUFBQSxDQUFBO0FBQUE7QUFPQUUsUUFBQUEsMEJBQUFBLHNCQUFBQSxrQkFBVyxNQUFYQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFDLG1CQUFxQkQsTUFBTztBQUQvQkMsUUFBQUEsQ0FBQUEsaUNBQUFBLENBUEE7QUFBQTtBQWNBQyxRQUFBQSw4QkFBQUEsMEJBQUFBLHNCQUFlLE1BQWZBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUMsVUFBWUYsTUFBTztBQUR0QkUsUUFBQUEsQ0FBQUEscUNBQUFBLENBZEE7QUFBQTtBQXFCQUMsUUFBQUEsOEJBQUFBLDBCQUFBQSxzQkFBZSxNQUFmQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFDLFVBQVlILE1BQU87QUFEdEJHLFFBQUFBLENBQUFBLHFDQUFBQSxDQXJCQTtBQUFBO0FBZ0NBQyxRQUFBQSwyQkFBQUEsdUJBQUFBLG1CQUFZLEtBQUQsRUFBUSxHQUFuQkE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBMUNKO0FBMEN1QixVQUFBO0FBQUEsVUFBQSxRQUFJLEVBQUo7QUFBQSxVQUFBLENBMUN2QjtBQUFBLFVBMkNNLE9BQUEsYUFBQSxRQUFLQyxLQUFMO0FBQUEsVUFDQSxJQUFLLG1DQUFMO0FBQ0UsVUFBQUMsTUFBTSxFQUFOO0FBQUEsVUFDQUMsTUFBQUYsS0FBQUUsUUFBQUEsRUFBQUEsRUFBQUEsRUE5Q1IsZ0JBOEN1QixDQUFELEVBQUcsQ0E5Q3pCLEVBQUE7O0FBQUE7QUFBQTtBQThDdUIsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBOUN2QjtBQUFBO0FBOEN5QixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0E5Q3pCO0FBQUEsWUErQ1UsSUFBQSxRQUFzQkMsR0FBQUMsT0FBQUEsQ0FBTyxFQUFQQSxDQUF0QixDQUFBO0FBQUEsY0FBQUMsSUFBSSxFQUFBLEdBQUEsQ0FBR0YsR0FBSCxDQUFBLEdBQUEsR0FBQSxHQUFBLENBQVVFLENBQVYsQ0FBQSxHQUFBLEdBQUosQ0EvQ1Y7QUFBQSxZQWdEVSxPQUFBSixDQUFBQSxNQWhEVkssU0FnRFVMLEdBaERWSyxNQWdEaUJQLFNBQUFBLENBQVFRLEdBQUVGLENBQVZOLENBaERqQk8sQ0FnRFVMLENBaERWLENBQUEsa0JBQUEsaUJBQUEsS0E4Q1FDLENBREE7QUFBQSxVQUtBLE9BQUFELEdBTEEsQ0FERjtBQURBLFVBQUEsS0FRQSxJQUFLLG9DQUFMO0FBQ0UsVUFBQUEsTUFBTSxFQUFOO0FBQUEsVUFDQUMsTUFBQUYsS0FBQUUsUUFBQUEsRUFBQUEsRUFBQUEsRUFyRFIsZ0JBcUR1QixDQXJEdkIsRUFBQTs7QUFBQTtBQUFBO0FBcUR1QixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0FyRHZCO0FBQUEsWUFzRFVHLElBQUksRUFBQSxHQUFBLENBQUdGLEdBQUgsQ0FBQSxHQUFBLElBdERkO0FBQUEsWUF1RFUsT0FBQUYsQ0FBQUEsTUF2RFZLLFNBdURVTCxHQXZEVkssTUF1RGlCUCxTQUFBQSxDQUFRUSxHQUFFRixDQUFWTixDQXZEakJPLENBdURVTCxDQXZEVixDQUFBLGtCQUFBLGlCQUFBLEtBcURRQyxDQURBO0FBQUEsVUFLQSxPQUFBRCxHQUxBLENBREY7QUFSQSxVQUFBLE1BZ0JFLE9BQUEsQ0FBQyxDQUFDRSxHQUFELEVBQUtILEtBQUwsQ0FBRCxDQWhCRixDQUFBLElBM0NOO0FBMENJRCxRQUFBQSxDQUFBQSxtQ0FBQUEsQ0FoQ0E7QUFBQTtBQTJEQVMsUUFBQUEsNkJBQUFBLHlCQUFBQSxxQkFBYyxLQUFkQTtBQUFBQSxVQUFBQTs7QUFBQUE7QUFDRSxVQUFBUCxNQUFNLFlBQUEsRUFBTjtBQUFBLFVBQ0FDLE1BQUFPLEtBQUFQLFFBQUFBLEVBQUFBLEVBQUFBLEVBdkVOLGdCQXVFcUIsQ0FBRCxFQUFHLENBdkV2QixFQUFBOztBQUFBO0FBQUE7QUF1RXFCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQXZFckI7QUFBQTtBQXVFdUIsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBdkV2QjtBQUFBLFlBd0VRUSxPQUFPSixTQUFBLENBQUNELENBQUFNLE9BQUFBLENBQVEsR0FBUkEsQ0FBQUMsT0FBQUEsQ0FBQUEsQ0FBRCxDQUFBTixFQUF1QkQsQ0FBQVEsTUFBQUEsQ0FBTyxXQUFQQSxDQUFBZCxTQUFBQSxDQUFBQSxDQUF2Qk8sQ0F4RWY7QUFBQSxZQXlFUVEsSUFBSWIsR0F6RVo7QUFBQSxZQTJFUWMsTUFBTUMsVUFBQUEsUUFBQUEsRUFBQUEsRUFBQUEsRUEzRWQsaUJBMkVzQixDQUFELEVBQUcsSUEzRXhCLEVBQUE7O0FBQUE7QUFBQTtBQTJFc0IsY0FBQTtBQUFBLGNBQUE7QUFBQSxjQUFBLENBM0V0QjtBQUFBO0FBMkV3QixjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0EzRXhCO0FBQUEsY0FBQSxPQUFBLEdBQUEsQ0FBQSxtQkFBQSxrQkFBQSxNQTJFY0EsQ0EzRWQ7QUFBQSxZQTZFUWQsTUFBQVEsSUFBQVIsUUFBQUEsRUFBQUEsRUFBQUEsRUE3RVIsaUJBNkVzQixDQTdFdEIsRUFBQTs7QUFBQTtBQUFBO0FBNkVzQixjQUFBO0FBQUEsY0FBQTtBQUFBLGNBQUEsQ0E3RXRCO0FBQUEsY0E4RVUsT0FBQSxhQUFBLFFBQUtlLENBQUw7QUFBQSxjQUNBLElBQUssaUJBQUw7QUFDRSxjQUFBRixHQUFBRyxNQUFBQSxDQUFLLElBQUksSUFBVEEsQ0FBQTtBQUFBLGNBQ0EsT0FBQUgsQ0FBQUEsTUFBTUMsVUFBQUEsUUFBQUEsRUFBQUEsRUFBQUEsRUFqRmxCLGlCQWlGMkIsQ0FBRCxFQUFHLElBakY3QixFQUFBOztBQUFBO0FBQUE7QUFpRjJCLGdCQUFBO0FBQUEsZ0JBQUE7QUFBQSxnQkFBQSxDQWpGM0I7QUFBQTtBQWlGNkIsZ0JBQUE7QUFBQSxnQkFBQTtBQUFBLGdCQUFBLENBakY3QjtBQUFBLGdCQWtGY0YsQ0FBQUssT0FBQUEsQ0FBS1osQ0FBTFksQ0FsRmQ7QUFBQSxnQkFtRmMsT0FBQUwsQ0FBQUEsSUFBSUEsQ0FBQU0sTUFBQUEsQ0FBQUEsQ0FBSk4sQ0FuRmQsQ0FBQSxtQkFBQSxrQkFBQSxNQWlGa0JFLENBQU5ELENBREEsQ0FERjtBQURBLGNBQUE7QUFRRSxjQUFBQSxHQUFBRyxNQUFBQSxDQUFLLFlBQUEsSUFBSSxJQUFUQSxDQUFBO0FBQUEsY0FDQSxPQUFBSCxDQUFBQSxNQUFNQyxVQUFBQSxRQUFBQSxFQUFBQSxFQUFBQSxFQXZGbEIsaUJBdUYyQixDQUFELEVBQUcsSUF2RjdCLEVBQUE7O0FBQUE7QUFBQTtBQXVGMkIsZ0JBQUE7QUFBQSxnQkFBQTtBQUFBLGdCQUFBLENBdkYzQjtBQUFBO0FBdUY2QixnQkFBQTtBQUFBLGdCQUFBO0FBQUEsZ0JBQUEsQ0F2RjdCO0FBQUEsZ0JBQUEsY0F3RmNGLENBQUFPLE9BQUFBLENBQUVKLENBQUZJLENBeEZkLFNBQUEsQ0FBQUMsQ0FBQUEsVUFBQSxDQXdGZ0JMLENBeEZoQixFQXdGdUJWLENBeEZ2QixDQUFBZSxDQUFBLEVBd0ZjQyxNQUFBVCxDQUFBUyxPQUFBQSxFQXhGZCxVQUFBRCxPQUFBLENBd0ZjQyxDQXhGZCxFQUFBRCxPQUFBLENBQUFFLFVBQUFGLE9BQUEsQ0FBQSxRQUFBLENBQUFFLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQUFBLENBQUE7QUFBQSxnQkF5RmMsSUFBQSxRQUFhRSxJQUFEQyxNQUFBQSxDQUFBQSxDQUFaLENBQUE7QUFBQTtBQXpGZCxrQkFBQUwsVUFBQSxDQXlGZ0JMLENBekZoQixFQXlGcUJWLENBekZyQixDQUFBO0FBQUEsa0JBeUZjZ0IsTUFBQVQsQ0FBQVMsT0FBQUEsRUF6RmQsVUFBQUQsT0FBQSxDQXlGY0MsQ0F6RmQ7QUFBQSxrQkFBQUQsT0FBQSxDQUFBRSxVQUFBRixPQUFBLENBQUEsUUFBQSxDQUFBRSxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0F5RmMsQ0F6RmQ7QUFBQSxnQkEwRmMsT0FBQVYsQ0FBQUEsSUFBSUEsQ0FBQU8sT0FBQUEsQ0FBRUosQ0FBRkksQ0FBSlAsQ0ExRmQsQ0FBQSxtQkFBQSxrQkFBQSxNQXVGa0JFLENBQU5ELENBREEsQ0FSRixDQUFBLElBOUVWLENBQUEsbUJBQUEsa0JBQUEsTUE2RVFiLENBN0VSO0FBQUEsWUE4RlEsT0FBQWEsR0FBQUcsTUFBQUEsQ0FBS1gsR0FBRyxLQUFSVyxDQTlGUixDQUFBLGtCQUFBLGlCQUFBLEtBdUVNaEIsQ0FEQTtBQUFBLFVBMkJBLE9BQUFELEdBM0JBO0FBREZPLFFBQUFBLENBQUFBLG9DQUFBQSxDQTNEQTtBQUFBO0FBMkZBb0IsUUFBQUEsa0NBQUFBLG1DQUFBQSxTQUFtQixJQUFuQkE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQUMsVUFBQTlCLFNBQUFBLENBQVErQixJQUFSL0IsQ0FBQThCLFFBQUFBLEVBQUFBLEVBQUFBLEVBdEdOLGlCQXNHNEIsQ0FBRCxFQUFHLENBdEc5QixFQUFBOztBQUFBO0FBQUE7QUFzRzRCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQXRHNUI7QUFBQTtBQXNHOEIsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBdEc5QjtBQUFBLFlBc0dpQyxPQUFBLENBQUMsb0JBQUQsRUFBTyxvQkFBUCxDQUFBRSxhQUFBQSxDQUFzQnhCLENBQUFmLE9BQUFBLENBQUFBLENBQXRCdUMsQ0F0R2pDLENBQUEsbUJBQUEsa0JBQUEsTUFzR01GO0FBREZELFFBQUFBLENBQUFBLDhDQUFBQSxDQTNGQTtBQUFBO0FBa0dBSSxRQUFBQSwrQkFBQUEsNEJBQUFBLHVCQUFnQixJQUFELEVBQU8sR0FBdEJBO0FBQUFBLFVBQUFBOztBQUFBQTtBQTVHSjtBQTRHMEIsVUFBQTtBQUFBLFVBQUEsUUFBSSxHQUFKO0FBQUEsVUFBQSxDQTVHMUI7QUFBQSxVQTZHTSxPQUFBQyxVQUFBbEMsU0FBQUEsQ0FBUStCLElBQVIvQixDQUFBa0MsT0FBQUEsRUFBQUEsRUFBQUEsRUE3R04saUJBNkcyQixDQUFELEVBQUcsQ0E3RzdCLEVBQUE7O0FBQUE7QUFBQTtBQTZHMkIsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBN0czQjtBQUFBO0FBNkc2QixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0E3RzdCO0FBQUEsWUE2R2dDLE9BQUEzQixTQUFBQSxhQUFBWixRQUFBQSxDQUFPVyxDQUFQWCxDQUFBWSxFQUFZLEdBQVpBLENBQUFBLE1BQWlCWixRQUFBQSxDQUFPYSxDQUFBMkIsTUFBQUEsQ0FBQUEsQ0FBUHhDLENBQWpCWSxDQTdHaEMsQ0FBQSxtQkFBQSxrQkFBQSxNQTZHTTJCLENBQUFFLE1BQUFBLENBQWlFQyxHQUFqRUQsQ0E3R047QUE0R0lILFFBQUFBLENBQUFBLHdDQUFBQSxDQWxHQTtBQUFBO0FBeUdBSyxRQUFBQSxtQ0FBQUEsZ0NBQUFBLDJCQUFvQixJQUFwQkE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUMsS0FBSyx3QkFBQUMsUUFBQUEsQ0FBQUEsQ0FBTDtBQUFBLFVBQ0FyQyxVQUFBSCxTQUFBQSxDQUFRK0IsSUFBUi9CLENBQUFHLFFBQUFBLEVBQUFBLEVBQUFBLEVBckhOLGlCQXFINEIsQ0FBRCxFQUFHLENBckg5QixFQUFBOztBQUFBO0FBQUE7QUFxSDRCLFlBQUE7QUFBQSxZQUFBO0FBQUEsWUFBQSxDQXJINUI7QUFBQTtBQXFIOEIsWUFBQTtBQUFBLFlBQUE7QUFBQSxZQUFBLENBckg5QjtBQUFBLFlBcUhpQyxPQUFBb0MsRUFBQW5CLE9BQUFBLENBQU0sQ0FBQ2QsQ0FBRCxFQUFHRSxDQUFILENBQU5ZLENBckhqQyxDQUFBLG1CQUFBLGtCQUFBLE1BcUhNakIsQ0FEQTtBQUFBLFVBRUEsT0FBQW9DLEVBRkE7QUFERkQsUUFBQUEsQ0FBQUEsMkNBQUFBLENBekdBO0FBQUE7QUFrSEFHLFFBQUFBLCtCQUFBQSw0QkFBQUEsdUJBQWdCLE1BQUQsRUFBUyxHQUF4QkE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBNUhKO0FBNEg0QixVQUFBO0FBQUEsVUFBQSxRQUFJLEdBQUo7QUFBQSxVQUFBLENBNUg1QjtBQUFBLFVBNkhNLFdBQUFoQyxXQUFBQSxDQUFVeUIsTUFBQXRDLE1BQUFnQixPQUFBQSxDQUFheUIsR0FBYnpCLENBQUFzQixPQUFBQSxFQUFBQSxFQUFBQSxFQTdIaEIsaUJBNkh5QyxDQTdIekMsRUFBQTs7QUFBQTtBQUFBO0FBNkh5QyxZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0E3SHpDO0FBQUEsWUE2SDRDLE9BQUFBLE1BQUFRLENBQUE5QixPQUFBQSxDQUFRLEdBQVJBLENBQUFzQixPQUFBQSxFQUFBQSxFQUFBQSxNQUFpQlMsUUFBQUEsQ0FBTyxRQUFQQSxZQUFqQlQsQ0E3SDVDLENBQUEsbUJBQUEsa0JBQUEsTUE2SGdCQSxDQUFWekIsQ0E3SE47QUE0SElnQyxRQUFBQSxDQUFBQSx3Q0FBQUEsQ0FsSEE7QUFKRmpELE1BQUFBLEdBQUFBLFdBQUFBLFdBRkE7QUFBQSxVQTRIQW9ELFFBQUFBLENBQU8seUJBQVBBLENBNUhBO0FBQUEsTUErSEFKLFVBQUlLLElBQUpMLGFBQUFBLHNCQUFBQSxrQkFBZ0IsSUFBaEJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQW5JRjtBQW1Ja0IsUUFBQTtBQUFBLFFBQUEsU0FBSyxHQUFMO0FBQUEsUUFBQSxDQW5JbEI7QUFBQSxRQW9JSSxJQUFBLFFBQUcsb0JBQUFNLFFBQUFBLENBQVNmLElBQVRlLENBQUgsQ0FBQTtBQUFBLFVBQ0UsT0FBQSx3QkFBQVIsaUJBQUFBLENBQXlCUCxJQUF6Qk87QUFERixRQUFBLE9BRUEsSUFBQSxRQUFNLElBQUEsSUFBQSxtQkFBQSxZQUFBLFNBQUFRLFFBQUFBLENBQXVCZixJQUF2QmUsQ0FBTixDQUFBO0FBQUEsVUFDRSxXQUFBQyxLQUFBQSxDQUFLLGFBQWVoQixJQUFBaUIsTUFBQUEsQ0FBQUEsQ0FBVSxDQUE5QkQ7QUFERixRQUFBO0FBQUEsVUFHRSxXQUFBQSxLQUFBQSxDQUFLLGNBQUxBO0FBSEYsUUFBQSxDQXRJSjtBQW1JRVAsTUFBQUEsQ0FBQUEsa0NBQUFBLENBL0hBO0FBQUE7QUE4SUFwQixNQUFBQSxzQkFBQUEsc0JBQUFBLFNBQU8sS0FBUEE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQSxLQUF1QjZCLEtBQXZCLHNCQUFBLEVBQUE3QyxDQUFBQSxtQ0FBQUEsQ0FBQSxFQUFLSCxDQUFBQSxxQ0FBQUEsQ0FBTCxFQUFZaUQsQ0FBQUEsd0NBQUFBLENBQVosSUFBQTtBQUFBLFFBRUEsSUFBQSxRQUFPQSxRQUFQLENBQUE7QUFBQSxVQUdFLE9BQUVDLGNBQU8sUUFBVS9DLEdBQUksRUFBSSxzQkFBQWdELFNBQUFBLENBQWVuRCxLQUFmbUQsQ0FBc0IsRUFBSUYsUUFBUztBQUhoRSxRQUFBO0FBQUEsVUFDRSxPQUFFQyxjQUFPLFFBQVUvQyxHQUFJLEVBQUksc0JBQUFnRCxTQUFBQSxDQUFlbkQsS0FBZm1ELENBQXNCO0FBRG5ELFFBQUEsQ0FGQTtBQURGaEMsTUFBQUEsQ0FBQUEsaUNBQUFBLENBOUlBO0FBQUE7QUF5SkFFLE1BQUFBLHNCQUFBQSxrQkFBQUEsU0FBTyxHQUFQQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxXQUFBK0IsUUFBQUEsQ0FBU0YsY0FBTyxLQUFPL0MsR0FBSSxDQUEzQmlEO0FBREYvQixNQUFBQSxDQUFBQSw2QkFBQUEsQ0F6SkE7QUFBQTtBQThKQU4sTUFBQUEsdUJBQUFBLG1CQUFBQSxlQUFRLEdBQUQsRUFBTSxLQUFOLEVBQWEsUUFBcEJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQWxLRjtBQWtLc0IsUUFBQTtBQUFBLFFBQUEsYUFBVyxHQUFYO0FBQUEsUUFBQSxDQWxLdEI7QUFBQSxRQW1LSSxJQUFBLFFBQU9rQyxRQUFQLENBQUE7QUFBQSxVQUdFLE9BQUVDLGNBQU8sS0FBTy9DLEdBQUksRUFBSSxzQkFBQWdELFNBQUFBLENBQWVuRCxLQUFmbUQsQ0FBc0IsRUFBSUYsUUFBUztBQUg3RCxRQUFBO0FBQUEsVUFDRSxPQUFFQyxjQUFPLEtBQU8vQyxHQUFJLEVBQUksc0JBQUFnRCxTQUFBQSxDQUFlbkQsS0FBZm1ELENBQXNCO0FBRGhELFFBQUEsQ0FuS0o7QUFrS0VwQyxNQUFBQSxDQUFBQSwrQkFBQUEsQ0E5SkE7QUFBQSxNQXFLQSxpQkFBTSxLQUFOLEVBQVUsS0FBVixDQXJLQTtBQUFBO0FBd0tBZ0IsTUFBQUEsNEJBQUFBLDRCQUFBQSxTQUFhLEdBQWJBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLE9BQUVtQixjQUFPLEtBQU8vQyxHQUFJO0FBRHRCNEIsTUFBQUEsQ0FBQUEsdUNBQUFBLENBeEtBO0FBQUEsTUE2S0EsT0FBQXNCLENBQUFBLDBCQUFBQSxzQkFBQUEsU0FBVyxHQUFYQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFFSCxjQUFPLFFBQVUvQyxHQUFJO0FBRHpCa0QsTUFBQUEsQ0FBQUEsaUNBQUFBLENBQUFBLGtCQTdLQTtBQURGN0QsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGQUQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzUwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvc3VwcG9ydC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFRoZSBlbmdpbmUgdGhlIGJyb3dzZXIgaXMgcnVubmluZyBvbi5cbiNcbiMgS2VlcCBpbiBtaW5kIGl0IHVzZXMgdGhlIHVzZXIgYWdlbnQgdG8ga25vdywgc28gaXQncyBub3QgcmVsaWFibGUgaW4gY2FzZSBvZlxuIyBzcG9vZmluZy5cbkJST1dTRVJfRU5HSU5FID0gYC9NU0lFfFdlYktpdHxQcmVzdG98R2Vja28vLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMF1gLmRvd25jYXNlIHJlc2N1ZSA6dW5rbm93blxuXG5tb2R1bGUgQnJvd3NlclxuICAjIEBwcml2YXRlXG4gIEBzdXBwb3J0ID0gYHt9YFxuXG4gICMgQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGdpdmVuIGZlYXR1cmUuXG4gIGRlZiBzZWxmLnN1cHBvcnRzPyhmZWF0dXJlKVxuICAgIGlmIGRlZmluZWQ/KGAjQHN1cHBvcnRbI3tmZWF0dXJlfV1gKVxuICAgICAgcmV0dXJuIGAjQHN1cHBvcnRbI3tmZWF0dXJlfV1gXG4gICAgZW5kXG5cbiAgICBzdXBwb3J0ID0gY2FzZSBmZWF0dXJlXG4gICAgICB3aGVuICdNdXRhdGlvbk9ic2VydmVyJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXJgKVxuXG4gICAgICB3aGVuICdXZWJTb2NrZXQnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuV2ViU29ja2V0YClcblxuICAgICAgd2hlbiAnRXZlbnRTb3VyY2UnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuRXZlbnRTb3VyY2VgKVxuXG4gICAgICB3aGVuICdYSFInXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuWE1MSHR0cFJlcXVlc3RgKVxuXG4gICAgICB3aGVuICdBY3RpdmVYJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LkFjdGl2ZVhPYmplY3RgKVxuXG4gICAgICB3aGVuICdXZWJTUUwnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cub3BlbkRhdGFiYXNlYClcblxuICAgICAgd2hlbiAnUXVlcnkuY3NzJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbGApXG5cbiAgICAgIHdoZW4gJ1F1ZXJ5LnhwYXRoJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZXZhbHVhdGVgKVxuXG4gICAgICB3aGVuICdTdG9yYWdlLmxvY2FsJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LmxvY2FsU3RvcmFnZWApXG5cbiAgICAgIHdoZW4gJ1N0b3JhZ2UuZ2xvYmFsJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lmdsb2JhbFN0b3JhZ2VgKVxuXG4gICAgICB3aGVuICdTdG9yYWdlLnNlc3Npb24nXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuc2Vzc2lvblN0b3JhZ2VgKVxuXG4gICAgICB3aGVuICdJbW1lZGlhdGUnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cuc2V0SW1tZWRpYXRlYClcblxuICAgICAgd2hlbiAnSW1tZWRpYXRlIChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cubXNTZXRJbW1lZGlhdGVgKVxuXG4gICAgICB3aGVuICdJbW1lZGlhdGUgKEZpcmVmb3gpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1velNldEltbWVkaWF0ZWApXG5cbiAgICAgIHdoZW4gJ0ltbWVkaWF0ZSAoT3BlcmEpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm9TZXRJbW1lZGlhdGVgKVxuXG4gICAgICB3aGVuICdJbW1lZGlhdGUgKENocm9tZSknLCAnc2V0SW1tZWRpYXRlIChTYWZhcmkpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LndlYmtpdFNldEltbWVkaWF0ZWApXG5cbiAgICAgIHdoZW4gJ0NTUy5jb21wdXRlZCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYClcblxuICAgICAgd2hlbiAnQ1NTLmN1cnJlbnQnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY3VycmVudFN0eWxlYClcblxuICAgICAgd2hlbiAnV2luZG93LnNlbmQnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cucG9zdE1lc3NhZ2VgKVxuXG4gICAgICB3aGVuICdXaW5kb3cuc2VuZCAoQXN5bmNocm9ub3VzKSdcbiAgICAgICAgaWYgZGVmaW5lZD8oYHdpbmRvdy5wb3N0TWVzc2FnZWApICYmICFkZWZpbmVkPyhgd2luZG93LmltcG9ydFNjcmlwdHNgKVxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIG9rICA9IHRydWUsXG4gICAgICAgICAgICAgICAgb2xkID0gd2luZG93Lm9ubWVzc2FnZTtcblxuICAgICAgICAgICAgd2luZG93Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyBvayA9IGZhbHNlOyB9O1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKVxuICAgICAgICAgICAgd2luZG93Lm9ubWVzc2FnZSA9IG9sZDtcblxuICAgICAgICAgICAgcmV0dXJuIG9rO1xuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG5cbiAgICAgIHdoZW4gJ1dpbmRvdy5zZW5kIChTeW5jaHJvbm91cyknXG4gICAgICAgICFzdXBwb3J0cz8oJ1dpbmRvdy5zZW5kIChBc3luY2hyb25vdXMpJylcblxuICAgICAgd2hlbiAnV2luZG93LmlubmVyU2l6ZSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5pbm5lckhlaWdodGApXG5cbiAgICAgIHdoZW4gJ1dpbmRvdy5vdXRlclNpemUnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cub3V0ZXJIZWlnaHRgKVxuXG4gICAgICB3aGVuICdXaW5kb3cuc2Nyb2xsJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRgKVxuXG4gICAgICB3aGVuICdXaW5kb3cuc2Nyb2xsQnknXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsQnlgKVxuXG4gICAgICB3aGVuICdXaW5kb3cucGFnZU9mZnNldCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5wYWdlWE9mZnNldGApXG5cbiAgICAgIHdoZW4gJ0F0dHIuaXNJZCdcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdpZCcsICd4eHh4eHh4eHh4eHh4Jyk7XG5cbiAgICAgICAgICByZXR1cm4gdHlwZW9mKGRpdi5hdHRyaWJ1dGVzWydpZCddLmlzSWQpICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuYWRkQmVoYXZpb3InXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkQmVoYXZpb3JgKVxuXG4gICAgICB3aGVuICdFbGVtZW50LmNsYXNzTmFtZSdcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzTmFtZScsICd4Jyk7XG5cbiAgICAgICAgICByZXR1cm4gZGl2LmNsYXNzTmFtZSA9PT0gJ3gnO1xuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuY2xhc3MnXG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICd4Jyk7XG5cbiAgICAgICAgICByZXR1cm4gZGl2LmNsYXNzTmFtZSA9PT0gJ3gnO1xuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuZm9yJ1xuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgJ3gnKTtcblxuICAgICAgICAgIHJldHVybiBsYWJlbC5odG1sRm9yID09PSAneCc7XG4gICAgICAgIH1cblxuICAgICAgd2hlbiAnRWxlbWVudC5odG1sRm9yJ1xuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnaHRtbEZvcicsICd4Jyk7XG5cbiAgICAgICAgICByZXR1cm4gbGFiZWwuaHRtbEZvciA9PT0gJ3gnO1xuICAgICAgICB9XG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuY2xpZW50U2l6ZSdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRgKVxuXG4gICAgICB3aGVuICdFbGVtZW50LnNjcm9sbCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0YClcblxuICAgICAgd2hlbiAnRWxlbWVudC50ZXh0Q29udGVudCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC50ZXh0Q29udGVudGApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuaW5uZXJUZXh0J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmlubmVyVGV4dGApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQubWF0Y2hlcydcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5tYXRjaGVzYClcblxuICAgICAgd2hlbiAnRWxlbWVudC5tYXRjaGVzIChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3JgKVxuXG4gICAgICB3aGVuICdFbGVtZW50Lm1hdGNoZXMgKEZpcmVmb3gpJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvcmApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQubWF0Y2hlcyAoT3BlcmEpJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9NYXRjaGVzU2VsZWN0b3JgKVxuXG4gICAgICB3aGVuICdFbGVtZW50Lm1hdGNoZXMgKENocm9tZSknLCAnRWxlbWVudC5tYXRjaGVzIChTYWZhcmkpJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvcmApXG5cbiAgICAgIHdoZW4gJ0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LnJlYWR5c3RhdGVjaGFuZ2UnXG4gICAgICAgIGBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpYFxuXG4gICAgICB3aGVuICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBgbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKWBcblxuICAgICAgICAgIHRydWVcbiAgICAgICAgcmVzY3VlIFN0YW5kYXJkRXJyb3IsIEpTOjpFcnJvclxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIGVuZFxuXG4gICAgICB3aGVuICdFdmVudC5jcmVhdGUnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5jcmVhdGVFdmVudGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmNyZWF0ZU9iamVjdCdcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0YClcblxuICAgICAgd2hlbiAnRXZlbnQuYWRkTGlzdGVuZXInXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyYClcblxuICAgICAgd2hlbiAnRXZlbnQuYXR0YWNoJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuYXR0YWNoRXZlbnRgKVxuXG4gICAgICB3aGVuICdFdmVudC5yZW1vdmVMaXN0ZW5lcidcbiAgICAgICAgZGVmaW5lZD8oYGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXJgKVxuXG4gICAgICB3aGVuICdFdmVudC5kZXRhY2gnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5kZXRhY2hFdmVudGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmRpc3BhdGNoJ1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudGApXG5cbiAgICAgIHdoZW4gJ0V2ZW50LmZpcmUnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5maXJlRXZlbnRgKVxuXG4gICAgICB3aGVuIC9eRXZlbnRcXC4oW0EtWl0uKj8pJC9cbiAgICAgICAgYCgjeyQxfSArIFwiRXZlbnRcIikgaW4gd2luZG93YFxuXG4gICAgICB3aGVuICdEb2N1bWVudC52aWV3J1xuICAgICAgICBkZWZpbmVkPyhgZG9jdW1lbnQuZGVmYXVsdFZpZXdgKVxuXG4gICAgICB3aGVuICdEb2N1bWVudC53aW5kb3cnXG4gICAgICAgIGRlZmluZWQ/KGBkb2N1bWVudC5wYXJlbnRXaW5kb3dgKVxuXG4gICAgICB3aGVuICdIaXN0b3J5J1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlYClcblxuICAgICAgd2hlbiAnSGlzdG9yeS5zdGF0ZSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5oaXN0b3J5LnN0YXRlYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLnJlcXVlc3QnXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLnJlcXVlc3QgKEludGVybmV0IEV4cGxvcmVyKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5yZXF1ZXN0IChGaXJlZm94KSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24ucmVxdWVzdCAoT3BlcmEpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24ucmVxdWVzdCAoQ2hyb21lKScsICdBbmltYXRpb24ucmVxdWVzdCAoU2FmYXJpKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLmNhbmNlbCAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsIChGaXJlZm94KSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWwgKE9wZXJhKSdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsIChDaHJvbWUpJywgJ0FuaW1hdGlvbi5jYW5jZWwgKFNhZmFyaSknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsUmVxdWVzdCdcbiAgICAgICAgZGVmaW5lZD8oYHdpbmRvdy5jYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKVxuXG4gICAgICB3aGVuICdBbmltYXRpb24uY2FuY2VsUmVxdWVzdCAoSW50ZXJuZXQgRXhwbG9yZXIpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1zQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lYClcblxuICAgICAgd2hlbiAnQW5pbWF0aW9uLmNhbmNlbFJlcXVlc3QgKEZpcmVmb3gpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChPcGVyYSknXG4gICAgICAgIGRlZmluZWQ/KGB3aW5kb3cub0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChDaHJvbWUpJywgJ0FuaW1hdGlvbi5jYW5jZWxSZXF1ZXN0IChTYWZhcmkpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZWApXG5cbiAgICAgIHdoZW4gJ0F1ZGlvJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LkF1ZGlvQ29udGV4dGApXG5cbiAgICAgIHdoZW4gJ0F1ZGlvIChTYWZhcmkpJywgJ0F1ZGlvIChDaHJvbWUpJ1xuICAgICAgICBkZWZpbmVkPyhgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dGApXG4gICAgZW5kXG5cbiAgICBgI0BzdXBwb3J0WyN7ZmVhdHVyZX1dID0gI3tzdXBwb3J0fWBcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgZ2l2ZW4gcG9seWZpbGwgaXMgbG9hZGVkLlxuICBkZWYgc2VsZi5sb2FkZWQ/KG5hbWUpXG4gICAgY2FzZSBuYW1lXG4gICAgd2hlbiAnU2l6emxlJ1xuICAgICAgZGVmaW5lZD8oYHdpbmRvdy5TaXp6bGVgKVxuXG4gICAgd2hlbiAnd2lja2VkLWdvb2QteHBhdGgnXG4gICAgICBkZWZpbmVkPyhgd2luZG93LndneHBhdGhgKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImRvd25jYXNlIiwibW9kdWxlIiwiQHN1cHBvcnQiLCJzdXBwb3J0cz8iLCJzZWxmIiwiZmVhdHVyZSIsInN1cHBvcnQiLCIhIiwibG9hZGVkPyIsIm5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUlBLEVBQUEsOENBQWlCLGNBQUE7QUFBQSxJQUFBLE9BQUEsQ0FBQyx1REFBRCxDQUFBQSxVQUFBQSxDQUFBQTtBQUFBLEVBQUE7QUFBQSxJQUFtRSxxREFBQTtBQUFBLE1BQUE7QUFBQSxRQUFPLE9BQUE7QUFBUCxNQUFBO0FBQUEsSUFBQSxDQUFuRTtBQUFBLEVBQUEsQ0FBQSxJQUFqQixDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBRUUsSUFBQUMsZUFBWSxFQUFaO0FBQUEsSUFHQUMsVUFBSUMsSUFBSkQsZ0JBQUFBLDJCQUFBQSxTQUFtQixPQUFuQkE7QUFBQUEsTUFBQUE7QUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFBLFFBQUcsUUFBV0QsWUFBUSxDQUFHRyxPQUFRLENBQTlCLGtCQUFILENBQUE7QUFBQSxRQUNFLE9BQVNILFlBQVEsQ0FBR0csT0FBUSxDQUQ5QixDQUFBO0FBQUEsTUFJQUMsVUFBVSxhQUFBLFFBQUtELE9BQUw7QUFBQSxNQUNSLElBQUssaUNBQUwsR0FDRSxPQUFBLFFBQVUsdUJBQVYsa0JBREY7QUFEUSxNQUFBLEtBSVIsSUFBSywwQkFBTCxHQUNFLE9BQUEsUUFBVSxnQkFBVixrQkFERjtBQUpRLE1BQUEsS0FPUixJQUFLLDRCQUFMLEdBQ0UsT0FBQSxRQUFVLGtCQUFWLGtCQURGO0FBUFEsTUFBQSxLQVVSLElBQUssb0JBQUwsR0FDRSxPQUFBLFFBQVUscUJBQVYsa0JBREY7QUFWUSxNQUFBLEtBYVIsSUFBSyx3QkFBTCxHQUNFLE9BQUEsUUFBVSxvQkFBVixrQkFERjtBQWJRLE1B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QUEsQ0F0UkE7QUFGRlAsRUFBQUEsR0FBQUEsV0FBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3Njc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyXG5cbmNsYXNzIEV2ZW50XG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0V2ZW50cy9DcmVhdGluZ19hbmRfdHJpZ2dlcmluZ19ldmVudHNcbiAgY2xhc3MgRGVmaW5pdGlvblxuICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAjIEBwcml2YXRlXG4gICAgZGVmIHNlbGYubmV3KCZibG9jaylcbiAgICAgIGRhdGEgPSBzdXBlcihgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH1gKVxuICAgICAgYmxvY2suY2FsbChkYXRhKSBpZiBibG9ja1xuXG4gICAgICBkYXRhLnRvX25cbiAgICBlbmRcblxuICAgICMgU2V0IHRoZSBldmVudCBhcyBidWJibGluZy5cbiAgICBkZWYgYnViYmxlcz0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYnViYmxlcyA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgIyBTZXQgdGhlIGV2ZW50IGFzIGNhbmNlbGFibGUuXG4gICAgZGVmIGNhbmNlbGFibGU9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmNhbmNlbGFibGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIFRhcmdldFxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgc2VsZi5jb252ZXJ0ZXJzXG4gICAgICBAY29udmVydGVycyB8fD0gW11cbiAgICBlbmRcblxuICAgICMgQHByaXZhdGVcbiAgICBkZWYgc2VsZi5yZWdpc3RlcigmYmxvY2spXG4gICAgICBjb252ZXJ0ZXJzIDw8IGJsb2NrXG4gICAgZW5kXG5cbiAgICAjIEBwcml2YXRlXG4gICAgZGVmIHNlbGYuY29udmVydCh2YWx1ZSlcbiAgICAgIHJldHVybiB2YWx1ZSB1bmxlc3MgbmF0aXZlPyh2YWx1ZSlcblxuICAgICAgY29udmVydGVycy5lYWNoIHt8YmxvY2t8XG4gICAgICAgIGlmIHJlc3VsdCA9IGJsb2NrLmNhbGwodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBlbmRcbiAgICAgIH1cblxuICAgICAgbmlsXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5pbmNsdWRlZChrbGFzcylcbiAgICAgIGtsYXNzLmluc3RhbmNlX2V2YWwge1xuICAgICAgICBkZWYgc2VsZi50YXJnZXQoJmJsb2NrKVxuICAgICAgICAgIEV2ZW50OjpUYXJnZXQucmVnaXN0ZXIoJmJsb2NrKVxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGNsYXNzIENhbGxiYWNrXG4gICAgICBhdHRyX3JlYWRlciA6dGFyZ2V0LCA6bmFtZSwgOnNlbGVjdG9yXG5cbiAgICAgICMgQHByaXZhdGVcbiAgICAgIGRlZiBpbml0aWFsaXplKHRhcmdldCwgbmFtZSwgc2VsZWN0b3IgPSBuaWwsICZibG9jaylcbiAgICAgICAgQHRhcmdldCAgID0gdGFyZ2V0XG4gICAgICAgIEBuYW1lICAgICA9IG5hbWVcbiAgICAgICAgQHNlbGVjdG9yID0gc2VsZWN0b3JcbiAgICAgICAgQGJsb2NrICAgID0gYmxvY2tcbiAgICAgIGVuZFxuXG4gICAgICAjIENhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIGdpdmVuIGV2ZW50LlxuICAgICAgI1xuICAgICAgIyBAcGFyYW0gZXZlbnQgW25hdGl2ZV0gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcbiAgICAgIGRlZiBjYWxsKGV2ZW50KVxuICAgICAgICB0b19wcm9jLmNhbGwoZXZlbnQpXG4gICAgICBlbmRcblxuICAgICAgIyBHZXQgdGhlIG5hdGl2ZSBmdW5jdGlvbiBsaW5rZWQgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgZGVmIHRvX3Byb2NcbiAgICAgICAgQHByb2MgfHw9IC0+IGV2ZW50IHtcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gc2VsZi50YXJnZXQubmF0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2ZW50ID0gRXZlbnQubmV3KGV2ZW50LCBzZWxmKVxuXG4gICAgICAgICAgdW5sZXNzIGV2ZW50LnN0b3BwZWQ/XG4gICAgICAgICAgICBAYmxvY2suY2FsbChldmVudCwgKmV2ZW50LmFyZ3VtZW50cylcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgICFldmVudC5wcmV2ZW50ZWQ/XG4gICAgICAgIH1cbiAgICAgIGVuZFxuXG4gICAgICAjIEAhYXR0cmlidXRlIFtyXSBldmVudFxuICAgICAgIyBAcmV0dXJuIFtDbGFzc10gdGhlIGNsYXNzIGZvciB0aGUgZXZlbnRcbiAgICAgIGRlZiBldmVudFxuICAgICAgICBFdmVudC5jbGFzc19mb3IoQG5hbWUpXG4gICAgICBlbmRcblxuICAgICAgIyBTdG9wIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IGxpbmtlZCB0byB0aGUgY2FsbGJhY2suXG4gICAgICBkZWYgb2ZmXG4gICAgICAgIHRhcmdldC5vZmYoc2VsZilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY2xhc3MgRGVsZWdhdGVcbiAgICAgIGRlZiBpbml0aWFsaXplKHRhcmdldCwgbmFtZSwgcGFpcilcbiAgICAgICAgQHRhcmdldCA9IHRhcmdldFxuICAgICAgICBAbmFtZSAgID0gbmFtZVxuICAgICAgICBAcGFpciAgID0gcGFpclxuICAgICAgZW5kXG5cbiAgICAgICMgU3RvcCBsaXN0ZW5pbmcgZm9yIHRoZSBldmVudCBsaW5rZWQgdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgZGVmIG9mZlxuICAgICAgICBkZWxlZ2F0ZSA9IEB0YXJnZXQuZGVsZWdhdGVkW0BuYW1lXVxuICAgICAgICBkZWxlZ2F0ZS5sYXN0LmRlbGV0ZShAcGFpcilcblxuICAgICAgICBpZiBkZWxlZ2F0ZS5sYXN0LmVtcHR5P1xuICAgICAgICAgIGRlbGVnYXRlLmZpcnN0Lm9mZlxuICAgICAgICAgIGRlbGVnYXRlLmRlbGV0ZShAbmFtZSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIERlbGVnYXRlcyA9IFN0cnVjdC5uZXcoOmNhbGxiYWNrLCA6aGFuZGxlcnMpXG5cbiAgICAjIEBvdmVybG9hZCBvbihuYW1lLCAmYmxvY2spXG4gICAgI1xuICAgICMgICBTdGFydCBsaXN0ZW5pbmcgZm9yIGFuIGV2ZW50IG9uIHRoZSB0YXJnZXQuXG4gICAgI1xuICAgICMgICBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZVxuICAgICNcbiAgICAjICAgQHlpZWxkcGFyYW0gZXZlbnQgW0V2ZW50XSB0aGUgZXZlbnRcbiAgICAjXG4gICAgIyAgIEByZXR1cm4gW0NhbGxiYWNrXVxuICAgICNcbiAgICAjIEBvdmVybG9hZCBvbihuYW1lLCBzZWxlY3RvciwgJmJsb2NrKVxuICAgICNcbiAgICAjICAgU3RhcnQgbGlzdGVuaW5nIGZvciBhbiBldmVudCBvbiB0aGUgdGFyZ2V0IGNoaWxkcmVuLlxuICAgICNcbiAgICAjICAgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWVcbiAgICAjICAgQHBhcmFtIHNlbGVjdG9yIFtTdHJpbmddIHRoZSBDU1Mgc2VsZWN0b3IgdG8gdHJpZ2dlciB0aGUgZXZlbnQgb25cbiAgICAjXG4gICAgIyAgIEB5aWVsZHBhcmFtIGV2ZW50IFtFdmVudF0gdGhlIGV2ZW50XG4gICAgI1xuICAgICMgICBAcmV0dXJuIFtEZWxlZ2F0ZV1cbiAgICBkZWYgb24obmFtZSwgc2VsZWN0b3IgPSBuaWwsICZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBoYXMgYmVlbiBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIG5hbWUgPSBFdmVudC5uYW1lX2ZvcihuYW1lKVxuXG4gICAgICBpZiBzZWxlY3RvclxuICAgICAgICB1bmxlc3MgZGVsZWdhdGUgPSBkZWxlZ2F0ZWRbbmFtZV1cbiAgICAgICAgICBkZWxlZ2F0ZSA9IGRlbGVnYXRlZFtuYW1lXSA9IERlbGVnYXRlcy5uZXdcblxuICAgICAgICAgIGlmICV3W2JsdXIgZm9jdXNdLmluY2x1ZGU/KG5hbWUpXG4gICAgICAgICAgICBkZWxlZ2F0ZS5jYWxsYmFjayA9IG9uISBuYW1lIGRvIHxlfFxuICAgICAgICAgICAgICBkZWxlZ2F0ZShkZWxlZ2F0ZSwgZSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGVnYXRlLmNhbGxiYWNrID0gb24gbmFtZSBkbyB8ZXxcbiAgICAgICAgICAgICAgZGVsZWdhdGUoZGVsZWdhdGUsIGUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcblxuICAgICAgICAgIHBhaXIgPSBbc2VsZWN0b3IsIGJsb2NrXVxuICAgICAgICAgIGRlbGVnYXRlLmhhbmRsZXJzID0gW3BhaXJdXG5cbiAgICAgICAgICBEZWxlZ2F0ZS5uZXcoc2VsZiwgbmFtZSwgcGFpcilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHBhaXIgPSBbc2VsZWN0b3IsIGJsb2NrXVxuICAgICAgICAgIGRlbGVnYXRlLmhhbmRsZXJzIDw8IHBhaXJcblxuICAgICAgICAgIERlbGVnYXRlLm5ldyhzZWxmLCBuYW1lLCBwYWlyKVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgY2FsbGJhY2sgPSBDYWxsYmFjay5uZXcoc2VsZiwgbmFtZSwgc2VsZWN0b3IsICZibG9jaylcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG5cbiAgICAgICAgYXR0YWNoKGNhbGxiYWNrKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIFN0YXJ0IGxpc3RlbmluZyBmb3IgYW4gZXZlbnQgaW4gdGhlIGNhcHR1cmluZyBwaGFzZS5cbiAgICAjXG4gICAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgZXZlbnQgbmFtZVxuICAgICNcbiAgICAjIEB5aWVsZHBhcmFtIGV2ZW50IFtFdmVudF0gdGhlIGV2ZW50XG4gICAgI1xuICAgICMgQHJldHVybiBbQ2FsbGJhY2tdXG4gICAgZGVmIG9uIShuYW1lLCAmYmxvY2spXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgaGFzIGJlZW4gZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgICBuYW1lICAgICA9IEV2ZW50Lm5hbWVfZm9yKG5hbWUpXG4gICAgICBjYWxsYmFjayA9IENhbGxiYWNrLm5ldyhzZWxmLCBuYW1lLCAmYmxvY2spXG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjaylcblxuICAgICAgYXR0YWNoIShjYWxsYmFjaylcbiAgICBlbmRcblxuICAgIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5hZGRMaXN0ZW5lcidcbiAgICAgIGRlZiBhdHRhY2goY2FsbGJhY2spXG4gICAgICAgIGAjQG5hdGl2ZS5hZGRFdmVudExpc3RlbmVyKCN7Y2FsbGJhY2submFtZX0sICN7Y2FsbGJhY2sudG9fcHJvY30pYFxuXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICBlbmRcblxuICAgICAgZGVmIGF0dGFjaCEoY2FsbGJhY2spXG4gICAgICAgIGAjQG5hdGl2ZS5hZGRFdmVudExpc3RlbmVyKCN7Y2FsbGJhY2submFtZX0sICN7Y2FsbGJhY2sudG9fcHJvY30sIHRydWUpYFxuXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICBlbmRcbiAgICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuYXR0YWNoJ1xuICAgICAgZGVmIGF0dGFjaChjYWxsYmFjaylcbiAgICAgICAgaWYgY2FsbGJhY2suZXZlbnQgPT0gQ3VzdG9tXG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICBpZiAoISNAbmF0aXZlLiRjdXN0b20pIHtcbiAgICAgICAgICAgICAgI0BuYXRpdmUuJGN1c3RvbSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICNAbmF0aXZlLiRjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9ICNAbmF0aXZlLiRjYWxsYmFja3NbaV07XG5cbiAgICAgICAgICAgICAgICAgIGlmICgje2BjYWxsYmFja2AuZXZlbnQgPT0gQ3VzdG9tfSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gY2FsbGJhY2submFtZTtcblxuICAgICAgICAgICAgICAgICAgICAje2BjYWxsYmFja2AuY2FsbChgZXZlbnRgKX07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICNAbmF0aXZlLmF0dGFjaEV2ZW50KFwib25kYXRhYXZhaWxhYmxlXCIsICNAbmF0aXZlLiRjdXN0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGAjQG5hdGl2ZS5hdHRhY2hFdmVudChcIm9uXCIgKyAje2NhbGxiYWNrLm5hbWV9LCAje2NhbGxiYWNrLnRvX3Byb2N9KWBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgYXR0YWNoIShjYWxsYmFjaylcbiAgICAgICAgY2FzZSBjYWxsYmFjay5uYW1lXG4gICAgICAgIHdoZW4gOmJsdXJcbiAgICAgICAgICBgI0BuYXRpdmUuYXR0YWNoRXZlbnQoXCJvbmZvY3Vzb3V0XCIsICN7Y2FsbGJhY2sudG9fcHJvY30pYFxuXG4gICAgICAgIHdoZW4gOmZvY3VzXG4gICAgICAgICAgYCNAbmF0aXZlLmF0dGFjaEV2ZW50KFwib25mb2N1c2luXCIsICN7Y2FsbGJhY2sudG9fcHJvY30pYFxuXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3YXJuIFwiYXR0YWNoOiBjYXB0dXJlIGRvZXNuJ3Qgd29yayBvbiB0aGlzIGJyb3dzZXJcIlxuICAgICAgICAgIGF0dGFjaChjYWxsYmFjaylcbiAgICAgICAgZW5kXG5cbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICMgQHRvZG8gaW1wbGVtZW50IHBvbHlmaWxsXG4gICAgICAjIEBwcml2YXRlXG4gICAgICBkZWYgYXR0YWNoKCopXG4gICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgICAgIGVuZFxuXG4gICAgICAjIEB0b2RvIGltcGxlbWVudCBwb2x5ZmlsbFxuICAgICAgIyBAcHJpdmF0ZVxuICAgICAgZGVmIGF0dGFjaCEoKilcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIEBvdmVybG9hZCBvbmUobmFtZSwgJmJsb2NrKVxuICAgICNcbiAgICAjICAgU3RhcnQgbGlzdGVuaW5nIGZvciBhbiBldmVudCBvbiB0aGUgdGFyZ2V0LiBSZW1vdmUgdGhlIGV2ZW50IGFmdGVyIGZpcmluZ1xuICAgICMgICBzbyB0aGF0IGl0IGlzIGZpcmVkIGF0IG1vc3Qgb25jZS5cbiAgICAjXG4gICAgIyAgIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBldmVudCBuYW1lXG4gICAgI1xuICAgICMgICBAeWllbGRwYXJhbSBldmVudCBbRXZlbnRdIHRoZSBldmVudFxuICAgICNcbiAgICAjICAgQHJldHVybiBbQ2FsbGJhY2tdXG4gICAgI1xuICAgICMgQG92ZXJsb2FkIG9uZShuYW1lLCBzZWxlY3RvciwgJmJsb2NrKVxuICAgICNcbiAgICAjICAgU3RhcnQgbGlzdGVuaW5nIGZvciBhbiBldmVudCBvbiB0aGUgdGFyZ2V0IGNoaWxkcmVuLiBSZW1vdmUgdGhlIGV2ZW50IGFmdGVyXG4gICAgIyAgIGZpcmluZyBzbyB0aGF0IGl0IGlzIGZpcmVkIGF0IG1vc3Qgb25jZS5cbiAgICAjXG4gICAgIyAgIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBldmVudCBuYW1lXG4gICAgIyAgIEBwYXJhbSBzZWxlY3RvciBbU3RyaW5nXSB0aGUgQ1NTIHNlbGVjdG9yIHRvIHRyaWdnZXIgdGhlIGV2ZW50IG9uXG4gICAgI1xuICAgICMgICBAeWllbGRwYXJhbSBldmVudCBbRXZlbnRdIHRoZSBldmVudFxuICAgICNcbiAgICAjICAgQHJldHVybiBbRGVsZWdhdGVdXG4gICAgZGVmIG9uZSAobmFtZSwgc2VsZWN0b3IgPSBuaWwsICZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBoYXMgYmVlbiBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIGNiID0gb24gbmFtZSwgc2VsZWN0b3IgZG8gfCphcmdzfFxuICAgICAgICBvdXQgPSBibG9jay5jYWxsKCphcmdzKVxuICAgICAgICBjYi5vZmZcbiAgICAgICAgb3V0XG4gICAgICBlbmRcbiAgICBlbmRcbiAgICAjIEBvdmVybG9hZCBvZmYoKVxuICAgICMgICBTdG9wIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50LlxuICAgICNcbiAgICAjIEBvdmVybG9hZCBvZmYod2hhdClcbiAgICAjICAgU3RvcCBsaXN0ZW5pbmcgZm9yIGFuIGV2ZW50LlxuICAgICNcbiAgICAjICAgQHBhcmFtIHdoYXQgW0NhbGxiYWNrLCBTdHJpbmcsIFJlZ2V4cF0gd2hhdCB0byBzdG9wIGxpc3RlbmluZyBmb3JcbiAgICBkZWYgb2ZmKHdoYXQgPSBuaWwpXG4gICAgICBjYXNlIHdoYXRcbiAgICAgIHdoZW4gQ2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2tzLmRlbGV0ZSh3aGF0KVxuICAgICAgICBkZXRhY2god2hhdClcblxuICAgICAgd2hlbiBTdHJpbmdcbiAgICAgICAgaWYgd2hhdC5pbmNsdWRlPyg/Kikgb3Igd2hhdC5pbmNsdWRlPyg/PylcbiAgICAgICAgICBvZmYoUmVnZXhwLm5ldyh3aGF0LmdzdWIoL1xcKi8sICcuKj8nKS5nc3ViKC9cXD8vLCA/LikpKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgd2hhdCA9IEV2ZW50Lm5hbWVfZm9yKHdoYXQpXG5cbiAgICAgICAgICBjYWxsYmFja3MuZGVsZXRlX2lmIHt8Y2FsbGJhY2t8XG4gICAgICAgICAgICBpZiBjYWxsYmFjay5uYW1lID09IHdoYXRcbiAgICAgICAgICAgICAgZGV0YWNoKGNhbGxiYWNrKVxuXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG5cbiAgICAgIHdoZW4gUmVnZXhwXG4gICAgICAgIGNhbGxiYWNrcy5kZWxldGVfaWYge3xjYWxsYmFja3xcbiAgICAgICAgICBpZiBjYWxsYmFjay5uYW1lID1+IHdoYXRcbiAgICAgICAgICAgIGRldGFjaChjYWxsYmFjaylcblxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIGVuZFxuICAgICAgICB9XG5cbiAgICAgIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzLmVhY2gge3xjYWxsYmFja3xcbiAgICAgICAgICBkZXRhY2goY2FsbGJhY2spXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFja3MuY2xlYXJcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LnJlbW92ZUxpc3RlbmVyJ1xuICAgICAgZGVmIGRldGFjaChjYWxsYmFjaylcbiAgICAgICAgYCNAbmF0aXZlLnJlbW92ZUV2ZW50TGlzdGVuZXIoI3tjYWxsYmFjay5uYW1lfSwgI3tjYWxsYmFjay50b19wcm9jfSwgZmFsc2UpYFxuICAgICAgZW5kXG4gICAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmRldGFjaCdcbiAgICAgIGRlZiBkZXRhY2goY2FsbGJhY2spXG4gICAgICAgIGlmIGNhbGxiYWNrLmV2ZW50ID09IEN1c3RvbVxuICAgICAgICAgIGlmIGNhbGxiYWNrcy5ub25lPyB7IHxjfCBjLmV2ZW50ID09IEN1c3RvbSB9XG4gICAgICAgICAgICAleHtcbiAgICAgICAgICAgICAgI0BuYXRpdmUuZGV0YWNoRXZlbnQoXCJvbmRhdGFhdmFpbGFibGVcIiwgI0BuYXRpdmUuJGN1c3RvbSk7XG5cbiAgICAgICAgICAgICAgZGVsZXRlICNAbmF0aXZlLiRjdXN0b207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgI0BuYXRpdmUuZGV0YWNoRXZlbnQoXCJvblwiICsgI3tjYWxsYmFjay5uYW1lfSwgI3tjYWxsYmFjay50b19wcm9jfSlgXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgIyBAdG9kbyBpbXBsZW1lbnQgaW50ZXJuYWwgaGFuZGxlciB0aGluZ1xuICAgICAgIyBAcHJpdmF0ZVxuICAgICAgZGVmIGRldGFjaChjYWxsYmFjaylcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAjIFRyaWdnZXIgYW4gZXZlbnQgb24gdGhlIHRhcmdldC5cbiAgICAjXG4gICAgIyBAcGFyYW0gZXZlbnQgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWVcbiAgICAjIEBwYXJhbSBhcmdzIFtBcnJheV0gb3B0aW9uYWwgYXJndW1lbnRzIHRvIHRoZSBldmVudCBjYWxsYmFja1xuICAgICNcbiAgICAjIEB5aWVsZHBhcmFtIGRlZmluaXRpb24gW0RlZmluaXRpb25dIGRlZmluaXRpb24gdG8gY3VzdG9taXplIHRoZSBldmVudFxuICAgIGRlZiB0cmlnZ2VyKGV2ZW50LCAqYXJncywgJmJsb2NrKVxuICAgICAgaWYgZXZlbnQuaXNfYT8gU3RyaW5nXG4gICAgICAgIGV2ZW50ID0gRXZlbnQuY3JlYXRlKGV2ZW50LCAqYXJncywgJmJsb2NrKVxuICAgICAgZW5kXG5cbiAgICAgIGRpc3BhdGNoKGV2ZW50KVxuICAgIGVuZFxuXG4gICAgIyBUcmlnZ2VyIGFuIGV2ZW50IG9uIHRoZSB0YXJnZXQgd2l0aG91dCBidWJibGluZy5cbiAgICAjXG4gICAgIyBAcGFyYW0gZXZlbnQgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWVcbiAgICAjIEBwYXJhbSBhcmdzIFtBcnJheV0gb3B0aW9uYWwgYXJndW1lbnRzIHRvIHRoZSBldmVudCBjYWxsYmFja1xuICAgICNcbiAgICAjIEB5aWVsZHBhcmFtIGRlZmluaXRpb24gW0RlZmluaXRpb25dIGRlZmluaXRpb24gdG8gY3VzdG9taXplIHRoZSBldmVudFxuICAgIGRlZiB0cmlnZ2VyIShldmVudCwgKmFyZ3MsICZibG9jaylcbiAgICAgIHRyaWdnZXIgZXZlbnQsICphcmdzIGRvIHxlfFxuICAgICAgICBibG9jay5jYWxsKGUpIGlmIGJsb2NrXG4gICAgICAgIGUuYnViYmxlcyA9IGZhbHNlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5kaXNwYXRjaCdcbiAgICAgIGRlZiBkaXNwYXRjaChldmVudClcbiAgICAgICAgYCNAbmF0aXZlLmRpc3BhdGNoRXZlbnQoI3tldmVudC50b19ufSlgXG4gICAgICBlbmRcbiAgICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuZmlyZSdcbiAgICAgIGRlZiBkaXNwYXRjaChldmVudClcbiAgICAgICAgaWYgQ3VzdG9tID09PSBldmVudFxuICAgICAgICAgIGAjQG5hdGl2ZS5maXJlRXZlbnQoXCJvbmRhdGFhdmFpbGFibGVcIiwgI3tldmVudC50b19ufSlgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBgI0BuYXRpdmUuZmlyZUV2ZW50KFwib25cIiArICN7ZXZlbnQubmFtZX0sICN7ZXZlbnQudG9fbn0pYFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICMgQHRvZG8gaW1wbGVtZW50IHBvbHlmaWxsXG4gICAgICAjIEBwcml2YXRlXG4gICAgICBkZWYgZGlzcGF0Y2goKilcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJpdmF0ZVxuICAgIGRlZiBjYWxsYmFja3NcbiAgICAgICV4e1xuICAgICAgICBpZiAoISNAbmF0aXZlLiRjYWxsYmFja3MpIHtcbiAgICAgICAgICAjQG5hdGl2ZS4kY2FsbGJhY2tzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI0BuYXRpdmUuJGNhbGxiYWNrcztcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBkZWxlZ2F0ZWRcbiAgICAgICV4e1xuICAgICAgICBpZiAoISNAbmF0aXZlLiRkZWxlZ2F0ZWQpIHtcbiAgICAgICAgICAjQG5hdGl2ZS4kZGVsZWdhdGVkID0gI3t7fX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI0BuYXRpdmUuJGRlbGVnYXRlZDtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBkZWxlZ2F0ZShkZWxlZ2F0ZXMsIGV2ZW50LCBlbGVtZW50ID0gZXZlbnQudGFyZ2V0KVxuICAgICAgcmV0dXJuIGlmIGVsZW1lbnQubmlsPyB8fCBlbGVtZW50ID09IGV2ZW50Lm9uXG5cbiAgICAgIGRlbGVnYXRlcy5oYW5kbGVycy5lYWNoIHt8c2VsZWN0b3IsIGJsb2NrfFxuICAgICAgICBpZiBlbGVtZW50ID1+IHNlbGVjdG9yXG4gICAgICAgICAgbmV3ICAgID0gZXZlbnQuZHVwXG4gICAgICAgICAgbmV3Lm9uID0gZWxlbWVudFxuXG4gICAgICAgICAgYmxvY2suY2FsbCBuZXcsICpuZXcuYXJndW1lbnRzXG4gICAgICAgIGVuZFxuICAgICAgfVxuXG4gICAgICBkZWxlZ2F0ZShkZWxlZ2F0ZXMsIGV2ZW50LCBlbGVtZW50LnBhcmVudClcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJpbmNsdWRlIiwibmV3Iiwic2VsZiIsImRhdGEiLCJibG9jayIsImNhbGwiLCJ0b19uIiwiYnViYmxlcz0iLCJAbmF0aXZlIiwidmFsdWUiLCJjYW5jZWxhYmxlPSIsImNvbnZlcnRlcnMiLCJAY29udmVydGVycyIsInJlZ2lzdGVyIiwiPDwiLCJjb252ZXJ0IiwibmF0aXZlPyIsImVhY2giLCJyZXN1bHQiLCJpbmNsdWRlZCIsImluc3RhbmNlX2V2YWwiLCJrbGFzcyIsInRhcmdldCIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkB0YXJnZXQiLCJAbmFtZSIsIm5hbWUiLCJAc2VsZWN0b3IiLCJzZWxlY3RvciIsIkBibG9jayIsInRvX3Byb2MiLCJldmVudCIsIkBwcm9jIiwic3RvcHBlZD8iLCJhcmd1bWVudHMiLCJwcmV2ZW50ZWQ/IiwiISIsImNsYXNzX2ZvciIsIm9mZiIsIkBwYWlyIiwicGFpciIsImRlbGVnYXRlIiwiZGVsZWdhdGVkIiwiW10iLCJsYXN0IiwiZGVsZXRlIiwiZW1wdHk/IiwiZmlyc3QiLCJvbiIsInJhaXNlIiwibmFtZV9mb3IiLCJoYW5kbGVycyIsIiR3cml0ZXIiLCJbXT0iLCItIiwiMSIsImluY2x1ZGU/Iiwib24hIiwiZSIsImNhbGxiYWNrPSIsImhhbmRsZXJzPSIsImNhbGxiYWNrIiwiY2FsbGJhY2tzIiwicHVzaCIsImF0dGFjaCIsImF0dGFjaCEiLCJzdXBwb3J0cz8iLCI9PSIsIndhcm4iLCJvbmUiLCJjYiIsIm91dCIsImFyZ3MiLCJ3aGF0IiwiZGV0YWNoIiwiZ3N1YiIsImRlbGV0ZV9pZiIsIj1+IiwiY2xlYXIiLCJub25lPyIsImMiLCJ0cmlnZ2VyIiwiaXNfYT8iLCJjcmVhdGUiLCJkaXNwYXRjaCIsInRyaWdnZXIhIiwiPT09IiwicHJpdmF0ZSIsImVsZW1lbnQiLCJuaWw/IiwiZGVsZWdhdGVzIiwibmV3JCIsImR1cCIsIm9uPSIsInBhcmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFB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LE1BK2JNWSxDQS9iTjtBQUFBLFVBd2NNLFdBQUF5QixVQUFBQSxDQUFTaUQsV0FBVzNELE9BQU95RCxPQUFBTSxRQUFBQSxDQUFBQSxDQUEzQnJELENBeGNOO0FBNGJJQSxRQUFBQSxDQUFBQSxrQ0FBQUEsQ0E3WkE7QUFGRjVDLE1BQUFBLEdBQUFBLFdBQUFBLFdBekJBO0FBREZDLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjgzMjYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L3VpLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBVSSA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuVUknXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGRldGFpbD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGV0YWlsID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgdmlldz0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudmlldyA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFVJRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJVSUV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdFVJRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2MudmlldyB8fCB3aW5kb3csIGRlc2MuZGV0YWlsIHx8IDApO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmRldGFpbFxuICBhbGlhc19uYXRpdmUgOnZpZXdcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJkZXRhaWw9IiwiQG5hdGl2ZSIsInZhbHVlIiwidmlldz0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsdUJBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLFVBQWxCQTtBQURGRixRQUFBQSxDQUFBQSxrQ0FBQUEsQ0FBQTtBQUFBLFFBSUFEO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFDRTtBQUFBSSxVQUFBQSwyQkFBQUEsMEJBQUFBLFNBQVksS0FBWkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTyxVQUFZQztBQUR2QkYsVUFBQUEsQ0FBQUEscUNBQUFBLENBQUE7QUFBQSxVQUlBLE9BQUFHLENBQUFBLHlCQUFBQSx3QkFBQUEsU0FBVSxLQUFWQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFRixjQUFPLFFBQVVDO0FBRHJCQyxVQUFBQSxDQUFBQSxtQ0FBQUEsQ0FBQUEsaUJBSkE7QUFERlAsUUFBQUEsR0FBQUEsV0FBQUEsRUFBbUIsMEJBQW5CQSxXQUpBO0FBQUEsUUFjQSxJQUFBLFlBY09DLGVBQUFBLENBQUFBLENBZFAsQ0FBQTtBQUFBLFVBQUEsSUFBQSxRQUFHLHVCQUFBRSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUgsQ0FBQTtBQUFBLFlBQ0VLLFVBQUlOLElBQUpNLGdCQUFBQSxrQkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsY0FBQUE7O0FBQUFBLGNBQ0UsT0FBQyxZQUFjQyxJQUFLLEVBQUlDLElBQUs7QUFEL0JGLFlBQUFBLENBQUFBLDZCQUFBQTtBQURGLFVBQUEsT0FJQSxJQUFBLFFBQU0sdUJBQUFMLGNBQUFBLENBQWtCLGNBQWxCQSxDQUFOLENBQUE7QUFBQSxZQUNFSyxVQUFJTixJQUFKTSxnQkFBQUEsa0JBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQTtBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBUElBLFlBQUFBLENBQUFBLDZCQUFBQSxDQURGLENBSkEsQ0FkQTtBQUFBLFlBOEJBRyxjQUFBQSxDQUFhLFFBQWJBLENBOUJBO0FBQUEsUUErQkEsV0FBQUEsY0FBQUEsQ0FBYSxNQUFiQSxDQS9CQTtBQURGWCxNQUFBQSxHQUFBQSxXQUFBQSxFQUFXLHFCQUFYQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjgzOTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L21vdXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBNb3VzZSA8IFVJXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBub3QgJCRbOk1vdXNlRXZlbnRdLm5pbD9cbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IFVJOjpEZWZpbml0aW9uXG4gICAgY2xhc3MgQ2xpZW50XG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5jbGllbnRYID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUuY2xpZW50WSA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjbGFzcyBMYXllclxuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgZGVmIHg9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUubGF5ZXJYID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUubGF5ZXJZID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNsYXNzIE9mZnNldFxuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgZGVmIHg9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUub2Zmc2V0WCA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLm9mZnNldFk9ICN7dmFsdWV9YFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjbGFzcyBQYWdlXG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5wYWdlWCA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnBhZ2VZID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGNsYXNzIFNjcmVlblxuICAgICAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcblxuICAgICAgZGVmIHg9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUuc2NyZWVuWCA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG5cbiAgICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnNjcmVlblkgPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY2xhc3MgQW5jZXN0b3JcbiAgICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnggPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgeT0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS55ID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zY3JlZW5YID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgeT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuc2NyZWVuWSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGFsdCFcbiAgICAgIGAjQG5hdGl2ZS5hbHRLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGN0cmwhXG4gICAgICBgI0BuYXRpdmUuY3RybEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgbWV0YSFcbiAgICAgIGAjQG5hdGl2ZS5tZXRhS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBidXR0b249KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmJ1dHRvbiA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGNsaWVudFxuICAgICAgQ2xpZW50Lm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIGxheWVyXG4gICAgICBMYXllci5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiBvZmZzZXRcbiAgICAgIE9mZnNldC5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiBwYWdlXG4gICAgICBQYWdlLm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIHNjcmVlblxuICAgICAgU2NyZWVuLm5ldyhAbmF0aXZlKVxuICAgIGVuZFxuXG4gICAgZGVmIGFuY2VzdG9yXG4gICAgICBBbmNlc3Rvci5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiByZWxhdGVkPShlbGVtKVxuICAgICAgYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXQgPSAje05hdGl2ZS50cnlfY29udmVydChlbGVtKX1gXG4gICAgZW5kXG5cbiAgICBkZWYgZnJvbT0oZWxlbSlcbiAgICAgIGAjQG5hdGl2ZS5mcm9tRWxlbWVudCA9ICN7TmF0aXZlLnRyeV9jb252ZXJ0KGVsZW0pfWBcbiAgICBlbmRcblxuICAgIGRlZiB0bz0oZWxlbSlcbiAgICAgIGAjQG5hdGl2ZS50b0VsZW1lbnQgPSAje05hdGl2ZS50cnlfY29udmVydChlbGVtKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgTW91c2VFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0TW91c2VFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgZGVzYy5kZXRhaWwgfHwgMCxcbiAgICAgICAgICAgICAgZGVzYy5zY3JlZW5YIHx8IDAsIGRlc2Muc2NyZWVuWSB8fCAwLFxuICAgICAgICAgICAgICBkZXNjLmNsaWVudFggfHwgMCwgZGVzYy5jbGllbnRZIHx8IDAsXG4gICAgICAgICAgICAgIGRlc2MuY3RybEtleSB8fCBmYWxzZSwgZGVzYy5hbHRLZXkgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIGRlc2Muc2hpZnRLZXkgfHwgZmFsc2UsIGRlc2MubWV0YUtleSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgZGVzYy5idXR0b24gfHwgMCwgZGVzYy5yZWxhdGVkVGFyZ2V0IHx8IG51bGwpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFsdD8sIDphbHRLZXlcbiAgYWxpYXNfbmF0aXZlIDpjdHJsPywgOmN0cmxLZXlcbiAgYWxpYXNfbmF0aXZlIDptZXRhPywgOm1ldGFLZXlcbiAgYWxpYXNfbmF0aXZlIDpzaGlmdD8sIDpzaGlmdEtleVxuICBhbGlhc19uYXRpdmUgOmJ1dHRvblxuXG4gIGRlZiBjbGllbnRcbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLmNsaWVudFhgLCBgI0BuYXRpdmUuY2xpZW50WWApXG4gIGVuZFxuXG4gIGRlZiBsYXllclxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUubGF5ZXJYYCwgYCNAbmF0aXZlLmxheWVyWWApIHVubGVzcyBgI0BuYXRpdmUubGF5ZXJYID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBvZmZzZXRcbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLm9mZnNldFhgLCBgI0BuYXRpdmUub2Zmc2V0WWApIHVubGVzcyBgI0BuYXRpdmUub2Zmc2V0WCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgcGFnZVxuICAgIFBvc2l0aW9uLm5ldyhgI0BuYXRpdmUucGFnZVhgLCBgI0BuYXRpdmUucGFnZVlgKSB1bmxlc3MgYCNAbmF0aXZlLnBhZ2VYID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBzY3JlZW5cbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLnNjcmVlblhgLCBgI0BuYXRpdmUuc2NyZWVuWWApIHVubGVzcyBgI0BuYXRpdmUuc2NyZWVuWCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgYW5jZXN0b3JcbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLnhgLCBgI0BuYXRpdmUueWApIHVubGVzcyBgI0BuYXRpdmUueCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgeFxuICAgIHNjcmVlbi54XG4gIGVuZFxuXG4gIGRlZiB5XG4gICAgc2NyZWVuLnlcbiAgZW5kXG5cbiAgZGVmIHJlbGF0ZWRcbiAgICBET00oYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXRgKSB1bmxlc3MgYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIGZyb21cbiAgICBET00oYCNAbmF0aXZlLmZyb21FbGVtZW50YCkgdW5sZXNzIGAjQG5hdGl2ZS5mcm9tRWxlbWVudCA9PSBudWxsYFxuICBlbmRcblxuICBkZWYgdG9cbiAgICBET00oYCNAbmF0aXZlLnRvRWxlbWVudGApIHVubGVzcyBgI0BuYXRpdmUudG9FbGVtZW50ID09IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBjbGljaz9cbiAgICBuYW1lLmRvd25jYXNlID09ICdjbGljaydcbiAgZW5kXG5cbiAgZGVmIGRvdWJsZV9jbGljaz9cbiAgICBuYW1lLmRvd25jYXNlID09ICdkYmxjbGljaydcbiAgZW5kXG5cbiAgZGVmIGRvd24/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2Vkb3duJ1xuICBlbmRcblxuICBkZWYgZW50ZXI/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2VlbnRlcidcbiAgZW5kXG5cbiAgZGVmIGxlYXZlP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ21vdXNlbGVhdmUnXG4gIGVuZFxuXG4gIGRlZiBtb3ZlP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ21vdXNlbW92ZSdcbiAgZW5kXG5cbiAgZGVmIG91dD9cbiAgICBuYW1lLmRvd25jYXNlID09ICdtb3VzZW91dCdcbiAgZW5kXG5cbiAgZGVmIG92ZXI/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2VvdmVyJ1xuICBlbmRcblxuICBkZWYgdXA/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnbW91c2V1cCdcbiAgZW5kXG5cbiAgZGVmIHNob3c/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAnc2hvdydcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwiJCQiLCJbXSIsIm5pbD8iLCIhIiwiaW5jbHVkZSIsIng9IiwiQG5hdGl2ZSIsInZhbHVlIiwieT0iLCJhbHQhIiwiY3RybCEiLCJtZXRhISIsImJ1dHRvbj0iLCJjbGllbnQiLCJuZXciLCJsYXllciIsIm9mZnNldCIsInBhZ2UiLCJzY3JlZW4iLCJhbmNlc3RvciIsInJlbGF0ZWQ9IiwidHJ5X2NvbnZlcnQiLCJlbGVtIiwiZnJvbT0iLCJ0bz0iLCJzdXBwb3J0cz8iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsIngiLCJ5IiwicmVsYXRlZCIsIkRPTSIsImZyb20iLCJ0byIsImNsaWNrPyIsImRvd25jYXNlIiwiPT0iLCJkb3VibGVfY2xpY2s/IiwiZG93bj8iLCJlbnRlcj8iLCJsZWF2ZT8iLCJtb3ZlPyIsIm91dD8iLCJvdmVyPyIsInVwPyIsInNob3c/Il0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELGlCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEs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U0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsV0FBQWxCLE1BQUFBLENBQUFBLENBQUFVLFVBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWlCLFdBQWpCQTtBQURGTyxRQUFBQSxDQUFBQSxpQ0FBQUEsQ0E3T0E7QUFBQTtBQWlQQUMsUUFBQUEsdUJBQUFBLG9CQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBbkIsTUFBQUEsQ0FBQUEsQ0FBQVUsVUFBQUEsQ0FBQUEsQ0FBQUMsT0FBQUEsQ0FBaUIsU0FBakJBO0FBREZRLFFBQUFBLENBQUFBLCtCQUFBQSxDQWpQQTtBQUFBLFFBcVBBLE9BQUFDLENBQUFBLHlCQUFBQSxzQkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsV0FBQXBCLE1BQUFBLENBQUFBLENBQUFVLFVBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWlCLE1BQWpCQTtBQURGUyxRQUFBQSxDQUFBQSxpQ0FBQUEsQ0FBQUEsaUJBclBBO0FBREZsRCxNQUFBQSxHQUFBQSxXQUFBQSxFQUFjLGtCQUFkQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg4MzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2tleWJvYXJkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBLZXlib2FyZCA8IFVJXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuS2V5Ym9hcmQnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBVSTo6RGVmaW5pdGlvblxuICAgIGRlZiBhbHQhXG4gICAgICBgI0BuYXRpdmUuYWx0S2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBjdHJsIVxuICAgICAgYCNAbmF0aXZlLmN0cmxLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIG1ldGEhXG4gICAgICBgI0BuYXRpdmUubWV0YUtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgc2hpZnQhXG4gICAgICBgI0BuYXRpdmUuc2hpZnRLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGNvZGU9KGNvZGUpXG4gICAgICBgI0BuYXRpdmUua2V5Q29kZSA9ICNAbmF0aXZlLndoaWNoID0gI3tjb2RlfWBcbiAgICBlbmRcblxuICAgIGRlZiBrZXk9KGtleSlcbiAgICAgIGAjQG5hdGl2ZS5rZXkgPSAje2tleX1gXG4gICAgZW5kXG5cbiAgICBkZWYgY2hhcj0oY2hhcilcbiAgICAgIGAjQG5hdGl2ZS5jaGFyID0gI0BuYXRpdmUuY2hhckNvZGUgPSAje2NoYXJ9YFxuICAgIGVuZFxuXG4gICAgZGVmIHJlcGVhdCFcbiAgICAgIGAjQG5hdGl2ZS5yZXBlYXQgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGxvY2FsZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubG9jYWxlID0gdmFsdWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgS2V5Ym9hcmRFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gXCJcIjtcblxuICAgICAgICBpZiAoZGVzYy5hbHRLZXkpIHtcbiAgICAgICAgICBtb2RpZmllcnMgKz0gXCJBbHQgXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5jdHJsS2V5KSB7XG4gICAgICAgICAgbW9kaWZpZXJzICs9IFwiQ3RybCBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgbW9kaWZpZXJzICs9IFwiU2hpZnRcIiA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy5tZXRhS2V5KSB7XG4gICAgICAgICAgbW9kaWZpZXJzICs9IFwiTWV0YSBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiS2V5Ym9hcmRFdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRLZXlib2FyZEV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLnZpZXcgfHwgd2luZG93LCBkZXNjLndoaWNoLCAwLFxuICAgICAgICAgICAgICBtb2RpZmllcnMsIGRlc2MucmVwZWF0LCBkZXNjLmxvY2FsZSk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6YWx0PywgOmFsdEtleVxuICBhbGlhc19uYXRpdmUgOmN0cmw/LCA6Y3RybEtleVxuICBhbGlhc19uYXRpdmUgOm1ldGE/LCA6bWV0YUtleVxuICBhbGlhc19uYXRpdmUgOnNoaWZ0PywgOnNoaWZ0S2V5XG4gIGFsaWFzX25hdGl2ZSA6bG9jYWxlXG4gIGFsaWFzX25hdGl2ZSA6cmVwZWF0PywgOnJlcGVhdFxuXG4gIGRlZiBrZXlcbiAgICBgI0BuYXRpdmUua2V5IHx8ICNAbmF0aXZlLmtleUlkZW50aWZpZXIgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgY29kZVxuICAgIGAjQG5hdGl2ZS5rZXlDb2RlIHx8ICNAbmF0aXZlLndoaWNoIHx8IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGNoYXJcbiAgICBgI0BuYXRpdmUuY2hhciB8fCAjQG5hdGl2ZS5jaGFyQ29kZSB8fCAje2NvZGUgPyBjb2RlLmNociA6IG5pbH1gXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2kga2V5XG5cbiAgZGVmIGRvd24/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAna2V5ZG93bidcbiAgZW5kXG5cbiAgZGVmIHByZXNzP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2tleXByZXNzJ1xuICBlbmRcblxuICBkZWYgdXA/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAna2V5dXAnXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsInN1cHBvcnRzPyIsImFsdCEiLCJAbmF0aXZlIiwiY3RybCEiLCJtZXRhISIsInNoaWZ0ISIsImNvZGU9IiwiY29kZSIsImtleT0iLCJrZXkiLCJjaGFyPSIsImNoYXIkIiwicmVwZWF0ISIsImxvY2FsZT0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsImNoYXIiLCJjaHIiLCJkb3duPyIsImRvd25jYXNlIiwiPT0iLCJwcmVzcz8iLCJ1cD8iXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsUUFBQUMsVUFBSUMsSUFBSkQsaUJBQUFBLDZCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLHVCQUFBRSxjQUFBQSxDQUFrQixnQkFBbEJBO0FBREZGLFFBQUFBLENBQUFBLHdDQUFBQSxDQUFBO0FBQUEsUUFJQUQ7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFO0FBQUFJLFVBQUFBLHdCQUFBQSx5QkFBQUEsU0FBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTztBQURYRCxV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QUFERkUsUUFBQUEsQ0FBQUEsa0NBQUFBLENBQUFBLGVBMUdBO0FBREYzQixNQUFBQSxHQUFBQSxXQUFBQSxFQUFpQixrQkFBakJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTAxMCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZm9jdXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEZvY3VzIDwgVUlcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5Gb2N1cydcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IFVJOjpEZWZpbml0aW9uXG4gICAgZGVmIHZpZXc9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnZpZXcgPSAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX1gXG4gICAgZW5kXG5cbiAgICBkZWYgcmVsYXRlZD0oZWxlbSlcbiAgICAgIGAjQG5hdGl2ZS5yZWxhdGVkVGFyZ2V0ID0gI3tOYXRpdmUuY29udmVydChlbGVtKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRm9jdXNFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkZvY3VzRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0Rm9jdXNFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgMCwgZGVzYy5yZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgZGVmIHJlbGF0ZWRcbiAgICBET00oYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXRgKVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJ2aWV3PSIsIkBuYXRpdmUiLCJjb252ZXJ0IiwidmFsdWUiLCJyZWxhdGVkPSIsImVsZW0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsInJlbGF0ZWQiLCJET00iXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsUUFBQUMsVUFBSUMsSUFBSkQsaUJBQUFBLDBCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLHVCQUFBRSxjQUFBQSxDQUFrQixhQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEscUNBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUksVUFBQUEseUJBQUFBLHdCQUFBQSxTQUFVLEtBQVZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sUUFBVSxzQkFBQUMsU0FBQUEsQ0FBZUMsS0FBZkQ7QUFEckJGLFVBQUFBLENBQUFBLG1DQUFBQSxDQUFBO0FBQUEsVUFJQSxPQUFBSSxDQUFBQSw0QkFBQUEsMkJBQUFBLFNBQWEsSUFBYkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUgsY0FBTyxpQkFBbUIsc0JBQUFDLFNBQUFBLENBQWVHLElBQWZIO0FBRDlCRSxVQUFBQSxDQUFBQSxzQ0FBQUEsQ0FBQUEsb0JBSkE7QUFERlIsUUFBQUEsR0FBQUEsV0FBQUEsRUFBbUIsSUFBQSxrQkFBQSxlQUFuQkEsV0FKQTtBQUFBLFFBY0EsSUFBQSxZQWNPQyxlQUFBQSxDQUFBQSxDQWRQLENBQUE7QUFBQSxVQUFBLElBQUEsUUFBRyx1QkFBQUUsY0FBQUEsQ0FBa0IsbUJBQWxCQSxDQUFILENBQUE7QUFBQSxZQUNFTyxVQUFJUixJQUFKUSxnQkFBQUEscUJBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQSxjQUNFLE9BQUMsZUFBaUJDLElBQUssRUFBSUMsSUFBSztBQURsQ0YsWUFBQUEsQ0FBQUEsZ0NBQUFBO0FBREYsVUFBQSxPQUlBLElBQUEsUUFBTSx1QkFBQVAsY0FBQUEsQ0FBa0IsY0FBbEJBLENBQU4sQ0FBQTtBQUFBLFlBQ0VPLFVBQUlSLElBQUpRLGdCQUFBQSxxQkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsY0FBQUE7O0FBQUFBO0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFQSUEsWUFBQUEsQ0FBQUEsZ0NBQUFBLENBREYsQ0FKQSxDQWRBO0FBQUEsUUE4QkEsT0FBQUcsQ0FBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsV0FBQUMsS0FBQUEsQ0FBTVQsY0FBTyxjQUFiUztBQURGRCxRQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEsbUJBOUJBO0FBREZiLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWMsa0JBQWRBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTA4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvd2hlZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIFdoZWVsIDwgVUlcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIG5vdCAkJFs6V2hlZWxFdmVudF0ubmlsP1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kZWx0YVggPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiB5PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kZWx0YVkgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiB6PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kZWx0YVogPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBtb2RlPSh2YWx1ZSlcbiAgICAgIHZhbHVlID0gY2FzZSB2YWx1ZVxuICAgICAgICB3aGVuIDpwaXhlbCB0aGVuIGBXaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTGBcbiAgICAgICAgd2hlbiA6bGluZSAgdGhlbiBgV2hlZWxFdmVudC5ET01fREVMVEFfTElORWBcbiAgICAgICAgd2hlbiA6cGFnZSAgdGhlbiBgV2hlZWxFdmVudC5ET01fREVMVEFfUEFHRWBcbiAgICAgIGVuZFxuXG4gICAgICBgI0BuYXRpdmUuZGVsdGFNb2RlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgIGBuZXcgV2hlZWxFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDp4LCA6ZGVsdGFYXG4gIGFsaWFzX25hdGl2ZSA6eSwgOmRlbHRhWVxuICBhbGlhc19uYXRpdmUgOnosIDpkZWx0YVpcblxuICBkZWYgbW9kZVxuICAgIGNhc2UgYCNAbmF0aXZlLmRlbHRhTW9kZWBcbiAgICAgIHdoZW4gYFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMYCB0aGVuIDpwaXhlbFxuICAgICAgd2hlbiBgV2hlZWxFdmVudC5ET01fREVMVEFfTElORWAgIHRoZW4gOmxpbmVcbiAgICAgIHdoZW4gYFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BBR0VgICB0aGVuIDpwYWdlXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsIiQkIiwiW10iLCJuaWw/IiwiISIsIng9IiwiQG5hdGl2ZSIsInZhbHVlIiwieT0iLCJ6PSIsIm1vZGU9IiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiLCJtb2RlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELGlCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7QUFBQUE7O0FBQUFBLFVBQ0UsT0FBSUUsUUFBQUMsT0FBQUEsQ0FBRyxZQUFIQSxDQUFBQyxTQUFBQSxDQUFBQSxDQUFKQyxNQUFBQSxDQUFBQTtBQURGTCxRQUFBQSxDQUFBQSxxQ0FBQUEsQ0FBQTtBQUFBLFFBSUFEO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFDRTtBQUFBTyxVQUFBQSxzQkFBQUEscUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTyxVQUFZQztBQUR2QkYsVUFBQUEsQ0FBQUEsZ0NBQUFBLENBQUE7QUFBQTtBQUlBRyxVQUFBQSxzQkFBQUEscUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUYsY0FBTyxVQUFZQztBQUR2QkMsVUFBQUEsQ0FBQUEsZ0NBQUFBLENBSkE7QUFBQTtBQVFBQyxVQUFBQSxzQkFBQUEscUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUgsY0FBTyxVQUFZQztBQUR2QkUsVUFBQUEsQ0FBQUEsZ0NBQUFBLENBUkE7QUFBQSxVQVlBLE9BQUFDLENBQUFBLHlCQUFBQSx3QkFBQUEsU0FBVSxLQUFWQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUFDRSxZQUFBSCxRQUFRLGFBQUEsUUFBS0EsS0FBTDtBQUFBLFlBQ04sSUFBSyxzQkFBTCxHQUFpQixPQUFDLDBCQUFELENBQWpCO0FBRE0sWUFBQSxLQUVOLElBQUsscUJBQUwsR0FBaUIsT0FBQyx5QkFBRCxDQUFqQjtBQUZNLFlBQUEsS0FHTixJQUFLLHFCQUFMLEdBQWlCLE9BQUMseUJBQUQsQ0FBakI7QUFITSxZQUFBLG1CQUFBLElBQVI7QUFBQSxZQU1BLE9BQUVELGNBQU8sYUFBZUMsS0FOeEI7QUFERkcsVUFBQUEsQ0FBQUEsbUNBQUFBLENBQUFBLGlCQVpBO0FBREZaLFFBQUFBLEdBQUFBLFdBQUFBLEVBQW1CLDBCQUFuQkEsV0FKQTtBQUFBLFFBNEJBYSxVQUFJWCxJQUFKVyxnQkFBQUEscUJBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUMsZUFBaUJDLElBQUssRUFBSUMsSUFBSztBQURsQ0YsUUFBQUEsQ0FBQUEsZ0NBQUFBLENBNUJBO0FBQUEsWUFnQ0FHLGNBQUFBLENBQWEsS0FBSSxRQUFqQkEsQ0FoQ0E7QUFBQSxZQWlDQUEsY0FBQUEsQ0FBYSxLQUFJLFFBQWpCQSxDQWpDQTtBQUFBLFlBa0NBQSxjQUFBQSxDQUFhLEtBQUksUUFBakJBLENBbENBO0FBQUEsUUFvQ0EsT0FBQUMsQ0FBQUEsd0JBQUFBLGdCQUFBQSxnQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSxhQUFBLFFBQU9ULGNBQU8sVUFBZDtBQUFBLFVBQ0UsSUFBSyxDQUFDLDBCQUFELGdCQUFMLEdBQXVDLE9BQUEsT0FBdkM7QUFERixVQUFBLEtBRUUsSUFBSyxDQUFDLHlCQUFELGdCQUFMLEdBQXVDLE9BQUEsTUFBdkM7QUFGRixVQUFBLEtBR0UsSUFBSyxDQUFDLHlCQUFELGdCQUFMLEdBQXVDLE9BQUEsTUFBdkM7QUFIRixVQUFBLG1CQUFBO0FBREZTLFFBQUFBLENBQUFBLDJCQUFBQSxDQUFBQSxnQkFwQ0E7QUFERmpCLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWMsa0JBQWRBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTE3MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvYmxvYi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlclxuXG5jbGFzcyBCbG9iXG4gIGluY2x1ZGUgTmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gICMgQ3JlYXRlIGEgbmV3IGJsb2IgZnJvbSBhbnl0aGluZyB0aGF0IEJsb2IgQVBJIHN1cHBvcnRzXG4gIGRlZiBzZWxmLmNyZWF0ZShmcm9tLCBvcHRpb25zPXt9KVxuICAgIG5ldyhgbmV3IEJsb2IoI3tOYXRpdmUuY29udmVydChmcm9tKX0sICN7b3B0aW9ucy50b19ufSlgKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBzaXplXG4gICMgQHJldHVybiBbSW50ZWdlcl0gYmxvYiBzaXplIGluIGJ5dGVzXG4gIGRlZiBzaXplXG4gICAgYCNAbmF0aXZlLnNpemVgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHR5cGVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIGJsb2IgbWltZSB0eXBlXG4gIGRlZiB0eXBlXG4gICAgYCNAbmF0aXZlLnR5cGVgXG4gIGVuZFxuXG4gICMgQ29udmVydCBhIGJsb2IgdG8gYSBVVEYtOCBlbmNvZGVkIHN0cmluZy5cbiAgI1xuICAjIElmIGJsb2NrIGlzIGdpdmVuIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJhbWV0ZXIgb25jZSB3ZSByZWNlaXZlXG4gICMgdGhlIHRleHQuIE90aGVyd2lzZSByZXR1cm4gYSB7UHJvbWlzZX0gd2hpY2ggd2lsbCByZXNvbHZlIG9uY2Ugd2VcbiAgIyByZWNlaXZlIGl0LlxuICBkZWYgdGV4dCgmYmxvY2spXG4gICAgcHJvbWlzZSA9IG5pbFxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHByb21pc2UgPSBQcm9taXNlLm5ld1xuICAgICAgYmxvY2sgPSBwcm9jIHsgfGl8IHByb21pc2UucmVzb2x2ZShpKSB9XG4gICAgZW5kXG4gICAgYCNAbmF0aXZlLnRleHQoKS50aGVuKCN7YmxvY2sudG9fbn0pYFxuICAgIHByb21pc2VcbiAgZW5kXG5cbiAgIyB7QnVmZmVyfSB2aWV3IGludG8gdGhlIGJsb2JcbiAgI1xuICAjIElmIGJsb2NrIGlzIGdpdmVuIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJhbWV0ZXIgb25jZSB3ZSByZWNlaXZlXG4gICMgdGhlIGJ1ZmZlci4gT3RoZXJ3aXNlIHJldHVybiBhIHtQcm9taXNlfSB3aGljaCB3aWxsIHJlc29sdmUgb25jZSB3ZVxuICAjIHJlY2VpdmUgaXQuXG4gIGRlZiBidWZmZXJcbiAgICBwcm9taXNlID0gbmlsXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4gICAgICBibG9jayA9IHByb2MgeyB8aXwgcHJvbWlzZS5yZXNvbHZlKGkpIH1cbiAgICBlbmRcbiAgICByZXNibG9jayA9IHByb2MgeyB8aXwgYmxvY2suY2FsbChCdWZmZXIubmV3KGkpKSB9XG4gICAgYCNAbmF0aXZlLmFycmF5QnVmZmVyKCkudGhlbigje3Jlc2Jsb2NrLnRvX259KWBcbiAgICBwcm9taXNlXG4gIGVuZFxuXG4gICMgQ3JlYXRlIGEgbmV3IGJsb2IgYnkgc2xpY2luZyB0aGlzIGJsb2JcbiAgZGVmIHNsaWNlKHN0YXJ0LCBmaW5pc2g9bmlsKVxuICAgIEJsb2IubmV3KGAjQG5hdGl2ZS5zbGljZSgje3N0YXJ0fSwgI3tmaW5pc2h9KWApXG4gIGVuZFxuXG4gICMgQ29udmVydCBhIGJsb2IgdG8gYW4gVVJMIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgYmxvYiBpbiBET01cbiAgIyBlZy4gZGlzcGxheSBzb21lIG11bHRpbWVkaWFcbiAgZGVmIHRvX3VybCh3aW5kb3c9JHdpbmRvdylcbiAgICBgI3t3aW5kb3cudG9fbn0uVVJMLmNyZWF0ZU9iamVjdFVSTCgjQG5hdGl2ZSlgXG4gIGVuZFxuXG4gICMgUmVuYW1lIGEgYmxvYiBhbmQgcmV0dXJuIGEge0ZpbGV9IHdpdGggYSBuZXcgbmFtZS5cbiAgI1xuICAjIEByZXR1cm4gW0ZpbGVdIGEgcmVuYW1lZCBibG9iXG4gIGRlZiByZW5hbWUobmV3X2ZpbGVuYW1lKVxuICAgIEZpbGUuY3JlYXRlKFtzZWxmXSwgbmV3X2ZpbGVuYW1lLCB0eXBlOiB0eXBlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiByZXNwb25kX3RvPyg6bGFzdF9tb2RpZmllZCkgPyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbW9kaWZpZWQgOiBUaW1lLm5vdylcbiAgZW5kXG5lbmRcblxuY2xhc3MgRmlsZSA8IEJsb2JcbiAgIyBDcmVhdGUgYSBuZXcgZmlsZSBmcm9tIGFueXRoaW5nIHRoYXQgRmlsZSBBUEkgc3VwcG9ydHNcbiAgZGVmIHNlbGYuY3JlYXRlKGZyb20sIG5hbWUsIG9wdGlvbnM9e30pXG4gICAgbmV3KGBuZXcgRmlsZSgje05hdGl2ZS5jb252ZXJ0KGZyb20pfSwgI3tuYW1lfSwgI3tvcHRpb25zLnRvX259KWApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGxhc3RfbW9kaWZpZWRcbiAgIyBAcmV0dXJuIFtUaW1lXSBsYXN0IG1vZGlmaWVkIGRhdGUgb2YgdGhpcyBmaWxlXG4gIGRlZiBsYXN0X21vZGlmaWVkXG4gICAgVGltZS5hdChgI0BuYXRpdmUubGFzdE1vZGlmaWVkYC8xMDAwLjApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIGZpbGVuYW1lIFxuICBkZWYgbmFtZVxuICAgIGAjQG5hdGl2ZS5uYW1lYFxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImluY2x1ZGUiLCJjcmVhdGUiLCJzZWxmIiwibmV3IiwiY29udmVydCIsImZyb20iLCJvcHRpb25zIiwidG9fbiIsInNpemUiLCJAbmF0aXZlIiwidHlwZSIsInRleHQiLCJwcm9taXNlIiwiYmxvY2tfZ2l2ZW4/IiwiYmxvY2siLCJwcm9jIiwicmVzb2x2ZSIsImkiLCJidWZmZXIiLCJyZXNibG9jayIsImNhbGwiLCJzbGljZSIsInN0YXJ0IiwiZmluaXNoIiwidG9fdXJsIiwiJHdpbmRvdyIsIndpbmRvdyIsInJlbmFtZSIsIm5ld19maWxlbmFtZSIsInJlc3BvbmRfdG8/IiwibGFzdF9tb2RpZmllZCIsIm5vdyIsIm5hbWUiLCJhdCIsIi8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUVBLElBQUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxVQUFBQyxTQUFBQSxDQUFRLG1DQUFSQSxDQUFBO0FBQUEsTUFHQUMsVUFBSUMsSUFBSkQsYUFBQUEsaUJBQUFBLGtCQUFnQixJQUFELEVBQU8sT0FBdEJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQVBGO0FBT3dCLFFBQUE7QUFBQSxRQUFBLFlBQVEsWUFBQSxFQUFSO0FBQUEsUUFBQSxDQVB4QjtB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QSxDQUFhLENBQS9ESixDQTlFSjtBQTZFRUYsTUFBQUEsQ0FBQUEsOEJBQUFBLENBQUE7QUFBQTtBQU1BNkIsTUFBQUEsaUNBQUFBLHlCQUFBQSx5QkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQSxvQkFBQUcsSUFBQUEsQ0FBUUMsV0FBRXpCLGNBQU8sYUFBVHlCLEVBQXdCLE1BQXhCQSxDQUFSRDtBQURGSCxNQUFBQSxDQUFBQSxvQ0FBQUEsQ0FOQTtBQUFBLE1BWUEsT0FBQUUsQ0FBQUEsd0JBQUFBLGdCQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBRXZCLGNBQU87QUFEWHVCLE1BQUFBLENBQUFBLDJCQUFBQSxDQUFBQSxnQkFaQTtBQUZGakMsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYSxvQkFBYkEsV0F4RUE7QUFGQUQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTMzNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZGF0YV90cmFuc2Zlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdicm93c2VyL2Jsb2InXG5cbm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG4jIHtEYXRhVHJhbnNmZXJ9IGlzIGFuIG9iamVjdCB3aGljaCBtYW5hZ2VzIGluY2x1ZGVkIGRhdGEgdG9cbiMgYW4gZXZlbnQgb2YgdHlwZSB7RXZlbnQ6OkRyYWd9IG9yIHtFdmVudDo6Q2xpcGJvYXJkfS5cbmNsYXNzIERhdGFUcmFuc2ZlclxuICBpbmNsdWRlIE5hdGl2ZUNhY2hlZFdyYXBwZXJcblxuICAjIEAhYXR0cmlidXRlIFtyd10gZWZmZWN0XG4gICMgQHJldHVybiBbU3ltYm9sXSBFZmZlY3Qgb2YgdGhpcyBkcm9wIG9wZXJhdGlvbi5cbiAgIyAgIE11c3QgYmUgb25lIG9mOiA6bm9uZSwgOmNvcHksIDpsaW5rIG9yIDptb3ZlLlxuICBkZWYgZWZmZWN0XG4gICAgYCNAbmF0aXZlLmRyb3BFZmZlY3RgXG4gIGVuZFxuXG4gIGRlZiBlZmZlY3Q9IChlZmZlY3QpXG4gICAgYCNAbmF0aXZlLmRyb3BFZmZlY3QgPSAje2VmZmVjdH1gXG4gIGVuZFxuXG4gICMgRXh0cmFjdCBzb21lIHRleHQgZGF0YSBmcm9tIHRoaXMge0RhdGFUcmFuc2Zlcn0gaW5zdGFuY2UuXG4gIGRlZiBbXSAodHlwZSlcbiAgICBgI0BuYXRpdmUuZ2V0RGF0YSgje3R5cGV9KWBcbiAgZW5kXG5cbiAgIyBFbWJlZCBzb21lIHRleHQgZGF0YSBpbiB0aGlzIHtEYXRhVHJhbnNmZXJ9IGluc3RhbmNlLlxuICBkZWYgW109ICh0eXBlLCB2YWx1ZSlcbiAgICBgI0BuYXRpdmUuc2V0RGF0YSgje3R5cGV9LCAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX0pYFxuICBlbmRcblxuICAjIENsZWFyIHNvbWUgKG9yIGFsbCwgaWYgdHlwZSBpcyBub3Qgc3BlY2lmaWVkKSB0ZXh0IGRhdGEgZnJvbVxuICAjIHRoaXMge0RhdGFUcmFuc2Zlcn0gaW5zdGFuY2UuXG4gIGRlZiBjbGVhciAodHlwZT1uaWwpXG4gICAgYCNAbmF0aXZlLmNsZWFyRGF0YSgje3R5cGUudG9fbn0pYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFt3XSBkcmFnX2ltYWdlXG4gICMgU2V0cyBhIGRyYWcgaW1hZ2UgZm9yIHRoaXMge0RhdGFUcmFuc2Zlcn0uIFVzZSBzb21lXG4gICMge0RPTTo6RWxlbWVudDo6SW1hZ2V9IG9yIHtDYW52YXN9IGFzIGEgdmFsdWUuXG4gIGRlZiBkcmFnX2ltYWdlPSAoaW1hZ2UpXG4gICAgYCNAbmF0aXZlLnNldERyYWdJbWFnZSgje05hdGl2ZS5jb252ZXJ0KGltYWdlKX0pYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBmaWxlc1xuICAjIEByZXR1cm4gW0FycmF5PEZpbGU+XSBsaXN0IG9mIGZpbGVzIGF0dGFjaGVkIHRvIHRoaXMge0RhdGFUcmFuc2Zlcn1cbiAgZGVmIGZpbGVzXG4gICAgTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLmZpbGVzYCkubWFwIHsgfGZ8IEZpbGUubmV3KGYudG9fbikgfVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBpdGVtc1xuICAjIEByZXR1cm4gW0FycmF5PEl0ZW0+XSBsaXN0IG9mIGl0ZW1zIGF0dGFjaGVkIHRvIHRoaXMge0RhdGFUcmFuc2Zlcn1cbiAgZGVmIGl0ZW1zXG4gICAgTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLml0ZW1zYCkubWFwIHsgfGl8IEl0ZW0ubmV3KGkudG9fbikgfVxuICBlbmRcblxuICAjIEFuIGluc3RhbmNlIG9mIGBEYXRhVHJhbnNmZXJJdGVtYFxuICBjbGFzcyBJdGVtXG4gICAgaW5jbHVkZSBOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBraW5kXG4gICAgIyBAcmV0dXJuIFtTeW1ib2xdIGtpbmQgb2YgYW4gaXRlbTogOnN0cmluZyBvciA6ZmlsZVxuICAgIGRlZiBraW5kXG4gICAgICBgI0BuYXRpdmUua2luZGBcbiAgICBlbmRcblxuICAgIGRlZiBzdHJpbmc/OyBraW5kID09ICdzdHJpbmcnOyAgICAgICAgICAgZW5kXG4gICAgZGVmIGZpbGU/OyAgIGtpbmQgPT0gJ2ZpbGUnICYmIHRvX2ZpbGU7ICBlbmQgIyBTb21lIGZpbGVzIGNhbid0IGJlIHJlc29sdmVkLi4uXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSB0eXBlXG4gICAgIyBAcmV0dXJuIFtTdHJpbmddIG1pbWUgdHlwZSBvZiBhbiBpdGVtXG4gICAgZGVmIHR5cGVcbiAgICAgIGAjQG5hdGl2ZS50eXBlYFxuICAgIGVuZFxuXG4gICAgIyBDb252ZXJ0IHRvIHN0cmluZyBhbmQgY2FsbCBiYWNrIG9uY2UgcmVhZHksIG9yIHJldHVybiBhXG4gICAgIyBwcm9taXNlIGlmIGEgYmxvY2sgaXNuJ3QgZ2l2ZW4uXG4gICAgZGVmIHRvX3N0cmluZygmYmxvY2spXG4gICAgICBwcm9taXNlID0gbmlsXG4gICAgICBpZiAhYmxvY2tcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UubmV3XG4gICAgICAgIGJsb2NrID0gcHJvYyB7IHxpfCBwcm9taXNlLnJlc29sdmUoaSkgfVxuICAgICAgZW5kXG4gICAgICBgI0BuYXRpdmUuZ2V0QXNTdHJpbmcoI3tibG9jay50b19ufSlgXG4gICAgICByZXR1cm4gcHJvbWlzZVxuICAgIGVuZFxuXG4gICAgIyBDb252ZXJ0IHRvIGZpbGUgb3IgcmV0dXJuIG5pbCBpZiBpbXBvc3NpYmxlXG4gICAgZGVmIHRvX2ZpbGVcbiAgICAgIGFzX2ZpbGUgPSBgI0BuYXRpdmUuZ2V0QXNGaWxlKClgXG4gICAgICBGaWxlLm5ldyhhc19maWxlKSBpZiBhc19maWxlXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIm1vZHVsZSIsImNsYXNzIiwiaW5jbHVkZSIsImVmZmVjdCIsIkBuYXRpdmUiLCJlZmZlY3Q9IiwiW10iLCJ0eXBlIiwiW109IiwiY29udmVydCIsInZhbHVlIiwiY2xlYXIiLCJ0b19uIiwiZHJhZ19pbWFnZT0iLCJpbWFnZSIsImZpbGVzIiwibWFwIiwibmV3IiwiZiIsIml0ZW1zIiwiaSIsImtpbmQiLCJzdHJpbmc/IiwiPT0iLCJmaWxlPyIsInRvX2ZpbGUiLCJ0b19zdHJpbmciLCJwcm9taXNlIiwiYmxvY2siLCIhIiwicHJvYyIsInJlc29sdmUiLCJhc19maWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGNBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFJaEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFlBQUFDLFNBQUFBLENBQVEsbUNBQVJBLENBQUE7QUFBQTtBQUtBQyxRQUFBQSww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QkE7QUFBQSxVQThCQSxPQUFBRCxDQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUFDRSxZQUFBTyxVQUFZNUIsY0FBTyxZQUFuQjtBQUFBLFlBQ0EsSUFBQSxRQUFxQjRCLE9BQXJCLENBQUE7QUFBQSxjQUFBLE9BQUEsb0JBQUFmLEtBQUFBLENBQVNlLE9BQVRmO0FBQUEsWUFBQTtBQUFBO0FBQUEsWUFBQSxDQURBO0FBREZRLFVBQUFBLENBQUFBLDhCQUFBQSxDQUFBQSxtQkE5QkE7QUFERnhCLFFBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBakRBO0FBREZBLE1BQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBSmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NTAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9jb21wb3NpdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQ29tcG9zaXRpb24gPCBVSVxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkNvbXBvc2l0aW9uJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgVUk6OkRlZmluaXRpb25cbiAgICBkZWYgZGF0YT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGF0YSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGxvY2FsZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubG9jYWxlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgQ29tcG9zaXRpb25FdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkNvbXBvc2l0aW9uRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0Q29tcG9zaXRpb25FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy52aWV3IHx8IHdpbmRvdywgZGVzYy5kYXRhLCBkZXNjLmxvY2FsZSk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6ZGF0YVxuICBhbGlhc19uYXRpdmUgOmxvY2FsZVxuXG4gIGRlZiBzdGFydD9cbiAgICBuYW1lLmRvd25jYXNlID09ICdjb21wb3NpdGlvbnN0YXJ0J1xuICBlbmRcblxuICBkZWYgdXBkYXRlP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2NvbXBvc2l0aW9udXBkYXRlJ1xuICBlbmRcblxuICBkZWYgZW5kP1xuICAgIG5hbWUuZG93bmNhc2UgPT0gJ2NvbXBvc2l0aW9uZW5kJ1xuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJkYXRhPSIsIkBuYXRpdmUiLCJ2YWx1ZSIsImxvY2FsZT0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsInN0YXJ0PyIsImRvd25jYXNlIiwiPT0iLCJ1cGRhdGU/IiwiZW5kPyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsZ0NBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLG1CQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEsMkNBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUksVUFBQUEseUJBQUFBLHdCQUFBQSxTQUFVLEtBQVZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sUUFBVUM7QUFEckJGLFVBQUFBLENBQUFBLG1DQUFBQSxDQUFBO0FBQUEsVUFJQSxPQUFBRyxDQUFBQSwyQkFBQUEsMEJBQUFBLFNBQVksS0FBWkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUYsY0FBTyxVQUFZQztBQUR2QkMsVUFBQUEsQ0FBQUEscUNBQUFBLENBQUFBLG1CQUpBO0FBREZQLFFBQUFBLEdBQUFBLFdBQUFBLEVBQW1CLElBQUEsa0JBQUEsZUFBbkJBLFdBSkE7QUFBQSxRQWNBLElBQUEsWUFjT0MsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO0FBQUEsVUFBQSxJQUFBLFFBQUcsdUJBQUFFLGNBQUFBLENBQWtCLG1CQUFsQkEsQ0FBSCxDQUFBO0FBQUEsWUFDRUssVUFBSU4sSUFBSk0sZ0JBQUFBLDJCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUEsY0FDRSxPQUFDLHFCQUF1QkMsSUFBSyxFQUFJQyxJQUFLO0FBRHhDRixZQUFBQSxDQUFBQSxzQ0FBQUE7QUFERixVQUFBLE9BSUEsSUFBQSxRQUFNLHVCQUFBTCxjQUFBQSxDQUFrQixjQUFsQkEsQ0FBTixDQUFBO0FBQUEsWUFDRUssVUFBSU4sSUFBSk0sZ0JBQUFBLDJCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUE7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVBJQSxZQUFBQSxDQUFBQSxzQ0FBQUEsQ0FERixDQUpBLENBZEE7QUFBQSxZQThCQUcsY0FBQUEsQ0FBYSxNQUFiQSxDQTlCQTtBQUFBLFlBK0JBQSxjQUFBQSxDQUFhLFFBQWJBLENBL0JBO0FBQUE7QUFpQ0FDLFFBQUFBLDBCQUFBQSw0QkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsV0FBQUgsTUFBQUEsQ0FBQUEsQ0FBQUksVUFBQUEsQ0FBQUEsQ0FBQUMsT0FBQUEsQ0FBaUIsa0JBQWpCQTtBQURGRixRQUFBQSxDQUFBQSx1Q0FBQUEsQ0FqQ0E7QUFBQTtBQXFDQUcsUUFBQUEsMkJBQUFBLDZCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBTixNQUFBQSxDQUFBQSxDQUFBSSxVQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFpQixtQkFBakJBO0FBREZDLFFBQUFBLENBQUFBLHdDQUFBQSxDQXJDQTtBQUFBLFFBeUNBLE9BQUFDLENBQUFBLHdCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsV0FBQVAsTUFBQUEsQ0FBQUEsQ0FBQUksVUFBQUEsQ0FBQUEsQ0FBQUMsT0FBQUEsQ0FBaUIsZ0JBQWpCQTtBQURGRSxRQUFBQSxDQUFBQSxxQ0FBQUEsQ0FBQUEsZ0JBekNBO0FBREZoQixNQUFBQSxHQUFBQSxXQUFBQSxFQUFvQixrQkFBcEJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTU4OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvYW5pbWF0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBBbmltYXRpb24gPCBFdmVudFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkFuaW1hdGlvbidcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgYW5pbWF0aW9uPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5hbmltYXRpb25OYW1lID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgZWxhcHNlZD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZWxhcHNlZFRpbWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBBbmltYXRpb25FdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkFuaW1hdGlvbkV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEFuaW1hdGlvbkV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLmFuaW1hdGlvbk5hbWUsIGRlc2MuZWxhcHNlZFRpbWUpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOm5hbWUsIDphbmltYXRpb25OYW1lXG4gIGFsaWFzX25hdGl2ZSA6ZWxhcHNlZCwgOmVsYXBzZWRUaW1lXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/IiwiYW5pbWF0aW9uPSIsIkBuYXRpdmUiLCJ2YWx1ZSIsImVsYXBzZWQ9IiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsVUFBSUMsSUFBSkQsaUJBQUFBLDhCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLHVCQUFBRSxjQUFBQSxDQUFrQixpQkFBbEJBO0FBREZGLFFBQUFBLENBQUFBLHlDQUFBQSxDQUFBO0FBQUEsUUFJQUQ7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFO0FBQUFJLFVBQUFBLDhCQUFBQSw2QkFBQUEsU0FBZSxLQUFmQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFQyxjQUFPLGlCQUFtQkM7QUFEOUJGLFVBQUFBLENBQUFBLHdDQUFBQSxDQUFBO0FBQUEsVUFJQSxPQUFBRyxDQUFBQSw0QkFBQUEsMkJBQUFBLFNBQWEsS0FBYkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUYsY0FBTyxlQUFpQkM7QUFENUJDLFVBQUFBLENBQUFBLHNDQUFBQSxDQUFBQSxvQkFKQTtBQURGUCxRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQWNBLElBQUEsWUFjT0MsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO0FBQUEsVUFBQSxJQUFBLFFBQUcsdUJBQUFFLGNBQUFBLENBQWtCLG1CQUFsQkEsQ0FBSCxDQUFBO0FBQUEsWUFDRUssVUFBSU4sSUFBSk0sZ0JBQUFBLHlCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUEsY0FDRSxPQUFDLG1CQUFxQkMsSUFBSyxFQUFJQyxJQUFLO0FBRHRDRixZQUFBQSxDQUFBQSxvQ0FBQUE7QUFERixVQUFBLE9BSUEsSUFBQSxRQUFNLHVCQUFBTCxjQUFBQSxDQUFrQixjQUFsQkEsQ0FBTixDQUFBO0FBQUEsWUFDRUssVUFBSU4sSUFBSk0sZ0JBQUFBLHlCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUE7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVBJQSxZQUFBQSxDQUFBQSxvQ0FBQUEsQ0FERixDQUpBLENBZEE7QUFBQSxZQThCQUcsY0FBQUEsQ0FBYSxRQUFPLGVBQXBCQSxDQTlCQTtBQUFBLFFBK0JBLFdBQUFBLGNBQUFBLENBQWEsV0FBVSxhQUF2QkEsQ0EvQkE7QUFERlgsTUFBQUEsR0FBQUEsV0FBQUEsRUFBa0IscUJBQWxCQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk2NjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2F1ZGlvX3Byb2Nlc3NpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEF1ZGlvUHJvY2Vzc2luZyA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuQXVkaW9Qcm9jZXNzaW5nJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiB0aW1lPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5wbGF5YmFja1RpbWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBpbnB1dD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuaW5wdXRCdWZmZXIgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBvdXRwdXQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLm91dHB1dEJ1ZmZlciA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IEF1ZGlvUHJvY2Vzc2luZ0V2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6dGltZSwgOnBsYXliYWNrVGltZVxuICBhbGlhc19uYXRpdmUgOmlucHV0LCA6aW5wdXRCdWZmZXJcbiAgYWxpYXNfbmF0aXZlIDpvdXRwdXQsIDpvdXRwdXRCdWZmZXJcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJ0aW1lPSIsIkBuYXRpdmUiLCJ2YWx1ZSIsImlucHV0PSIsIm91dHB1dD0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsb0NBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLHVCQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEsK0NBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUksVUFBQUEseUJBQUFBLHdCQUFBQSxTQUFVLEtBQVZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sZ0JBQWtCQztBQUQ3QkYsVUFBQUEsQ0FBQUEsbUNBQUFBLENBQUE7QUFBQTtBQUlBRyxVQUFBQSwwQkFBQUEseUJBQUFBLFNBQVcsS0FBWEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUYsY0FBTyxlQUFpQkM7QUFENUJDLFVBQUFBLENBQUFBLG9DQUFBQSxDQUpBO0FBQUEsVUFRQSxPQUFBQyxDQUFBQSwyQkFBQUEsMEJBQUFBLFNBQVksS0FBWkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUgsY0FBTyxnQkFBa0JDO0FBRDdCRSxVQUFBQSxDQUFBQSxxQ0FBQUEsQ0FBQUEsbUJBUkE7QUFERlIsUUFBQUEsR0FBQUEsV0FBQUEsRUFBbUIsMEJBQW5CQSxXQUpBO0FBQUEsUUFrQkEsSUFBQSxZQUlPQyxlQUFBQSxDQUFBQSxDQUpQLENBQUE7QUFBQSxVQUFBLElBQUEsUUFBRyx1QkFBQUUsY0FBQUEsQ0FBa0IsbUJBQWxCQSxDQUFILENBQUE7QUFBQSxZQUNFTSxVQUFJUCxJQUFKTyxnQkFBQUEsK0JBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQSxjQUNFLE9BQUMseUJBQTJCQyxJQUFLLEVBQUlDLElBQUs7QUFENUNGLFlBQUFBLENBQUFBLDBDQUFBQSxDQURGLENBQUEsQ0FsQkE7QUFBQSxZQXdCQUcsY0FBQUEsQ0FBYSxRQUFPLGNBQXBCQSxDQXhCQTtBQUFBLFlBeUJBQSxjQUFBQSxDQUFhLFNBQVEsYUFBckJBLENBekJBO0FBQUEsUUEwQkEsV0FBQUEsY0FBQUEsQ0FBYSxVQUFTLGNBQXRCQSxDQTFCQTtBQURGWixNQUFBQSxHQUFBQSxXQUFBQSxFQUF3QixxQkFBeEJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTcyNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvYmVmb3JlX3VubG9hZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQmVmb3JlVW5sb2FkIDwgRXZlbnRcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5CZWZvcmVVbmxvYWQnXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgQmVmb3JlVW5sb2FkRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/IiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsVUFBSUMsSUFBSkQsaUJBQUFBLGlDQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLHVCQUFBRSxjQUFBQSxDQUFrQixvQkFBbEJBO0FBREZGLFFBQUFBLENBQUFBLDRDQUFBQSxDQUFBO0FBQUEsUUFJQSxJQUFBLFlBSU9BLGVBQUFBLENBQUFBLENBSlAsQ0FBQTtBQUFBLFVBQUEsSUFBQSxRQUFHLHVCQUFBRSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUgsQ0FBQTtBQUFBLFlBQ0UsT0FBQUMsQ0FBQUEsVUFBSUYsSUFBSkUsZ0JBQUFBLDRCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUEsY0FDRSxPQUFDLHNCQUF3QkMsSUFBSyxFQUFJQyxJQUFLO0FBRHpDRixZQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQUE7QUFERixVQUFBO0FBQUE7QUFBQSxVQUFBO0FBQUEsUUFBQTtBQUFBO0FBQUEsUUFBQSxDQUpBO0FBREZKLE1BQUFBLEdBQUFBLFdBQUFBLEVBQXFCLHFCQUFyQkE7QUFGZ0JBLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQWhCRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NzcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9jbGlwYm9hcmQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIENsaXBib2FyZCA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuQ2xpcGJvYXJkJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBkYXRhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kYXRhID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgdHlwZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGF0YVR5cGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBDbGlwYm9hcmRFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmRhdGFcbiAgYWxpYXNfbmF0aXZlIDp0eXBlLCA6ZGF0YVR5cGVcblxuICAjIFJldHVybnMgYSB7RGF0YVRyYW5zZmVyfSByZWxhdGVkIHRvIHRoaXMgZXZlbnRcbiAgI1xuICAjIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RhdGFUcmFuc2ZlclxuICBkZWYgdHJhbnNmZXJcbiAgICBEYXRhVHJhbnNmZXIubmV3KGAjQG5hdGl2ZS5jbGlwYm9hcmREYXRhYClcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/IiwiZGF0YT0iLCJAbmF0aXZlIiwidmFsdWUiLCJ0eXBlPSIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIiwidHJhbnNmZXIiLCJuZXciXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsUUFBQUMsVUFBSUMsSUFBSkQsaUJBQUFBLDhCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLHVCQUFBRSxjQUFBQSxDQUFrQixpQkFBbEJBO0FBREZGLFFBQUFBLENBQUFBLHlDQUFBQSxDQUFBO0FBQUEsUUFJQUQ7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFO0FBQUFJLFVBQUFBLHlCQUFBQSx3QkFBQUEsU0FBVSxLQUFWQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFQyxjQUFPLFFBQVVDO0FBRHJCRixVQUFBQSxDQUFBQSxtQ0FBQUEsQ0FBQTtBQUFBLFVBSUEsT0FBQUcsQ0FBQUEseUJBQUFBLHdCQUFBQSxTQUFVLEtBQVZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVGLGNBQU8sWUFBY0M7QUFEekJDLFVBQUFBLENBQUFBLG1DQUFBQSxDQUFBQSxpQkFKQTtBQURGUCxRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQWNBLElBQUEsWUFJT0MsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO0FBQUEsVUFBQSxJQUFBLFFBQUcsdUJBQUFFLGNBQUFBLENBQWtCLG1CQUFsQkEsQ0FBSCxDQUFBO0FBQUEsWUFDRUssVUFBSU4sSUFBSk0sZ0JBQUFBLHlCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUEsY0FDRSxPQUFDLG1CQUFxQkMsSUFBSyxFQUFJQyxJQUFLO0FBRHRDRixZQUFBQSxDQUFBQSxvQ0FBQUEsQ0FERixDQUFBLENBZEE7QUFBQSxZQW9CQUcsY0FBQUEsQ0FBYSxNQUFiQSxDQXBCQTtBQUFBLFlBcUJBQSxjQUFBQSxDQUFhLFFBQU8sVUFBcEJBLENBckJBO0FBQUEsUUEwQkEsT0FBQUMsQ0FBQUEsNEJBQUFBLHdCQUFBQSxvQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSw0QkFBQUMsS0FBQUEsQ0FBbUJSLGNBQU8sY0FBMUJRO0FBREZELFFBQUFBLENBQUFBLG1DQUFBQSxDQUFBQSxvQkExQkE7QUFERlosTUFBQUEsR0FBQUEsV0FBQUEsRUFBa0IscUJBQWxCQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk4MzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RldmljZV9saWdodC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgRGV2aWNlTGlnaHQgPCBFdmVudFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRldmljZUxpZ2h0J1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiB2YWx1ZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudmFsdWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBEZXZpY2VMaWdodEV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6dmFsdWVcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJ2YWx1ZT0iLCJAbmF0aXZlIiwidmFsdWUiLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsZ0NBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLG1CQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEsMkNBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBLFVBQ0UsT0FBQUksQ0FBQUEsMEJBQUFBLHlCQUFBQSxTQUFXLEtBQVhBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sU0FBV0M7QUFEdEJGLFVBQUFBLENBQUFBLG9DQUFBQSxDQUFBQTtBQURGSixRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQVVBLElBQUEsWUFJT0MsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO0FBQUEsVUFBQSxJQUFBLFFBQUcsdUJBQUFFLGNBQUFBLENBQWtCLG1CQUFsQkEsQ0FBSCxDQUFBO0FBQUEsWUFDRUksVUFBSUwsSUFBSkssZ0JBQUFBLDJCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUEsY0FDRSxPQUFDLHFCQUF1QkMsSUFBSyxFQUFJQyxJQUFLO0FBRHhDRixZQUFBQSxDQUFBQSxzQ0FBQUEsQ0FERixDQUFBLENBVkE7QUFBQSxRQWdCQSxXQUFBRyxjQUFBQSxDQUFhLE9BQWJBLENBaEJBO0FBREZWLE1BQUFBLEdBQUFBLFdBQUFBLEVBQW9CLHFCQUFwQkE7QUFGZ0JBLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQWhCRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5ODg2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9kZXZpY2VfbW90aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBEZXZpY2VNb3Rpb24gPCBFdmVudFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRldmljZU1vdGlvbidcbiAgZW5kXG5cbiAgQWNjZWxlcmF0aW9uID0gU3RydWN0Lm5ldyg6eCwgOnksIDp6KVxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGFjY2VsZXJhdGlvbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYWNjZWxlcmF0aW9uID0gI3t2YWx1ZS50b19ufWBcbiAgICBlbmRcblxuICAgIGRlZiBhY2NlbGVyYXRpb25fd2l0aF9ncmF2aXR5PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5ID0gI3t2YWx1ZS50b19ufWBcbiAgICBlbmRcblxuICAgIGRlZiByb3RhdGlvbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUucm90YXRpb25SYXRlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgaW50ZXJ2YWw9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmludGVydmFsID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRGV2aWNlTW90aW9uRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJEZXZpY2VNb3Rpb25FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXREZXZpY2VNb3Rpb25FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy5hY2NlbGVyYXRpb24sIGRlc2MuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSxcbiAgICAgICAgICAgICAgZGVzYy5yb3RhdGlvblJhdGUsIGRlc2MuaW50ZXJ2YWwpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFjY2VsZXJhdGlvblxuICBhbGlhc19uYXRpdmUgOmFjY2VsZXJhdGlvbl93aXRoX2dyYXZpdHksIDphY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5XG4gIGFsaWFzX25hdGl2ZSA6cm90YXRpb24sIDpyb3RhdGlvblJhdGVcbiAgYWxpYXNfbmF0aXZlIDppbnRlcnZhbFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsInN1cHBvcnRzPyIsIm5ldyIsImFjY2VsZXJhdGlvbj0iLCJAbmF0aXZlIiwidmFsdWUiLCJ0b19uIiwiYWNjZWxlcmF0aW9uX3dpdGhfZ3Jhdml0eT0iLCJyb3RhdGlvbj0iLCJpbnRlcnZhbD0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsaUNBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLG9CQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEsNENBQUFBLENBQUE7QUFBQSxRQUlBLDRDQUFlLHNCQUFBRyxLQUFBQSxDQUFXLEtBQUksS0FBSSxHQUFuQkEsQ0FBZixDQUpBO0FBQUEsUUFNQUo7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFO0FBQUFLLFVBQUFBLGlDQUFBQSxnQ0FBQUEsU0FBa0IsS0FBbEJBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sZ0JBQWtCQyxLQUFBQyxNQUFBQSxDQUFBQTtBQUQ3QkgsVUFBQUEsQ0FBQUEsMkNBQUFBLENBQUE7QUFBQTtBQUlBSSxVQUFBQSw4Q0FBQUEsNkNBQUFBLFNBQStCLEtBQS9CQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFSCxjQUFPLGdDQUFrQ0MsS0FBQUMsTUFBQUEsQ0FBQUE7QUFEN0NDLFVBQUFBLENBQUFBLHdEQUFBQSxDQUpBO0FBQUE7QUFRQUMsVUFBQUEsNkJBQUFBLDRCQUFBQSxTQUFjLEtBQWRBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVKLGNBQU8sZ0JBQWtCQztBQUQ3QkcsVUFBQUEsQ0FBQUEsdUNBQUFBLENBUkE7QUFBQSxVQVlBLE9BQUFDLENBQUFBLDZCQUFBQSw0QkFBQUEsU0FBYyxLQUFkQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFTCxjQUFPLFlBQWNDO0FBRHpCSSxVQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQUEscUJBWkE7QUFERlgsUUFBQUEsR0FBQUEsV0FBQUEsRUFBbUIsMEJBQW5CQSxXQU5BO0FBQUEsUUF3QkEsSUFBQSxZQWVPQyxlQUFBQSxDQUFBQSxDQWZQLENBQUE7QUFBQSxVQUFBLElBQUEsUUFBRyx1QkFBQUUsY0FBQUEsQ0FBa0IsbUJBQWxCQSxDQUFILENBQUE7QUFBQSxZQUNFUyxVQUFJVixJQUFKVSxnQkFBQUEsNEJBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQSxjQUNFLE9BQUMsc0JBQXdCQyxJQUFLLEVBQUlDLElBQUs7QUFEekNGLFlBQUFBLENBQUFBLHVDQUFBQTtBQURGLFVBQUEsT0FJQSxJQUFBLFFBQU0sdUJBQUFULGNBQUFBLENBQWtCLGNBQWxCQSxDQUFOLENBQUE7QUFBQSxZQUNFUyxVQUFJVixJQUFKVSxnQkFBQUEsNEJBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQTtBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFSSUEsWUFBQUEsQ0FBQUEsdUNBQUFBLENBREYsQ0FKQSxDQXhCQTtBQUFBLFlBeUNBRyxjQUFBQSxDQUFhLGNBQWJBLENBekNBO0FBQUEsWUEwQ0FBLGNBQUFBLENBQWEsNkJBQTRCLDhCQUF6Q0EsQ0ExQ0E7QUFBQSxZQTJDQUEsY0FBQUEsQ0FBYSxZQUFXLGNBQXhCQSxDQTNDQTtBQUFBLFFBNENBLFdBQUFBLGNBQUFBLENBQWEsVUFBYkEsQ0E1Q0E7QUFERmYsTUFBQUEsR0FBQUEsV0FBQUEsRUFBcUIscUJBQXJCQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk5NzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RldmljZV9vcmllbnRhdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgRGV2aWNlT3JpZW50YXRpb24gPCBFdmVudFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRldmljZU9yaWVudGF0aW9uJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBhYnNvbHV0ZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYWJzb2x1dGUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBhbHBoYT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuYWxwaGEgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBiZXRhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5iZXRhID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgZ2FtbWE9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmdhbW1hID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRGV2aWNlT3JpZW50YXRpb25FdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkRldmljZU9yaWVudGF0aW9uRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0RGV2aWNlT3JpZW50YXRpb25FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy5hbHBoYSwgZGVzYy5iZXRhLCBkZXNjLmdhbW1hLCBkZXNjLmFic29sdXRlKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDphYnNvbHV0ZVxuICBhbGlhc19uYXRpdmUgOmFscGhhXG4gIGFsaWFzX25hdGl2ZSA6YmV0YVxuICBhbGlhc19uYXRpdmUgOmdhbW1hXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/IiwiYWJzb2x1dGU9IiwiQG5hdGl2ZSIsInZhbHVlIiwiYWxwaGE9IiwiYmV0YT0iLCJnYW1tYT0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsc0NBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLHlCQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEsaURBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUksVUFBQUEsNkJBQUFBLDRCQUFBQSxTQUFjLEtBQWRBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sWUFBY0M7QUFEekJGLFVBQUFBLENBQUFBLHVDQUFBQSxDQUFBO0FBQUE7QUFJQUcsVUFBQUEsMEJBQUFBLHlCQUFBQSxTQUFXLEtBQVhBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVGLGNBQU8sU0FBV0M7QUFEdEJDLFVBQUFBLENBQUFBLG9DQUFBQSxDQUpBO0FBQUE7QUFRQUMsVUFBQUEseUJBQUFBLHdCQUFBQSxTQUFVLEtBQVZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVILGNBQU8sUUFBVUM7QUFEckJFLFVBQUFBLENBQUFBLG1DQUFBQSxDQVJBO0FBQUEsVUFZQSxPQUFBQyxDQUFBQSwwQkFBQUEseUJBQUFBLFNBQVcsS0FBWEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUosY0FBTyxTQUFXQztBQUR0QkcsVUFBQUEsQ0FBQUEsb0NBQUFBLENBQUFBLGtCQVpBO0FBREZULFFBQUFBLEdBQUFBLFdBQUFBLEVBQW1CLDBCQUFuQkEsV0FKQTtBQUFBLFFBc0JBLElBQUEsWUFjT0MsZUFBQUEsQ0FBQUEsQ0FkUCxDQUFBO0FBQUEsVUFBQSxJQUFBLFFBQUcsdUJBQUFFLGNBQUFBLENBQWtCLG1CQUFsQkEsQ0FBSCxDQUFBO0FBQUEsWUFDRU8sVUFBSVIsSUFBSlEsZ0JBQUFBLGlDQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUEsY0FDRSxPQUFDLDJCQUE2QkMsSUFBSyxFQUFJQyxJQUFLO0FBRDlDRixZQUFBQSxDQUFBQSw0Q0FBQUE7QUFERixVQUFBLE9BSUEsSUFBQSxRQUFNLHVCQUFBUCxjQUFBQSxDQUFrQixjQUFsQkEsQ0FBTixDQUFBO0FBQUEsWUFDRU8sVUFBSVIsSUFBSlEsZ0JBQUFBLGlDQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUE7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVBJQSxZQUFBQSxDQUFBQSw0Q0FBQUEsQ0FERixDQUpBLENBdEJBO0FBQUEsWUFzQ0FHLGNBQUFBLENBQWEsVUFBYkEsQ0F0Q0E7QUFBQSxZQXVDQUEsY0FBQUEsQ0FBYSxPQUFiQSxDQXZDQTtBQUFBLFlBd0NBQSxjQUFBQSxDQUFhLE1BQWJBLENBeENBO0FBQUEsUUF5Q0EsV0FBQUEsY0FBQUEsQ0FBYSxPQUFiQSxDQXpDQTtBQURGYixNQUFBQSxHQUFBQSxXQUFBQSxFQUEwQixxQkFBMUJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDA1OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZGV2aWNlX3Byb3hpbWl0eS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgRGV2aWNlUHJveGltaXR5IDwgRXZlbnRcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5EZXZpY2VQcm94aW1pdHknXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIHZhbHVlPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS52YWx1ZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG1pbj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubWluID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgbWF4PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5tYXggPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBEZXZpY2VQcm94aW1pdHlFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOnZhbHVlXG4gIGFsaWFzX25hdGl2ZSA6bWluXG4gIGFsaWFzX25hdGl2ZSA6bWF4XG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/IiwidmFsdWU9IiwiQG5hdGl2ZSIsInZhbHVlIiwibWluPSIsIm1heD0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsb0NBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLHVCQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEsK0NBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUksVUFBQUEsMEJBQUFBLHlCQUFBQSxTQUFXLEtBQVhBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sU0FBV0M7QUFEdEJGLFVBQUFBLENBQUFBLG9DQUFBQSxDQUFBO0FBQUE7QUFJQUcsVUFBQUEsd0JBQUFBLHVCQUFBQSxTQUFTLEtBQVRBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVGLGNBQU8sT0FBU0M7QUFEcEJDLFVBQUFBLENBQUFBLGtDQUFBQSxDQUpBO0FBQUEsVUFRQSxPQUFBQyxDQUFBQSx3QkFBQUEsdUJBQUFBLFNBQVMsS0FBVEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUgsY0FBTyxPQUFTQztBQURwQkUsVUFBQUEsQ0FBQUEsa0NBQUFBLENBQUFBLGdCQVJBO0FBREZSLFFBQUFBLEdBQUFBLFdBQUFBLEVBQW1CLDBCQUFuQkEsV0FKQTtBQUFBLFFBa0JBLElBQUEsWUFJT0MsZUFBQUEsQ0FBQUEsQ0FKUCxDQUFBO0FBQUEsVUFBQSxJQUFBLFFBQUcsdUJBQUFFLGNBQUFBLENBQWtCLG1CQUFsQkEsQ0FBSCxDQUFBO0FBQUEsWUFDRU0sVUFBSVAsSUFBSk8sZ0JBQUFBLCtCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUEsY0FDRSxPQUFDLHlCQUEyQkMsSUFBSyxFQUFJQyxJQUFLO0FBRDVDRixZQUFBQSxDQUFBQSwwQ0FBQUEsQ0FERixDQUFBLENBbEJBO0FBQUEsWUF3QkFHLGNBQUFBLENBQWEsT0FBYkEsQ0F4QkE7QUFBQSxZQXlCQUEsY0FBQUEsQ0FBYSxLQUFiQSxDQXpCQTtBQUFBLFFBMEJBLFdBQUFBLGNBQUFBLENBQWEsS0FBYkEsQ0ExQkE7QUFERlosTUFBQUEsR0FBQUEsV0FBQUEsRUFBd0IscUJBQXhCQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzAxMjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2RyYWcucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIERyYWcgPCBFdmVudFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkRyYWcnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgY2xhc3MgQ2xpZW50XG4gICAgICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gICAgICBkZWYgeD0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5jbGllbnRYID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcblxuICAgICAgZGVmIHk9KHZhbHVlKVxuICAgICAgICBgI0BuYXRpdmUuY2xpZW50WSA9ICN7dmFsdWV9YFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjbGFzcyBTY3JlZW5cbiAgICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICAgIGRlZiB4PSh2YWx1ZSlcbiAgICAgICAgYCNAbmF0aXZlLnNjcmVlblggPSAje3ZhbHVlfWBcbiAgICAgIGVuZFxuXG4gICAgICBkZWYgeT0odmFsdWUpXG4gICAgICAgIGAjQG5hdGl2ZS5zY3JlZW5ZID0gI3t2YWx1ZX1gXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBhbHQhXG4gICAgICBgI0BuYXRpdmUuYWx0S2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBjdHJsIVxuICAgICAgYCNAbmF0aXZlLmN0cmxLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIG1ldGEhXG4gICAgICBgI0BuYXRpdmUubWV0YUtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgYnV0dG9uPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5idXR0b24gPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBjbGllbnRcbiAgICAgIENsaWVudC5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiBzY3JlZW5cbiAgICAgIFNjcmVlbi5uZXcoQG5hdGl2ZSlcbiAgICBlbmRcblxuICAgIGRlZiByZWxhdGVkPShlbGVtKVxuICAgICAgYCNAbmF0aXZlLnJlbGF0ZWRUYXJnZXQgPSAje05hdGl2ZS5jb252ZXJ0KGVsZW0pfWBcbiAgICBlbmRcblxuICAgIGRlZiB0cmFuc2Zlcj0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuZGF0YVRyYW5zZmVyID0gI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IERyYWdFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkRyYWdFdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXREcmFnRXZlbnQobmFtZSwgZGVzYy5idWJibGVzLCBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgICAgICAgIGRlc2MudmlldyB8fCB3aW5kb3csIDAsXG4gICAgICAgICAgICAgIGRlc2Muc2NyZWVuWCB8fCAwLCBkZXNjLnNjcmVlblkgfHwgMCxcbiAgICAgICAgICAgICAgZGVzYy5jbGllbnRYIHx8IDAsIGRlc2MuY2xpZW50WSB8fCAwLFxuICAgICAgICAgICAgICBkZXNjLmN0cmxLZXksIGRlc2MuYWx0S2V5LCBkZXNjLnNoaWZ0S2V5LCBkZXNjLm1ldGFLZXksXG4gICAgICAgICAgICAgIGRlc2MuYnV0dG9uIHx8IDAsIGRlc2MucmVsYXRlZFRhcmdldCwgZGVzYy5kYXRhVHJhbnNmZXIpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOmFsdD8sIDphbHRLZXlcbiAgYWxpYXNfbmF0aXZlIDpjdHJsPywgOmN0cmxLZXlcbiAgYWxpYXNfbmF0aXZlIDptZXRhPywgOm1ldGFLZXlcbiAgYWxpYXNfbmF0aXZlIDpzaGlmdD8sIDpzaGlmdEtleVxuICBhbGlhc19uYXRpdmUgOmJ1dHRvblxuXG4gIGRlZiBjbGllbnRcbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLmNsaWVudFhgLCBgI0BuYXRpdmUuY2xpZW50WWApXG4gIGVuZFxuXG4gIGRlZiBzY3JlZW5cbiAgICBQb3NpdGlvbi5uZXcoYCNAbmF0aXZlLnNjcmVlblhgLCBgI0BuYXRpdmUuc2NyZWVuWWApIGlmIGRlZmluZWQ/KGAjQG5hdGl2ZS5zY3JlZW5YYClcbiAgZW5kXG5cbiAgZGVmIHhcbiAgICBzY3JlZW4ueFxuICBlbmRcblxuICBkZWYgeVxuICAgIHNjcmVlbi55XG4gIGVuZFxuXG4gIGRlZiByZWxhdGVkXG4gICAgRE9NKGAjQG5hdGl2ZS5yZWxhdGVkVGFyZ2V0YClcbiAgZW5kXG5cbiAgIyBSZXR1cm5zIGEge0RhdGFUcmFuc2Zlcn0gcmVsYXRlZCB0byB0aGlzIGV2ZW50XG4gICNcbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9EYXRhVHJhbnNmZXJcbiAgZGVmIHRyYW5zZmVyXG4gICAgRGF0YVRyYW5zZmVyLm5ldyhgI0BuYXRpdmUuZGF0YVRyYW5zZmVyYClcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/IiwiaW5jbHVkZSIsIng9IiwiQG5hdGl2ZSIsInZhbHVlIiwieT0iLCJhbHQhIiwiY3RybCEiLCJtZXRhISIsImJ1dHRvbj0iLCJjbGllbnQiLCJuZXciLCJzY3JlZW4iLCJyZWxhdGVkPSIsImNvbnZlcnQiLCJlbGVtIiwidHJhbnNmZXI9IiwiY29uc3RydWN0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LG9CQUFBQSxvQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSw0QkFBQWQsS0FBQUEsQ0FBbUJSLGNBQU8sYUFBMUJRO0FBREZjLFFBQUFBLENBQUFBLCtCQUFBQSxDQUFBQSxvQkEvR0E7QUFERjVCLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWEscUJBQWJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDMxOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvZ2FtZXBhZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgR2FtZXBhZCA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuR2FtZXBhZCdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgaWQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmlkID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgaW5kZXg9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmluZGV4ID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgYXQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnRpbWVzdGFtcCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGF4ZXM9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmF4ZXMgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBidXR0b25zPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5idXR0b25zID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGByZXR1cm4gbmV3IEdhbWVwYWRFdmVudCgje25hbWV9LCB7XG4gICAgICAgIGJ1YmJsZXM6ICAgIGRlc2MuYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICBnYW1lcGFkOiAgICBkZXNjIH0pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGRlZiBpZFxuICAgIGAjQG5hdGl2ZS5nYW1lcGFkLmlkYFxuICBlbmRcblxuICBkZWYgaW5kZXhcbiAgICBgI0BuYXRpdmUuZ2FtZXBhZC5pbmRleGBcbiAgZW5kXG5cbiAgZGVmIGF0XG4gICAgYCNAbmF0aXZlLmdhbWVwYWQudGltZXN0YW1wYFxuICBlbmRcblxuICBkZWYgYXhlc1xuICAgIGAjQG5hdGl2ZS5nYW1lcGFkLmF4ZXNgXG4gIGVuZFxuXG4gIGRlZiBidXR0b25zXG4gICAgYCNAbmF0aXZlLmdhbWVwYWQuYnV0dG9uc2BcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/IiwiaWQ9IiwiQG5hdGl2ZSIsInZhbHVlIiwiaW5kZXg9IiwiYXQ9IiwiYXhlcz0iLCJidXR0b25zPSIsImNvbnN0cnVjdCIsIm5hbWUiLCJpZCIsImluZGV4IiwiYXQiLCJheGVzIiwiYnV0dG9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsNEJBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLGVBQWxCQTtBQURGRixRQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQTtBQUFBLFFBSUFEO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFDRTtBQUFBSSxVQUFBQSx1QkFBQUEsc0JBQUFBLFNBQVEsS0FBUkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTyxNQUFRQztBQURuQkYsVUFBQUEsQ0FBQUEsaUNBQUFBLENBQUE7QUFBQTtBQUlBRyxVQUFBQSwwQkFBQUEseUJBQUFBLFNBQVcsS0FBWEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUYsY0FBTyxTQUFXQztBQUR0QkMsVUFBQUEsQ0FBQUEsb0NBQUFBLENBSkE7QUFBQTtBQVFBQyxVQUFBQSx1QkFBQUEsc0JBQUFBLFNBQVEsS0FBUkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUgsY0FBTyxhQUFlQztBQUQxQkUsVUFBQUEsQ0FBQUEsaUNBQUFBLENBUkE7QUFBQTtBQVlBQyxVQUFBQSx5QkFBQUEsd0JBQUFBLFNBQVUsS0FBVkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUosY0FBTyxRQUFVQztBQURyQkcsVUFBQUEsQ0FBQUEsbUNBQUFBLENBWkE7QUFBQSxVQWdCQSxPQUFBQyxDQUFBQSw0QkFBQUEsMkJBQUFBLFNBQWEsS0FBYkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUwsY0FBTyxXQUFhQztBQUR4QkksVUFBQUEsQ0FBQUEsc0NBQUFBLENBQUFBLG9CQWhCQTtBQURGVixRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQTBCQSxJQUFBLFlBT09DLGVBQUFBLENBQUFBLENBUFAsQ0FBQTtBQUFBLFVBQUEsSUFBQSxRQUFHLHVCQUFBRSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUgsQ0FBQTtBQUFBLFlBQ0VRLFVBQUlULElBQUpTLGdCQUFBQSx1QkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsY0FBQUE7O0FBQUFBLGNBQ0csd0JBQTBCQyxJQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUpJRCxZQUFBQSxDQUFBQSxrQ0FBQUEsQ0FERixDQUFBLENBMUJBO0FBQUE7QUFtQ0FFLFFBQUFBLHNCQUFBQSxnQkFBQUEsY0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBRVIsY0FBTztBQURYUSxRQUFBQSxDQUFBQSwyQkFBQUEsQ0FuQ0E7QUFBQTtBQXVDQUMsUUFBQUEseUJBQUFBLG1CQUFBQSxpQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBRVQsY0FBTztBQURYUyxRQUFBQSxDQUFBQSw4QkFBQUEsQ0F2Q0E7QUFBQTtBQTJDQUMsUUFBQUEsc0JBQUFBLGlCQUFBQSxjQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFFVixjQUFPO0FBRFhVLFFBQUFBLENBQUFBLDRCQUFBQSxDQTNDQTtBQUFBO0FBK0NBQyxRQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFFWCxjQUFPO0FBRFhXLFFBQUFBLENBQUFBLDhCQUFBQSxDQS9DQTtBQUFBLFFBbURBLE9BQUFDLENBQUFBLDJCQUFBQSxzQkFBQUEsbUJBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUVaLGNBQU87QUFEWFksUUFBQUEsQ0FBQUEsaUNBQUFBLENBQUFBLG1CQW5EQTtBQURGakIsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IscUJBQWhCQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzA0MjYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L2hhc2hfY2hhbmdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBIYXNoQ2hhbmdlIDwgRXZlbnRcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5IYXNoQ2hhbmdlJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBvbGQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLm9sZFVSTCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG5ldz0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubmV3VVJMID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgSGFzaENoYW5nZUV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6b2xkLCA6b2xkVVJMXG4gIGFsaWFzX25hdGl2ZSA6bmV3LCA6bmV3VVJMXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/Iiwib2xkPSIsIkBuYXRpdmUiLCJ2YWx1ZSIsIm5ldz0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsK0JBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLGtCQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEsMENBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUksVUFBQUEsd0JBQUFBLHVCQUFBQSxTQUFTLEtBQVRBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sVUFBWUM7QUFEdkJGLFVBQUFBLENBQUFBLGtDQUFBQSxDQUFBO0FBQUEsVUFJQSxPQUFBRyxDQUFBQSx3QkFBQUEsdUJBQUFBLFNBQVMsS0FBVEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUYsY0FBTyxVQUFZQztBQUR2QkMsVUFBQUEsQ0FBQUEsa0NBQUFBLENBQUFBLGdCQUpBO0FBREZQLFFBQUFBLEdBQUFBLFdBQUFBLEVBQW1CLDBCQUFuQkEsV0FKQTtBQUFBLFFBY0EsSUFBQSxZQUlPQyxlQUFBQSxDQUFBQSxDQUpQLENBQUE7QUFBQSxVQUFBLElBQUEsUUFBRyx1QkFBQUUsY0FBQUEsQ0FBa0IsbUJBQWxCQSxDQUFILENBQUE7QUFBQSxZQUNFSyxVQUFJTixJQUFKTSxnQkFBQUEsMEJBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQSxjQUNFLE9BQUMsb0JBQXNCQyxJQUFLLEVBQUlDLElBQUs7QUFEdkNGLFlBQUFBLENBQUFBLHFDQUFBQSxDQURGLENBQUEsQ0FkQTtBQUFBLFlBb0JBRyxjQUFBQSxDQUFhLE9BQU0sUUFBbkJBLENBcEJBO0FBQUEsUUFxQkEsV0FBQUEsY0FBQUEsQ0FBYSxPQUFNLFFBQW5CQSxDQXJCQTtBQURGWCxNQUFBQSxHQUFBQSxXQUFBQSxFQUFtQixxQkFBbkJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDQ4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvcHJvZ3Jlc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIFByb2dyZXNzIDwgRXZlbnRcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5Qcm9ncmVzcydcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgY29tcHV0YWJsZT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUuY29tcHV0YWJsZUxlbmd0aCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIGxvYWRlZD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUubG9hZGVkID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgdG90YWw9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnRvdGFsID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgUHJvZ3Jlc3NFdmVudCgje25hbWV9LCAje2Rlc2N9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZSdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgICV4e1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIlByb2dyZXNzRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0UHJvZ3Jlc3NFdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSxcbiAgICAgICAgICAgICAgZGVzYy5jb21wdXRhYmxlLCBkZXNjLmxvYWRlZCwgZGVzYy50b3RhbCk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6Y29tcHV0YWJsZT8sIDpjb21wdXRhYmxlTGVuZ3RoXG4gIGFsaWFzX25hdGl2ZSA6bG9hZGVkXG4gIGFsaWFzX25hdGl2ZSA6dG90YWxcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJjb21wdXRhYmxlPSIsIkBuYXRpdmUiLCJ2YWx1ZSIsImxvYWRlZD0iLCJ0b3RhbD0iLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsNkJBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLGdCQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEsd0NBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUksVUFBQUEsK0JBQUFBLDhCQUFBQSxTQUFnQixLQUFoQkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTyxvQkFBc0JDO0FBRGpDRixVQUFBQSxDQUFBQSx5Q0FBQUEsQ0FBQTtBQUFBO0FBSUFHLFVBQUFBLDJCQUFBQSwwQkFBQUEsU0FBWSxLQUFaQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFRixjQUFPLFVBQVlDO0FBRHZCQyxVQUFBQSxDQUFBQSxxQ0FBQUEsQ0FKQTtBQUFBLFVBUUEsT0FBQUMsQ0FBQUEsMEJBQUFBLHlCQUFBQSxTQUFXLEtBQVhBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVILGNBQU8sU0FBV0M7QUFEdEJFLFVBQUFBLENBQUFBLG9DQUFBQSxDQUFBQSxrQkFSQTtBQURGUixRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQWtCQSxJQUFBLFlBY09DLGVBQUFBLENBQUFBLENBZFAsQ0FBQTtBQUFBLFVBQUEsSUFBQSxRQUFHLHVCQUFBRSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUgsQ0FBQTtBQUFBLFlBQ0VNLFVBQUlQLElBQUpPLGdCQUFBQSx3QkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsY0FBQUE7O0FBQUFBLGNBQ0UsT0FBQyxrQkFBb0JDLElBQUssRUFBSUMsSUFBSztBQURyQ0YsWUFBQUEsQ0FBQUEsbUNBQUFBO0FBREYsVUFBQSxPQUlBLElBQUEsUUFBTSx1QkFBQU4sY0FBQUEsQ0FBa0IsY0FBbEJBLENBQU4sQ0FBQTtBQUFBLFlBQ0VNLFVBQUlQLElBQUpPLGdCQUFBQSx3QkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsY0FBQUE7O0FBQUFBO0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFQSUEsWUFBQUEsQ0FBQUEsbUNBQUFBLENBREYsQ0FKQSxDQWxCQTtBQUFBLFlBa0NBRyxjQUFBQSxDQUFhLGVBQWMsa0JBQTNCQSxDQWxDQTtBQUFBLFlBbUNBQSxjQUFBQSxDQUFhLFFBQWJBLENBbkNBO0FBQUEsUUFvQ0EsV0FBQUEsY0FBQUEsQ0FBYSxPQUFiQSxDQXBDQTtBQURGWixNQUFBQSxHQUFBQSxXQUFBQSxFQUFpQixxQkFBakJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDU2MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvcGFnZV90cmFuc2l0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBQYWdlVHJhbnNpdGlvbiA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuUGFnZVRyYW5zaXRpb24nXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIHBlcnNpc3RlZD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUucGVyc2lzdGVkID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5QYWdlVHJhbnNpdGlvbidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgUGFnZVRyYW5zaXRpb25FdmVudChuYW1lLCBkZXNjKWBcbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBhbGlhc19uYXRpdmUgOnBlcnNpc3RlZD8sIDpwZXJzaXN0ZWRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJwZXJzaXN0ZWQ9IiwiQG5hdGl2ZSIsInZhbHVlIiwiY29uc3RydWN0IiwiYWxpYXNfbmF0aXZlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELGlCQUFBQSxtQ0FBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSx1QkFBQUUsY0FBQUEsQ0FBa0Isc0JBQWxCQTtBQURGRixRQUFBQSxDQUFBQSw4Q0FBQUEsQ0FBQTtBQUFBLFFBSUFEO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUEsVUFDRSxPQUFBSSxDQUFBQSw4QkFBQUEsNkJBQUFBLFNBQWUsS0FBZkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTyxhQUFlQztBQUQxQkYsVUFBQUEsQ0FBQUEsd0NBQUFBLENBQUFBO0FBREZKLFFBQUFBLEdBQUFBLFdBQUFBLEVBQW1CLDBCQUFuQkEsV0FKQTtBQUFBLFFBVUEsSUFBQSxZQUlPQyxlQUFBQSxDQUFBQSxDQUpQLENBQUE7QUFBQSxVQUFBLElBQUEsUUFBRyx1QkFBQUUsY0FBQUEsQ0FBa0Isc0JBQWxCQSxDQUFILENBQUE7QUFBQSxZQUNFSSxVQUFJTCxJQUFKSyxnQkFBQUEsOEJBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQSxjQUNFLE9BQUMsbUNBQUQ7QUFERkEsWUFBQUEsQ0FBQUEseUNBQUFBLENBREYsQ0FBQSxDQVZBO0FBQUEsUUFnQkEsV0FBQUMsY0FBQUEsQ0FBYSxjQUFhLFdBQTFCQSxDQWhCQTtBQURGUixNQUFBQSxHQUFBQSxXQUFBQSxFQUF1QixxQkFBdkJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDYxNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvcG9wX3N0YXRlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBQb3BTdGF0ZSA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuUG9wU3RhdGUnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIHN0YXRlPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zdGF0ZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFBvcFN0YXRlRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ1BvcFN0YXRlRXZlbnQnKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRQb3BTdGF0ZUV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLnN0YXRlKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDpzdGF0ZVxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsInN1cHBvcnRzPyIsInN0YXRlPSIsIkBuYXRpdmUiLCJ2YWx1ZSIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELGlCQUFBQSw2QkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSx1QkFBQUUsY0FBQUEsQ0FBa0IsZ0JBQWxCQTtBQURGRixRQUFBQSxDQUFBQSx3Q0FBQUEsQ0FBQTtBQUFBLFFBSUFEO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUEsVUFDRSxPQUFBSSxDQUFBQSwwQkFBQUEseUJBQUFBLFNBQVcsS0FBWEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTyxTQUFXQztBQUR0QkYsVUFBQUEsQ0FBQUEsb0NBQUFBLENBQUFBO0FBREZKLFFBQUFBLEdBQUFBLFdBQUFBLEVBQW1CLDBCQUFuQkEsV0FKQTtBQUFBLFFBVUEsSUFBQSxZQWNPQyxlQUFBQSxDQUFBQSxDQWRQLENBQUE7QUFBQSxVQUFBLElBQUEsUUFBRyx1QkFBQUUsY0FBQUEsQ0FBa0IsbUJBQWxCQSxDQUFILENBQUE7QUFBQSxZQUNFSSxVQUFJTCxJQUFKSyxnQkFBQUEsd0JBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQSxjQUNFLE9BQUMsa0JBQW9CQyxJQUFLLEVBQUlDLElBQUs7QUFEckNGLFlBQUFBLENBQUFBLG1DQUFBQTtBQURGLFVBQUEsT0FJQSxJQUFBLFFBQU0sdUJBQUFKLGNBQUFBLENBQWtCLGNBQWxCQSxDQUFOLENBQUE7QUFBQSxZQUNFSSxVQUFJTCxJQUFKSyxnQkFBQUEsd0JBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLGNBQUFBOztBQUFBQTtBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBUElBLFlBQUFBLENBQUFBLG1DQUFBQSxDQURGLENBSkEsQ0FWQTtBQUFBLFFBMEJBLFdBQUFHLGNBQUFBLENBQWEsT0FBYkEsQ0ExQkE7QUFERlYsTUFBQUEsR0FBQUEsV0FBQUEsRUFBaUIscUJBQWpCQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzA2NzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2V2ZW50L3N0b3JhZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIFN0b3JhZ2UgPCBFdmVudFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LlN0b3JhZ2UnXG4gIGVuZFxuXG4gIGNsYXNzIERlZmluaXRpb24gPCBEZWZpbml0aW9uXG4gICAgZGVmIGtleT0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUua2V5ID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgbmV3PSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5uZXdWYWx1ZSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIG9sZD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUub2xkVmFsdWUgPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBhcmVhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5zdG9yYWdlQXJlYSA9ICN7dmFsdWV9YFxuICAgIGVuZFxuXG4gICAgZGVmIHVybD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudXJsID0gI3t2YWx1ZX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgU3RvcmFnZUV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6a2V5XG4gIGFsaWFzX25hdGl2ZSA6bmV3LCA6bmV3VmFsdWVcbiAgYWxpYXNfbmF0aXZlIDpvbGQsIDpvbGRWYWx1ZVxuICBhbGlhc19uYXRpdmUgOmFyZWEsIDpzdG9yYWdlQXJlYVxuICBhbGlhc19uYXRpdmUgOnVybFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsInN1cHBvcnRzPyIsImtleT0iLCJAbmF0aXZlIiwidmFsdWUiLCJuZXc9Iiwib2xkPSIsImFyZWE9IiwidXJsPSIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIiwiYWxpYXNfbmF0aXZlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELGlCQUFBQSw0QkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSx1QkFBQUUsY0FBQUEsQ0FBa0IsZUFBbEJBO0FBREZGLFFBQUFBLENBQUFBLHVDQUFBQSxDQUFBO0FBQUEsUUFJQUQ7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFO0FBQUFJLFVBQUFBLHdCQUFBQSx1QkFBQUEsU0FBUyxLQUFUQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFQyxjQUFPLE9BQVNDO0FBRHBCRixVQUFBQSxDQUFBQSxrQ0FBQUEsQ0FBQTtBQUFBO0FBSUFHLFVBQUFBLHdCQUFBQSx1QkFBQUEsU0FBUyxLQUFUQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFRixjQUFPLFlBQWNDO0FBRHpCQyxVQUFBQSxDQUFBQSxrQ0FBQUEsQ0FKQTtBQUFBO0FBUUFDLFVBQUFBLHdCQUFBQSx1QkFBQUEsU0FBUyxLQUFUQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFSCxjQUFPLFlBQWNDO0FBRHpCRSxVQUFBQSxDQUFBQSxrQ0FBQUEsQ0FSQTtBQUFBO0FBWUFDLFVBQUFBLHlCQUFBQSx3QkFBQUEsU0FBVSxLQUFWQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFSixjQUFPLGVBQWlCQztBQUQ1QkcsVUFBQUEsQ0FBQUEsbUNBQUFBLENBWkE7QUFBQSxVQWdCQSxPQUFBQyxDQUFBQSx3QkFBQUEsdUJBQUFBLFNBQVMsS0FBVEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUwsY0FBTyxPQUFTQztBQURwQkksVUFBQUEsQ0FBQUEsa0NBQUFBLENBQUFBLGdCQWhCQTtBQURGVixRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQTBCQSxJQUFBLFlBSU9DLGVBQUFBLENBQUFBLENBSlAsQ0FBQTtBQUFBLFVBQUEsSUFBQSxRQUFHLHVCQUFBRSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUgsQ0FBQTtBQUFBLFlBQ0VRLFVBQUlULElBQUpTLGdCQUFBQSx1QkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsY0FBQUE7O0FBQUFBLGNBQ0UsT0FBQyxpQkFBbUJDLElBQUssRUFBSUMsSUFBSztBQURwQ0YsWUFBQUEsQ0FBQUEsa0NBQUFBLENBREYsQ0FBQSxDQTFCQTtBQUFBLFlBZ0NBRyxjQUFBQSxDQUFhLEtBQWJBLENBaENBO0FBQUEsWUFpQ0FBLGNBQUFBLENBQWEsT0FBTSxVQUFuQkEsQ0FqQ0E7QUFBQSxZQWtDQUEsY0FBQUEsQ0FBYSxPQUFNLFVBQW5CQSxDQWxDQTtBQUFBLFlBbUNBQSxjQUFBQSxDQUFhLFFBQU8sYUFBcEJBLENBbkNBO0FBQUEsUUFvQ0EsV0FBQUEsY0FBQUEsQ0FBYSxLQUFiQSxDQXBDQTtBQURGZCxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQixxQkFBaEJBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDc1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvdG91Y2gucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIFRvdWNoIDwgRXZlbnRcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5Ub3VjaCdcbiAgZW5kXG5cbiAgY2xhc3MgRGVmaW5pdGlvbiA8IERlZmluaXRpb25cbiAgICBkZWYgYWx0IVxuICAgICAgYCNAbmF0aXZlLmFsdEtleSA9IHRydWVgXG4gICAgZW5kXG5cbiAgICBkZWYgY3RybCFcbiAgICAgIGAjQG5hdGl2ZS5jdHJsS2V5ID0gdHJ1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBtZXRhIVxuICAgICAgYCNAbmF0aXZlLm1ldGFLZXkgPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIHNoaWZ0IVxuICAgICAgYCNAbmF0aXZlLnNoaWZ0S2V5ID0gdHJ1ZWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBUb3VjaEV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuXG4gIGFsaWFzX25hdGl2ZSA6YWx0PywgOmFsdEtleVxuICBhbGlhc19uYXRpdmUgOmN0cmw/LCA6Y3RybEtleVxuICBhbGlhc19uYXRpdmUgOm1ldGE/LCA6bWV0YUtleVxuICBhbGlhc19uYXRpdmUgOnNoaWZ0PywgOnNoaWZ0S2V5XG5cbiAgIyBUT0RPOiBpbXBsZW1lbnQgdG91Y2hlcyBhbmQgdGFyZ2V0VG91Y2hlc1xuXG4gIGRlZiBjYW5jZWw/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAndG91Y2hjYW5jZWwnXG4gIGVuZFxuXG4gIGRlZiBlbmQ/XG4gICAgbmFtZS5kb3duY2FzZSA9PSAndG91Y2hlbmQnXG4gIGVuZFxuXG4gIGRlZiBsZWF2ZT9cbiAgICBuYW1lLmRvd25jYXNlID09ICd0b3VjaGxlYXZlJ1xuICBlbmRcblxuICBkZWYgbW92ZT9cbiAgICBuYW1lLmRvd25jYXNlID09ICd0b3VjaG1vdmUnXG4gIGVuZFxuXG4gIGRlZiBzdGFydD9cbiAgICBuYW1lLmRvd25jYXNlID09ICd0b3VjaHN0YXJ0J1xuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJhbHQhIiwiQG5hdGl2ZSIsImN0cmwhIiwibWV0YSEiLCJzaGlmdCEiLCJjb25zdHJ1Y3QiLCJuYW1lIiwiZGVzYyIsImFsaWFzX25hdGl2ZSIsImNhbmNlbD8iLCJkb3duY2FzZSIsIj09IiwiZW5kPyIsImxlYXZlPyIsIm1vdmU/Iiwic3RhcnQ/Il0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELGlCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSx1QkFBQUUsY0FBQUEsQ0FBa0IsYUFBbEJBO0FBREZGLFFBQUFBLENBQUFBLHFDQUFBQSxDQUFBO0FBQUEsUUFJQUQ7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFO0FBQUFJLFVBQUFBLHdCQUFBQSx5QkFBQUEsU0FBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTztBQURYRCxVQUFBQSxDQUFBQSxvQ0FBQUEsQ0FBQTtBQUFBO0FBSUFFLFVBQUFBLHlCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUQsY0FBTztBQURYQyxVQUFBQSxDQUFBQSxxQ0FBQUEsQ0FKQTtBQUFBO0FBUUFDLFVBQUFBLHlCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUYsY0FBTztBQURYRSxVQUFBQSxDQUFBQSxxQ0FBQUEsQ0FSQTtBQUFBLFVBWUEsT0FBQUMsQ0FBQUEsMEJBQUFBLDJCQUFBQSxTQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFSCxjQUFPO0FBRFhHLFVBQUFBLENBQUFBLHNDQUFBQSxDQUFBQSxrQkFaQTtBQURGUixRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQXNCQSxJQUFBLFlBSU9DLGVBQUFBLENBQUFBLENBSlAsQ0FBQTtBQUFBLFVBQUEsSUFBQSxRQUFHLHVCQUFBRSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUgsQ0FBQTtBQUFBLFlBQ0VNLFVBQUlQLElBQUpPLGdCQUFBQSxxQkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsY0FBQUE7O0FBQUFBLGNBQ0UsT0FBQyxlQUFpQkMsSUFBSyxFQUFJQyxJQUFLO0FBRGxDRixZQUFBQSxDQUFBQSxnQ0FBQUEsQ0FERixDQUFBLENBdEJBO0FBQUEsWUE0QkFHLGNBQUFBLENBQWEsUUFBTyxRQUFwQkEsQ0E1QkE7QUFBQSxZQTZCQUEsY0FBQUEsQ0FBYSxTQUFRLFNBQXJCQSxDQTdCQTtBQUFBLFlBOEJBQSxjQUFBQSxDQUFhLFNBQVEsU0FBckJBLENBOUJBO0FBQUEsWUErQkFBLGNBQUFBLENBQWEsVUFBUyxVQUF0QkEsQ0EvQkE7QUFBQTtBQW1DQUMsUUFBQUEsMkJBQUFBLHVCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBSCxNQUFBQSxDQUFBQSxDQUFBSSxVQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFpQixhQUFqQkE7QUFERkYsUUFBQUEsQ0FBQUEsa0NBQUFBLENBbkNBO0FBQUE7QUF1Q0FHLFFBQUFBLHdCQUFBQSxvQkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsV0FBQU4sTUFBQUEsQ0FBQUEsQ0FBQUksVUFBQUEsQ0FBQUEsQ0FBQUMsT0FBQUEsQ0FBaUIsVUFBakJBO0FBREZDLFFBQUFBLENBQUFBLCtCQUFBQSxDQXZDQTtBQUFBO0FBMkNBQyxRQUFBQSwwQkFBQUEsc0JBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLFdBQUFQLE1BQUFBLENBQUFBLENBQUFJLFVBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWlCLFlBQWpCQTtBQURGRSxRQUFBQSxDQUFBQSxpQ0FBQUEsQ0EzQ0E7QUFBQTtBQStDQUMsUUFBQUEseUJBQUFBLHNCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBUixNQUFBQSxDQUFBQSxDQUFBSSxVQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFpQixXQUFqQkE7QUFERkcsUUFBQUEsQ0FBQUEsaUNBQUFBLENBL0NBO0FBQUEsUUFtREEsT0FBQUMsQ0FBQUEsMEJBQUFBLHVCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBVCxNQUFBQSxDQUFBQSxDQUFBSSxVQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFpQixZQUFqQkE7QUFERkksUUFBQUEsQ0FBQUEsa0NBQUFBLENBQUFBLGtCQW5EQTtBQURGbkIsTUFBQUEsR0FBQUEsV0FBQUEsRUFBYyxxQkFBZEE7QUFGZ0JBLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQWhCRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwODU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9zZW5zb3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIFNlbnNvciA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuU2Vuc29yJ1xuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY29uc3RydWN0b3InXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBgbmV3IFNlbnNvckV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbmQgaWYgc3VwcG9ydGVkP1xuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsInN1cHBvcnRzPyIsImNvbnN0cnVjdCIsIm5hbWUiLCJkZXNjIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEIsT0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELGlCQUFBQSwyQkFBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSx1QkFBQUUsY0FBQUEsQ0FBa0IsY0FBbEJBO0FBREZGLFFBQUFBLENBQUFBLHNDQUFBQSxDQUFBO0FBQUEsUUFJQSxJQUFBLFlBSU9BLGVBQUFBLENBQUFBLENBSlAsQ0FBQTtBQUFBLFVBQUEsSUFBQSxRQUFHLHVCQUFBRSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUgsQ0FBQTtBQUFBLFlBQ0UsT0FBQUMsQ0FBQUEsVUFBSUYsSUFBSkUsZ0JBQUFBLHNCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUEsY0FDRSxPQUFDLGdCQUFrQkMsSUFBSyxFQUFJQyxJQUFLO0FBRG5DRixZQUFBQSxDQUFBQSxpQ0FBQUEsQ0FBQUE7QUFERixVQUFBO0FBQUE7QUFBQSxVQUFBO0FBQUEsUUFBQTtBQUFBO0FBQUEsUUFBQSxDQUpBO0FBREZKLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWUscUJBQWZBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMDkwMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vb3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBPcGVuU3RydWN0XG4gIGRlZiBpbml0aWFsaXplKGhhc2ggPSBuaWwpXG4gICAgQHRhYmxlID0ge31cblxuICAgIGlmIGhhc2hcbiAgICAgIGhhc2guZWFjaF9wYWlyIGRvIHxrZXksIHZhbHVlfFxuICAgICAgICBAdGFibGVbbmV3X29zdHJ1Y3RfbWVtYmVyKGtleSldID0gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW10obmFtZSlcbiAgICBAdGFibGVbbmFtZS50b19zeW1dXG4gIGVuZFxuXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXG4gICAgQHRhYmxlW25ld19vc3RydWN0X21lbWJlcihuYW1lKV0gPSB2YWx1ZVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3NpbmcobmFtZSwgKmFyZ3MpXG4gICAgaWYgYXJncy5sZW5ndGggPiAyXG4gICAgICByYWlzZSBOb01ldGhvZEVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciAjPE9wZW5TdHJ1Y3Q+XCIsIG5hbWUpXG4gICAgZW5kXG4gICAgaWYgbmFtZS5lbmRfd2l0aD8gJz0nXG4gICAgICBpZiBhcmdzLmxlbmd0aCAhPSAxXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKSdcbiAgICAgIGVuZFxuICAgICAgQHRhYmxlW25ld19vc3RydWN0X21lbWJlcihuYW1lWzAuLi0yXSldID0gYXJnc1swXVxuICAgIGVsc2VcbiAgICAgIEB0YWJsZVtuYW1lLnRvX3N5bV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2hfcGFpclxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9wYWlyIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIEB0YWJsZS5lYWNoX3BhaXIgZG8gfHBhaXJ8XG4gICAgICB5aWVsZCBwYWlyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmlzX2E/KE9wZW5TdHJ1Y3QpXG5cbiAgICBAdGFibGUgPT0gb3RoZXIuaW5zdGFuY2VfdmFyaWFibGVfZ2V0KDpAdGFibGUpXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pc19hPyhPcGVuU3RydWN0KVxuXG4gICAgQHRhYmxlID09PSBvdGhlci5pbnN0YW5jZV92YXJpYWJsZV9nZXQoOkB0YWJsZSlcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pc19hPyhPcGVuU3RydWN0KVxuXG4gICAgQHRhYmxlLmVxbD8gb3RoZXIuaW5zdGFuY2VfdmFyaWFibGVfZ2V0KDpAdGFibGUpXG4gIGVuZFxuXG4gIGRlZiB0b19oXG4gICAgQHRhYmxlLmR1cFxuICBlbmRcblxuICBkZWYgdG9fblxuICAgIEB0YWJsZS50b19uXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgQHRhYmxlLmhhc2hcbiAgZW5kXG5cbiAgYXR0cl9yZWFkZXIgOnRhYmxlXG5cbiAgZGVmIGRlbGV0ZV9maWVsZChuYW1lKVxuICAgIHN5bSA9IG5hbWUudG9fc3ltXG4gICAgYmVnaW5cbiAgICAgIHNpbmdsZXRvbl9jbGFzcy5fX3NlbmRfXyg6cmVtb3ZlX21ldGhvZCwgc3ltLCBcIiN7c3ltfT1cIilcbiAgICByZXNjdWUgTmFtZUVycm9yXG4gICAgZW5kXG4gICAgQHRhYmxlLmRlbGV0ZSBzeW1cbiAgZW5kXG5cbiAgZGVmIG5ld19vc3RydWN0X21lbWJlcihuYW1lKVxuICAgIG5hbWUgPSBuYW1lLnRvX3N5bVxuICAgIHVubGVzcyByZXNwb25kX3RvPyhuYW1lKVxuICAgICAgZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QobmFtZSkgeyBAdGFibGVbbmFtZV0gfVxuICAgICAgZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QoXCIje25hbWV9PVwiKSB7IHx4fCBAdGFibGVbbmFtZV0gPSB4IH1cbiAgICBlbmRcbiAgICBuYW1lXG4gIGVuZFxuXG4gIGB2YXIgb3N0cnVjdF9pZHM7YFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKG9zdHJ1Y3RfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIG9zdHJ1Y3RfaWQgPSAje19faWRfX307XG4gICAgfVxuICAgIGJlZ2luXG4gICAgICByZXN1bHQgPSBcIiM8I3tzZWxmLmNsYXNzfVwiXG4gICAgICAleHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIG9zdHJ1Y3RfaWRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9zdHJ1Y3RfaWRzLmhhc093blByb3BlcnR5KG9zdHJ1Y3RfaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICcgLi4uPic7XG4gICAgICAgIH1cbiAgICAgICAgb3N0cnVjdF9pZHNbb3N0cnVjdF9pZF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gJyAnIGlmIEB0YWJsZS5hbnk/XG5cbiAgICAgIHJlc3VsdCArPSBlYWNoX3BhaXIubWFwIGRvIHxuYW1lLCB2YWx1ZXxcbiAgICAgICAgXCIje25hbWV9PSN7dmFsdWUuaW5zcGVjdH1cIlxuICAgICAgZW5kLmpvaW4gJywgJ1xuXG4gICAgICByZXN1bHQgKz0gJz4nXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuc3VyZVxuICAgICAgJXh7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBvc3RydWN0X2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiaW5pdGlhbGl6ZSIsIkB0YWJsZSIsImhhc2giLCJlYWNoX3BhaXIiLCIkd3JpdGVyIiwibmV3X29zdHJ1Y3RfbWVtYmVyIiwia2V5IiwidmFsdWUiLCJbXT0iLCItIiwiMSIsIltdIiwibmFtZSIsInRvX3N5bSIsIm1ldGhvZF9taXNzaW5nIiwiPiIsImFyZ3MiLCJsZW5ndGgiLCIyIiwicmFpc2UiLCJuZXciLCJlbmRfd2l0aD8iLCIhPSIsIjAiLCItMiIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwicGFpciIsIj09Iiwib3RoZXIiLCJpc19hPyIsImluc3RhbmNlX3ZhcmlhYmxlX2dldCIsIj09PSIsImVxbD8iLCJ0b19oIiwiZHVwIiwidG9fbiIsImF0dHJfcmVhZGVyIiwiZGVsZXRlX2ZpZWxkIiwic3ltIiwic2luZ2xldG9uX2NsYXNzIiwiX19zZW5kX18iLCJkZWxldGUiLCJyZXNwb25kX3RvPyIsImRlZmluZV9zaW5nbGV0b25fbWV0aG9kIiwieCIsImluc3BlY3QiLCJfX2lkX18iLCJyZXN1bHQiLCJzZWxmIiwiYW55PyIsIisiLCJtYXAiLCJqb2luIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRTtBQUFBQyxJQUFBQSw4QkFBQUEsMkJBQUFBLHNCQUFlLElBQWZBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUZGO0FBRWlCLE1BQUE7QUFBQSxNQUFBLFNBQU8sR0FBUDtBQUFBLE1BQUEsQ0FGakI7QUFBQSxNQUdJQyxhQUFTLFlBQUEsRUFIYjtBQUFBLE1BS0ksSUFBQSxRQUFHQyxJQUFILENBQUE7QUFBQSxRQUNFLE9BQUFDLE1BQUFELElBQUFDLGFBQUFBLEVBQUFBLEVBQUFBLEVBTk4sZ0JBTXlCLEdBQUQsRUFBTSxLQU45QixFQUFBO0FBQUE7O0FBQUE7QUFBQTtBQU15QixVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0FOekI7QUFBQTtBQU04QixVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0FOOUI7QUFBQSxVQUFBQyxVQUFBLEtBT2VDLG9CQUFBQSxDQUFtQkMsR0FBbkJELENBUGYsRUFPMENFLEtBUDFDLENBQUE7QUFBQSxVQU9RQyxNQUFBUCxVQUFBTyxPQUFBQSxFQVBSLFVBQUFKLE9BQUEsQ0FPUUksQ0FQUjtBQUFBLFVBQUEsT0FBQUosT0FBQSxDQUFBSyxVQUFBTCxPQUFBLENBQUEsUUFBQSxDQUFBSyxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0FBQSxrQkFBQSxpQkFBQSxLQU1NTjtBQURGLE1BQUE7QUFBQTtBQUFBLE1BQUEsQ0FMSjtBQUVFSCxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQTtBQUFBO0FBVUFXLElBQUFBLHNCQUFBQSxtQkFBQUEsU0FBTyxJQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBVixVQUFBVSxPQUFBQSxDQUFPQyxJQUFBQyxRQUFBQSxDQUFBQSxDQUFQRjtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FWQTtBQUFBO0FBY0FILElBQUFBLHVCQUFBQSxzQkFBQUEsU0FBUSxJQUFELEVBQU8sS0FBZEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBaEJGLE1BQUFKLFVBQUEsS0FpQldDLG9CQUFBQSxDQUFtQk8sSUFBbkJQLENBakJYLEVBaUJ1Q0UsS0FqQnZDLENBQUE7QUFBQSxNQWlCSUMsTUFBQVAsVUFBQU8sT0FBQUEsRUFqQkosVUFBQUosT0FBQSxDQWlCSUksQ0FqQko7QUFBQSxNQUFBLE9BQUFKLE9BQUEsQ0FBQUssVUFBQUwsT0FBQSxDQUFBLFFBQUEsQ0FBQUssRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBO0FBZ0JFRCxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0FkQTtBQUFBO0FBa0JBTSxJQUFBQSxrQ0FBQUEsK0JBQUFBLDBCQUFtQixJQUFELEVBcEJwQixFQW9CRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBcEJGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBb0IyQixNQUFBLGtCQXBCM0I7QUFBQSxNQXFCSSxJQUFBLFFBQUdDLE9BQUFDLElBQUFDLFFBQUFBLENBQUFBLENBQUFGLEVBQWNHLENBQWRILENBQUgsQ0FBQTtBQUFBLFlBQ0VJLE9BQUFBLENBQU0sNkJBQUFDLEtBQUFBLENBQWtCLEVBQUEsR0FBQSxvQkFBQSxHQUFBLENBQXFCUixJQUFyQixDQUFBLEdBQUEsdUJBQWdEQSxJQUFsRVEsQ0FBTkQsQ0FERixDQXJCSjtBQUFBLE1Bd0JJLElBQUEsUUFBR1AsSUFBQVMsY0FBQUEsQ0FBZSxHQUFmQSxDQUFILENBQUE7QUFBQTtBQUNFLFFBQUEsSUFBQSxRQUFHTCxJQUFBQyxRQUFBQSxDQUFBQSxDQUFBSyxPQUFBQSxDQUFlWixDQUFmWSxDQUFILENBQUE7QUFBQSxjQUNFSCxPQUFBQSxDQUFNLCtCQUFlLHFDQUFyQkEsQ0FERixDQUFBO0FBQUE7QUF6Qk4sUUFBQWYsVUFBQSxLQTRCYUMsb0JBQUFBLENBQW1CTyxJQUFBRCxPQUFBQSxDQUFLLE9BQUFZLENBQUEsRUFBR0MsRUFBSCxRQUFMYixDQUFuQk4sQ0E1QmIsRUE0QmdEVyxJQUFBTCxPQUFBQSxDQUFLWSxDQUFMWixDQTVCaEQsQ0FBQTtBQUFBLFFBNEJNSCxNQUFBUCxVQUFBTyxPQUFBQSxFQTVCTixVQUFBSixPQUFBLENBNEJNSSxDQTVCTjtBQUFBLFFBQUEsT0FBQUosT0FBQSxDQUFBSyxVQUFBTCxPQUFBLENBQUEsUUFBQSxDQUFBSyxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0F5Qk07QUFERixNQUFBO0FBQUEsUUFNRSxPQUFBUixVQUFBVSxPQUFBQSxDQUFPQyxJQUFBQyxRQUFBQSxDQUFBQSxDQUFQRjtBQU5GLE1BQUEsQ0F4Qko7QUFvQkVHLElBQUFBLENBQUFBLDJDQUFBQSxDQWxCQTtBQUFBO0FBZ0NBWCxJQUFBQSw2QkFBQUEsMEJBQUFBLHFCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFDRSxNQUFBLElBQWtDc0IsZ0JBQWxDO0FBQUEsTUFBQTtBQUFBLFFBQUEsV0FBT0MsVUFBQUEsQ0FBUyxXQUFUQTtBQUFQLE1BQUEsQ0FBQTtBQUFBLE1BRUEsT0FBQXZCLE1BQUFGLFVBQUFFLGFBQUFBLEVBQUFBLEVBQUFBLEVBckNKLGdCQXFDeUIsSUFyQ3pCLEVBQUE7O0FBQUE7QUFBQTtBQXFDeUIsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBckN6QjtBQUFBLFFBc0NNLE9BQUEsb0JBQU13QixJQUFOLENBQUEsQ0F0Q04sQ0FBQSxrQkFBQSxpQkFBQSxLQXFDSXhCLENBRkE7QUFERkEsSUFBQUEsQ0FBQUEscUNBQUFBLENBaENBO0FBQUE7QUF3Q0F5QixJQUFBQSxzQkFBQUEsdUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFBLFFBQW9CQyxLQUFBQyxVQUFBQSxDQUFZLDBCQUFaQSxDQUFwQixDQUFBO0FBQUEsTUFBQTtBQUFBLFFBQUEsT0FBTztBQUFQLE1BQUEsQ0FBQTtBQUFBLE1BRUEsT0FBQTdCLFVBQUEyQixPQUFBQSxDQUFVQyxLQUFBRSx1QkFBQUEsQ0FBNEIsUUFBNUJBLENBQVZILENBRkE7QUFERkEsSUFBQUEsQ0FBQUEsa0NBQUFBLENBeENBO0FBQUE7QUE4Q0FJLElBQUFBLHVCQUFBQSwwQkFBQUEsU0FBUSxLQUFSQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQUEsUUFBb0JILEtBQUFDLFVBQUFBLENBQVksMEJBQVpBLENBQXBCLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPO0FBQVAsTUFBQSxDQUFBO0FBQUEsTUFFQSxPQUFBN0IsVUFBQStCLFFBQUFBLENBQVdILEtBQUFFLHVCQUFBQSxDQUE0QixRQUE1QkEsQ0FBWEMsQ0FGQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0E5Q0E7QUFBQTtBQW9EQUMsSUFBQUEsd0JBQUFBLDBCQUFBQSxTQUFTLEtBQVRBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBQSxRQUFvQkosS0FBQUMsVUFBQUEsQ0FBWSwwQkFBWkEsQ0FBcEIsQ0FBQTtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU87QUFBUCxNQUFBLENBQUE7QUFBQSxNQUVBLE9BQUE3QixVQUFBZ0MsU0FBQUEsQ0FBWUosS0FBQUUsdUJBQUFBLENBQTRCLFFBQTVCQSxDQUFaRSxDQUZBO0FBREZBLElBQUFBLENBQUFBLHFDQUFBQSxDQXBEQTtBQUFBO0FBMERBQyxJQUFBQSx3QkFBQUEsc0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBakMsVUFBQWtDLEtBQUFBLENBQUFBO0FBREZELElBQUFBLENBQUFBLGlDQUFBQSxDQTFEQTtBQUFBO0FBOERBRSxJQUFBQSx3QkFBQUEsc0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBbkMsVUFBQW1DLE1BQUFBLENBQUFBO0FBREZBLElBQUFBLENBQUFBLGlDQUFBQSxDQTlEQTtBQUFBO0FBa0VBbEMsSUFBQUEsd0JBQUFBLHNCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUQsVUFBQUMsTUFBQUEsQ0FBQUE7QUFERkEsSUFBQUEsQ0FBQUEsaUNBQUFBLENBbEVBO0FBQUEsUUFzRUFtQyxhQUFBQSxDQUFZLE9BQVpBLENBdEVBO0FBQUE7QUF3RUFDLElBQUFBLGdDQUFBQSw4QkFBQUEsd0JBQWlCLElBQWpCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBQyxNQUFNM0IsSUFBQUMsUUFBQUEsQ0FBQUEsQ0FBTjtBQUFBO0FBQ0EsTUFDRTtBQUFBLFlBQUEyQixpQkFBQUEsQ0FBQUEsQ0FBQUMsVUFBQUEsQ0FBeUIsaUJBQWdCRixLQUFLLEVBQUEsR0FBQSxDQUFHQSxHQUFILENBQUEsR0FBQSxHQUE5Q0U7QUFBQSxNQUFBO0FBQUEsUUFDRixzQkFBTyxDQUFBLHlCQUFBLENBQVA7QUFBQSxVQUFBO0FBQUE7QUFBQSxVQUFBO0FBQUEsUUFBQSxDQURFO0FBQUEsTUFBQSxDQURGLENBREE7QUFBQSxNQUtBLE9BQUF4QyxVQUFBeUMsUUFBQUEsQ0FBY0gsR0FBZEcsQ0FMQTtBQURGSixJQUFBQSxDQUFBQSx5Q0FBQUEsQ0F4RUE7QUFBQTtBQWlGQWpDLElBQUFBLHNDQUFBQSxvQ0FBQUEsOEJBQXVCLElBQXZCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBTyxPQUFPQSxJQUFBQyxRQUFBQSxDQUFBQSxDQUFQO0FBQUEsTUFDQSxJQUFBLFlBQU84QixnQkFBQUEsQ0FBWS9CLElBQVorQixDQUFQLENBQUE7QUFBQSxNQUFBO0FBQUE7QUFDRSxRQUFBQyxVQUFBQSwyQkFBQUEsRUFBQUEsQ0FBd0JoQyxJQUF4QmdDLENBQUFBLEVBdEZOLGlCQUFBLEVBQUE7QUFBQTs7QUFBQSxRQXNGc0MsT0FBQTNDLFVBQUFVLE9BQUFBLENBQU9DLElBQVBELENBdEZ0QyxtQkFBQSxrQkFBQSxNQXNGTWlDLENBQUE7QUFBQSxRQUNBQSxVQUFBQSwyQkFBQUEsRUFBQUEsQ0FBd0IsRUFBQSxHQUFBLENBQUdoQyxJQUFILENBQUEsR0FBQSxHQUF4QmdDLENBQUFBLEVBdkZOLGlCQXVGNkMsQ0F2RjdDLEVBQUE7QUFBQTs7QUFBQTtBQUFBO0FBdUY2QyxVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0F2RjdDO0FBQUEsVUFBQXhDLFVBQUEsQ0F1RnVEUSxJQXZGdkQsRUF1RitEaUMsQ0F2Ri9ELENBQUE7QUFBQSxVQXVGZ0RyQyxNQUFBUCxVQUFBTyxPQUFBQSxFQXZGaEQsVUFBQUosT0FBQSxDQXVGZ0RJLENBdkZoRDtBQUFBLFVBQUEsT0FBQUosT0FBQSxDQUFBSyxVQUFBTCxPQUFBLENBQUEsUUFBQSxDQUFBSyxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0FBQSxtQkFBQSxrQkFBQSxNQXVGTW1DLENBREE7QUFERixNQUFBLENBREE7QUFBQSxNQUtBLE9BQUFoQyxJQUxBO0FBREZQLElBQUFBLENBQUFBLCtDQUFBQSxDQWpGQTtBQUFBLElBMEZDLGdCQTFGRDtBQUFBO0FBNEZBeUMsSUFBQUEsMkJBQUFBLHlCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0U7QUFDSjtBQUNBLDJCQUF5QkMsUUFBQUEsQ0FBQUEsQ0FBTztBQUNoQyxJQUhJO0FBQUE7QUFJQSxhQUNFLGNBQUE7QUFBQTtBQUFBLE1BQUFDLFNBQVMsRUFBQSxHQUFBLElBQUEsR0FBQSxDQUFLQyxJQUFBbEQsT0FBQUEsQ0FBQUEsQ0FBTCxDQUFUO0FBQUE7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BVE07QUFBQSxNQVdBLElBQUEsUUFBaUJFLFVBQUFpRCxTQUFBQSxDQUFBQSxDQUFqQixDQUFBO0FBQUEsUUFBQUYsU0EvR05HLFNBK0dNSCxNQS9HTkcsRUErR2dCLEdBL0doQkEsQ0ErR00sQ0FYQTtBQUFBLE1BYUFILFNBakhORyxTQWlITUgsTUFqSE5HLEVBaUhnQkMsVUFBQWpELFdBQUFBLENBQUFBLENBQUFpRCxPQUFBQSxFQUFBQSxFQUFBQSxFQWpIaEIsaUJBaUhrQyxJQUFELEVBQU8sS0FqSHhDLEVBQUE7O0FBQUE7QUFBQTtBQWlIa0MsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBakhsQztBQUFBO0FBaUh3QyxRQUFBO0FBQUEsUUFBQTtBQUFBLFFBQUEsQ0FqSHhDO0FBQUEsUUFrSFEsT0FBQSxFQUFBLEdBQUEsQ0FBR3hDLElBQUgsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFXTCxLQUFBdUMsU0FBQUEsQ0FBQUEsQ0FBWCxDQWxIUixDQUFBLG1CQUFBLGtCQUFBLE1BaUhnQk0sQ0FBQUMsTUFBQUEsQ0FFRCxJQUZDQSxDQWpIaEJGLENBb0dNO0FBQUEsTUFpQkFILFNBckhORyxTQXFITUgsTUFySE5HLEVBcUhnQixHQXJIaEJBLENBb0dNO0FBQUEsTUFtQkEsT0FBQUgsTUFuQkE7QUFBQSxNQUFBO0FBQUE7QUFzQk47QUFDQTtBQUNBO0FBQ0E7QUF6Qk0sTUFBQSxDQUFBLE1BREYsQ0FKQTtBQURGRixJQUFBQSxDQUFBQSxvQ0FBQUEsQ0E1RkE7QUFBQSxJQStIQSxPQUFBLGlCQUFNLE1BQU4sRUFBVyxTQUFYLENBL0hBO0FBREYvQyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxMTU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9jdXN0b20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnb3N0cnVjdCdcblxubW9kdWxlIEJyb3dzZXI7IGNsYXNzIEV2ZW50XG5cbmNsYXNzIEN1c3RvbSA8IEV2ZW50XG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuQ3VzdG9tJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCB2YWx1ZSlcbiAgICAgIGlmIG5hbWUuZW5kX3dpdGg/ID89XG4gICAgICAgIGAjQG5hdGl2ZVsje25hbWVbMCAuLiAtMl19XSA9IHZhbHVlYFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgICAgYnViYmxlczogICAgZGVzYy5idWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgIGRldGFpbDogICAgIGRlc2MgfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChuYW1lLCBkZXNjLmJ1YmJsZXMsIGRlc2MuY2FuY2VsYWJsZSwgZGVzYyk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY3JlYXRlT2JqZWN0J1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgTmF0aXZlKGBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpYCkubWVyZ2UhKGB7XG4gICAgICAgIHR5cGU6ICAgICAgIG5hbWUsXG4gICAgICAgIGJ1YmJsZXM6ICAgIGRlc2MuYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICBkZXRhaWw6ICAgICBkZXNjIH1gKS50b19uXG4gICAgZW5kXG4gIGVsc2VcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIE5hdGl2ZShkZXNjKS5tZXJnZSEoYHtcbiAgICAgICAgdHlwZTogICAgICAgbmFtZSxcbiAgICAgICAgYnViYmxlczogICAgZGVzYy5idWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiBkZXNjLmNhbmNlbGFibGUsXG4gICAgICAgIGRldGFpbDogICAgIGRlc2MgfWApLnRvX25cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZXZlbnQsIGNhbGxiYWNrID0gbmlsKVxuICAgIHN1cGVyKGV2ZW50LCBjYWxsYmFjaylcblxuICAgIEBkZXRhaWwgPSBIYXNoLm5ldyhgI3tldmVudH0uZGV0YWlsYClcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKGlkLCAqKVxuICAgIHJldHVybiBAZGV0YWlsW2lkXSBpZiBAZGV0YWlsLmhhc19rZXk/KGlkKVxuXG4gICAgc3VwZXJcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwiY2xhc3MiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsInN1cHBvcnRzPyIsIm1ldGhvZF9taXNzaW5nIiwibmFtZSIsImVuZF93aXRoPyIsIkBuYXRpdmUiLCJbXSIsIjAiLCItMiIsImNvbnN0cnVjdCIsIk5hdGl2ZSIsIm1lcmdlISIsInRvX24iLCJkZXNjIiwiaW5pdGlhbGl6ZSIsImV2ZW50IiwiY2FsbGJhY2siLCJAZGV0YWlsIiwibmV3IiwiaGFzX2tleT8iLCJpZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxTQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQztBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCLE9BQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxpQkFBQUEsMkJBQUFBLFNBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUEsdUJBQUFFLGNBQUFBLENBQWtCLGNBQWxCQTtBQURGRixRQUFBQSxDQUFBQSxzQ0FBQUEsQ0FBQTtBQUFBLFFBSUFEO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUEsVUFDRSxPQUFBSSxDQUFBQSxrQ0FBQUEsK0JBQUFBLDBCQUFtQixJQUFELEVBQU8sS0FBekJBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLElBQUEsUUFBR0MsSUFBQUMsY0FBQUEsQ0FBZSxHQUFmQSxDQUFILENBQUE7QUFBQSxjQUNFLE9BQUVDLGNBQU8sQ0FBR0YsSUFBQUcsT0FBQUEsQ0FBSyxPQUFBQyxDQUFBLEVBQUtDLEVBQUwsUUFBTEYsQ0FBYztBQUQ1QixZQUFBO0FBQUE7QUFBQSxZQUFBO0FBREZKLFVBQUFBLENBQUFBLDBDQUFBQSxDQUFBQTtBQURGSixRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQVlBLElBQUEsUUFBRyx1QkFBQUcsY0FBQUEsQ0FBa0IsbUJBQWxCQSxDQUFILENBQUE7QUFBQSxVQUNFUSxVQUFJVCxJQUFKUyxnQkFBQUEsc0JBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNHO0FBQ1A7QUFDQTtBQUNBO0FBSklBLFVBQUFBLENBQUFBLGlDQUFBQTtBQURGLFFBQUEsT0FPQSxJQUFBLFFBQU0sdUJBQUFSLGNBQUFBLENBQWtCLGNBQWxCQSxDQUFOLENBQUE7QUFBQSxVQUNFUSxVQUFJVCxJQUFKUyxnQkFBQUEsc0JBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLFlBQUFBOztBQUFBQTtBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQU5JQSxVQUFBQSxDQUFBQSxpQ0FBQUE7QUFERixRQUFBLE9BU0EsSUFBQSxRQUFNLHVCQUFBUixjQUFBQSxDQUFrQixvQkFBbEJBLENBQU4sQ0FBQTtBQUFBLFVBQ0VRLFVBQUlULElBQUpTLGdCQUFBQSxzQkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsV0FBQUMsUUFBQUEsQ0FBUSw0QkFBUkEsQ0FBQUMsV0FBQUEsQ0FBK0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMEJBSk1BLENBQUFDLE1BQUFBLENBQUFBO0FBREZILFVBQUFBLENBQUFBLGlDQUFBQTtBQURGLFFBQUE7QUFBQSxVQVNFQSxVQUFJVCxJQUFKUyxnQkFBQUEsc0JBQUFBLHFCQUFtQixJQUFELEVBQU8sSUFBekJBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLFdBQUFDLFFBQUFBLENBQU9HLElBQVBILENBQUFDLFdBQUFBLENBQXFCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDBCQUpNQSxDQUFBQyxNQUFBQSxDQUFBQTtBQURGSCxVQUFBQSxDQUFBQSxpQ0FBQUE7QUFURixRQUFBLENBNUJBO0FBQUE7QUE4Q0FLLFFBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQWUsS0FBRCxFQUFRLFFBQXRCQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFBQUE7QUFBQUE7QUFwREY7QUFvRHdCLFVBQUE7QUFBQSxVQUFBLGFBQVcsR0FBWDtBQUFBLFVBQUEsQ0FwRHhCO0FBQUEsVUFxREksVUFBQSxFQUFBLDJFQUFBLEVBQUEsQ0FBTUMsT0FBT0MsUUFBYixDQUFBLE1BQUEsQ0FyREo7QUFBQSxVQXVESSxPQUFBQyxDQUFBQSxjQUFVLG9CQUFBQyxLQUFBQSxDQUFZSCxLQUFNLE9BQWxCRyxDQUFWRCxDQXZESjtBQW9ERUgsUUFBQUEsQ0FBQUEsbUNBQUFBLENBOUNBO0FBQUEsUUFvREEsT0FBQVosQ0FBQUEsa0NBQUFBLDJCQUFBQSwwQkFBbUIsRUFBRCxFQTFEcEIsRUEwREVBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQSxVQUFBQTtBQUFBQTtBQTFERjtBQUFBLFVBQUEsNERBQUE7QUFBQSxVQUFBO0FBQUEsVUEyREksSUFBQSxRQUFzQmUsV0FBQUUsYUFBQUEsQ0FBaUJDLEVBQWpCRCxDQUF0QixDQUFBO0FBQUEsWUFBQSxPQUFPRixXQUFBWCxPQUFBQSxDQUFRYyxFQUFSZCxDQUFQLENBM0RKO0FBQUEsVUE2REksT0FBQSxVQUFBLEVBQUEsbUZBQUEsUUFBQSxPQUFBLENBN0RKO0FBMERFSixRQUFBQSxDQUFBQSx1Q0FBQUEsQ0FBQUEsMEJBcERBO0FBREZKLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWUscUJBQWZBO0FBRmdCQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFoQkQsRUFBQUEsR0FBQUEsV0FBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxMjc5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnVmZmVyL2FycmF5LnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJ1ZmZlclxuICBjbGFzcyBBcnJheVxuICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICBkZWYgc2VsZi5mb3IoYml0cywgdHlwZSlcbiAgICAgICQkW1wiI3tCdWZmZXIubmFtZV9mb3IgYml0cywgdHlwZX1BcnJheVwiXVxuICAgIGVuZFxuXG4gICAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgICBhdHRyX3JlYWRlciA6YnVmZmVyLCA6dHlwZVxuXG4gICAgZGVmIGluaXRpYWxpemUoYnVmZmVyLCBiaXRzID0gbmlsLCB0eXBlID0gbmlsKVxuICAgICAgaWYgTmF0aXZlID09IGJ1ZmZlclxuICAgICAgICBzdXBlcihidWZmZXIpXG4gICAgICBlbHNlXG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciBrbGFzcyA9ICN7QXJyYXkuZm9yKGJpdHMsIHR5cGUpfTtcblxuICAgICAgICAgICN7c3VwZXIoYG5ldyBrbGFzcygje2J1ZmZlci50b19ufSlgKX1cbiAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIEBidWZmZXIgPSBidWZmZXJcbiAgICAgIEB0eXBlICAgPSB0eXBlXG4gICAgZW5kXG5cbiAgICBkZWYgYml0c1xuICAgICAgYCN7QG5hdGl2ZX0uQllURVNfUEVSX0VMRU1FTlQgKiA4YFxuICAgIGVuZFxuXG4gICAgZGVmIFtdKGluZGV4LCBvZmZzZXQgPSBuaWwpXG4gICAgICBvZmZzZXQgPyBgI3tAbmF0aXZlfS5zdWJhcnJheShpbmRleCwgb2Zmc2V0KWAgOiBgI3tAbmF0aXZlfVtpbmRleF1gXG4gICAgZW5kXG5cbiAgICBkZWYgW109KGluZGV4LCB2YWx1ZSlcbiAgICAgIGAje0BuYXRpdmV9W2luZGV4XSA9IHZhbHVlYFxuICAgIGVuZFxuXG4gICAgZGVmIGJ5dGVzaXplXG4gICAgICBgI3tAbmF0aXZlfS5ieXRlTGVuZ3RoYFxuICAgIGVuZFxuXG4gICAgZGVmIGVhY2hcbiAgICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gI3tAbmF0aXZlfS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYCN7QG5hdGl2ZX1baV1gfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBsZW5ndGhcbiAgICAgIGAje0BuYXRpdmV9Lmxlbmd0aGBcbiAgICBlbmRcblxuICAgIGRlZiBtZXJnZSEob3RoZXIsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAgIGAje0BuYXRpdmV9LnNldCgje290aGVyLnRvX259LCBvZmZzZXQpYFxuICAgIGVuZFxuXG4gICAgYWxpYXMgc2l6ZSBsZW5ndGhcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImluY2x1ZGUiLCJmb3IiLCJzZWxmIiwiJCQiLCJbXSIsIm5hbWVfZm9yIiwiYml0cyIsInR5cGUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCI9PSIsImJ1ZmZlciIsInRvX24iLCJAYnVmZmVyIiwiQHR5cGUiLCJAbmF0aXZlIiwib2Zmc2V0IiwiW109IiwiYnl0ZXNpemUiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJsZW5ndGgiLCJtZXJnZSEiLCJvdGhlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUFBQTtBQUNFLFVBQUFDLFNBQUFBLENBQVEsSUFBQSxzQkFBQSxZQUFSQSxDQUFBO0FBQUEsTUFFQUMsVUFBSUMsSUFBSkQsVUFBQUEsZUFBQUEsU0FBYSxJQUFELEVBQU8sSUFBbkJBO0FBQUFBLFFBQUFBO0FBQUFBOztBQUFBQSxRQUNFLE9BQUFFLFFBQUFDLE9BQUFBLENBQUcsRUFBQSxHQUFBLENBQUcsc0JBQUFDLFVBQUFBLENBQWdCQyxNQUFNQyxJQUF0QkYsQ0FBSCxDQUFBLEdBQUEsT0FBSEQ7QUFERkgsTUFBQUEsQ0FBQUEsMEJBQUFBLENBRkE7QUFBQSxVQU1BRCxTQUFBQSxDQUFRLDBCQUFSQSxDQU5BO0FBQUEsVUFRQVEsYUFBQUEsQ0FBWSxVQUFTLE1BQXJCQSxDQVJBO0FBQUE7QUFVQUMsTUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBZSxNQUFELEVBQVMsSUFBVCxFQUFxQixJQUFuQ0E7QUFB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ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJidWZmZXIvdmlldy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBCdWZmZXJcbiAgY2xhc3MgVmlld1xuICAgIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgICAhJCRbOkRhdGFWaWV3XS5uaWw/XG4gICAgZW5kXG5cbiAgICBhdHRyX3JlYWRlciA6YnVmZmVyLCA6b2Zmc2V0XG5cbiAgICBkZWYgaW5pdGlhbGl6ZShidWZmZXIsIG9mZnNldCA9IG5pbCwgbGVuZ3RoID0gbmlsKVxuICAgICAgaWYgbmF0aXZlPyhidWZmZXIpXG4gICAgICAgIHN1cGVyKGJ1ZmZlcilcbiAgICAgIGVsc2lmIG9mZnNldCAmJiBsZW5ndGhcbiAgICAgICAgc3VwZXIoYG5ldyBEYXRhVmlldygje2J1ZmZlci50b19ufSwgI3tvZmZzZXQudG9fbn0sICN7bGVuZ3RoLnRvX259KWApXG4gICAgICBlbHNpZiBvZmZzZXRcbiAgICAgICAgc3VwZXIoYG5ldyBEYXRhVmlldygje2J1ZmZlci50b19ufSwgI3tvZmZzZXQudG9fbn0pYClcbiAgICAgIGVsc2VcbiAgICAgICAgc3VwZXIoYG5ldyBEYXRhVmlldygje2J1ZmZlci50b19ufSlgKVxuICAgICAgZW5kXG5cbiAgICAgIEBidWZmZXIgPSBidWZmZXJcbiAgICAgIEBvZmZzZXQgPSBvZmZzZXRcbiAgICBlbmRcblxuICAgIGRlZiBsZW5ndGhcbiAgICAgIGAje0BuYXRpdmV9LmJ5dGVMZW5ndGhgXG4gICAgZW5kXG5cbiAgICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gICAgZGVmIGdldChvZmZzZXQsIGJpdHMgPSA4LCB0eXBlID0gOnVuc2lnbmVkLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9W1wiZ2V0XCIgKyAje0J1ZmZlci5uYW1lX2ZvciBiaXRzLCB0eXBlfV0ob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgYWxpYXMgW10gZ2V0XG5cbiAgICBkZWYgc2V0KG9mZnNldCwgdmFsdWUsIGJpdHMgPSA4LCB0eXBlID0gOnVuc2lnbmVkLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9W1wic2V0XCIgKyAje0J1ZmZlci5uYW1lX2ZvciBiaXRzLCB0eXBlfV0ob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGFsaWFzIFtdPSBzZXRcblxuICAgIGRlZiBnZXRfaW50OChvZmZzZXQsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uZ2V0SW50OChvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X2ludDgob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5zZXRJbnQ4KG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgZ2V0X3VpbnQ4KG9mZnNldCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5nZXRVaW50OChvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X3VpbnQ4KG9mZnNldCwgdmFsdWUsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uc2V0VWludDgob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBnZXRfaW50MTYob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldEludDE2KG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBzZXRfaW50MTYob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5zZXRJbnQxNihvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF91aW50MTYob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgc2V0X3VpbnQxNihvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldFVpbnQxNihvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF9pbnQzMihvZmZzZXQsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uZ2V0SW50MzIob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIHNldF9pbnQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldEludDMyKG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgZ2V0X3VpbnQzMihvZmZzZXQsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBzZXRfdWludDMyKG9mZnNldCwgdmFsdWUsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uc2V0VWludDMyKG9mZnNldCwgdmFsdWUsIGxpdHRsZSlgXG4gICAgZW5kXG5cbiAgICBkZWYgZ2V0X2Zsb2F0MzIob2Zmc2V0LCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LmdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIHNldF9mbG9hdDMyKG9mZnNldCwgdmFsdWUsIGxpdHRsZSA9IGZhbHNlKVxuICAgICAgYCN7QG5hdGl2ZX0uc2V0RmxvYXQzMihvZmZzZXQsIHZhbHVlLCBsaXR0bGUpYFxuICAgIGVuZFxuXG4gICAgZGVmIGdldF9mbG9hdDY0KG9mZnNldCwgbGl0dGxlID0gZmFsc2UpXG4gICAgICBgI3tAbmF0aXZlfS5nZXRGbG9hdDY0KG9mZnNldCwgbGl0dGxlKWBcbiAgICBlbmRcblxuICAgIGRlZiBzZXRfZmxvYXQ2NChvZmZzZXQsIHZhbHVlLCBsaXR0bGUgPSBmYWxzZSlcbiAgICAgIGAje0BuYXRpdmV9LnNldEZsb2F0NjQob2Zmc2V0LCB2YWx1ZSwgbGl0dGxlKWBcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImluY2x1ZGUiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsIiQkIiwiW10iLCJuaWw/IiwiISIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIm5hdGl2ZT8iLCJidWZmZXIiLCJvZmZzZXQiLCJsZW5ndGgiLCJ0b19uIiwiQGJ1ZmZlciIsIkBvZmZzZXQiLCJAbmF0aXZlIiwiZ2V0IiwiOCIsIm5hbWVfZm9yIiwiYml0cyIsInR5cGUiLCJzZXQiLCJnZXRfaW50OCIsInNldF9pbnQ4IiwiZ2V0X3VpbnQ4Iiwic2V0X3VpbnQ4IiwiZ2V0X2ludDE2Iiwic2V0X2ludDE2IiwiZ2V0X3VpbnQxNiIsInNldF91aW50MTYiLCJnZXRfaW50MzIiLCJzZXRfaW50MzIiLCJnZXRfdWludDMyIiwic2V0X3VpbnQzMiIsImdldF9mbG9hdDMyIiwic2V0X2Zsb2F0MzIiLCJnZXRfZmxvYXQ2NCIsInNldF9mbG9hdDY0Il0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsVUFBQUMsU0FBQUEsQ0FBUSxJQUFBLHNCQUFBLFlBQVJBLENBQUE7QUFBQSxNQUVBQyxVQUFJQyxJQUFKRCxpQkFBQUEseUJBQUFBLFNBQUFBO0FBQUFBLFFBQUFBO0FBQUFBOztBQUFBQSxRQUNFLE9BQUNFLFFBQUFDLE9BQUFBLENBQUcsVUFBSEEsQ0FBQUMsU0FBQUEsQ0FBQUEsQ0FBREMsTUFBQUEsQ0FBQUE7QUFERkwsTUFBQUEsQ0FBQUEsb0NBQUFBLENBRkE7QUFBQSxVQU1BTSxhQUFBQSxDQUFZLFVBQVMsUUFBckJB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UUFBQSxDQWhHbkM7QUFBQSxRQWlHTSxPQUFHcEIsY0FBUSxrQ0FqR2pCO0FBZ0dJb0IsTUFBQUEsQ0FBQUEsbUNBQUFBLENBN0ZBO0FBQUE7QUFpR0FDLE1BQUFBLCtCQUFBQSx1QkFBQUEsdUJBQWdCLE1BQUQsRUFBUyxNQUF4QkE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBcEdKO0FBb0c0QixRQUFBO0FBQUEsUUFBQSxXQUFTLEtBQVQ7QUFBQSxRQUFBLENBcEc1QjtBQUFBLFFBcUdNLE9BQUdyQixjQUFRLDJCQXJHakI7QUFvR0lxQixNQUFBQSxDQUFBQSxtQ0FBQUEsQ0FqR0E7QUFBQSxNQXFHQSxPQUFBQyxDQUFBQSwrQkFBQUEsdUJBQUFBLHVCQUFnQixNQUFELEVBQVMsS0FBVCxFQUFnQixNQUEvQkE7QUFBQUEsUUFBQUE7O0FBQUFBO0FBeEdKO0FBd0dtQyxRQUFBO0FBQUEsUUFBQSxXQUFTLEtBQVQ7QUFBQSxRQUFBLENBeEduQztBQUFBLFFBeUdNLE9BQUd0QixjQUFRLGtDQXpHakI7QUF3R0lzQixNQUFBQSxDQUFBQSxtQ0FBQUEsQ0FBQUEsdUJBckdBO0FBREZ2QyxJQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQURGQSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxNjc3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9idWZmZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnbmF0aXZlJ1xucmVxdWlyZSAnYnVmZmVyL2FycmF5J1xucmVxdWlyZSAnYnVmZmVyL3ZpZXcnXG5cbmNsYXNzIEJ1ZmZlclxuICBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlclxuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICAhJCRbOkFycmF5QnVmZmVyXS5uaWw/XG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5hbWVfZm9yKGJpdHMsIHR5cGUpXG4gICAgcGFydCA9IGNhc2UgdHlwZVxuICAgICAgICAgICB3aGVuIDp1bnNpZ25lZCB0aGVuICdVaW50J1xuICAgICAgICAgICB3aGVuIDpzaWduZWQgICB0aGVuICdJbnQnXG4gICAgICAgICAgIHdoZW4gOmZsb2F0ICAgIHRoZW4gJ0Zsb2F0J1xuICAgICAgICAgICBlbmRcbiAgICBcIiN7cGFydH0je2JpdHN9XCJcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoc2l6ZSwgYml0cyA9IDgpXG4gICAgaWYgbmF0aXZlPyhzaXplKVxuICAgICAgc3VwZXIoc2l6ZSlcbiAgICBlbHNlXG4gICAgICBzdXBlcihgbmV3IEFycmF5QnVmZmVyKHNpemUgKiAoYml0cyAvIDgpKWApXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgI3tAbmF0aXZlfS5ieXRlTGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGRlZiB0b19hKGJpdHMgPSA4LCB0eXBlID0gOnVuc2lnbmVkKVxuICAgIEFycmF5Lm5ldyhzZWxmLCBiaXRzLCB0eXBlKVxuICBlbmRcblxuICBkZWYgdmlldyhvZmZzZXQgPSBuaWwsIGxlbmd0aCA9IG5pbClcbiAgICBWaWV3Lm5ldyhzZWxmLCBvZmZzZXQsIGxlbmd0aClcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwic3VwcG9ydGVkPyIsInNlbGYiLCIkJCIsIltdIiwibmlsPyIsIiEiLCJuYW1lX2ZvciIsInBhcnQiLCJ0eXBlIiwiYml0cyIsImluaXRpYWxpemUiLCI4IiwibmF0aXZlPyIsInNpemUiLCJsZW5ndGgiLCJAbmF0aXZlIiwidG9fYSIsIm5ldyIsInZpZXciLCJvZmZzZXQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsUUFBUkEsQ0FBQTtBQUFBLE1BQ0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FEQTtBQUFBLE1BRUFBLFNBQUFBLENBQVEsYUFBUkEsQ0FGQTtBQUFBLEVBSUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsSUFBQSxzQkFBQSxZQUFSQSxDQUFBO0FBQUEsSUFFQUMsVUFBSUMsSUFBSkQsaUJBQUFBLDJCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTtBQUFBQTs7QUFBQUEsTUFDRSxPQUFDRSxRQUFBQyxPQUFBQSxDQUFHLGFBQUhBLENBQUFDLFNBQUFBLENBQUFBLENBQURDLE1BQUFBLENBQUFBO0FBREZMLElBQUFBLENBQUFBLHNDQUFBQSxDQUZBO0FBQUEsSUFNQU0sVUFBSUwsSUFBSkssZUFBQUEscUJBQUFBLG9CQUFrQixJQUFELEVBQU8sSUFBeEJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLE9BQU8sYUFBQSxRQUFLQyxJQUFMO0FBQUEsTUFDQSxJQUFLLHlCQUFMLEdBQW9CLE9BQUEsTUFBcEI7QUFEQSxNQUFBLEtBRUEsSUFBSyx1QkFBTCxHQUFvQixPQUFBLEtBQXBCO0FBRkEsTUFBQSxLQUdBLElBQUssc0JBQUwsR0FBb0IsT0FBQSxPQUFwQjtBQUhBLE1BQUEsbUJBQUEsSUFBUDtBQUFBLE1BS0EsT0FBQSxFQUFBLEdBQUEsQ0FBR0QsSUFBSCxDQUFBLEdBQUEsQ0FBVUUsSUFBVixDQUxBO0FBREZILElBQUFBLENBQUFBLGdDQUFBQSxDQU5BO0FBQUE7QUFlQUksSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBZSxJQUFELEVBQU8sSUFBckJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQXJCRjtBQXFCdUIsTUFBQTtBQUFBLE1BQUEsU0FBT0MsQ0FBUDtBQUFBLE1BQUEsQ0FyQnZCO0FBQUEsTUFzQkksSUFBQSxZQUFHQyxZQUFBQSxDQUFRQyxJQUFSRCxDQUFILENBQUE7QUFBQSxRQUNFLE9BQUEsVUFBQSxFQUFBLDJFQUFBLEVBQUEsQ0FBTUMsSUFBTixDQUFBLE1BQUE7QUFERixNQUFBO0FBQUEsUUFHRSxPQUFBLFVBQUEsRUFBQSwyRUFBQSxFQUFBLENBQU8sa0NBQVAsQ0FBQSxNQUFBO0FBSEYsTUFBQSxDQXRCSjtBQXFCRUgsSUFBQUEsQ0FBQUEsbUNBQUFBLENBZkE7QUFBQTtBQXVCQUksSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBR0MsY0FBUTtBQURiRCxJQUFBQSxDQUFBQSw4QkFBQUEsQ0F2QkE7QUFBQSxJQTJCQSxpQkFBTSxNQUFOLEVBQVcsUUFBWCxDQTNCQTtBQUFBO0FBNkJBRSxJQUFBQSx3QkFBQUEsaUJBQUFBLGdCQUFTLElBQUQsRUFBVyxJQUFuQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbkNGO0FBbUNXLE1BQUE7QUFBQSxNQUFBLFNBQU9MLENBQVA7QUFBQSxNQUFBLENBbkNYO0FBQUE7QUFtQ3FCLE1BQUE7QUFBQSxNQUFBLFNBQU8sVUFBUDtBQUFBLE1BQUEsQ0FuQ3JCO0FBQUEsTUFvQ0ksT0FBQSxxQkFBQU0sS0FBQUEsQ0FBVWhCLE1BQU1RLE1BQU1ELElBQXRCUyxDQXBDSjtBQW1DRUQsSUFBQUEsQ0FBQUEsNkJBQUFBLENBN0JBO0FBQUEsSUFpQ0EsT0FBQUUsQ0FBQUEsd0JBQUFBLGlCQUFBQSxnQkFBUyxNQUFELEVBQWUsTUFBdkJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXZDRjtBQXVDVyxNQUFBO0FBQUEsTUFBQSxXQUFTLEdBQVQ7QUFBQSxNQUFBLENBdkNYO0FBQUE7QUF1Q3lCLE1BQUE7QUFBQSxNQUFBLFdBQVMsR0FBVDtBQUFBLE1BQUEsQ0F2Q3pCO0FBQUEsTUF3Q0ksT0FBQSxvQkFBQUQsS0FBQUEsQ0FBU2hCLE1BQU1rQixRQUFRTCxNQUF2QkcsQ0F4Q0o7QUF1Q0VDLElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQSxnQkFqQ0E7QUFERnBCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBSkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMTc2NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZXZlbnQvbWVzc2FnZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdidWZmZXInXG5cbm1vZHVsZSBCcm93c2VyOyBjbGFzcyBFdmVudFxuXG5jbGFzcyBNZXNzYWdlIDwgRXZlbnRcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5NZXNzYWdlJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBkYXRhPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5kYXRhID0gdmFsdWVgXG4gICAgZW5kXG5cbiAgICBkZWYgb3JpZ2luPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5vcmlnaW4gPSB2YWx1ZWBcbiAgICBlbmRcblxuICAgIGRlZiBzb3VyY2U9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLnNvdXJjZSA9ICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBNZXNzYWdlRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNZXNzYWdlRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0TWVzc2FnZUV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLmRhdGEsIGRlc2Mub3JpZ2luLCBcIlwiLCBkZXNjLnNvdXJjZSB8fCB3aW5kb3cpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kIGlmIHN1cHBvcnRlZD9cblxuICBkZWYgZGF0YVxuICAgICV4e1xuICAgICAgaWYgKHdpbmRvdy5BcnJheUJ1ZmZlciAmJiAjQG5hdGl2ZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuICN7QnVmZmVyLm5ldyhgI0BuYXRpdmUuZGF0YWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHdpbmRvdy5CbG9iICYmICNAbmF0aXZlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiAje0Jsb2IubmV3KGAjQG5hdGl2ZS5kYXRhYCl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjQG5hdGl2ZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDpvcmlnaW5cblxuICBkZWYgc291cmNlXG4gICAgJXh7XG4gICAgICB2YXIgc291cmNlID0gI0BuYXRpdmUuc291cmNlO1xuXG4gICAgICBpZiAod2luZG93LldpbmRvdyAmJiBzb3VyY2UgaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSB7XG4gICAgICAgIHJldHVybiAje1dpbmRvdy5uZXcoYHNvdXJjZWApfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwiY2xhc3MiLCJzdXBwb3J0ZWQ/Iiwic2VsZiIsInN1cHBvcnRzPyIsImRhdGE9IiwiQG5hdGl2ZSIsIm9yaWdpbj0iLCJzb3VyY2U9IiwiY29udmVydCIsInZhbHVlIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJkYXRhIiwibmV3IiwiYWxpYXNfbmF0aXZlIiwic291cmNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFFBQVJBLENBQUE7QUFBQSxF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bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC9jbG9zZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgRXZlbnRcblxuY2xhc3MgQ2xvc2UgPCBFdmVudFxuICBkZWYgc2VsZi5zdXBwb3J0ZWQ/XG4gICAgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LkNsb3NlJ1xuICBlbmRcblxuICBjbGFzcyBEZWZpbml0aW9uIDwgRGVmaW5pdGlvblxuICAgIGRlZiBjb2RlPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5jb2RlID0gI3t2YWx1ZX1gXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhc29uPSh2YWx1ZSlcbiAgICAgIGAjQG5hdGl2ZS5yZWFzb24gPSAje3ZhbHVlfWBcbiAgICBlbmRcblxuICAgIGRlZiBjbGVhbiEodmFsdWUpXG4gICAgICBgI0BuYXRpdmUud2FzQ2xlYW4gPSB0cnVlYFxuICAgIGVuZFxuXG4gICAgZGVmIG5vdF9jbGVhbiEodmFsdWUpXG4gICAgICBgI0BuYXRpdmUud2FzQ2xlYW4gPSBmYWxzZWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNvbnN0cnVjdG9yJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgYG5ldyBDbG9zZUV2ZW50KCN7bmFtZX0sICN7ZGVzY30pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuY3JlYXRlJ1xuICAgIGRlZiBzZWxmLmNvbnN0cnVjdChuYW1lLCBkZXNjKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ2xvc2VFdmVudFwiKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDbG9zZUV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICBkZXNjLndhc0NsZWFuLCBkZXNjLmNvZGUsIGRlc2MucmVhc29uKTtcblxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZCBpZiBzdXBwb3J0ZWQ/XG5cbiAgYWxpYXNfbmF0aXZlIDpjb2RlXG4gIGFsaWFzX25hdGl2ZSA6cmVhc29uXG4gIGFsaWFzX25hdGl2ZSA6Y2xlYW4/LCA6d2FzQ2xlYW5cbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwic3VwcG9ydGVkPyIsInNlbGYiLCJzdXBwb3J0cz8iLCJjb2RlPSIsIkBuYXRpdmUiLCJ2YWx1ZSIsInJlYXNvbj0iLCJjbGVhbiEiLCJub3RfY2xlYW4hIiwiY29uc3RydWN0IiwibmFtZSIsImRlc2MiLCJhbGlhc19uYXRpdmUiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsVUFBSUMsSUFBSkQsaUJBQUFBLDBCQUFBQSxTQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLHVCQUFBRSxjQUFBQSxDQUFrQixhQUFsQkE7QUFERkYsUUFBQUEsQ0FBQUEscUNBQUFBLENBQUE7QUFBQSxRQUlBRDtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUksVUFBQUEseUJBQUFBLHdCQUFBQSxTQUFVLEtBQVZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVDLGNBQU8sUUFBVUM7QUFEckJGLFVBQUFBLENBQUFBLG1DQUFBQSxDQUFBO0FBQUE7QUFJQUcsVUFBQUEsMkJBQUFBLDBCQUFBQSxTQUFZLEtBQVpBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVGLGNBQU8sVUFBWUM7QUFEdkJDLFVBQUFBLENBQUFBLHFDQUFBQSxDQUpBO0FBQUE7QUFRQUMsVUFBQUEsMEJBQUFBLDJCQUFBQSxTQUFXLEtBQVhBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVILGNBQU87QUFEWEcsVUFBQUEsQ0FBQUEsc0NBQUFBLENBUkE7QUFBQSxVQVlBLE9BQUFDLENBQUFBLDhCQUFBQSwrQkFBQUEsU0FBZSxLQUFmQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFSixjQUFPO0FBRFhJLFVBQUFBLENBQUFBLDBDQUFBQSxDQUFBQSxzQkFaQTtBQURGVCxRQUFBQSxHQUFBQSxXQUFBQSxFQUFtQiwwQkFBbkJBLFdBSkE7QUFBQSxRQXNCQSxJQUFBLFlBY09DLGVBQUFBLENBQUFBLENBZFAsQ0FBQTtBQUFBLFVBQUEsSUFBQSxRQUFHLHVCQUFBRSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUgsQ0FBQTtBQUFBLFlBQ0VPLFVBQUlSLElBQUpRLGdCQUFBQSxxQkFBQUEscUJBQW1CLElBQUQsRUFBTyxJQUF6QkE7QUFBQUEsY0FBQUE7O0FBQUFBLGNBQ0UsT0FBQyxlQUFpQkMsSUFBSyxFQUFJQyxJQUFLO0FBRGxDRixZQUFBQSxDQUFBQSxnQ0FBQUE7QUFERixVQUFBLE9BSUEsSUFBQSxRQUFNLHVCQUFBUCxjQUFBQSxDQUFrQixjQUFsQkEsQ0FBTixDQUFBO0FBQUEsWUFDRU8sVUFBSVIsSUFBSlEsZ0JBQUFBLHFCQUFBQSxxQkFBbUIsSUFBRCxFQUFPLElBQXpCQTtBQUFBQSxjQUFBQTs7QUFBQUE7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQVBJQSxZQUFBQSxDQUFBQSxnQ0FBQUEsQ0FERixDQUpBLENBdEJBO0FBQUEsWUFzQ0FHLGNBQUFBLENBQWEsTUFBYkEsQ0F0Q0E7QUFBQSxZQXVDQUEsY0FBQUEsQ0FBYSxRQUFiQSxDQXZDQTtBQUFBLFFBd0NBLFdBQUFBLGNBQUFBLENBQWEsVUFBUyxVQUF0QkEsQ0F4Q0E7QUFERmIsTUFBQUEsR0FBQUEsV0FBQUEsRUFBYyxxQkFBZEE7QUFGZ0JBLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQWhCRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMxOTU5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9ldmVudC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdicm93c2VyL2V2ZW50L2Jhc2UnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L3VpJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9tb3VzZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQva2V5Ym9hcmQnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2ZvY3VzJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC93aGVlbCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvZGF0YV90cmFuc2ZlcidcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvY29tcG9zaXRpb24nXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2FuaW1hdGlvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvYXVkaW9fcHJvY2Vzc2luZydcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvYmVmb3JlX3VubG9hZCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvY29tcG9zaXRpb24nXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2NsaXBib2FyZCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvZGV2aWNlX2xpZ2h0J1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9kZXZpY2VfbW90aW9uJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9kZXZpY2Vfb3JpZW50YXRpb24nXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2RldmljZV9wcm94aW1pdHknXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2RyYWcnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2dhbWVwYWQnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2hhc2hfY2hhbmdlJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9wcm9ncmVzcydcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvcGFnZV90cmFuc2l0aW9uJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9wb3Bfc3RhdGUnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L3N0b3JhZ2UnXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L3RvdWNoJ1xucmVxdWlyZSAnYnJvd3Nlci9ldmVudC9zZW5zb3InXG5yZXF1aXJlICdicm93c2VyL2V2ZW50L2N1c3RvbSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvbWVzc2FnZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZXZlbnQvY2xvc2UnXG5cbm1vZHVsZSBCcm93c2VyXG5cbmNsYXNzIEV2ZW50XG4gIGRlZiBzZWxmLmFsaWFzZXNcbiAgICBAYWxpYXNlcyB8fD0ge1xuICAgICAgJ2RvbTpsb2FkJyA9PiAnRE9NQ29udGVudExvYWRlZCcsXG4gICAgICAnaG92ZXInICAgID0+ICdtb3VzZTpvdmVyJ1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubmFtZV9mb3IobmFtZSlcbiAgICAoYWxpYXNlc1tuYW1lXSB8fCBuYW1lKS5nc3ViKD86LCAnJylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xhc3NfZm9yKG5hbWUpXG4gICAgY2FzZSBuYW1lX2ZvcihuYW1lKVxuICAgICAgd2hlbiAnYW5pbWF0aW9uZW5kJywgJ2FuaW1hdGlvbml0ZXJhdGlvbicsICdhbmltYXRpb25zdGFydCdcbiAgICAgICAgQW5pbWF0aW9uXG5cbiAgICAgIHdoZW4gJ2F1ZGlvcHJvY2VzcydcbiAgICAgICAgQXVkaW9Qcm9jZXNzaW5nXG5cbiAgICAgIHdoZW4gJ2JlZm9yZXVubG9hZCdcbiAgICAgICAgQmVmb3JlVW5sb2FkXG5cbiAgICAgIHdoZW4gJ2NvbXBvc2l0aW9uZW5kJywgJ2NvbXBvc2l0aW9uc3RhcnQnLCAnY29tcG9zaXRpb251cGRhdGUnXG4gICAgICAgIENvbXBvc2l0aW9uXG5cbiAgICAgIHdoZW4gJ2NvcHknLCAnY3V0JywgJ3Bhc3RlJ1xuICAgICAgICBDbGlwYm9hcmRcblxuICAgICAgd2hlbiAnZGV2aWNlbGlnaHQnXG4gICAgICAgIERldmljZUxpZ2h0XG5cbiAgICAgIHdoZW4gJ2RldmljZW1vdGlvbidcbiAgICAgICAgRGV2aWNlTW90aW9uXG5cbiAgICAgIHdoZW4gJ2RldmljZW9yaWVudGF0aW9uJ1xuICAgICAgICBEZXZpY2VPcmllbnRhdGlvblxuXG4gICAgICB3aGVuICdkZXZpY2Vwcm94aW1pdHknXG4gICAgICAgIERldmljZVByb3hpbWl0eVxuXG4gICAgICB3aGVuICdkcmFnJywgJ2RyYWdlbmQnLCAnZHJhZ2VudGVyJywgJ2RyYWdleGl0JywgJ2RyYWdsZWF2ZScsICdkcmFnb3ZlcicsICdkcmFnc3RhcnQnLCAnZHJvcCdcbiAgICAgICAgRHJhZ1xuXG4gICAgICB3aGVuICdnYW1lcGFkY29ubmVjdGVkJywgJ2dhbWVwYWRkaXNjb25uZWN0ZWQnXG4gICAgICAgIEdhbWVwYWRcblxuICAgICAgd2hlbiAnaGFzaGNoYW5nZSdcbiAgICAgICAgSGFzaENoYW5nZVxuXG4gICAgICB3aGVuICdwcm9ncmVzcycsICdsb2FkJywgJ2xvYWRlbmQnLCAnbG9hZHN0YXJ0J1xuICAgICAgICBQcm9ncmVzc1xuXG4gICAgICB3aGVuICdwYWdlaGlkZScsICdwYWdlc2hvdydcbiAgICAgICAgUGFnZVRyYW5zaXRpb25cblxuICAgICAgd2hlbiAncG9wc3RhdGUnXG4gICAgICAgIFBvcFN0YXRlXG5cbiAgICAgIHdoZW4gJ3N0b3JhZ2UnXG4gICAgICAgIFN0b3JhZ2VcblxuICAgICAgd2hlbiAndG91Y2hjYW5jZWwnLCAndG91Y2hlbmQnLCAndG91Y2hsZWF2ZScsICd0b3VjaG1vdmUnLCAndG91Y2hzdGFydCdcbiAgICAgICAgVG91Y2hcblxuICAgICAgd2hlbiAnY29tcGFzc25lZWRzY2FsaWJyYXRpb24nLCAndXNlcnByb3hpbWl0eSdcbiAgICAgICAgU2Vuc29yXG5cbiAgICAgIHdoZW4gJ21lc3NhZ2UnXG4gICAgICAgIE1lc3NhZ2VcblxuICAgICAgd2hlbiAnY2xvc2UnXG4gICAgICAgIENsb3NlXG5cbiAgICAgIHdoZW4gJ2NsaWNrJywgJ2NvbnRleHRtZW51JywgJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZWVudGVyJyxcbiAgICAgICAgICAgJ21vdXNlbGVhdmUnLCAnbW91c2Vtb3ZlJywgJ21vdXNlb3V0JywgJ21vdXNlb3ZlcicsICdtb3VzZXVwJyxcbiAgICAgICAgICAgJ3Nob3cnXG4gICAgICAgIE1vdXNlXG5cbiAgICAgIHdoZW4gJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnXG4gICAgICAgIEtleWJvYXJkXG5cbiAgICAgIHdoZW4gJ2JsdXInLCAnZm9jdXMnLCAnZm9jdXNpbicsICdmb2N1c291dCdcbiAgICAgICAgRm9jdXNcblxuICAgICAgd2hlbiAnd2hlZWwnLCAnbW91c2V3aGVlbCdcbiAgICAgICAgV2hlZWxcblxuICAgICAgd2hlbiAnYWJvcnQnLCAnYWZ0ZXJwcmludCcsICdiZWZvcmVwcmludCcsICdjYWNoZWQnLCAnY2FucGxheScsXG4gICAgICAgICAgICdjYW5wbGF5dGhyb3VnaCcsICdjaGFuZ2UnLCAnY2hhcmdpbmdjaGFuZ2UnLCAnY2hhcmdpbmd0aW1lY2hhbmdlJyxcbiAgICAgICAgICAgJ2NoZWNraW5nJywgJ2Nsb3NlJywgJ2Rpc2NoYXJnaW5ndGltZWNoYW5nZScsICdET01Db250ZW50TG9hZGVkJyxcbiAgICAgICAgICAgJ2Rvd25sb2FkaW5nJywgJ2R1cmF0aW9uY2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5kZWQnLCAnZXJyb3InLFxuICAgICAgICAgICAnZnVsbHNjcmVlbmNoYW5nZScsICdmdWxsc2NyZWVuZXJyb3InLCAnaW5wdXQnLCAnaW52YWxpZCcsXG4gICAgICAgICAgICdsZXZlbGNoYW5nZScsICdsb2FkZWRkYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ25vdXBkYXRlJywgJ29ic29sZXRlJyxcbiAgICAgICAgICAgJ29mZmxpbmUnLCAnb25saW5lJywgJ29wZW4nLCAnb3JpZW50YXRpb25jaGFuZ2UnLCAncGF1c2UnLFxuICAgICAgICAgICAncG9pbnRlcmxvY2tjaGFuZ2UnLCAncG9pbnRlcmxvY2tlcnJvcicsICdwbGF5JywgJ3BsYXlpbmcnLFxuICAgICAgICAgICAncmF0ZWNoYW5nZScsICdyZWFkeXN0YXRlY2hhbmdlJywgJ3Jlc2V0JywgJ3NlZWtlZCcsICdzZWVraW5nJyxcbiAgICAgICAgICAgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1Y2Nlc3MnLCAnc3VzcGVuZCcsICd0aW1ldXBkYXRlJywgJ3VwZGF0ZXJlYWR5JyxcbiAgICAgICAgICAgJ3Zpc2liaWxpdHljaGFuZ2UnLCAndm9sdW1lY2hhbmdlJywgJ3dhaXRpbmcnXG4gICAgICAgIEV2ZW50XG5cbiAgICAgIGVsc2VcbiAgICAgICAgQ3VzdG9tXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnN1cHBvcnRlZD9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNyZWF0ZShuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIG5hbWUgID0gbmFtZV9mb3IobmFtZSlcbiAgICBrbGFzcyA9IGNsYXNzX2ZvcihuYW1lKVxuXG4gICAgZXZlbnQgPSBrbGFzcy5uZXcoa2xhc3MuY29uc3RydWN0KG5hbWUsIGtsYXNzLmNvbnN0X2dldCg6RGVmaW5pdGlvbikubmV3KCZibG9jaykpKVxuICAgIGV2ZW50LmFyZ3VtZW50cyA9IGFyZ3NcblxuICAgIGV2ZW50XG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jb25zdHJ1Y3RvcidcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIGBuZXcgRXZlbnQoI3tuYW1lfSwgI3tkZXNjfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFdmVudC5jcmVhdGUnXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGRlc2MuYnViYmxlcywgZGVzYy5jYW5jZWxhYmxlKTtcblxuICAgICAgICAje3JldHVybiBOYXRpdmUoYGV2ZW50YCkubWVyZ2UhKGRlc2MpfTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0V2ZW50LmNyZWF0ZU9iamVjdCdcbiAgICBkZWYgc2VsZi5jb25zdHJ1Y3QobmFtZSwgZGVzYylcbiAgICAgIE5hdGl2ZShgZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKWApIFxcXG4gICAgICAgIC5tZXJnZSEoZGVzYykgXFxcbiAgICAgICAgLm1lcmdlIShgeyB0eXBlOiBuYW1lIH1gKSBcXFxuICAgICAgICAudG9fblxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIHNlbGYuY29uc3RydWN0KG5hbWUsIGRlc2MpXG4gICAgICBOYXRpdmUoZGVzYykubWVyZ2UhKGB7IHR5cGU6IG5hbWUgfWApLnRvX25cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYubmV3KHZhbHVlLCBjYWxsYmFjayA9IG5pbClcbiAgICByZXR1cm4gc3VwZXIgdW5sZXNzIHNlbGYgPT0gRXZlbnRcblxuICAgIGtsYXNzID0gY2xhc3NfZm9yKGNhbGxiYWNrID8gY2FsbGJhY2submFtZSA6IGB2YWx1ZS50eXBlYClcblxuICAgIGlmIGtsYXNzID09IEV2ZW50XG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIGtsYXNzLm5ldyh2YWx1ZSwgY2FsbGJhY2spXG4gICAgZW5kXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpjYWxsYmFja1xuICBhdHRyX3dyaXRlciA6b25cblxuICBkZWYgaW5pdGlhbGl6ZShldmVudCwgY2FsbGJhY2sgPSBuaWwpXG4gICAgc3VwZXIoZXZlbnQpXG5cbiAgICBAY2FsbGJhY2sgPSBjYWxsYmFja1xuICBlbmRcblxuICBkZWYgbmFtZVxuICAgIGAjQG5hdGl2ZS50eXBlYFxuICBlbmRcblxuICBkZWYgb25cbiAgICBAb24gfHwgVGFyZ2V0LmNvbnZlcnQoYCNAbmF0aXZlLmN1cnJlbnRUYXJnZXRgKVxuICBlbmRcblxuICBkZWYgdGFyZ2V0XG4gICAgVGFyZ2V0LmNvbnZlcnQoYCNAbmF0aXZlLnNyY0VsZW1lbnQgfHwgI0BuYXRpdmUudGFyZ2V0YClcbiAgZW5kXG5cbiAgZGVmIGFyZ3VtZW50c1xuICAgIGAjQG5hdGl2ZS5hcmd1bWVudHMgfHwgW11gXG4gIGVuZFxuXG4gIGRlZiBhcmd1bWVudHM9KGFyZ3MpXG4gICAgYCNAbmF0aXZlLmFyZ3VtZW50cyA9ICN7YXJnc31gXG4gIGVuZFxuXG4gIGFsaWFzX25hdGl2ZSA6YnViYmxlcz8sIDpidWJibGVzXG4gIGFsaWFzX25hdGl2ZSA6Y2FuY2VsYWJsZT8sIDpjYW5jZWxhYmxlXG4gIGFsaWFzX25hdGl2ZSA6ZGF0YVxuICBhbGlhc19uYXRpdmUgOnBoYXNlLCA6ZXZlbnRQaGFzZVxuICBhbGlhc19uYXRpdmUgOmF0LCA6dGltZVN0YW1wXG5cbiAgZGVmIG9mZlxuICAgIEBjYWxsYmFjay5vZmYgaWYgQGNhbGxiYWNrXG4gIGVuZFxuXG4gIGRlZiBzdG9wcGVkP1xuICAgIGAhISNAbmF0aXZlLnN0b3BwZWRgXG4gIGVuZFxuXG4gIGRlZiBzdG9wXG4gICAgYCNAbmF0aXZlLnN0b3BQcm9wYWdhdGlvbigpYCBpZiBkZWZpbmVkPyhgI0BuYXRpdmUuc3RvcFByb3BhZ2F0aW9uYClcbiAgICBgI0BuYXRpdmUuc3RvcHBlZCA9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBwcmV2ZW50XG4gICAgYCNAbmF0aXZlLnByZXZlbnREZWZhdWx0KClgIGlmIGRlZmluZWQ/KGAjQG5hdGl2ZS5wcmV2ZW50RGVmYXVsdGApXG4gICAgYCNAbmF0aXZlLnByZXZlbnRlZCA9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBwcmV2ZW50ZWQ/XG4gICAgYCEhI0BuYXRpdmUucHJldmVudGVkYFxuICBlbmRcblxuICBkZWYgc3RvcCFcbiAgICBwcmV2ZW50XG4gICAgc3RvcFxuICBlbmRcbmVuZFxuXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwiY2xhc3MiLCJhbGlhc2VzIiwic2VsZiIsIkBhbGlhc2VzIiwibmFtZV9mb3IiLCJbXSIsIm5hbWUiLCJnc3ViIiwiY2xhc3NfZm9yIiwic3VwcG9ydGVkPyIsImNyZWF0ZSIsImtsYXNzIiwiZXZlbnQiLCJuZXciLCJjb25zdHJ1Y3QiLCJjb25zdF9nZXQiLCJibG9jayIsIiR3cml0ZXIiLCJhcmdzIiwiYXJndW1lbnRzPSIsIi0iLCIxIiwic3VwcG9ydHM/IiwiZGVzYyIsIk5hdGl2ZSIsIm1lcmdlISIsInRvX24iLCI9PSIsImNhbGxiYWNrIiwidmFsdWUiLCJhdHRyX3JlYWRlciIsImF0dHJfd3JpdGVyIiwiaW5pdGlhbGl6ZSIsIkBjYWxsYmFjayIsIkBuYXRpdmUiLCJvbiIsIkBvbiIsImNvbnZlcnQiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJhbGlhc19uYXRpdmUiLCJvZmYiLCJzdG9wcGVkPyIsInN0b3AiLCJwcmV2ZW50IiwicHJldmVudGVkPyIsInN0b3AhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSxrQkFBUkEsQ0FEQTtBQUFBLE1BRUFBLFNBQUFBLENBQVEscUJBQVJBLENBRkE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLHdCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSxxQkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEscUJBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLDZCQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSwyQkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEseUJBQVJBLENBUkE7QUFBQSxNQVNBQSxTQUFBQSxDQUFRLGdDQUFSQSxDQVRBO0FBQUEs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IiIsInNvdXJjZXMiOlsiYnJvd3Nlci93aW5kb3cvdmlldy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgY2xhc3MgV2luZG93XG5cbmNsYXNzIFZpZXdcbiAgZGVmIGluaXRpYWxpemUod2luZG93KVxuICAgIEB3aW5kb3cgPSB3aW5kb3dcbiAgICBAbmF0aXZlID0gd2luZG93LnRvX25cbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ1dpbmRvdy5pbm5lclNpemUnXG4gICAgZGVmIHdpZHRoXG4gICAgICBgI0BuYXRpdmUuaW5uZXJXaWR0aGBcbiAgICBlbmRcblxuICAgIGRlZiBoZWlnaHRcbiAgICAgIGAjQG5hdGl2ZS5pbm5lckhlaWdodGBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQuY2xpZW50U2l6ZSdcbiAgICBkZWYgaGVpZ2h0XG4gICAgICBgI0BuYXRpdmUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodGBcbiAgICBlbmRcblxuICAgIGRlZiB3aWR0aFxuICAgICAgYCNAbmF0aXZlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aGBcbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiB3aWR0aFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3dpbmRvdyBzaXplIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuXG4gICAgZGVmIGhlaWdodFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3dpbmRvdyBzaXplIHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiaW5pdGlhbGl6ZSIsIkB3aW5kb3ciLCJ3aW5kb3ciLCJAbmF0aXZlIiwidG9fbiIsInN1cHBvcnRzPyIsIndpZHRoIiwiaGVpZ2h0IiwicmFpc2UiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQixPQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUMsUUFBQUEsOEJBQUFBLHFCQUFBQSxzQkFBZSxNQUFmQTtBQUFBQSxVQUFBQTs7QUFBQUE7QUFDRSxVQUFBQyxjQUFVQyxNQUFWO0FBQUEsVUFDQSxPQUFBQyxDQUFBQSxpQkFBVUQsTUFBQUUsTUFBQUEsQ0FBQUEsQ0FBVkQsQ0FEQTtBQURGSCxRQUFBQSxDQUFBQSxnQ0FBQUEsQ0FBQTtBQUFBLFFBS0EsSUFBQSxRQUFHLHVCQUFBSyxjQUFBQSxDQUFrQixrQkFBbEJBLENBQUgsQ0FBQTtBQUFBO0FBQ0U7QUFBQUMsVUFBQUEseUJBQUFBLGdCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUgsY0FBTztBQURYRyxVQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQTtBQUFBLFVBSUEsT0FBQUMsQ0FBQUEsMEJBQUFBLGlCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUosY0FBTztBQURYSSxVQUFBQSxDQUFBQSw0QkFBQUEsQ0FBQUEsa0JBSkE7QUFERixRQUFBLE9BUUEsSUFBQSxRQUFNLHVCQUFBRixjQUFBQSxDQUFrQixvQkFBbEJBLENBQU4sQ0FBQTtBQUFBO0FBQ0U7QUFBQUUsVUFBQUEsMEJBQUFBLGlCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUosY0FBTztBQURYSSxVQUFBQSxDQUFBQSw0QkFBQUEsQ0FBQTtBQUFBLFVBSUEsT0FBQUQsQ0FBQUEseUJBQUFBLGdCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUgsY0FBTztBQURYRyxVQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQUEsaUJBSkE7QUFERixRQUFBO0FBQUE7QUFTRTtBQUFBQSxVQUFBQSx5QkFBQUEsZ0JBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxXQUFBRSxPQUFBQSxDQUFNLHFDQUFxQix5QkFBM0JBO0FBREZGLFVBQUFBLENBQUFBLDJCQUFBQSxDQUFBO0FBQUEsVUFJQSxPQUFBQyxDQUFBQSwwQkFBQUEsaUJBQUFBLGtCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxXQUFBQyxPQUFBQSxDQUFNLHFDQUFxQix5QkFBM0JBO0FBREZELFVBQUFBLENBQUFBLDRCQUFBQSxDQUFBQSxrQkFKQTtBQVRGLFFBQUEsQ0FiQTtBQURGUixNQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUZnQkEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBaEJELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzIzMTIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL3dpbmRvdy9zaXplLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBjbGFzcyBXaW5kb3dcblxuIyBBbGxvd3MgYWNjZXNzIGFuZCBtYW5pcHVsYXRpb24gb2YgdGhlIHtXaW5kb3d9IHNpemUuXG5jbGFzcyBTaXplXG4gICMgQHByaXZhdGVcbiAgZGVmIGluaXRpYWxpemUod2luZG93KVxuICAgIEB3aW5kb3cgPSB3aW5kb3dcbiAgICBAbmF0aXZlID0gd2luZG93LnRvX25cbiAgZW5kXG5cbiAgZGVmIHNldCgqYXJncylcbiAgICBpZiBIYXNoID09PSBhcmdzLmZpcnN0XG4gICAgICB3aWR0aCwgaGVpZ2h0ID0gYXJncy5maXJzdC52YWx1ZXNfYXQoOndpZHRoLCA6aGVpZ2h0KVxuICAgIGVsc2VcbiAgICAgIHdpZHRoLCBoZWlnaHQgPSBhcmdzXG4gICAgZW5kXG5cbiAgICB3aWR0aCAgfHw9IHNlbGYud2lkdGhcbiAgICBoZWlnaHQgfHw9IHNlbGYuaGVpZ2h0XG5cbiAgICBgI0BuYXRpdmUucmVzaXplVG8oI3t3aWR0aH0sICN7aGVpZ2h0fSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgd2lkdGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgd2lkdGggb2YgdGhlIHdpbmRvd1xuXG4gICMgQCFhdHRyaWJ1dGUgaGVpZ2h0XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIGhlaWdodCBvZiB0aGUgd2luZG93XG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ1dpbmRvdy5vdXRlclNpemUnXG4gICAgZGVmIHdpZHRoXG4gICAgICBgI0BuYXRpdmUub3V0ZXJXaWR0aGBcbiAgICBlbmRcblxuICAgIGRlZiBoZWlnaHRcbiAgICAgIGAjQG5hdGl2ZS5vdXRlckhlaWdodGBcbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiB3aWR0aFxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3dpbmRvdyBvdXRlciBzaXplIG5vdCBzdXBwb3J0ZWQnXG4gICAgZW5kXG5cbiAgICBkZWYgaGVpZ2h0XG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnd2luZG93IG91dGVyIHNpemUgbm90IHN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHdpZHRoPSh2YWx1ZSlcbiAgICBzZXQod2lkdGg6IHZhbHVlKVxuICBlbmRcblxuICBkZWYgaGVpZ2h0PSh2YWx1ZSlcbiAgICBzZXQoaGVpZ2h0OiB2YWx1ZSlcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImluaXRpYWxpemUiLCJAd2luZG93Iiwid2luZG93IiwiQG5hdGl2ZSIsInRvX24iLCJzZXQiLCI9PT0iLCJhcmdzIiwiZmlyc3QiLCJ2YWx1ZXNfYXQiLCJ3aWR0aCIsImhlaWdodCIsInNlbGYiLCJzdXBwb3J0cz8iLCJyYWlzZSIsIndpZHRoPSIsInZhbHVlIiwiaGVpZ2h0PSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFB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Z0JBLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQWhCRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMyNDA2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci93aW5kb3cucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci93aW5kb3cvdmlldydcbnJlcXVpcmUgJ2Jyb3dzZXIvd2luZG93L3NpemUnXG5cbm1vZHVsZSBCcm93c2VyXG5cbiMgV3JhcHBlciBjbGFzcyBmb3IgdGhlIGB3aW5kb3dgIG9iamVjdCwgYW4gaW5zdGFuY2Ugb2YgaXQgZ2V0c1xuIyBzZXQgdG8gYCR3aW5kb3dgLlxuY2xhc3MgV2luZG93XG4gIGRlZiBzZWxmLm9wZW4odXJsLCBvcHRpb25zKVxuICAgIG5hbWUgICAgID0gb3B0aW9ucy5kZWxldGUoOm5hbWUpXG4gICAgZmVhdHVyZXMgPSBvcHRpb25zLm1hcCB7fGtleSwgdmFsdWV8XG4gICAgICB2YWx1ZSA9IGNhc2UgdmFsdWVcbiAgICAgICAgICAgICAgd2hlbiB0cnVlICB0aGVuIDp5ZXNcbiAgICAgICAgICAgICAgd2hlbiBmYWxzZSB0aGVuIDpub1xuICAgICAgICAgICAgICBlbHNlICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIFwiI3trZXl9PSN7dmFsdWV9XCJcbiAgICB9LmpvaW4oPywpXG5cbiAgICAleHtcbiAgICAgIHZhciB3aW4gPSB3aW5kb3cub3Blbigje3VybH0sICN7bmFtZX0sICN7ZmVhdHVyZXN9KTtcblxuICAgICAgaWYgKHdpbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje25ldyhgd2luYCl9O1xuICAgIH1cbiAgZW5kXG5cbiAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG4gIGluY2x1ZGUgRXZlbnQ6OlRhcmdldFxuXG4gIHRhcmdldCB7fHZhbHVlfFxuICAgICR3aW5kb3cgaWYgYCN7dmFsdWV9ID09IHdpbmRvd2BcbiAgfVxuXG4gICMgQWxlcnQgdGhlIHBhc3NlZCBzdHJpbmcuXG4gIGRlZiBhbGVydCh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuYWxlcnQodmFsdWUpYFxuXG4gICAgdmFsdWVcbiAgZW5kXG5cbiAgIyBEaXNwbGF5IGEgcHJvbXB0IGRpYWxvZyB3aXRoIHRoZSBwYXNzZWQgc3RyaW5nIGFzIHRleHQuXG4gIGRlZiBwcm9tcHQodmFsdWUpXG4gICAgYCNAbmF0aXZlLnByb21wdCh2YWx1ZSkgfHwgbmlsYFxuICBlbmRcblxuICAjIERpc3BsYXkgYSBjb25maXJtYXRpb24gZGlhbG9nIHdpdGggdGhlIHBhc3NlZCBzdHJpbmcgYXMgdGV4dC5cbiAgZGVmIGNvbmZpcm0odmFsdWUpXG4gICAgYCNAbmF0aXZlLmNvbmZpcm0odmFsdWUpIHx8IGZhbHNlYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBwYXJlbnRcbiAgIyBAcmV0dXJuIFtXaW5kb3ddIHBhcmVudCBvZiB0aGUgY3VycmVudCB3aW5kb3cgb3Igc3ViZnJhbWVcbiAgZGVmIHBhcmVudFxuICAgIEBwYXJlbnQgfHw9IEJyb3dzZXI6OldpbmRvdy5uZXcoYCNAbmF0aXZlLnBhcmVudGApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHRvcFxuICAjIEByZXR1cm4gW1dpbmRvd10gcmVmZXJlbmNlIHRvIHRoZSB0b3Btb3N0IHdpbmRvdyBpbiB0aGUgd2luZG93IGhpZXJhcmNoeVxuICBkZWYgdG9wXG4gICAgQHRvcCB8fD0gQnJvd3Nlcjo6V2luZG93Lm5ldyhgI0BuYXRpdmUudG9wYClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gb3BlbmVyXG4gICMgQHJldHVybiBbV2luZG93XSByZWZlcmVuY2UgdG8gdGhlIHdpbmRvdyB0aGF0IG9wZW5lZCB0aGUgd2luZG93IHVzaW5nIGBvcGVuYFxuICBkZWYgb3BlbmVyXG4gICAgQG9wZW5lciB8fD0gQnJvd3Nlcjo6V2luZG93Lm5ldyhgI0BuYXRpdmUub3BlbmVyYClcbiAgZW5kXG5cbiAgIyBHZXQgdGhlIHtWaWV3fSBmb3IgdGhlIHdpbmRvdy5cbiAgI1xuICAjIEByZXR1cm4gW1ZpZXddXG4gIGRlZiB2aWV3XG4gICAgQHZpZXcgfHw9IFZpZXcubmV3KHNlbGYpXG4gIGVuZFxuXG4gICMgR2V0IHRoZSB7U2l6ZX0gZm9yIHRoaXMgd2luZG93LlxuICAjXG4gICMgQHJldHVybiBbU2l6ZV1cbiAgZGVmIHNpemVcbiAgICBAc2l6ZSB8fD0gU2l6ZS5uZXcoc2VsZilcbiAgZW5kXG5cbiAgIyBHZXQgdGhlIHtET006OkVsZW1lbnQ6OlNjcm9sbH0gZm9yIHRoaXMgd2luZG93LlxuICAjXG4gICMgQHJldHVybiBbRE9NOjpFbGVtZW50OjpTY3JvbGxdXG4gIGRlZiBzY3JvbGxcbiAgICBAc2Nyb2xsIHx8PSBET006OkVsZW1lbnQ6OlNjcm9sbC5uZXcoc2VsZilcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ1dpbmRvdy5zZW5kJ1xuICAgIGRlZiBzZW5kKG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSlcbiAgICAgIGAjQG5hdGl2ZS5wb3N0TWVzc2FnZSgje21lc3NhZ2V9LCAje29wdGlvbnNbOnRvXSB8fCAnKid9KWBcbiAgICBlbmRcbiAgZWxzZVxuICAgICMgU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHdpbmRvdy5cbiAgICAjXG4gICAgIyBAcGFyYW0gbWVzc2FnZSBbU3RyaW5nXSB0aGUgbWVzc2FnZVxuICAgICMgQHBhcmFtIG9wdGlvbnMgW0hhc2hdIG9wdGlvbmFsIGB0bzogdGFyZ2V0YFxuICAgIGRlZiBzZW5kKG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSlcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdtZXNzYWdlIHNlbmRpbmcgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBjbG9zZVxuICAgIGAje0BuYXRpdmV9LmNsb3NlKClgXG4gIGVuZFxuZW5kXG5cbmVuZFxuXG4kd2luZG93ID0gQnJvd3Nlcjo6V2luZG93Lm5ldyhgd2luZG93YClcblxubW9kdWxlIEtlcm5lbFxuICAjIChzZWUgQnJvd3Nlcjo6V2luZG93I2FsZXJ0KVxuICBkZWYgYWxlcnQodmFsdWUpXG4gICAgJHdpbmRvdy5hbGVydCh2YWx1ZSlcbiAgZW5kXG5cbiAgIyAoc2VlIEJyb3dzZXI6OldpbmRvdyNwcm9tcHQpXG4gIGRlZiBwcm9tcHQodmFsdWUpXG4gICAgJHdpbmRvdy5wcm9tcHQodmFsdWUpXG4gIGVuZFxuXG4gICMgKHNlZSBCcm93c2VyOjpXaW5kb3cjY29uZmlybSlcbiAgZGVmIGNvbmZpcm0odmFsdWUpXG4gICAgJHdpbmRvdy5jb25maXJtKHZhbHVlKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJtb2R1bGUiLCJjbGFzcyIsIm9wZW4iLCJzZWxmIiwibmFtZSIsIm9wdGlvbnMiLCJkZWxldGUiLCJmZWF0dXJlcyIsIm1hcCIsInZhbHVlIiwia2V5Iiwiam9pbiIsInVybCIsIm5ldyIsImluY2x1ZGUiLCJ0YXJnZXQiLCIkd2luZG93IiwiYWxlcnQiLCJAbmF0aXZlIiwicHJvbXB0IiwiY29uZmlybSIsInBhcmVudCIsIkBwYXJlbnQiLCJ0b3AiLCJAdG9wIiwib3BlbmVyIiwiQG9wZW5lciIsInZpZXciLCJAdmlldyIsInNpemUiLCJAc2l6ZSIsInNjcm9sbCIsIkBzY3JvbGwiLCJzdXBwb3J0cz8iLCJzZW5kIiwibWVzc2FnZSIsIltdIiwicmFpc2UiLCJjbG9zZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxxQkFBUkEsQ0FBQTtBQUFBLE1BQ0FBLFNBQUFBLENBQVEscUJBQVJBLENBREE7QUFBQSxFQUdBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBSUFDO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUE7QUFBQUE7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QVVBQyxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFZLEtBQVpBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQSxNQUNFLE9BQUFKLGFBQUFJLFNBQUFBLENBQWdCWCxLQUFoQlc7QUFERkEsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBVkE7QUFGRnBCLEVBQUFBLEdBQUFBLFdBQUFBLFdBckhBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzI1OTEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9ub2RlX3NldC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG4jIEFsbG93cyBtYW5pcHVsYXRpb24gb2YgYSBzZXQgb2Yge05vZGV9cy5cbmNsYXNzIE5vZGVTZXRcbiAgIyBDcmVhdGUgYSBuZXcge05vZGVTZXR9IGZyb20gdGhlIGdpdmVuIG5vZGVzLlxuICAjXG4gICMgTm90ZSB0aGF0IHRoZSBub2RlcyBhcmUgZmxhdHRlbmVkIGFuZCBjb252ZXJ0ZWQgd2l0aCBET00gYXV0b21hdGljYWxseSxcbiAgIyB0aGlzIG1lYW5zIHlvdSBjYW4gcGFzcyB7Tm9kZVNldH1zIGFuZCB7TmF0aXZlOjpBcnJheX1zIGFzIHdlbGwuXG4gIGRlZiBzZWxmLltdKCpub2RlcylcbiAgICBuZXcobm9kZXMuZmxhdHRlbi5tYXAgeyB8eHwgRE9NKE5hdGl2ZS5jb252ZXJ0KHgpKSB9LnVuaXEpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGxpdGVyYWwpXG4gICAgQGxpdGVyYWwgPSBsaXRlcmFsXG4gIGVuZFxuXG4gICMgQW55IG90aGVyIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBub2RlIGluIHRoZSBzZXQuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhuYW1lLCAqYXJncywgJmJsb2NrKVxuICAgIHVubGVzcyBAbGl0ZXJhbC5yZXNwb25kX3RvPyBuYW1lXG4gICAgICBlYWNoIHt8ZWx8XG4gICAgICAgIGVsLl9fc2VuZF9fKG5hbWUsICphcmdzLCAmYmxvY2spXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZW5kXG5cbiAgICByZXN1bHQgPSBAbGl0ZXJhbC5fX3NlbmRfXyBuYW1lLCAqYXJncywgJmJsb2NrXG5cbiAgICBpZiBgcmVzdWx0ID09PSAjQGxpdGVyYWxgXG4gICAgICBzZWxmXG4gICAgZWxzaWYgQXJyYXkgPT09IHJlc3VsdFxuICAgICAgTm9kZVNldC5uZXcocmVzdWx0KVxuICAgIGVsc2VcbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhuYW1lLCAqKVxuICAgIEBsaXRlcmFsLnJlc3BvbmRfdG8/KG5hbWUpXG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3JzLlxuICAjXG4gICMgQHBhcmFtIHJ1bGVzIFtBcnJheTxTdHJpbmc+XSB0aGUgQ1NTIHNlbGVjdG9ycyB0byBtYXRjaCB3aXRoXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlP11cbiAgZGVmIGF0X2NzcygqcnVsZXMpXG4gICAgZWFjaCB7fG5vZGV8XG4gICAgICBpZiBub2RlID0gbm9kZS5hdF9jc3MoKnJ1bGVzKVxuICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gICMgR2V0IHRoZSBmaXJzdCBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBYUGF0aC5cbiAgI1xuICAjIEBwYXJhbSBwYXRocyBbQXJyYXk8U3RyaW5nPl0gdGhlIFhQYXRoIHRvIG1hdGNoIHdpdGhcbiAgI1xuICAjIEByZXR1cm4gW05vZGU/XVxuICBkZWYgYXRfeHBhdGgoKnBhdGhzKVxuICAgIGVhY2gge3xub2RlfFxuICAgICAgaWYgbm9kZSA9IG5vZGUuYXRfeHBhdGgoKnBhdGhzKVxuICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgZW5kXG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gICMgUXVlcnkgZm9yIGNoaWxkcmVuIG1hdGNoaW5nIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gICNcbiAgIyBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgQ1NTIHNlbGVjdG9yXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlU2V0XVxuICBkZWYgY3NzKHBhdGgpXG4gICAgTm9kZVNldFtAbGl0ZXJhbC5tYXAge3xub2RlfFxuICAgICAgbm9kZS5jc3MocGF0aClcbiAgICB9XVxuICBlbmRcblxuICAjIENyZWF0ZSBhbm90aGVyIHtOb2RlU2V0fSB3aXRoIGFsbCB0aGUgbm9kZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW5cbiAgIyBleHByZXNzaW9uLlxuICAjXG4gICMgQHBhcmFtIGV4cHJlc3Npb24gW1N0cmluZ10gYSBDU1Mgc2VsZWN0b3JcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSBuZXcge05vZGVTZXR9IHdpdGggdGhlIG1hdGNoaW5nIG5vZGVzXG4gIGRlZiBmaWx0ZXIoZXhwcmVzc2lvbilcbiAgICBOb2RlU2V0W0BsaXRlcmFsLnNlbGVjdCB7IHxub2RlfCBub2RlID1+IGV4cHJlc3Npb24gfV1cbiAgZW5kXG5cbiAgIyBTZWFyY2ggZm9yIG11bHRpcGxlIHNlbGVjdG9yc1xuICBkZWYgc2VhcmNoKCp3aGF0KVxuICAgIE5vZGVTZXRbQGxpdGVyYWwubWFwIHsgfG5vZGV8IG5vZGUuc2VhcmNoKCp3aGF0KSB9XVxuICBlbmRcblxuICAjIFF1ZXJ5IGZvciBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gWFBhdGguXG4gICNcbiAgIyBAcGFyYW0gcGF0aCBbU3RyaW5nXSB0aGUgWFBhdGhcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdXG4gIGRlZiB4cGF0aChwYXRoKVxuICAgIE5vZGVTZXRbQGxpdGVyYWwubWFwIHt8bm9kZXxcbiAgICAgIG5vZGUueHBhdGgocGF0aClcbiAgICB9XVxuICBlbmRcblxuICBkZWYgdG9fYXJ5XG4gICAgQGxpdGVyYWxcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsIltdIiwic2VsZiIsIm5ldyIsIm1hcCIsIm5vZGVzIiwiZmxhdHRlbiIsIkRPTSIsImNvbnZlcnQiLCJ4IiwidW5pcSIsImluaXRpYWxpemUiLCJAbGl0ZXJhbCIsImxpdGVyYWwiLCJtZXRob2RfbWlzc2luZyIsInJlc3BvbmRfdG8/IiwibmFtZSIsImVhY2giLCJfX3NlbmRfXyIsImVsIiwiYXJncyIsImJsb2NrIiwicmVzdWx0IiwiPT09IiwicmVzcG9uZF90b19taXNzaW5nPyIsImF0X2NzcyIsIm5vZGUiLCJydWxlcyIsImF0X3hwYXRoIiwicGF0aHMiLCJjc3MiLCJwYXRoIiwiZmlsdGVyIiwic2VsZWN0IiwiPX4iLCJleHByZXNzaW9uIiwic2VhcmNoIiwid2hhdCIsInhwYXRoIiwidG9fYXJ5Il0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFHaEJDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFBQUE7QUFLRSxRQUFBQyxVQUFJQyxJQUFKRCxTQUFBQSxnQkFBQUEsU0FURixFQVNFQTtBQUFBQSxVQUFBQTs7QUFBQUE7QUFURjtBQUFBLFVBQUEsNERBQUE7QUFBQTtBQVNjLFVBQUEsbUJBVGQ7QUFBQSxVQVVJLFdBQUFFLEtBQUFBLENBQUlDLE1BQUFDLEtBQUFDLFNBQUFBLENBQUFBLENBQUFGLE9BQUFBLEVBQUFBLEVBQUFBLEVBVlIsZ0JBVTZCLENBVjdCLEVBQUE7O0FBQUE7QUFBQTtBQVU2QixZQUFBO0FBQUEsWUFBQTtBQUFBLFlBQUEsQ0FWN0I7QUFBQSxZQVVnQyxXQUFBRyxLQUFBQSxDQUFJLHNCQUFBQyxTQUFBQSxDQUFlQyxDQUFmRCxDQUFKRCxDQVZoQyxDQUFBLGtCQUFBLGlCQUFBLEtBVVFILENB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QUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMjc5NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL25vZGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBBYnN0cmFjdCBjbGFzcyBmb3IgYWxsIERPTSBub2RlIHR5cGVzLlxuI1xuIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlXG5jbGFzcyBOb2RlXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gIEVMRU1FTlRfTk9ERSAgICAgICAgICAgICAgICA9IDFcbiAgQVRUUklCVVRFX05PREUgICAgICAgICAgICAgID0gMlxuICBURVhUX05PREUgICAgICAgICAgICAgICAgICAgPSAzXG4gIENEQVRBX1NFQ1RJT05fTk9ERSAgICAgICAgICA9IDRcbiAgRU5USVRZX1JFRkVSRU5DRV9OT0NFICAgICAgID0gNVxuICBFTlRJVFlfTk9ERSAgICAgICAgICAgICAgICAgPSA2XG4gIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSA9IDdcbiAgQ09NTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gOFxuICBET0NVTUVOVF9OT0RFICAgICAgICAgICAgICAgPSA5XG4gIERPQ1VNRU5UX1RZUEVfTk9ERSAgICAgICAgICA9IDEwXG4gIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgICAgICA9IDExXG4gIE5PVEFUSU9OX05PREUgICAgICAgICAgICAgICA9IDEyXG5cbiAgIyBXcmFwIGEgbmF0aXZlIERPTSBub2RlLlxuICAjXG4gICMgQHBhcmFtIHZhbHVlIFtuYXRpdmVdIHRoZSBuYXRpdmUgRE9NIG5vZGVcbiAgI1xuICAjIEByZXR1cm4gW05vZGVdXG4gIGRlZiBzZWxmLm5ldyh2YWx1ZSlcbiAgICBpZiBzZWxmID09IE5vZGVcbiAgICAgIEBjbGFzc2VzIHx8PSBbbmlsLCBFbGVtZW50LCBBdHRyaWJ1dGUsIFRleHQsIENEQVRBLCBuaWwsIG5pbCwgbmlsLCBDb21tZW50LCBEb2N1bWVudCwgbmlsLCBEb2N1bWVudEZyYWdtZW50XVxuXG4gICAgICBpZiBrbGFzcyA9IEBjbGFzc2VzW2B2YWx1ZS5ub2RlVHlwZWBdXG4gICAgICAgIGtsYXNzLm5ldyh2YWx1ZSlcbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2Nhbm5vdCBpbnN0YW50aWF0ZSBhIG5vbiBkZXJpdmVkIE5vZGUgb2JqZWN0J1xuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBSZXR1cm4gdHJ1ZSBvZiB0aGUgb3RoZXIgZWxlbWVudCBpcyB0aGUgc2FtZSB1bmRlcmx5aW5nIERPTSBub2RlLlxuICAjXG4gICMgQHJldHVybiBbQm9vbGVhbl1cbiAgZGVmID09KG90aGVyKVxuICAgIGAjQG5hdGl2ZSA9PT0gI3tOYXRpdmUuY29udmVydChvdGhlcil9YFxuICBlbmRcblxuICAjIEluaXRpYWxpemUgYSBuZXcgbm9kZSBhZnRlciBgI2R1cGAgb3IgYCNjbG9uZWAuXG4gICNcbiAgIyBUaGlzIG1ldGhvZCBpcyBub3QgdG8gYmUgY2FsbGVkIGRpcmVjdGx5LiBVc2UgYE5vZGUjZHVwYCBvclxuICAjIGBOb2RlI2Nsb25lYC5cbiAgI1xuICAjIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBkZWVwIGRldGFjaGVkIGNsb25lIG9mIGEgRE9NIHN1YnRyZWUgdG8gYmUgdXNlZFxuICAjIGluIHRoZSBzYW1lIGRvY3VtZW50LiBUaGUgbmV3IG5vZGUgd2lsbCBoYXZlIGFsbCBldmVudHMgZGV0YWNoZWQuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob2xkKVxuICAgIHNldF9uYXRpdmVfcmVmZXJlbmNlIGAje29sZC50b19ufS5jbG9uZU5vZGUodHJ1ZSlgXG4gIGVuZFxuXG4gICMgQXBwZW5kIGEgY2hpbGQgdG8gdGhlIG5vZGUuXG4gICNcbiAgIyBXaGVuIHBhc3NpbmcgYSB7U3RyaW5nfSBhIHRleHQgbm9kZSB3aWxsIGJlIGNyZWF0ZWQuXG4gICNcbiAgIyBXaGVuIHBhc3NpbmcgYW4gT2JqZWN0IHRoYXQgcmVzcG9uZHMgdG8gI2VhY2gsIGV2ZXJ5IHlpZWxkZWQgZWxlbWVudFxuICAjIHdpbGwgYmUgYWRkZWQgZm9sbG93aW5nIHRoZSBzYW1lIGxvZ2ljLlxuICAjXG4gICMgQHBhcmFtIG5vZGUgW1N0cmluZywgTm9kZSwgI2VhY2gsICN0b19uXSB0aGUgbm9kZSB0byBhcHBlbmRcbiAgI1xuICAjIEByZXR1cm4gW3NlbGZdXG4gIGRlZiA8PChub2RlKVxuICAgIGlmIE9wYWwucmVzcG9uZF90bz8gbm9kZSwgOmVhY2hcbiAgICAgIG5vZGUuZWFjaCB7IHxufCBzZWxmIDw8IG4gfVxuICAgICAgcmV0dXJuIHNlbGZcbiAgICBlbmRcblxuICAgIHVubGVzcyBuYXRpdmU/KG5vZGUpXG4gICAgICBpZiBTdHJpbmcgPT09IG5vZGVcbiAgICAgICAgbm9kZSA9IGAjQG5hdGl2ZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpYFxuICAgICAgZWxzZVxuICAgICAgICBub2RlID0gTmF0aXZlLmNvbnZlcnQobm9kZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYCNAbmF0aXZlLmFwcGVuZENoaWxkKG5vZGUpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgPj4obm9kZSlcbiAgICBpZiBPcGFsLnJlc3BvbmRfdG8/IG5vZGUsIDplYWNoXG4gICAgICBub2RlLmVhY2ggeyB8bnwgc2VsZiA+PiBuIH1cbiAgICAgIHJldHVybiBzZWxmXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgbmF0aXZlPyhub2RlKVxuICAgICAgaWYgU3RyaW5nID09PSBub2RlXG4gICAgICAgIG5vZGUgPSBgI0BuYXRpdmUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKWBcbiAgICAgIGVsc2VcbiAgICAgICAgbm9kZSA9IE5hdGl2ZS5jb252ZXJ0KG5vZGUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGlmIGAjQG5hdGl2ZS5maXJzdENoaWxkID09IG51bGxgXG4gICAgICBgI0BuYXRpdmUuYXBwZW5kQ2hpbGQobm9kZSlgXG4gICAgZWxzZVxuICAgICAgYCNAbmF0aXZlLmluc2VydEJlZm9yZShub2RlLCAjQG5hdGl2ZS5maXJzdENoaWxkKWBcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFkZF9jaGlsZChub2RlID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG5vZGVcbiAgICAgIG5vZGUgPSBET00oJmJsb2NrKVxuICAgIGVuZFxuXG4gICAgc2VsZiA8PCBub2RlXG4gIGVuZFxuXG4gICMgQWRkIHRoZSBwYXNzZWQgbm9kZSBhZnRlciB0aGlzIG9uZS5cbiAgI1xuICAjIFdoZW4gcGFzc2luZyBhIHtTdHJpbmd9IGEgdGV4dCBub2RlIHdpbGwgYmUgY3JlYXRlZC5cbiAgI1xuICAjIEBwYXJhbSBub2RlIFtTdHJpbmcsIE5vZGUsICN0b19uXSB0aGUgbm9kZSB0byBhZGRcbiAgZGVmIGFkZF9uZXh0X3NpYmxpbmcobm9kZSA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBub2RlXG4gICAgICBub2RlID0gRE9NKCZibG9jaylcbiAgICBlbmRcblxuICAgIHVubGVzcyBuYXRpdmU/KG5vZGUpXG4gICAgICBpZiBTdHJpbmcgPT09IG5vZGVcbiAgICAgICAgbm9kZSA9IGAjQG5hdGl2ZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpYFxuICAgICAgZWxzZVxuICAgICAgICBub2RlID0gTmF0aXZlLmNvbnZlcnQobm9kZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYCNAbmF0aXZlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsICNAbmF0aXZlLm5leHRTaWJsaW5nKWBcbiAgZW5kXG5cbiAgIyBBZGQgdGhlIHBhc3NlZCBub2RlIGJlZm9yZSB0aGlzIG9uZS5cbiAgI1xuICAjIFdoZW4gcGFzc2luZyBhIHtTdHJpbmd9IGEgdGV4dCBub2RlIHdpbGwgYmUgY3JlYXRlZC5cbiAgI1xuICAjIEBwYXJhbSBub2RlIFtTdHJpbmcsIE5vZGUsICN0b19uXSB0aGUgbm9kZSB0byBhZGRcbiAgZGVmIGFkZF9wcmV2aW91c19zaWJsaW5nKG5vZGUgPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3Mgbm9kZVxuICAgICAgbm9kZSA9IERPTSgmYmxvY2spXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgbmF0aXZlPyhub2RlKVxuICAgICAgaWYgU3RyaW5nID09PSBub2RlXG4gICAgICAgIG5vZGUgPSBgI0BuYXRpdmUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKWBcbiAgICAgIGVsc2VcbiAgICAgICAgbm9kZSA9IE5hdGl2ZS5jb252ZXJ0KG5vZGUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCAjQG5hdGl2ZSlgXG4gIGVuZFxuXG4gIGFsaWFzIGFmdGVyIGFkZF9uZXh0X3NpYmxpbmdcblxuICAjIEFwcGVuZCB0aGUgbm9kZSB0byB0aGUgcGFzc2VkIG9uZS5cbiAgI1xuICAjIEBwYXJhbSBub2RlIFtOb2RlXSB0aGUgbm9kZSB0byBhcHBlbmQgdG9cbiAgZGVmIGFwcGVuZF90byhub2RlKVxuICAgIG5vZGUgPDwgc2VsZlxuICBlbmRcblxuICAjIEdldCBhbiBhcnJheSBvZiBhbmNlc3RvcnMuXG4gICNcbiAgIyBQYXNzaW5nIGEgc2VsZWN0b3Igd2lsbCBzZWxlY3QgdGhlIGFuY2VzdG9ycyBtYXRjaGluZyBpdC5cbiAgI1xuICAjIEBwYXJhbSBleHByZXNzaW9uIFtTdHJpbmddIHRoZSBzZWxlY3RvciB0byB1c2UgYXMgZmlsdGVyXG4gICNcbiAgIyBAcmV0dXJuIFtOb2RlU2V0XVxuICBkZWYgYW5jZXN0b3JzKGV4cHJlc3Npb24gPSBuaWwpXG4gICAgcmV0dXJuIE5vZGVTZXRbXSB1bmxlc3MgcGFyZW50XG5cbiAgICBwYXJlbnRzID0gW3BhcmVudF1cblxuICAgIHdoaWxlIHBhcmVudCA9IHBhcmVudHMubGFzdC5wYXJlbnRcbiAgICAgIHBhcmVudHMgPDwgcGFyZW50XG4gICAgZW5kXG5cbiAgICBpZiBEb2N1bWVudCA9PT0gcGFyZW50cy5sYXN0XG4gICAgICBwYXJlbnRzLnBvcFxuICAgIGVuZFxuXG4gICAgaWYgZXhwcmVzc2lvblxuICAgICAgcGFyZW50cy5zZWxlY3QhIHsgfHB8IHAgPX4gZXhwcmVzc2lvbiB9XG4gICAgZW5kXG5cbiAgICBOb2RlU2V0Lm5ldyhwYXJlbnRzKVxuICBlbmRcblxuICBhbGlhcyBiZWZvcmUgYWRkX3ByZXZpb3VzX3NpYmxpbmdcblxuICAjIFJlbW92ZSB0aGUgbm9kZSBmcm9tIGl0cyBwYXJlbnQuXG4gIGRlZiByZW1vdmVcbiAgICBwYXJlbnQucmVtb3ZlX2NoaWxkKHNlbGYpIGlmIHBhcmVudFxuICBlbmRcblxuICAjIFJlbW92ZSBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoZSBub2RlLlxuICBkZWYgY2xlYXJcbiAgICBjaGlsZHJlbi5yZW1vdmVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBjb250ZW50XG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgaW5uZXIgdGV4dCBjb250ZW50IG9mIHRoZSBub2RlXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LnRleHRDb250ZW50J1xuICAgIGRlZiBjb250ZW50XG4gICAgICBgI0BuYXRpdmUudGV4dENvbnRlbnRgXG4gICAgZW5kXG5cbiAgICBkZWYgY29udGVudD0odmFsdWUpXG4gICAgICBgI0BuYXRpdmUudGV4dENvbnRlbnQgPSAje3ZhbHVlfWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQuaW5uZXJUZXh0J1xuICAgIGRlZiBjb250ZW50XG4gICAgICBgI0BuYXRpdmUuaW5uZXJUZXh0YFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbnRlbnQ9KHZhbHVlKVxuICAgICAgYCNAbmF0aXZlLmlubmVyVGV4dCA9ICN7dmFsdWV9YFxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIGNvbnRlbnRcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdub2RlIHRleHQgY29udGVudCB1bnN1cHBvcnRlZCdcbiAgICBlbmRcblxuICAgIGRlZiBjb250ZW50PSh2YWx1ZSlcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdub2RlIHRleHQgY29udGVudCB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGJsYW5rP1xuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIENEQVRBIHNlY3Rpb24uXG4gIGRlZiBjZGF0YT9cbiAgICBub2RlX3R5cGUgPT0gQ0RBVEFfU0VDVElPTl9OT0RFXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGNoaWxkXG4gICMgQHJldHVybiBbTm9kZT9dIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgbm9kZVxuICBkZWYgY2hpbGRcbiAgICBjaGlsZHJlbi5maXJzdFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIGNoaWxkcmVuXG4gICMgQHJldHVybiBbTm9kZVNldF0gdGhlIGNoaWxkcmVuIG9mIHRoZSBub2RlXG4gIGRlZiBjaGlsZHJlblxuICAgIE5vZGVTZXRbTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLmNoaWxkTm9kZXNgKV1cbiAgZW5kXG5cbiAgZGVmIGNoaWxkcmVuPShub2RlKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgZW5kXG5cbiAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIGNvbW1lbnQuXG4gIGRlZiBjb21tZW50P1xuICAgIG5vZGVfdHlwZSA9PSBDT01NRU5UX05PREVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcnddIGRvY3VtZW50XG4gICMgQHJldHVybiBbRG9jdW1lbnQ/XSB0aGUgZG9jdW1lbnQgdGhlIG5vZGUgaXMgYXR0YWNoZWQgdG9cbiAgZGVmIGRvY3VtZW50XG4gICAgRE9NKGAjQG5hdGl2ZS5vd25lckRvY3VtZW50YCkgaWYgZGVmaW5lZD8oYCNAbmF0aXZlLm93bmVyRG9jdW1lbnRgKVxuICBlbmRcblxuICAjIERldGFjaCBhIG5vZGUgYW5kIHRyYW5zZmVyIGl0IHRvIGFub3RoZXIgZG9jdW1lbnQuXG4gIGRlZiBkb2N1bWVudD0obmV3X2RvY3VtZW50KVxuICAgIGAje05hdGl2ZS50cnlfY29udmVydChuZXdfZG9jdW1lbnQsIG5ld19kb2N1bWVudCl9LmFkb3B0Tm9kZSgjQG5hdGl2ZSlgXG4gIGVuZFxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBkb2N1bWVudC5cbiAgZGVmIGRvY3VtZW50P1xuICAgIG5vZGVfdHlwZSA9PSBET0NVTUVOVF9OT0RFXG4gIGVuZFxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYW4gZWxlbWVudC5cbiAgZGVmIGVsZW0/XG4gICAgbm9kZV90eXBlID09IEVMRU1FTlRfTk9ERVxuICBlbmRcblxuICBhbGlhcyBlbGVtZW50PyBlbGVtP1xuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGVsZW1lbnRfY2hpbGRyZW5cbiAgIyBAcmV0dXJuIFtOb2RlU2V0XSBhbGwgdGhlIGNoaWxkcmVuIHdoaWNoIGFyZSBlbGVtZW50c1xuICBkZWYgZWxlbWVudF9jaGlsZHJlblxuICAgIGNoaWxkcmVuLnNlbGVjdCgmOmVsZW1lbnQ/KVxuICBlbmRcblxuICBhbGlhcyBlbGVtZW50cyBlbGVtZW50X2NoaWxkcmVuXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gZmlyc3RfZWxlbWVudF9jaGlsZFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgZmlyc3QgZWxlbWVudCBjaGlsZFxuICBkZWYgZmlyc3RfZWxlbWVudF9jaGlsZFxuICAgIGVsZW1lbnRfY2hpbGRyZW4uZmlyc3RcbiAgZW5kXG5cbiAgIyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIGRvY3VtZW50IGZyYWdtZW50LlxuICBkZWYgZnJhZ21lbnQ/XG4gICAgbm9kZV90eXBlID09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBpbm5lcl9odG1sXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgaW5uZXIgSFRNTCBvZiB0aGUgbm9kZVxuICBkZWYgaW5uZXJfaHRtbFxuICAgIGAjQG5hdGl2ZS5pbm5lckhUTUxgXG4gIGVuZFxuXG4gIGRlZiBpbm5lcl9odG1sPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuaW5uZXJIVE1MID0gI3t2YWx1ZX1gXG4gIGVuZFxuXG4gIGFsaWFzIGlubmVyX3RleHQgY29udGVudFxuICBhbGlhcyBpbm5lcl90ZXh0PSBjb250ZW50PVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGxhc3RfZWxlbWVudF9jaGlsZFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgbGFzdCBlbGVtZW50IGNoaWxkXG4gIGRlZiBsYXN0X2VsZW1lbnRfY2hpbGRcbiAgICBlbGVtZW50X2NoaWxkcmVuLmxhc3RcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBuYW1lXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgbm9kZVxuICBkZWYgbmFtZVxuICAgIGAjQG5hdGl2ZS5ub2RlTmFtZSB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiBuYW1lPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUubm9kZU5hbWUgPSAje3ZhbHVlLnRvX3N9YFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBuYW1lc3BhY2VcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBuYW1lc3BhY2Ugb2YgdGhlIG5vZGVcbiAgZGVmIG5hbWVzcGFjZVxuICAgIGAjQG5hdGl2ZS5uYW1lc3BhY2VVUkkgfHwgbmlsYFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIG5leHRcbiAgIyBAcmV0dXJuIFtOb2RlP10gdGhlIG5leHQgc2libGluZyBvZiB0aGUgbm9kZVxuICBkZWYgbmV4dFxuICAgIERPTShgI0BuYXRpdmUubmV4dFNpYmxpbmdgKSBpZiBgI0BuYXRpdmUubmV4dFNpYmxpbmcgIT0gbnVsbGBcbiAgZW5kXG5cbiAgYWxpYXMgbmV4dD0gYWRkX25leHRfc2libGluZ1xuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIG5leHRfZWxlbWVudFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgbmV4dCBlbGVtZW50IHNpYmxpbmcgb2YgdGhlIG5vZGVcbiAgZGVmIG5leHRfZWxlbWVudFxuICAgIGN1cnJlbnQgPSBzZWxmLm5leHRcblxuICAgIHdoaWxlIGN1cnJlbnQgJiYgIWN1cnJlbnQuZWxlbWVudD9cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcbiAgICBlbmRcblxuICAgIGN1cnJlbnRcbiAgZW5kXG5cbiAgYWxpYXMgbmV4dF9zaWJsaW5nIG5leHRcblxuICBhbGlhcyBub2RlX25hbWUgbmFtZVxuXG4gIGFsaWFzIG5vZGVfbmFtZT0gbmFtZT1cblxuICAjIEAhYXR0cmlidXRlIFtyXSBub2RlX3R5cGVcbiAgIyBAcmV0dXJuIFtTeW1ib2xdIHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gIGRlZiBub2RlX3R5cGVcbiAgICBgI0BuYXRpdmUubm9kZVR5cGVgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgcGFyZW50XG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBwYXJlbnQgb2YgdGhlIG5vZGVcbiAgZGVmIHBhcmVudFxuICAgIERPTShgI0BuYXRpdmUucGFyZW50Tm9kZWApIGlmIGAjQG5hdGl2ZS5wYXJlbnROb2RlICE9IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBwYXJlbnQ9KG5vZGUpXG4gICAgYCNAbmF0aXZlLnBhcmVudE5vZGUgPSAje05hdGl2ZS5jb252ZXJ0KG5vZGUpfWBcbiAgZW5kXG5cbiAgZGVmIHBhcnNlKHRleHQsIG9wdGlvbnMgPSB7fSlcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGRlZiBwYXRoXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICAjIFByZXBlbmQgdGhlIG5vZGUgdG8gdGhlIHBhc3NlZCBvbmUuXG4gICNcbiAgIyBAcGFyYW0gbm9kZSBbTm9kZV0gdGhlIG5vZGUgdG8gcHJlcGVuZCB0b1xuICBkZWYgcHJlcGVuZF90byhub2RlKVxuICAgIG5vZGUgPj4gc2VsZlxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIHByZXZpb3VzXG4gICMgQHJldHVybiBbTm9kZT9dIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBub2RlXG4gIGRlZiBwcmV2aW91c1xuICAgIERPTShgI0BuYXRpdmUucHJldmlvdXNTaWJsaW5nYCkgaWYgYCNAbmF0aXZlLnByZXZpb3VzU2libGluZyAhPSBudWxsYFxuICBlbmRcblxuICBhbGlhcyBwcmV2aW91cz0gYWRkX3ByZXZpb3VzX3NpYmxpbmdcblxuICAjIEAhYXR0cmlidXRlIFtyXSBwcmV2aW91c19lbGVtZW50XG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSBwcmV2aW91cyBlbGVtZW50IHNpYmxpbmcgb2YgdGhlIG5vZGVcbiAgZGVmIHByZXZpb3VzX2VsZW1lbnRcbiAgICBjdXJyZW50ID0gc2VsZi5wcmV2aW91c1xuXG4gICAgd2hpbGUgY3VycmVudCAmJiAhY3VycmVudC5lbGVtZW50P1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQucHJldmlvdXNcbiAgICBlbmRcblxuICAgIGN1cnJlbnRcbiAgZW5kXG5cbiAgYWxpYXMgcHJldmlvdXNfc2libGluZyBwcmV2aW91c1xuXG4gICMgUmVtb3ZlIHRoZSBnaXZlbiBub2RlIGZyb20gdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZS5cbiAgZGVmIHJlbW92ZV9jaGlsZChub2RlKVxuICAgIGAjQG5hdGl2ZS5yZW1vdmVDaGlsZCgje05hdGl2ZS50cnlfY29udmVydChub2RlKX0pYFxuICBlbmRcblxuICAjIFJlcGxhY2UgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gb25lLlxuICAjXG4gICMgQHRvZG8gaW1wbGVtZW50IGZvciBOb2RlU2V0XG4gICNcbiAgIyBAcGFyYW0gbm9kZSBbTm9kZV0gdGhlIG5vZGUgdG8gcmVwbGFjZSB3aXRoXG4gICMgQHJldHVybiBbTm9kZV0gdGhlIHBhc3NlZCBub2RlXG4gIGRlZiByZXBsYWNlKG5vZGUpXG4gICAgdW5sZXNzIG5hdGl2ZT8obm9kZSlcbiAgICAgIGlmIFN0cmluZyA9PT0gbm9kZVxuICAgICAgICBub2RlID0gYCNAbmF0aXZlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZSlgXG4gICAgICBlbHNlXG4gICAgICAgIG5vZGUgPSBOYXRpdmUuY29udmVydChub2RlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBgI0BuYXRpdmUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgI0BuYXRpdmUpYFxuXG4gICAgbm9kZVxuICBlbmRcblxuICBhbGlhcyByZXBsYWNlX3dpdGggcmVwbGFjZVxuXG4gIGFsaWFzIHRleHQgY29udGVudFxuICBhbGlhcyB0ZXh0PSBjb250ZW50PVxuXG4gICMgUmV0dXJuIHRydWUgaWYgdGhlIG5vZGUgaXMgYSB0ZXh0IG5vZGUuXG4gIGRlZiB0ZXh0P1xuICAgIG5vZGVfdHlwZSA9PSBURVhUX05PREVcbiAgZW5kXG5cbiAgZGVmIHRyYXZlcnNlKCZibG9jaylcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGFsaWFzIHR5cGUgbm9kZV90eXBlXG5cbiAgIyBAIWF0dHJpYnV0ZSB2YWx1ZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIHZhbHVlIG9mIHRoZSBub2RlXG4gIGRlZiB2YWx1ZVxuICAgIGAjQG5hdGl2ZS5ub2RlVmFsdWUgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdmFsdWU9KHZhbHVlKVxuICAgIGAjQG5hdGl2ZS5ub2RlVmFsdWUgPSB2YWx1ZWBcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxET006Ok5vZGU6ICN7bmFtZX0+XCJcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImluY2x1ZGUiLCIxIiwiMiIsIjMiLCI0IiwiNSIsIjYiLCI3IiwiOCIsIjkiLCIxMCIsIjExIiwiMTIiLCJuZXciLCJzZWxmIiwiPT0iLCJAY2xhc3NlcyIsImtsYXNzIiwiW10iLCJ2YWx1ZSIsInJhaXNlIiwiQG5hdGl2ZSIsImNvbnZlcnQiLCJvdGhlciIsImluaXRpYWxpemVfY29weSIsInNldF9uYXRpdmVfcmVmZXJlbmNlIiwib2xkIiwidG9fbiIsIjw8IiwicmVzcG9uZF90bz8iLCJub2RlIiwiZWFjaCIsIm4iLCJuYXRpdmU/IiwiPT09IiwiPj4iLCJhZGRfY2hpbGQiLCJET00iLCJibG9jayIsImFkZF9uZXh0X3NpYmxpbmciLCJhZGRfcHJldmlvdXNfc2libGluZyIsImFwcGVuZF90byIsImFuY2VzdG9ycyIsInBhcmVudCIsInBhcmVudHMiLCJsYXN0IiwicG9wIiwiZXhwcmVzc2lvbiIsInNlbGVjdCEiLCJwIiwiPX4iLCJyZW1vdmUiLCJyZW1vdmVfY2hpbGQiLCJjbGVhciIsImNoaWxkcmVuIiwic3VwcG9ydHM/IiwiY29udGVudCIsImNvbnRlbnQ9IiwiYmxhbms/IiwiY2RhdGE/Iiwibm9kZV90eXBlIiwiY2hpbGQiLCJmaXJzdCIsImNoaWxkcmVuPSIsImNvbW1lbnQ/IiwiZG9jdW1lbnQiLCJkb2N1bWVudD0iLCJ0cnlfY29udmVydCIsIm5ld19kb2N1bWVudCIsImRvY3VtZW50PyIsImVsZW0/IiwiZWxlbWVudF9jaGlsZHJlbiIsInNlbGVjdCIsImZpcnN0X2VsZW1lbnRfY2hpbGQiLCJmcmFnbWVudD8iLCJpbm5lcl9odG1sIiwiaW5uZXJfaHRtbD0iLCJsYXN0X2VsZW1lbnRfY2hpbGQiLCJuYW1lIiwibmFtZT0iLCJ0b19zIiwibmFtZXNwYWNlIiwibmV4dCIsIm5leHRfZWxlbWVudCIsImN1cnJlbnQiLCJlbGVtZW50PyIsIiEiLCJwYXJlbnQ9IiwicGFyc2UiLCJwYXRoIiwicHJlcGVuZF90byIsInByZXZpb3VzIiwicHJldmlvdXNfZWxlbWVudCIsInJlcGxhY2UiLCJ0ZXh0PyIsInRyYXZlcnNlIiwidmFsdWU9IiwiaW5zcGVjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BS2hCQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsWUFBQUMsU0FBQUEsQ0FBUSxJQUFBLHVCQUFBLHdCQUFSQSxDQUFBO0FBQUEsUUFFQSw0Q0FBOEJDLENBQTlCLENBRkE7QUFBQSxRQUdBLDhDQUE4QkMsQ0FBOUIsQ0FIQTtBQUFBLFFBSUEseUNBQThCQyxDQUE5QixDQUpBO0FBQUEsUUFLQSxrREFBOEJDLENBQTlCLENBTEE7QUFBQSxRQU1BLHFEQUE4QkMsQ0FBOUIsQ0FOQTtBQUFBLFFBT0EsMkNBQThCQyxDQUE5QixDQVBBO0FBQUEsUUFRQSwyREFBOEJDLENBQTlCLENBUkE7QUFBQSxRQVNBLDRDQUE4QkMsQ0FBOUIsQ0FUQTtBQUFBLFFBVUEsNkNBQThCQyxDQUE5QixDQVZBO0FBQUEsUUFXQSxrREFBOEJDLEVBQTlCLENBWEE7QUFBQSxRQVlBLHNEQUE4QkMsRUFBOUIsQ0FaQTtBQUFBLFFBYUEsNkNBQThCQyxFQUE5QixDQWJBO0FBQUEsUUFvQkFDLFVBQUlDLElBQUpELFVBQUFBLGNBQUFBLFNBQWEsS0FBYkE7QUFBQUEsVUFBQUE7QUFBQUE7O0FBQUFBLFVBQUFBO0FBQUFBLFVBQUFBO0FBQUFBLFVBQUFBO0FBQUFBLFVBQUFBO0FBQUFBLFVBQUFBO0FBQUFBLFVBQ0UsSUFBR0MsSUFBQUMs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Q0UsT0FBRUUsY0FBTztBQURYRixRQUFBQSxDQUFBQSw0QkFBQUEsQ0EzY0E7QUFBQTtBQStjQTZFLFFBQUFBLDBCQUFBQSxvQkFBQUEsU0FBVyxLQUFYQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFFM0UsY0FBTztBQURYMkUsUUFBQUEsQ0FBQUEsK0JBQUFBLENBL2NBO0FBQUEsUUFvZEEsT0FBQUMsQ0FBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSxFQUFBLEdBQUEsZUFBQSxHQUFBLEtBQWdCbkIsTUFBQUEsQ0FBQUEsQ0FBaEIsQ0FBQSxHQUFBO0FBREZtQixRQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEsbUJBcGRBO0FBREZsRyxNQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUxnQkQsSUFBQUEsR0FBQUEsV0FBQUE7QUFBaEJBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzMzNTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9hdHRyaWJ1dGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBFbmNhcHN1bGF0ZXMgYW4ge0VsZW1lbnR9IGF0dHJpYnV0ZS5cbmNsYXNzIEF0dHJpYnV0ZVxuICBpbmNsdWRlIEJyb3dzZXI6Ok5hdGl2ZUNhY2hlZFdyYXBwZXJcblxuICAjIEAhYXR0cmlidXRlIFtyXSBuYW1lXG4gICMgQHJldHVybiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gIGFsaWFzX25hdGl2ZSA6bmFtZVxuXG4gICMgQCFhdHRyaWJ1dGUgdmFsdWVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gIGFsaWFzX25hdGl2ZSA6dmFsdWVcbiAgYWxpYXNfbmF0aXZlIDp2YWx1ZT1cblxuICAjIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXR0cmlidXRlIGlzIGFuIGlkLlxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnQXR0ci5pc0lkJ1xuICAgIGFsaWFzX25hdGl2ZSA6aWQ/LCA6aXNJZFxuICBlbHNlXG4gICAgZGVmIGlkP1xuICAgICAgbmFtZSA9PSA6aWRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImluY2x1ZGUiLCJhbGlhc19uYXRpdmUiLCJzdXBwb3J0cz8iLCJpZD8iLCJuYW1lIiwiPT0iXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUdoQkM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUNFLFlBQUFDLFNBQUFBLENBQVEsSUFBQSx1QkFBQSx3QkFBUkEsQ0FBQTtBQUFBLFlBSUFDLGNBQUFBLENBQWEsTUFBYkEsQ0FKQTtBQUFBLFlBUUFBLGNBQUFBLENBQWEsT0FBYkEsQ0FSQTtBQUFBLFlBU0FBLGNBQUFBLENBQWEsUUFBYkEsQ0FUQTtBQUFBLFFBWUEsSUFBQSxRQUFHLHVCQUFBQyxjQUFBQSxDQUFrQixXQUFsQkEsQ0FBSCxDQUFBO0FBQUEsVUFDRSxXQUFBRCxjQUFBQSxDQUFhLE9BQU0sTUFBbkJBO0FBREYsUUFBQTtBQUFBLFVBR0UsT0FBQUUsQ0FBQUEsdUJBQUFBLHVCQUFBQSxTQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxXQUFBQyxNQUFBQSxDQUFBQSxDQUFBQyxPQUFBQSxDQUFRLElBQVJBO0FBREZGLFVBQUFBLENBQUFBLGtDQUFBQSxDQUFBQTtBQUhGLFFBQUEsQ0FaQTtBQURGSixNQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUhnQkQsSUFBQUEsR0FBQUEsV0FBQUE7QUFBaEJBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzMzOTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9jaGFyYWN0ZXJfZGF0YS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG5jbGFzcyBDaGFyYWN0ZXJEYXRhIDwgTm9kZVxuICAjIEFwcGVuZCBkYXRhIHRvIHRoZSBub2RlLlxuICAjXG4gICMgQHBhcmFtIHN0cmluZyBbU3RyaW5nXSB0aGUgZGF0YSB0byBhZGRcbiAgI1xuICAjIEByZXR1cm4gW3NlbGZdXG4gIGRlZiBhcHBlbmQoc3RyaW5nKVxuICAgIGAjQG5hdGl2ZS5hcHBlbmREYXRhKHN0cmluZylgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGRhdGFcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBkYXRhIG9mIHRoZSBub2RlXG4gIGRlZiBkYXRhXG4gICAgYCNAbmF0aXZlLmRhdGFgXG4gIGVuZFxuXG4gICMgRGVsZXRlIGRhdGEgZnJvbSB0aGUgbm9kZS5cbiAgI1xuICAjIEBwYXJhbSBjb3VudCBbSW50ZWdlcl0gaG93IG11Y2ggZGF0YSB0byBkZWxldGVcbiAgIyBAcGFyYW0gb2Zmc2V0IFtJbnRlZ2VyXSB0aGUgb2Zmc2V0IHRvIHN0YXJ0IGF0XG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgZGVsZXRlKGNvdW50LCBvZmZzZXQgPSAwKVxuICAgIGAjQG5hdGl2ZS5kZWxldGVEYXRhKG9mZnNldCwgY291bnQpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEluc2VydCBkYXRhIGluIHRoZSBub2RlLlxuICAjXG4gICMgQHBhcmFtIHN0cmluZyBbU3RyaW5nXSB0aGUgZGF0YSB0byBpbnNlcnRcbiAgIyBAcGFyYW0gb2Zmc2V0IFtJbnRlZ2VyXSB0aGUgb2Zmc2V0IHRvIHN0YXJ0IGF0XG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgaW5zZXJ0KHN0cmluZywgb2Zmc2V0ID0gMClcbiAgICBgI0BuYXRpdmUuaW5zZXJ0RGF0YShvZmZzZXQsIHN0cmluZylgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGxlbmd0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBsZW5ndGggb2YgdGhlIG5vZGVcbiAgYWxpYXNfbmF0aXZlIDpsZW5ndGhcblxuICAjIFJlcGxhY2UgZGF0YSBpbiB0aGUgbm9kZS5cbiAgI1xuICAjIEBwYXJhbSBzdHJpbmcgW1N0cmluZ10gdGhlIGRhdGEgdG8gcmVwbGFjZSB3aXRoXG4gICMgQHBhcmFtIG9mZnNldCBbSW50ZWdlcl0gdGhlIG9mZnNldCB0byBzdGFydCBhdFxuICAjIEBwYXJhbSBjb3VudCBbSW50ZWdlcl0gaG93IG11Y2ggZGF0YSB0byByZXBsYWNlXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgcmVwbGFjZShzdHJpbmcsIG9mZnNldCA9IDAsIGNvdW50ID0gYCNAbmF0aXZlLmxlbmd0aGApXG4gICAgYCNAbmF0aXZlLnJlcGxhY2VEYXRhKG9mZnNldCwgY291bnQsIHN0cmluZylgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgR2V0IGEgc3Vic3RyaW5nIG9mIHRoZSBkYXRhLlxuICAjXG4gICMgQHBhcmFtIGNvdW50IFtJbnRlZ2VyXSBob3cgbXVjaCBkYXRhIHRvIGxpY2VcbiAgIyBAcGFyYW0gb2Zmc2V0IFtJbnRlZ2VyXSB0aGUgb2Zmc2V0IHRvIHN0YXJ0IGF0XG4gICNcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSBzdWJzdHJpbmdcbiAgZGVmIHN1YnN0cmluZyhjb3VudCwgb2Zmc2V0ID0gMClcbiAgICBgI0BuYXRpdmUuc3Vic3RyaW5nRGF0YShvZmZzZXQsIGNvdW50KWBcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImFwcGVuZCIsIkBuYXRpdmUiLCJzZWxmIiwiZGF0YSIsImRlbGV0ZSIsIjAiLCJpbnNlcnQiLCJhbGlhc19uYXRpdmUiLCJyZXBsYWNlIiwic3Vic3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEJDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFBQUE7QUFNRTtBQUFBQyxRQUFBQSwwQkFBQUEsMEJBQUFBLGtCQUFXLE1BQVhBO0FBQUFBLFVBQUFBOztBQUFBQTtBQUNFLFVBQUVDLGNBQU8sbUJBQVQ7QUFBQSxVQUVBLE9BQUFDLElBRkE7QUFERkYsUUFBQUEsQ0FBQUEscUNBQUFBLENBQUE7QUFBQTtBQVFBRyxRQUFBQSx3QkFBQUEsd0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFFRixjQUFPO0FBRFhFLFFBQUFBLENBQUFBLG1DQUFBQSxDQVJBO0FBQUE7QUFrQkFDLFFBQUFBLDBCQUFBQSwwQkFBQUEsU0FBVyxLQUFELEVBQVEsTUFBbEJBO0FBQUFBLFVBQUFBOztBQUFBQTtBQTNCRjtBQTJCb0IsVUFBQTtBQUFBLFVBQUEsV0FBU0MsQ0FBVDtBQUFBLFVBQUEsQ0EzQnBCO0FBQUEsVUE0Qk1KLGNBQU8sMEJBNUJiO0FBQUEsVUE4QkksT0FBQUMsSUE5Qko7QUEyQkVFLFFBQUFBLENBQUFBLHNDQUFBQSxDQWxCQTtBQUFBO0FBOEJBRSxRQUFBQSwwQkFBQUEsMEJBQUFBLGtCQUFXLE1BQUQsRUFBUyxNQUFuQkE7QUFBQUEsVUFBQUE7O0FBQUFBO0FBdkNGO0FBdUNxQixVQUFBO0FBQUEsVUFBQSxXQUFTRCxDQUFUO0FBQUEsVUFBQSxDQXZDckI7QUFBQSxVQXdDTUosY0FBTywyQkF4Q2I7QUFBQSxVQTBDSSxPQUFBQyxJQTFDSjtBQXVDRUksUUFBQUEsQ0FBQUEsc0NBQUFBLENBOUJBO0FBQUEsWUFzQ0FDLGNBQUFBLENBQWEsUUFBYkEsQ0F0Q0E7QUFBQTtBQStDQUMsUUFBQUEsMkJBQUFBLDJCQUFBQSxtQkFBWSxNQUFELEVBQVMsTUFBVCxFQUFxQixLQUFoQ0E7QUFBQUEsVUFBQUE7O0FBQUFBO0FBeERGO0FBd0RzQixVQUFBO0FBQUEsVUFBQSxXQUFTSCxDQUFUO0FBQUEsVUFBQSxDQXhEdEI7QUFBQTtBQXdEa0MsVUFBQTtBQUFBLFVBQUEsVUFBVUosY0FBTyxPQUFqQjtBQUFBLFVBQUEsQ0F4RGxDO0FBQUEsVUF5RE1BLGNBQU8sbUNBekRiO0FBQUEsVUEyREksT0FBQUMsSUEzREo7QUF3REVNLFFBQUFBLENBQUFBLHVDQUFBQSxDQS9DQTtBQUFBLFFBMkRBLE9BQUFDLENBQUFBLDZCQUFBQSw2QkFBQUEscUJBQWMsS0FBRCxFQUFRLE1BQXJCQTtBQUFBQSxVQUFBQTs7QUFBQUE7QUFwRUY7QUFvRXVCLFVBQUE7QUFBQSxVQUFBLFdBQVNKLENBQVQ7QUFBQSxVQUFBLENBcEV2QjtBQUFBLFVBcUVJLE9BQUVKLGNBQU8sNkJBckViO0FBb0VFUSxRQUFBQSxDQUFBQSx5Q0FBQUEsQ0FBQUEscUJBM0RBO0FBTkZWLE1BQUFBLEdBQUFBLFdBQUFBLEVBQXNCLG9CQUF0QkE7QUFGZ0JELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzNDkwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vdGV4dC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG4jIEVuY2Fwc3VsYXRlcyBhIHRleHQgbm9kZS5cbiNcbiMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dFxuY2xhc3MgVGV4dCA8IENoYXJhY3RlckRhdGFcbiAgIyAoc2VlIERvY3VtZW50I2NyZWF0ZV90ZXh0KVxuICBkZWYgc2VsZi5jcmVhdGUoY29udGVudClcbiAgICAkZG9jdW1lbnQuY3JlYXRlX3RleHQoY29udGVudClcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gd2hvbGVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIHRoZSB3aG9sZSB0ZXh0XG4gICNcbiAgIyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0Lndob2xlVGV4dFxuICBkZWYgd2hvbGVcbiAgICBgI0BuYXRpdmUud2hvbGVUZXh0YFxuICBlbmRcblxuICAjIFNwbGl0IHRoZSB0ZXh0IG5vZGUgYXQgYSBnaXZlbiBvZmZzZXQuXG4gICNcbiAgIyBAcGFyYW0gb2Zmc2V0IFtJbnRlZ2VyXSB0aGUgb2Zmc2V0IHdoZXJlIHRvIHNwbGl0IHRoZSB0ZXh0IG5vZGVcbiAgI1xuICAjIEByZXR1cm4gW1RleHRdIHRoZSBuZXdseSBjcmVhdGVkIHRleHQgbm9kZVxuICAjXG4gICMgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dC5zcGxpdFRleHRcbiAgZGVmIHNwbGl0KG9mZnNldClcbiAgICBET00oYCNAbmF0aXZlLnNwbGl0VGV4dChvZmZzZXQpYClcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RE9NOjpUZXh0OiAje2RhdGF9PlwiXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJjcmVhdGUiLCJzZWxmIiwiJGRvY3VtZW50IiwiY3JlYXRlX3RleHQiLCJjb250ZW50Iiwid2hvbGUiLCJAbmF0aXZlIiwic3BsaXQiLCJET00iLCJpbnNwZWN0IiwiZGF0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BS2hCQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBO0FBRUUsUUFBQUMsVUFBSUMsSUFBSkQsYUFBQUEsaUJBQUFBLGtCQUFnQixPQUFoQkE7QUFBQUEsVUFBQUE7QUFBQUE7O0FBQUFBLFVBQ0UsT0FBQUUsZUFBQUMsYUFBQUEsQ0FBc0JDLE9BQXRCRDtBQURGSCxRQUFBQSxDQUFBQSw0QkFBQUEsQ0FBQTtBQUFBO0FBUUFLLFFBQUFBLHlCQUFBQSxnQkFBQUEsaUJBQUFBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUNFLE9BQUVDLGNBQU87QUFEWEQsUUFBQUEsQ0FBQUEsMkJBQUFBLENBUkE7QUFBQTtBQW1CQUUsUUFBQUEseUJBQUFBLGdCQUFBQSxpQkFBVSxNQUFWQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBQyxLQUFBQSxDQUFNRixjQUFPLGtCQUFiRTtBQURGRCxRQUFBQSxDQUFBQSwyQkFBQUEsQ0FuQkE7QUFBQSxRQXVCQSxPQUFBRSxDQUFBQSwyQkFBQUEsa0JBQUFBLG1CQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLEVBQUEsR0FBQSxlQUFBLEdBQUEsS0FBZ0JDLE1BQUFBLENBQUFBLENBQWhCLENBQUEsR0FBQTtBQURGRCxRQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUEsbUJBdkJBO0FBRkZWLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWEsNkJBQWJBO0FBTGdCRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzU0MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2NkYXRhLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbmNsYXNzIENEQVRBIDwgVGV4dFxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzxET006OkNEQVRBOiAje3ZhbHVlfT5cIlxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiaW5zcGVjdCIsInZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEJDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFBQyxDQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLEVBQUEsR0FBQSxnQkFBQSxHQUFBLEtBQWlCQyxPQUFBQSxDQUFBQSxDQUFqQixDQUFBLEdBQUE7QUFERkQsUUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBO0FBREZELE1BQUFBLEdBQUFBLFdBQUFBLEVBQWMsb0JBQWRBO0FBRmdCRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzU3MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2NvbW1lbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuY2xhc3MgQ29tbWVudCA8IENoYXJhY3RlckRhdGFcbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RE9NOjpDb21tZW50OiAje3ZhbHVlfT5cIlxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiaW5zcGVjdCIsInZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEJDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFBQyxDQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxPQUFBLEVBQUEsR0FBQSxrQkFBQSxHQUFBLEtBQW1CQyxPQUFBQSxDQUFBQSxDQUFuQixDQUFBLEdBQUE7QUFERkQsUUFBQUEsQ0FBQUEsZ0NBQUFBLENBQUFBO0FBREZELE1BQUFBLEdBQUFBLFdBQUFBLEVBQWdCLDZCQUFoQkE7QUFGZ0JELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzNjAwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9hdHRyaWJ1dGVzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBBdHRyaWJ1dGVzXG4gIGF0dHJfcmVhZGVyIDpuYW1lc3BhY2VcblxuICBkZWYgaW5pdGlhbGl6ZShlbGVtZW50LCBvcHRpb25zKVxuICAgIEBlbGVtZW50ICAgPSBlbGVtZW50XG4gICAgQG5hdGl2ZSAgICA9IGVsZW1lbnQudG9fblxuICAgIEBuYW1lc3BhY2UgPSBvcHRpb25zWzpuYW1lc3BhY2VdXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/KCdFbGVtZW50LmNsYXNzTmFtZScpIHx8IEJyb3dzZXIuc3VwcG9ydHM/KCdFbGVtZW50Lmh0bWxGb3InKVxuICAgIGRlZiBbXShuYW1lLCBvcHRpb25zID0ge30pXG4gICAgICBpZiBuYW1lID09IDpjbGFzcyAmJiBCcm93c2VyLnN1cHBvcnRzPygnRWxlbWVudC5jbGFzc05hbWUnKVxuICAgICAgICBuYW1lID0gOmNsYXNzTmFtZVxuICAgICAgZWxzaWYgbmFtZSA9PSA6Zm9yICYmIEJyb3dzZXIuc3VwcG9ydHM/KCdFbGVtZW50Lmh0bWxGb3InKVxuICAgICAgICBuYW1lID0gOmh0bWxGb3JcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYW1lc3BhY2UgPSBvcHRpb25zWzpuYW1lc3BhY2VdIHx8IEBuYW1lc3BhY2VcbiAgICAgICAgYCNAbmF0aXZlLmdldEF0dHJpYnV0ZU5TKCN7bmFtZXNwYWNlLnRvX3N9LCAje25hbWUudG9fc30pIHx8IG5pbGBcbiAgICAgIGVsc2VcbiAgICAgICAgYCNAbmF0aXZlLmdldEF0dHJpYnV0ZSgje25hbWUudG9fc30pIHx8IG5pbGBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIFtdPShuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KVxuICAgICAgaWYgbmFtZSA9PSA6Y2xhc3MgJiYgQnJvd3Nlci5zdXBwb3J0cz8oJ0VsZW1lbnQuY2xhc3NOYW1lJylcbiAgICAgICAgbmFtZSA9IDpjbGFzc05hbWVcbiAgICAgIGVsc2lmIG5hbWUgPT0gOmZvciAmJiBCcm93c2VyLnN1cHBvcnRzPygnRWxlbWVudC5odG1sRm9yJylcbiAgICAgICAgbmFtZSA9IDpodG1sRm9yXG4gICAgICBlbmRcblxuICAgICAgaWYgbmFtZXNwYWNlID0gb3B0aW9uc1s6bmFtZXNwYWNlXSB8fCBAbmFtZXNwYWNlXG4gICAgICAgIGAjQG5hdGl2ZS5zZXRBdHRyaWJ1dGVOUygje25hbWVzcGFjZS50b19zfSwgI3tuYW1lLnRvX3N9LCAje3ZhbHVlfSlgXG4gICAgICBlbHNlXG4gICAgICAgIGAjQG5hdGl2ZS5zZXRBdHRyaWJ1dGUoI3tuYW1lLnRvX3N9LCAje3ZhbHVlLnRvX3N9KWBcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbHNlXG4gICAgZGVmIFtdKG5hbWUsIG9wdGlvbnMgPSB7fSlcbiAgICAgIGlmIG5hbWVzcGFjZSA9IG9wdGlvbnNbOm5hbWVzcGFjZV0gfHwgQG5hbWVzcGFjZVxuICAgICAgICBgI0BuYXRpdmUuZ2V0QXR0cmlidXRlTlMoI3tuYW1lc3BhY2UudG9fc30sICN7bmFtZS50b19zfSkgfHwgbmlsYFxuICAgICAgZWxzZVxuICAgICAgICBgI0BuYXRpdmUuZ2V0QXR0cmlidXRlKCN7bmFtZS50b19zfSkgfHwgbmlsYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgW109KG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pXG4gICAgICBpZiBuYW1lc3BhY2UgPSBvcHRpb25zWzpuYW1lc3BhY2VdIHx8IEBuYW1lc3BhY2VcbiAgICAgICAgYCNAbmF0aXZlLnNldEF0dHJpYnV0ZU5TKCN7bmFtZXNwYWNlLnRvX3N9LCAje25hbWUudG9fc30sICN7dmFsdWV9KWBcbiAgICAgIGVsc2VcbiAgICAgICAgYCNAbmF0aXZlLnNldEF0dHJpYnV0ZSgje25hbWUudG9fc30sICN7dmFsdWUudG9fc30pYFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2ggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGVsZW1lbnQuYXR0cmlidXRlX25vZGVzLmVhY2gge3xhdHRyfFxuICAgICAgeWllbGQgYXR0ci5uYW1lLCBhdHRyLnZhbHVlXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBnZXQgW11cblxuICBkZWYgaGFzX2tleT8obmFtZSlcbiAgICAhIXNlbGZbbmFtZV1cbiAgZW5kXG5cbiAgZGVmIG1lcmdlIShoYXNoKVxuICAgIGhhc2guZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgc2VsZltuYW1lXSA9IHZhbHVlXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBzZXQgW109XG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQGVsZW1lbnQiLCJlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJAbmFtZXNwYWNlIiwib3B0aW9ucyIsIltdIiwic3VwcG9ydHM/IiwibmFtZSIsIj09IiwibmFtZXNwYWNlIiwidG9fcyIsIltdPSIsInZhbHVlIiwiaW5jbHVkZSIsImVhY2giLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImF0dHJpYnV0ZV9ub2RlcyIsImF0dHIiLCJzZWxmIiwiaGFzX2tleT8iLCIhIiwibWVyZ2UhIiwiaGFzaCIsIiR3cml0ZXIiLCItIiwiMSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQVlDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFFNUIsT0FBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFLGNBQUFDLGFBQUFBLENBQVksV0FBWkEsQ0FBQTtBQUFBO0FBRUFDLFVBQUFBLDhCQUFBQSwyQkFBQUEsc0JBQWUsT0FBRCxFQUFVLE9BQXhCQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUFDRSxZQUFBQyxlQUFhQyxPQUFiO0FBQUEsWUFDQUMsaUJBQWFELE9BQUFFLE1BQUFBLENBQUFBLENBRGI7QUFBQSxZQUVBLE9BQUFDLENBQUFBLGlCQUFhQyxPQUFBQyxPQUFBQSxDQUFRLFdBQVJBLENBQWJGLENBRkE7QUFERkwsVUFBQUEsQ0FBQUEsc0NBQUFBLENBRkE7QUFBQSxVQVFBLElBQUEsUUFBRyxjQUFBLHVCQUFBUSxjQUFBQSxDQUFrQixtQkFBbEJBLENBQUEsU0FBMEMsdUJBQUFBLGNBQUFBLENBQWtCLGlCQUFsQkEsQ0FBMUMsQ0FBSCxDQUFBO0FBQUE7QUFDRTtBQUFBRCxZQUFBQSxzQkFBQUEsbUJBQUFBLFNBQU8sSUFBRCxFQUFPLE9BQWJBO0FBQUFBLGNBQUFBOztBQUFBQTtBQWJKO0FBYWlCLGNBQUE7QUFBQSxjQUFBLFlBQVUsWUFBQSxFQUFWO0FBQUEsY0FBQSxDQWJqQjtBQUFBLGNBY00sSUFBQSxRQUFHLE9BQUFFLElBQUFDLE9BQUFBLENBQVEsT0FBUkEsQ0FBQSxJQUFrQix1QkFBQUYsY0FBQUEs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QVpELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMzNzcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9kYXRhLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBEYXRhXG4gIGF0dHJfcmVhZGVyIDplbGVtZW50XG5cbiAgZGVmIGluaXRpYWxpemUoZWxlbWVudClcbiAgICBAZWxlbWVudCA9IGVsZW1lbnRcbiAgICBAbmF0aXZlICA9IGVsZW1lbnQudG9fblxuXG4gICAgdW5sZXNzIGRlZmluZWQ/KGAjQG5hdGl2ZS4kZGF0YWApXG4gICAgICBgI0BuYXRpdmUuJGRhdGEgPSB7fWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGRhdGEgPSAjQG5hdGl2ZS4kZGF0YTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgI3tibG9jay5jYWxsIGBrZXlgLCBgZGF0YVtrZXldYH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGVsZW1lbnQuYXR0cmlidXRlcy5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICBpZiBuYW1lID1+IC9eZGF0YS0oLiopJC9cbiAgICAgICAgYmxvY2suY2FsbCAkMSwgdmFsdWVcbiAgICAgIGVuZFxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFzc2lnbihkYXRhKVxuICAgIGRhdGEuZWFjaCB7fG5hbWUsIHZhbHVlfFxuICAgICAgYCNAbmF0aXZlLiRkYXRhW25hbWVdID0gdmFsdWVgXG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgW10obmFtZSlcbiAgICBpZiBkYXRhID0gQGVsZW1lbnRbXCJkYXRhLSN7bmFtZX1cIl1cbiAgICAgIHJldHVybiBkYXRhXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9ICNAbmF0aXZlLiRkYXRhW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXG4gICAgYCNAbmF0aXZlLiRkYXRhW25hbWVdID0gdmFsdWVgXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkBlbGVtZW50IiwiZWxlbWVudCIsIkBuYXRpdmUiLCJ0b19uIiwiaW5jbHVkZSIsImVhY2giLCJibG9jayIsImVudW1fZm9yIiwiY2FsbCIsImF0dHJpYnV0ZXMiLCJuYW1lIiwiPX4iLCJ2YWx1ZSIsInNlbGYiLCJhc3NpZ24iLCJkYXRhIiwiW10iLCJbXT0iXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUFZQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRTVCLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxjQUFBQyxhQUFBQSxDQUFZLFNBQVpBLENBQUE7QUFBQTtBQUVBQyxVQUFBQSw4QkFBQUEscUJBQUFBLHNCQUFlLE9BQWZBO0FBQUFBLFlBQUFBOztBQUFBQTtBQUNFLFlBQUFDLGVBQVdDLE9BQVg7QUFBQSxZQUNB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LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9wb3NpdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgUG9zaXRpb25cbiAgYXR0cl9yZWFkZXIgOmVsZW1lbnRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBpbml0aWFsaXplKGVsZW1lbnQpXG4gICAgQGVsZW1lbnQgPSBlbGVtZW50XG4gICAgQG5hdGl2ZSAgPSBlbGVtZW50LnRvX25cbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgZ2V0XG4gICAgb2Zmc2V0ICAgICAgICA9IEBlbGVtZW50Lm9mZnNldFxuICAgIHBvc2l0aW9uICAgICAgPSBvZmZzZXQuZ2V0XG4gICAgcGFyZW50ICAgICAgICA9IG9mZnNldC5wYXJlbnRcbiAgICBwYXJlbnRfb2Zmc2V0ID0gQnJvd3Nlcjo6UG9zaXRpb24ubmV3KDAsIDApXG5cbiAgICBpZiBAZWxlbWVudC5zdHlsZVs6cG9zaXRpb25dID09IDpmaXhlZFxuICAgICAgdW5sZXNzIHBhcmVudCA9fiA6aHRtbFxuICAgICAgICBwYXJlbnRfb2Zmc2V0ID0gcGFyZW50Lm9mZnNldFxuICAgICAgZW5kXG5cbiAgICAgIHBhcmVudF9vZmZzZXQueCArPSBwYXJlbnQuc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXS50b19pXG4gICAgICBwYXJlbnRfb2Zmc2V0LnkgKz0gcGFyZW50LnN0eWxlWydib3JkZXItbGVmdC13aWR0aCddLnRvX2lcbiAgICBlbmRcblxuICAgIEJyb3dzZXI6OlBvc2l0aW9uLm5ldyhcbiAgICAgIHBvc2l0aW9uLnggLSBwYXJlbnRfb2Zmc2V0LnggLSBAZWxlbWVudC5zdHlsZVsnbWFyZ2luLWxlZnQnXS50b19pLFxuICAgICAgcG9zaXRpb24ueSAtIHBhcmVudF9vZmZzZXQueSAtIEBlbGVtZW50LnN0eWxlWydtYXJnaW4tdG9wJ10udG9faSlcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0geFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBvbiB0aGUgeCBheGlzXG4gIGRlZiB4XG4gICAgZ2V0LnhcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0geVxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBvbiB0aGUgeSBheGlzXG4gIGRlZiB5XG4gICAgZ2V0LnlcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQGVsZW1lbnQiLCJlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJnZXQiLCJvZmZzZXQiLCJwb3NpdGlvbiIsInBhcmVudCIsInBhcmVudF9vZmZzZXQiLCJuZXciLCIwIiwic3R5bGUiLCJbXSIsIj09IiwiPX4iLCIkd3JpdGVyIiwiKyIsIngiLCJ0b19pIiwieD0iLCItIiwiMSIsInkiLCJ5PSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQVlDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFFNUIsT0FBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFLGNBQUFDLGFBQUFBLENBQVksU0FBWkEsQ0FBQTtBQUFBO0FBR0FDLFVBQUFBLDhCQUFBQSx5QkFBQUEsc0JBQWUsT0FBZkE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBQ0UsWUFBQUMsZUFBV0MsT0FBWDtBQUFBLFlBQ0EsT0FBQUMsQ0FBQUEsaUJBQVdELE9BQUFFLE1BQUFBLENBQUFBLENBQVhELENBREE7QUFERkgsVUFBQUEs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QSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozMzk4MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvb2Zmc2V0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBPZmZzZXRcbiAgYXR0cl9yZWFkZXIgOmVsZW1lbnRcblxuICAjIEBwcml2YXRlXG4gIGRlZiBpbml0aWFsaXplKGVsZW1lbnQpXG4gICAgQGVsZW1lbnQgPSBlbGVtZW50XG4gICAgQG5hdGl2ZSAgPSBlbGVtZW50LnRvX25cbiAgZW5kXG5cbiAgZGVmIHBhcmVudFxuICAgIERPTShgI0BuYXRpdmUub2Zmc2V0UGFyZW50IHx8ICN7QGVsZW1lbnQuZG9jdW1lbnQucm9vdC50b19ufWApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgeFxuICAjIEByZXR1cm4gW0ludGVnZXJdXG4gIGRlZiB4XG4gICAgZ2V0LnhcbiAgZW5kXG5cbiAgZGVmIHg9KHZhbHVlKVxuICAgIHNldCB2YWx1ZSwgbmlsXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgeVxuICAjIEByZXR1cm4gW0ludGVnZXJdXG4gIGRlZiB5XG4gICAgZ2V0LnlcbiAgZW5kXG5cbiAgZGVmIHk9KHZhbHVlKVxuICAgIHNldCBuaWwsIHZhbHVlXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCdcbiAgICBkZWYgZ2V0XG4gICAgICBkb2MgID0gQGVsZW1lbnQuZG9jdW1lbnRcbiAgICAgIHJvb3QgPSBkb2Mucm9vdC50b19uXG4gICAgICB3aW4gID0gZG9jLndpbmRvdy50b19uXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgYm94ID0gI0BuYXRpdmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICB5ICAgPSBib3gudG9wICsgKCN7d2lufS5wYWdlWU9mZnNldCB8fCAje3Jvb3R9LnNjcm9sbFRvcCkgLSAoI3tyb290fS5jbGllbnRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ICAgPSBib3gubGVmdCArICgje3dpbn0ucGFnZVhPZmZzZXQgfHwgI3tyb290fS5zY3JvbGxMZWZ0KSAtICgje3Jvb3R9LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICB9XG5cbiAgICAgIEJyb3dzZXI6OlBvc2l0aW9uLm5ldyhgeGAsIGB5YClcbiAgICBlbmRcbiAgZWxzZVxuICAgIGRlZiBnZXRcbiAgICAgIGRvYyAgPSBkb2N1bWVudFxuICAgICAgcm9vdCA9IGRvYy5yb290LnRvX25cbiAgICAgIHdpbiAgPSBkb2Mud2luZG93LnRvX25cblxuICAgICAgJXh7XG4gICAgICAgIHZhciB5ID0gKCN7d2lufS5wYWdlWU9mZnNldCB8fCAje3Jvb3R9LnNjcm9sbFRvcCkgLSAoI3tyb290fS5jbGllbnRUb3AgfHwgMCksXG4gICAgICAgICAgICB4ID0gKCN7d2lufS5wYWdlWE9mZnNldCB8fCAje3Jvb3R9LnNjcm9sbExlZnQpIC0gKCN7cm9vdH0uY2xpZW50TGVmdCB8fCAwKTtcbiAgICAgIH1cblxuICAgICAgQnJvd3Nlcjo6UG9zaXRpb24ubmV3KGB4YCwgYHlgKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2V0KCp2YWx1ZSlcbiAgICBwb3NpdGlvbiA9IEBlbGVtZW50LnN0eWxlIVs6cG9zaXRpb25dXG5cbiAgICBpZiBwb3NpdGlvbiA9PSA6c3RhdGljXG4gICAgICBAZWxlbWVudC5zdHlsZVs6cG9zaXRpb25dID0gOnJlbGF0aXZlXG4gICAgZW5kXG5cbiAgICBvZmZzZXQgPSBnZXRcbiAgICB0b3AgICAgPSBAZWxlbWVudC5zdHlsZSFbOnRvcF0udG9fdVxuICAgIGxlZnQgICA9IEBlbGVtZW50LnN0eWxlIVs6bGVmdF0udG9fdVxuXG4gICAgaWYgQnJvd3Nlcjo6UG9zaXRpb24gPT09IHZhbHVlLmZpcnN0XG4gICAgICB4LCB5ID0gdmFsdWUuZmlyc3QueCwgdmFsdWUuZmlyc3QueVxuICAgIGVsc2lmIEhhc2ggPT09IHZhbHVlLmZpcnN0XG4gICAgICB4LCB5ID0gdmFsdWUuZmlyc3RbOnhdLCB2YWx1ZS5maXJzdFs6eV1cbiAgICBlbHNlXG4gICAgICB4LCB5ID0gdmFsdWVcbiAgICBlbmRcblxuICAgIEBlbGVtZW50LnN0eWxlWzpsZWZ0XSA9ICh4LnB4IC0gb2Zmc2V0LngpICsgbGVmdCBpZiB4XG4gICAgQGVsZW1lbnQuc3R5bGVbOnRvcF0gID0gKHkucHggLSBvZmZzZXQueSkgKyB0b3AgIGlmIHlcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQGVsZW1lbnQiLCJlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJwYXJlbnQiLCJET00iLCJkb2N1bWVudCIsInJvb3QiLCJ4IiwiZ2V0IiwieD0iLCJzZXQiLCJ2YWx1ZSIsInkiLCJ5PSIsInN1cHBvcnRzPyIsImRvYyIsIndpbiIsIndpbmRvdyIsIm5ldyIsInBvc2l0aW9uIiwic3R5bGUhIiwiW10iLCI9PSIsIiR3cml0ZXIiLCJbXT0iLCJzdHlsZSIsIi0iLCIxIiwib2Zmc2V0IiwidG9wIiwidG9fdSIsImxlZnQiLCI9PT0iLCJmaXJzdCIsIisiLCJweCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQVlDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUEsUUFFNUIsT0FBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFLGNBQUFDLGFBQUFBLENBQVksU0FBWkEsQ0FBQTtBQUFBO0FBR0FDLFVBQUFB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RCxPQUFBLENBcUZJQyxDQXJGSjtBQUFBLGNBQUEsT0FBQUQsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUEsUUFBQSxDQUFBRyxFQUFBQyxDQUFBRCxDQUFBLENBQUE7QUFxRkksWUFBQTtBQUFBO0FBQUEsWUFBQSxDQXJGSjtBQWlFRWhCLFVBQUFBLENBQUFBLDRCQUFBQSxDQUFBQSxlQTdEQTtBQURGZCxRQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUY0QkEsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0Isb0JBQWhCQTtBQUFaRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNDEzMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvc2Nyb2xsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG4jIEB0b2RvIENvbnNpZGVyIHVzaW5nIHRoZSBuZXcgaW50ZXJmYWNlcyB3aGljaCBhbGxvdyBmb3Igb3B0aW9uYWxcbiMgICAgICAgc21vb3RoIHRyYW5zaXRpb25zLlxuY2xhc3MgU2Nyb2xsXG4gIGF0dHJfcmVhZGVyIDplbGVtZW50XG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZShlbGVtZW50KVxuICAgIEBlbGVtZW50ID0gZWxlbWVudFxuICAgIEBuYXRpdmUgID0gZWxlbWVudC50b19uXG5cbiAgICAjIFBvcnRhYmxlIHN1cHBvcnQgZm9yIFdpbmRvdyNzY3JvbGwgYW5kIERvY3VtZW50I3Njcm9sbFxuICAgIEBzY3JvbGxpbmdfbmF0aXZlID0gQG5hdGl2ZVxuICAgIGlmIFtEb2N1bWVudCwgV2luZG93XS5pbmNsdWRlPyhAZWxlbWVudC5jbGFzcylcbiAgICAgICMgSWYgd2UgYXJlIGEgd2luZG93LCBsZXQncyBiZWNvbWUgYSBkb2N1bWVudCBmaXJzdC5cbiAgICAgIGlmIGRlZmluZWQ/IGAjQHNjcm9sbGluZ19uYXRpdmUuZG9jdW1lbnRgXG4gICAgICAgIEBzY3JvbGxpbmdfbmF0aXZlID0gYCNAc2Nyb2xsaW5nX25hdGl2ZS5kb2N1bWVudGBcbiAgICAgIGVuZFxuICAgICAgIyBUaGVyZSB3ZXJlIHNsaWdodCBkaXNhZ3JlZW1lbnRzIGluIHRoZSBwYXN0IHdoaWNoIGVsZW1lbnRcbiAgICAgICMgc2hvdWxkIHdlIGhhbmRsZS5cbiAgICAgIGlmIGRlZmluZWQ/IGAjQHNjcm9sbGluZ19uYXRpdmUuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcGBcbiAgICAgICAgQHNjcm9sbGluZ19uYXRpdmUgPSBgI0BzY3JvbGxpbmdfbmF0aXZlLmRvY3VtZW50RWxlbWVudGBcbiAgICAgIGVsc2lmIGRlZmluZWQ/IGAjQHNjcm9sbGluZ19uYXRpdmUuYm9keS5zY3JvbGxUb3BgXG4gICAgICAgIEBzY3JvbGxpbmdfbmF0aXZlID0gYCNAc2Nyb2xsaW5nX25hdGl2ZS5ib2R5YFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQG92ZXJsb2FkIHRvKHgsIHkpXG4gICNcbiAgIyAgIFNjcm9sbCB0byB0aGUgZ2l2ZW4geCBhbmQgeS5cbiAgI1xuICAjICAgQHBhcmFtIHggW0ludGVnZXJdIHNjcm9sbCB0byB4IG9uIHRoZSB4IGF4aXNcbiAgIyAgIEBwYXJhbSB5IFtJbnRlZ2VyXSBzY3JvbGwgdG8geSBvbiB0aGUgeSBheGlzXG4gICNcbiAgIyBAb3ZlcmxvYWQgdG8oaGFzaClcbiAgI1xuICAjICAgU2Nyb2xsIHRvIHRoZSBnaXZlbiB4IGFuZCB5LlxuICAjXG4gICMgICBAcGFyYW0gaGFzaCBbSGFzaF0gdGhlIGRlc2NyaXB0b3JcbiAgI1xuICAjICAgQG9wdGlvbiBoYXNoIFtJbnRlZ2VyXSA6eCBzY3JvbGwgdG8geCBvbiB0aGUgeCBheGlzXG4gICMgICBAb3B0aW9uIGhhc2ggW0ludGVnZXJdIDp5IHNjcm9sbCB0byB5IG9uIHRoZSB5IGF4aXNcbiAgI1xuICAjIEBvdmVybG9hZCB0byhzeW1ib2wpXG4gICNcbiAgIyAgIFNjcm9sbCB0byA6dG9wIG9yIHRvIDpib3R0b21cbiAgI1xuICAjICAgQHBhcmFtIHN5bWJvbCBbU3ltYm9sXSBlaXRoZXIgOnRvcCBvciA6Ym90dG9tXG4gIGRlZiB0bygqYXJncylcbiAgICB4LCB5ID0gbmlsLCBuaWxcbiAgICBjYXNlIGFyZ3MuZmlyc3RcbiAgICB3aGVuIEhhc2hcbiAgICAgIHggPSBhcmdzLmZpcnN0Wzp4XVxuICAgICAgeSA9IGFyZ3MuZmlyc3RbOnldXG4gICAgd2hlbiA6dG9wXG4gICAgICB5ID0gMFxuICAgIHdoZW4gOmJvdHRvbVxuICAgICAgeSA9IDk5OTk5OTk5XG4gICAgZWxzZVxuICAgICAgeCwgeSA9IGFyZ3NcbiAgICBlbmRcblxuICAgIHNldCh4LCB5KSBpZiB4IHx8IHlcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAb3ZlcmxvYWQgYnkoeCwgeSlcbiAgI1xuICAjICAgU2Nyb2xsIGJ5IHRoZSBnaXZlbiB4IGFuZCB5LlxuICAjXG4gICMgICBAcGFyYW0geCBbSW50ZWdlcl0gc2Nyb2xsIGJ5IHggb24gdGhlIHggYXhpc1xuICAjICAgQHBhcmFtIHkgW0ludGVnZXJdIHNjcm9sbCBieSB5IG9uIHRoZSB5IGF4aXNcbiAgI1xuICAjIEBvdmVybG9hZCBieShoYXNoKVxuICAjXG4gICMgICBTY3JvbGwgYnkgdGhlIGdpdmVuIHggYW5kIHkuXG4gICNcbiAgIyAgIEBwYXJhbSBoYXNoIFtIYXNoXSB0aGUgZGVzY3JpcHRvclxuICAjXG4gICMgICBAb3B0aW9uIGhhc2ggW0ludGVnZXJdIDp4IHNjcm9sbCBieSB4IG9uIHRoZSB4IGF4aXNcbiAgIyAgIEBvcHRpb24gaGFzaCBbSW50ZWdlcl0gOnkgc2Nyb2xsIGJ5IHkgb24gdGhlIHkgYXhpc1xuICBkZWYgYnkoKmFyZ3MpXG4gICAgY2FzZSBhcmdzLmZpcnN0XG4gICAgd2hlbiBIYXNoXG4gICAgICB4ID0gYXJncy5maXJzdFs6eF0gfHwgMFxuICAgICAgeSA9IGFyZ3MuZmlyc3RbOnldIHx8IDBcbiAgICBlbHNlXG4gICAgICB4LCB5ID0gYXJnc1xuICAgIGVuZFxuXG4gICAgc2V0X2J5KHgsIHkpXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LnNjcm9sbEJ5J1xuICAgIHByaXZhdGUgZGVmIHNldF9ieSh4LCB5KVxuICAgICAgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxCeSgje3h9LCAje3l9KWBcbiAgICBlbmRcbiAgZWxzZVxuICAgIHByaXZhdGUgZGVmIHNldF9ieSh4LCB5KVxuICAgICAgc2V0KHNlbGYueCArIHgsIHNlbGYueSArIHkpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LnNjcm9sbCdcbiAgICBwcml2YXRlIGRlZiBzZXQoeD1uaWwsIHk9bmlsKVxuICAgICAgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxUb3AgID0gI3t5fWAgaWYgeVxuICAgICAgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxMZWZ0ID0gI3t4fWAgaWYgeFxuICAgIGVuZFxuXG4gICAgZGVmIHBvc2l0aW9uXG4gICAgICBCcm93c2VyOjpQb3NpdGlvbi5uZXcoYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxMZWZ0YCwgYCNAc2Nyb2xsaW5nX25hdGl2ZS5zY3JvbGxUb3BgKVxuICAgIGVuZFxuICBlbHNlXG4gICAgcHJpdmF0ZSBkZWYgc2V0KHg9bmlsLCB5PW5pbClcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdzY3JvbGwgb24gZWxlbWVudCB1bnN1cHBvcnRlZCdcbiAgICBlbmRcblxuICAgIGRlZiBwb3NpdGlvblxuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3Njcm9sbCBvbiBlbGVtZW50IHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB4XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHNjcm9sbCBwb3NpdGlvbiBvbiB0aGUgeCBheGlzXG4gIGRlZiB4XG4gICAgcG9zaXRpb24ueFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB5XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIHNjcm9sbCBwb3NpdGlvbiBvbiB0aGUgeSBheGlzXG4gIGRlZiB5XG4gICAgcG9zaXRpb24ueVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBoZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxcbiAgZGVmIGhlaWdodFxuICAgIGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsSGVpZ2h0YFxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB3aWR0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsXG4gIGRlZiB3aWR0aFxuICAgIGAjQHNjcm9sbGluZ19uYXRpdmUuc2Nyb2xsV2lkdGhgXG4gIGVuZFxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50LnNjcm9sbEludG9WaWV3SWZOZWVkZWQnXG4gICAgZGVmIGludG9fdmlldyhhbGlnbiA9IHRydWUpXG4gICAgICBgI0BzY3JvbGxpbmdfbmF0aXZlLnNjcm9sbEludG9WaWV3SWZOZWVkZWQoYWxpZ24pYFxuICAgIGVuZFxuICBlbHNlXG4gICAgIyBOb24tc3RhbmRhcmQuIE5vdCBzdXBwb3J0ZWQgYnkgbW9kZXJuIEZpcmVmb3guIFVzZSB7I2ludG9fdmlldyF9XG4gICAgZGVmIGludG9fdmlldyhhbGlnbiA9IHRydWUpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbnRvX3ZpZXchKGFsaWduID0gdHJ1ZSlcbiAgICBgI0BzY3JvbGxpbmdfbmF0aXZlLnNjcm9sbEludG9WaWV3KGFsaWduKWBcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQGVsZW1lbnQiLCJlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJAc2Nyb2xsaW5nX25hdGl2ZSIsImluY2x1ZGU/IiwidG8iLCJ4IiwieSIsImFyZ3MiLCJmaXJzdCIsIltdIiwiMCIsIjk5OTk5OTk5Iiwic2V0Iiwic2VsZiIsImJ5Iiwic2V0X2J5Iiwic3VwcG9ydHM/IiwicHJpdmF0ZSIsIisiLCJwb3NpdGlvbiIsIm5ldyIsInJhaXNlIiwiaGVpZ2h0Iiwid2lkdGgiLCJpbnRvX3ZpZXciLCJpbnRvX3ZpZXchIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBWUM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUk1QixPQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsY0FBQUMsYUFBQUEsQ0FBWSxTQUFaQSxDQUFBO0FBQUE7QUFHQUMsVUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBZSxPQUFmQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUFDRSxZQUFBQyxlQUFXQyxPQUFYO0FBQUEsWUFDQUMsaUJBQVdELE9BQUFFLE1BQUFBLENBQUFBLENBRFg7QUFBQSxZQUlBQyx3QkFBb0JGLGNBSnBCO0FBQUEsWUFLQSxJQUFBLFFBQUcsQ0FBQyx3QkFBRCxFQUFXLHNCQUFYLENBQUFHLGFBQUFBLENBQTRCTCxZQUFBSCxPQUFBQSxDQUFBQSxDQUE1QlEsQ0FBSCxDQUFBO0FBQUE7QUFFRSxjQUFBLElBQUEsUUFBRyxRQUFXRCxxQkFBaUIsU0FBNUIsa0JBQUgsQ0FBQTtBQUFBLGdCQUNFQSx3QkFBc0JBLHFCQUFpQixTQUR6QyxDQUFBO0FBQUEsY0FLQSxJQUFBLFFBQUcsUUFB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QWxCQSxDQUFILENBQUE7QUFBQTtBQUNFUSxZQUFBQSw2QkFBQUEsdUJBQUFBLHFCQUFjLEtBQWRBO0FBQUFBLGNBQUFBOztBQUFBQTtBQXpKSjtBQXlKa0IsY0FBQTtBQUFBLGNBQUEsVUFBUSxJQUFSO0FBQUEsY0FBQSxDQXpKbEI7QUFBQSxjQTBKTSxPQUFFdEIscUJBQWlCLDhCQTFKekI7QUF5SklzQixZQUFBQSxDQUFBQSxtQ0FBQUE7QUFERixVQUFBO0FBQUE7QUFNRUEsWUFBQUEsNkJBQUFBLHVCQUFBQSxxQkFBYyxLQUFkQTtBQUFBQSxjQUFBQTs7QUFBQUE7QUE5Sko7QUE4SmtCLGNBQUE7QUFBQSxjQUFBLFVBQVEsSUFBUjtBQUFBLGNBQUEsQ0E5SmxCO0FBQUEsY0ErSk0sV0FBQUgsT0FBQUEsQ0FBTSxtQ0FBTkEsQ0EvSk47QUE4SklHLFlBQUFBLENBQUFBLG1DQUFBQTtBQU5GLFVBQUEsQ0FsSkE7QUFBQSxVQTZKQSxPQUFBQyxDQUFBQSw4QkFBQUEsNEJBQUFBLFNBQWUsS0FBZkE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBbktGO0FBbUtpQixZQUFBO0FBQUEsWUFBQSxVQUFRLElBQVI7QUFBQSxZQUFBLENBbktqQjtBQUFBLFlBb0tJLE9BQUV2QixxQkFBaUIsc0JBcEt2QjtBQW1LRXVCLFVBQUFBLENBQUFBLHdDQUFBQSxDQUFBQSxzQkE3SkE7QUFERjlCLFFBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBSjRCQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQixvQkFBaEJBO0FBQVpELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0MzUyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9zaXplLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBTaXplXG4gIGF0dHJfcmVhZGVyIDplbGVtZW50XG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgaW5pdGlhbGl6ZShlbGVtZW50LCAqaW5jKVxuICAgIEBlbGVtZW50ID0gZWxlbWVudFxuICAgIEBuYXRpdmUgID0gZWxlbWVudC50b19uXG4gICAgQGluY2x1ZGUgPSBpbmNcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSB3aWR0aFxuICAjIEByZXR1cm4gW0ludGVnZXJdIHRoZSBlbGVtZW50IHdpZHRoXG4gIGRlZiB3aWR0aFxuICAgIGAjQG5hdGl2ZS5vZmZzZXRXaWR0aGBcbiAgZW5kXG5cbiAgZGVmIHdpZHRoPSh2YWx1ZSlcbiAgICBAZWxlbWVudC5zdHlsZVs6d2lkdGhdID0gdmFsdWVcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBoZWlnaHRcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgZWxlbWVudCBoZWlnaHRcbiAgZGVmIGhlaWdodFxuICAgIGAjQG5hdGl2ZS5vZmZzZXRIZWlnaHRgXG4gIGVuZFxuXG4gIGRlZiBoZWlnaHQ9KHZhbHVlKVxuICAgIEBlbGVtZW50LnN0eWxlWzpoZWlnaHRdID0gdmFsdWVcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQGVsZW1lbnQiLCJlbGVtZW50IiwiQG5hdGl2ZSIsInRvX24iLCJAaW5jbHVkZSIsImluYyIsIndpZHRoIiwid2lkdGg9IiwiJHdyaXRlciIsInZhbHVlIiwiW109Iiwic3R5bGUiLCItIiwiMSIsImhlaWdodCIsImhlaWdodD0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUFZQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRTVCLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxjQUFBQyxhQUFBQSxDQUFZLFNBQVpBLENBQUE7QUFBQTtBQUdBQyxVQUFBQSw4QkFBQUEscUJBQUFBLHNCQUFlLE9BQUQsRUFQaEIsRUFPRUE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBUEY7QUFBQSxZQUFBLDREQUFBO0FBQUE7QUFPMEIsWUFBQSxpQkFQMUI7QUFBQSxZQVFJQyxlQUFXQyxPQVJmO0FBQUEsWUFTSUMsaUJBQVdELE9BQUFFLE1BQUFBLENBQUFBLENBVGY7QUFBQSxZQVVJLE9BQUFDLENBQUFBLGVBQVdDLEdBQVhELENBVko7QUFPRUwsVUFBQUEsQ0FBQUEsaUNBQUFBLENBSEE7QUFBQTtBQVdBTyxVQUFBQSx5QkFBQUEsZ0JBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFSixjQUFPO0FBRFhJLFVBQUFBLENBQUFBLDJCQUFBQSxDQVhBO0FBQUE7QUFlQUMsVUFBQUEsMEJBQUFBLG1CQUFBQSxTQUFXLEtBQVhBO0FBQUFBLFlBQUFBOztBQUFBQTtBQW5CRixZQUFBQyxVQUFBLENBb0JtQixPQXBCbkIsRUFvQjZCQyxLQXBCN0IsQ0FBQTtBQUFBLFlBb0JJQyxNQUFBVixZQUFBVyxPQUFBQSxDQUFBQSxDQUFBRCxPQUFBQSxFQXBCSixVQUFBRixPQUFBLENBb0JJRSxDQXBCSjtBQUFBLFlBQUEsT0FBQUYsT0FBQSxDQUFBSSxVQUFBSixPQUFBLENBQUEsUUFBQSxDQUFBSSxFQUFBQyxDQUFBRCxDQUFBLENBQUE7QUFtQkVMLFVBQUFBLENBQUFBLDhCQUFBQSxDQWZBO0FBQUE7QUFxQkFPLFVBQUFBLDBCQUFBQSxpQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVaLGNBQU87QUFEWFksVUFBQUEsQ0FBQUEsNEJBQUFBLENBckJBO0FBQUEsVUF5QkEsT0FBQUMsQ0FBQUEsMkJBQUFBLG9CQUFBQSxTQUFZLEtBQVpBO0FBQUFBLFlBQUFBOztBQUFBQTtBQTdCRixZQUFBUCxVQUFBLENBOEJtQixRQTlCbkIsRUE4QjhCQyxLQTlCOUIsQ0FBQTtBQUFBLFlBOEJJQyxNQUFBVixZQUFBVyxPQUFBQSxDQUFBQSxDQUFBRCxPQUFBQSxFQTlCSixVQUFBRixPQUFBLENBOEJJRSxDQTlCSjtBQUFBLFlBQUEsT0FBQUYsT0FBQSxDQUFBSSxVQUFBSixPQUFBLENBQUEsUUFBQSxDQUFBSSxFQUFBQyxDQUFBRCxDQUFBLENBQUE7QUE2QkVHLFVBQUFBLENBQUFBLCtCQUFBQSxDQUFBQSxtQkF6QkE7QUFERmxCLFFBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRjRCQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQixvQkFBaEJBO0FBQVpELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0NDMxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9idXR0b24ucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbmNsYXNzIEJ1dHRvbiA8IEVsZW1lbnRcbiAgZGVmIGRpc2FibGVkP1xuICAgIGAjQG5hdGl2ZS5kaXNhYmxlZGBcbiAgZW5kXG5cbiAgZGVmIGRpc2FibGVkPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuZGlzYWJsZWQgPSAje3ZhbHVlfWBcbiAgZW5kXG5cbiAgZGVmIGF1dG9mb2N1cz9cbiAgICBgI0BuYXRpdmUuYXV0b2ZvY3VzYFxuICBlbmRcblxuICBkZWYgYXV0b2ZvY3VzPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUuYXV0b2ZvY3VzID0gI3t2YWx1ZX1gXG4gIGVuZFxuXG4gIGRlZiBuYW1lXG4gICAgYCNAbmF0aXZlLm5hbWVgXG4gIGVuZFxuXG4gIGRlZiBuYW1lPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUubmFtZSA9ICN7dmFsdWV9YFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJkaXNhYmxlZD8iLCJAbmF0aXZlIiwiZGlzYWJsZWQ9IiwidmFsdWUiLCJhdXRvZm9jdXM/IiwiYXV0b2ZvY3VzPSIsIm5hbWUiLCJuYW1lPSJdLCJtYXBwaW5ncyI6Ijs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBWUM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUU1QixPQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUMsVUFBQUEsNkJBQUFBLDBCQUFBQSxTQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFQyxjQUFPO0FBRFhELFVBQUFBLENBQUFBLHFDQUFBQSxDQUFBO0FBQUE7QUFJQUUsVUFBQUEsNkJBQUFBLHdCQUFBQSxTQUFjLEtBQWRBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVELGNBQU8sWUFBY0U7QUFEekJELFVBQUFBLENBQUFBLG1DQUFBQSxDQUpBO0FBQUE7QUFRQUUsVUFBQUEsOEJBQUFBLDJCQUFBQSxTQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFSCxjQUFPO0FBRFhHLFVBQUFBLENBQUFBLHNDQUFBQSxDQVJBO0FBQUE7QUFZQUMsVUFBQUEsOEJBQUFBLHlCQUFBQSxTQUFlLEtBQWZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVKLGNBQU8sYUFBZUU7QUFEMUJFLFVBQUFBLENBQUFBLG9DQUFBQSxDQVpBO0FBQUE7QUFnQkFDLFVBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVMLGNBQU87QUFEWEssVUFBQUEsQ0FBQUEsNEJBQUFBLENBaEJBO0FBQUEsVUFvQkEsT0FBQUMsQ0FBQUEseUJBQUFBLG9CQUFBQSxTQUFVLEtBQVZBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVOLGNBQU8sUUFBVUU7QUFEckJJLFVBQUFBLENBQUFBLCtCQUFBQSxDQUFBQSxpQkFwQkE7QUFERlIsUUFBQUEsR0FBQUEsV0FBQUEsRUFBZSx1QkFBZkE7QUFGNEJBLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWdCLG9CQUFoQkE7QUFBWkQsSUFBQUEsR0FBQUEsV0FBQUE7QUFBaEJBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ0OTgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2ltYWdlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBJbWFnZSA8IEVsZW1lbnRcbiAgZGVmIGNvbXBsZXRlP1xuICAgIGAjQG5hdGl2ZS5jb21wbGV0ZWBcbiAgZW5kXG5cbiAgZGVmIGNyb3NzP1xuICAgIGAjQG5hdGl2ZS5jcm9zc09yaWdpbmBcbiAgZW5kXG5cbiAgZGVmIGhlaWdodFxuICAgIGAjQG5hdGl2ZS5uYXR1cmFsSGVpZ2h0YFxuICBlbmRcblxuICBkZWYgd2lkdGhcbiAgICBgI0BuYXRpdmUubmF0dXJhbFdpZHRoYFxuICBlbmRcbmVuZFxuXG5JbWcgPSBJbWFnZVxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJjb21wbGV0ZT8iLCJAbmF0aXZlIiwiY3Jvc3M/IiwiaGVpZ2h0Iiwid2lkdGgiXSwibWFwcGluZ3MiOiI7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQVlDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFFNUIsUUFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtBQUNFO0FBQUFDLFVBQUFBLDZCQUFBQSx5QkFBQUEsU0FBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTztBQURYRCxVQUFBQSxDQUFBQSxvQ0FBQUEsQ0FBQTtBQUFBO0FBSUFFLFVBQUFBLDBCQUFBQSxzQkFBQUEsU0FBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUQsY0FBTztBQURYQyxVQUFBQSxDQUFBQSxpQ0FBQUEsQ0FKQTtBQUFBO0FBUUFDLFVBQUFBLDBCQUFBQSxrQkFBQUEsa0JBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVGLGNBQU87QUFEWEUsVUFBQUEsQ0FBQUEsNkJBQUFBLENBUkE7QUFBQSxVQVlBLE9BQUFDLENBQUFBLHlCQUFBQSxpQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVILGNBQU87QUFEWEcsVUFBQUEsQ0FBQUEsNEJBQUFBLENBQUFBLGlCQVpBO0FBREZMLFFBQUFBLEdBQUFBLFdBQUFBLEVBQWMsdUJBQWRBLFdBQUE7QUFBQSxRQWtCQSxPQUFBLG1DQUFNLHFCQUFOLENBbEJBO0FBRjRCQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQixvQkFBaEJBO0FBQVpELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM0NTU1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vZWxlbWVudC9mb3JtLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jyb3dzZXIvYmxvYidcblxubW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbmNsYXNzIEZvcm0gPCBFbGVtZW50XG4gICMgQ2FwdHVyZSB0aGUgY29udGVudCBvZiB0aGlzIGZvcm0gdG8gYSBuZXcge0Zvcm1EYXRhfSBvYmplY3QsXG4gICNcbiAgIyBAcmV0dXJuIFtGb3JtRGF0YV1cbiAgZGVmIGZvcm1fZGF0YVxuICAgIEZvcm1EYXRhLmNyZWF0ZShzZWxmKVxuICBlbmRcblxuICAjIFN1Ym1pdCBhIGZvcm0uIFRoaXMgd2lsbCBmaXJlIGEgc3VibWl0IGV2ZW50LlxuICBkZWYgc3VibWl0XG4gICAgYCNAbmF0aXZlLnN1Ym1pdCgpYFxuICBlbmRcblxuICAjIFJlc2V0IGEgZm9ybS4gVGhpcyB3aWxsIGZpcmUgYSByZXNldCBldmVudC5cbiAgZGVmIHJlc2V0XG4gICAgYCNAbmF0aXZlLnJlc2V0KClgXG4gIGVuZFxuXG4gIGFsaWFzX25hdGl2ZSA6YWN0aW9uXG4gIGFsaWFzX25hdGl2ZSA6YWN0aW9uPVxuICBhbGlhc19uYXRpdmUgOm1ldGhvZFxuICBhbGlhc19uYXRpdmUgOm1ldGhvZD1cbiAgYWxpYXNfbmF0aXZlIDp0YXJnZXRcbiAgYWxpYXNfbmF0aXZlIDp0YXJnZXQ9XG4gIGFsaWFzX25hdGl2ZSA6bmFtZVxuICBhbGlhc19uYXRpdmUgOm5hbWU9IFxuICBhbGlhc19uYXRpdmUgOmVuY29kaW5nXG4gIGFsaWFzX25hdGl2ZSA6ZW5jb2Rpbmc9XG5cbiAgIyBSZXR1cm4gYSBOb2RlU2V0IGNvbnRhaW5pbmcgYWxsIGZvcm0gY29udHJvbHMgYmVsb25naW5nIHRvIHRoaXMgZm9ybSBlbGVtZW50LlxuICBkZWYgY29udHJvbHNcbiAgICBOb2RlU2V0W05hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5lbGVtZW50c2ApXVxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZDsgZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIm1vZHVsZSIsImNsYXNzIiwiZm9ybV9kYXRhIiwiY3JlYXRlIiwic2VsZiIsInN1Ym1pdCIsIkBuYXRpdmUiLCJyZXNldCIsImFsaWFzX25hdGl2ZSIsImNvbnRyb2xzIiwiW10iLCJuZXciXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUFZQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRTVCLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFJRTtBQUFBQyxVQUFBQSw2QkFBQUEsb0JBQUFBLHFCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFBLHdCQUFBQyxRQUFBQSxDQUFnQkMsSUFBaEJEO0FBREZELFVBQUFBLENBQUFBLCtCQUFBQSxDQUFBO0FBQUE7QUFLQUcsVUFBQUEsMEJBQUFBLGlCQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUMsY0FBTztBQURYRCxVQUFBQSxDQUFBQSw0QkFBQUEsQ0FMQTtBQUFBO0FBVUFFLFVBQUFBLHlCQUFBQSxnQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVELGNBQU87QUFEWEMsVUFBQUEsQ0FBQUEsMkJBQUFBLENBVkE7QUFBQSxjQWNBQyxjQUFBQSxDQUFhLFFBQWJBLENBZEE7QUFBQSxjQWVBQSxjQUFBQSxDQUFhLFNBQWJBLENBZkE7QUFBQSxjQWdCQUEsY0FBQUEsQ0FBYSxRQUFiQSxDQWhCQTtBQUFBLGNBaUJBQSxjQUFBQSxDQUFhLFNBQWJBLENBakJBO0FBQUEsY0FrQkFBLGNBQUFBLENBQWEsUUFBYkEsQ0FsQkE7QUFBQSxjQW1CQUEsY0FBQUEsQ0FBYSxTQUFiQSxDQW5CQTtBQUFBLGNBb0JBQSxjQUFBQSxDQUFhLE1BQWJBLENBcEJBO0FBQUEsY0FxQkFBLGNBQUFBLENBQWEsT0FBYkEsQ0FyQkE7QUFBQSxjQXNCQUEsY0FBQUEsQ0FBYSxVQUFiQSxDQXRCQTtBQUFBLGNBdUJBQSxjQUFBQSxDQUFhLFdBQWJBLENBdkJBO0FBQUEsVUEwQkEsT0FBQUMsQ0FBQUEsNEJBQUFBLG1CQUFBQSxvQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBQSx1QkFBQUMsT0FBQUEsQ0FBUSxJQUFBLHNCQUFBLFVBQUFDLEtBQUFBLENBQW9CTCxjQUFPLFNBQTNCSyxDQUFSRDtBQURGRCxVQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEsb0JBMUJBO0FBSkZSLFFBQUFBLEdBQUFBLFdBQUFBLEVBQWEsdUJBQWJBO0FBRjRCQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUFnQixvQkFBaEJBO0FBQVpELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ2MjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2lucHV0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2Jyb3dzZXIvYmxvYidcblxubW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbmNsYXNzIElucHV0IDwgRWxlbWVudFxuICBkZWYgdmFsdWVcbiAgICAleHtcbiAgICAgIGlmICgjQG5hdGl2ZS52YWx1ZSA9PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICNAbmF0aXZlLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHZhbHVlPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUudmFsdWUgPSAje3ZhbHVlfWBcbiAgZW5kXG5cbiAgZGVmIGNoZWNrZWQ/XG4gICAgYCNAbmF0aXZlLmNoZWNrZWRgXG4gIGVuZFxuXG4gIGRlZiBjaGVjayFcbiAgICBgI0BuYXRpdmUuY2hlY2tlZCA9ICdjaGVja2VkJ2BcbiAgZW5kXG5cbiAgZGVmIHVuY2hlY2shXG4gICAgYCNAbmF0aXZlLmNoZWNrZWQgPSAnJ2BcbiAgZW5kXG5cbiAgZGVmIGNsZWFyXG4gICAgYCNAbmF0aXZlLnZhbHVlID0gJydgXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGZpbGVzXG4gICMgQHJldHVybiBbQXJyYXk8RmlsZT5dIGxpc3Qgb2YgZmlsZXMgYXR0YWNoZWQgdG8gdGhpcyB7SW5wdXR9XG4gIGRlZiBmaWxlc1xuICAgIE5hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5maWxlc2ApLm1hcCB7IHxmfCBGaWxlLm5ldyhmLnRvX24pIH1cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmQ7IGVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJtb2R1bGUiLCJjbGFzcyIsInZhbHVlIiwiQG5hdGl2ZSIsInZhbHVlPSIsImNoZWNrZWQ/IiwiY2hlY2shIiwidW5jaGVjayEiLCJjbGVhciIsImZpbGVzIiwibWFwIiwibmV3IiwiZiIsInRvX24iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUFZQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRTVCLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFDRTtBQUFBQyxVQUFBQSx5QkFBQUEsaUJBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUFFRixVQUFXQyxjQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWdCQSxjQUFPO0FBQ3ZCO0FBQ0E7QUFSRUQsVUFBQUEsQ0FBQUEsNEJBQUFBLENBQUE7QUFBQTtBQVdBRSxVQUFBQSwwQkFBQUEsb0JBQUFBLFNBQVcsS0FBWEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUQsY0FBTyxTQUFXRDtBQUR0QkUsVUFBQUEsQ0FBQUEsK0JBQUFBLENBWEE7QUFBQTtBQWVBQyxVQUFBQSw0QkFBQUEsd0JBQUFBLFNBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVGLGNBQU87QUFEWEUsVUFBQUEsQ0FBQUEsbUNBQUFBLENBZkE7QUFBQTtBQW1CQUMsVUFBQUEsMEJBQUFBLHNCQUFBQSxTQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFSCxjQUFPO0FBRFhHLFVBQUFBLENBQUFBLGlDQUFBQSxDQW5CQTtBQUFBO0FBdUJBQyxVQUFBQSw0QkFBQUEsd0JBQUFBLFNBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVKLGNBQU87QUFEWEksVUFBQUEsQ0FBQUEsbUNBQUFBLENBdkJBO0FBQUE7QUEyQkFDLFVBQUFBLHlCQUFBQSxpQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVMLGNBQU87QUFEWEssVUFBQUEsQ0FBQUEsNEJBQUFBLENBM0JBO0FBQUEsVUFpQ0EsT0FBQUMsQ0FBQUEseUJBQUFBLGlCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBQUMsTUFBQSxJQUFBLHNCQUFBLFVBQUFDLEtBQUFBLENBQW9CUixjQUFPLE1BQTNCUSxDQUFBRCxPQUFBQSxFQUFBQSxFQUFBQSxFQXhDSixnQkF3QytDLENBeEMvQyxFQUFBOztBQUFBO0FBQUE7QUF3QytDLGNBQUE7QUFBQSxjQUFBO0FBQUEsY0FBQSxDQXhDL0M7QUFBQSxjQXdDa0QsT0FBQSxvQkFBQUMsS0FBQUEsQ0FBU0MsQ0FBQUMsTUFBQUEsQ0FBQUEsQ0FBVEYsQ0F4Q2xELENBQUEsa0JBQUEsaUJBQUEsS0F3Q0lEO0FBREZELFVBQUFBLENBQUFBLDRCQUFBQSxDQUFBQSxpQkFqQ0E7QUFERlIsUUFBQUEsR0FBQUEsV0FBQUEsRUFBYyx1QkFBZEE7QUFGNEJBLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWdCLG9CQUFoQkE7QUFBWkQsSUFBQUEsR0FBQUEsV0FBQUE7QUFBaEJBLEVBQUFBLEdBQUFBLFdBQUFBLFdBRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNDcxMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvc2VsZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NOyBjbGFzcyBFbGVtZW50IDwgTm9kZVxuXG5jbGFzcyBTZWxlY3QgPCBFbGVtZW50XG4gIGRlZiB2YWx1ZVxuICAgICV4e1xuICAgICAgaWYgKCNAbmF0aXZlLnZhbHVlID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI0BuYXRpdmUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGFiZWxzXG4gICAgTm9kZVNldFtOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUubGFiZWxzYCldXG4gIGVuZFxuXG4gIGRlZiBvcHRpb25zXG4gICAgTm9kZVNldFtOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUub3B0aW9uc2ApXVxuICBlbmRcblxuICBkZWYgb3B0aW9uXG4gICAgRE9NKGAjQG5hdGl2ZS5vcHRpb25zWyNAbmF0aXZlLnNlbGVjdGVkSW5kZXhdYClcbiAgZW5kXG5cbiAgZGVmIGluZGV4XG4gICAgYCNAbmF0aXZlLnNlbGVjdGVkSW5kZXhgXG4gIGVuZFxuXG4gIGFsaWFzX25hdGl2ZSA6bXVsdGlwbGU/LCA6bXVsdGlwbGVcbiAgYWxpYXNfbmF0aXZlIDpyZXF1aXJlZD8sIDpyZXF1aXJlZFxuICBhbGlhc19uYXRpdmUgOmxlbmd0aFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInZhbHVlIiwiQG5hdGl2ZSIsImxhYmVscyIsIltdIiwibmV3Iiwib3B0aW9ucyIsIm9wdGlvbiIsIkRPTSIsImluZGV4IiwiYWxpYXNfbmF0aXZlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBWUM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUU1QixPQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUMsVUFBQUEseUJBQUFBLGtCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBO0FBRUYsVUFBV0MsY0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxlQUFnQkEsY0FBTztBQUN2QjtBQUNBO0FBUkVELFVBQUFBLENBQUFBLDZCQUFBQSxDQUFBO0FBQUE7QUFXQUUsVUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBQSx1QkFBQUMsT0FBQUEsQ0FBUSxJQUFBLHNCQUFBLFVBQUFDLEtBQUFBLENBQW9CSCxjQUFPLE9BQTNCRyxDQUFSRDtBQURGRCxVQUFBQSxDQUFBQSw4QkFBQUEsQ0FYQTtBQUFBO0FBZUFHLFVBQUFBLDJCQUFBQSxvQkFBQUEsbUJBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUEsdUJBQUFGLE9BQUFBLENBQVEsSUFBQSxzQkFBQSxVQUFBQyxLQUFBQSxDQUFvQkgsY0FBTyxRQUEzQkcsQ0FBUkQ7QUFERkUsVUFBQUEsQ0FBQUEsK0JBQUFBLENBZkE7QUFBQTtBQW1CQUMsVUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsV0FBQUMsS0FBQUEsQ0FBTU4sY0FBTyxTQUFVQSxjQUFPLGVBQTlCTTtBQURGRCxVQUFBQSxDQUFBQSw4QkFBQUEsQ0FuQkE7QUFBQTtBQXVCQUUsVUFBQUEseUJBQUFBLGtCQUFBQSxpQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRVAsY0FBTztBQURYTyxVQUFBQSxDQUFBQSw2QkFBQUEsQ0F2QkE7QUFBQSxjQTJCQUMsY0FBQUEsQ0FBYSxhQUFZLFVBQXpCQSxDQTNCQTtBQUFBLGNBNEJBQSxjQUFBQSxDQUFhLGFBQVksVUFBekJBLENBNUJBO0FBQUEsVUE2QkEsV0FBQUEsY0FBQUEsQ0FBYSxRQUFiQSxDQTdCQTtBQURGVixRQUFBQSxHQUFBQSxXQUFBQSxFQUFlLHVCQUFmQTtBQUY0QkEsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0Isb0JBQWhCQTtBQUFaRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNDc4NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvdGVtcGxhdGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbmNsYXNzIFRlbXBsYXRlIDwgRWxlbWVudFxuICBkZWYgY29udGVudFxuICAgIERPTShgI0BuYXRpdmUuY29udGVudGApXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImNvbnRlbnQiLCJET00iLCJAbmF0aXZlIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFBWUM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQSxRQUU1QixPQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsVUFBQUE7O0FBQUFBO0FBQUFBLFVBQ0UsT0FBQUMsQ0FBQUEsMkJBQUFBLHNCQUFBQSxtQkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsV0FBQUMsS0FBQUEsQ0FBTUMsY0FBTyxRQUFiRDtBQURGRCxVQUFBQSxDQUFBQSxpQ0FBQUEsQ0FBQUE7QUFERkQsUUFBQUEsR0FBQUEsV0FBQUEsRUFBaUIsdUJBQWpCQTtBQUY0QkEsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0Isb0JBQWhCQTtBQUFaRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNDgyMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQvdGV4dGFyZWEucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET007IGNsYXNzIEVsZW1lbnQgPCBOb2RlXG5cbmNsYXNzIFRleHRhcmVhIDwgRWxlbWVudFxuICBkZWYgdmFsdWVcbiAgICAleHtcbiAgICAgIGlmICgjQG5hdGl2ZS52YWx1ZSA9PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICNAbmF0aXZlLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHZhbHVlPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUudmFsdWUgPSAje3ZhbHVlfWBcbiAgZW5kXG5cbiAgZGVmIGNsZWFyXG4gICAgYCNAbmF0aXZlLnZhbHVlID0gJydgXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInZhbHVlIiwiQG5hdGl2ZSIsInZhbHVlPSIsImNsZWFyIl0sIm1hcHBpbmdzIjoiOzs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUFZQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRTVCLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFDRTtBQUFBQyxVQUFBQSx5QkFBQUEsb0JBQUFBLGlCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUFFRixVQUFXQyxjQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWdCQSxjQUFPO0FBQ3ZCO0FBQ0E7QUFSRUQsVUFBQUEsQ0FBQUEsK0JBQUFBLENBQUE7QUFBQTtBQVdBRSxVQUFBQSwwQkFBQUEsdUJBQUFBLFNBQVcsS0FBWEE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsT0FBRUQsY0FBTyxTQUFXRDtBQUR0QkUsVUFBQUEsQ0FBQUEsa0NBQUFBLENBWEE7QUFBQSxVQWVBLE9BQUFDLENBQUFBLHlCQUFBQSxvQkFBQUEsaUJBQUFBO0FBQUFBLFlBQUFBOztBQUFBQSxZQUNFLE9BQUVGLGNBQU87QUFEWEUsVUFBQUEsQ0FBQUEsK0JBQUFBLENBQUFBLGlCQWZBO0FBREZKLFFBQUFBLEdBQUFBLFdBQUFBLEVBQWlCLHVCQUFqQkE7QUFGNEJBLE1BQUFBLEdBQUFBLFdBQUFBLEVBQWdCLG9CQUFoQkE7QUFBWkQsSUFBQUEsR0FBQUEsV0FBQUE7QUFBaEJBLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MzQ4NzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9lbGVtZW50L2lmcmFtZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTTsgY2xhc3MgRWxlbWVudCA8IE5vZGVcblxuY2xhc3MgSWZyYW1lIDwgRWxlbWVudFxuICAjIEAhYXR0cmlidXRlIHNyY1xuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIFVSTCBvZiB0aGUgcGFnZSB0byBlbWJlZFxuICBhbGlhc19uYXRpdmUgOnNyY1xuICBhbGlhc19uYXRpdmUgOnNyYz1cblxuICAjIEAhYXR0cmlidXRlIFtyXSBjb250ZW50X3dpbmRvd1xuICAjIEByZXR1cm4gW1dpbmRvd10gd2luZG93IG9mIGNvbnRlbnQgb2YgdGhpcyBpZnJhbWVcbiAgZGVmIGNvbnRlbnRfd2luZG93XG4gICAgQnJvd3Nlcjo6V2luZG93Lm5ldyhgI0BuYXRpdmUuY29udGVudFdpbmRvd2ApXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGNvbnRlbnRfZG9jdW1lbnRcbiAgIyBAcmV0dXJuIFtEb2N1bWVudF0gZG9jdW1lbnQgb2YgY29udGVudCBvZiB0aGlzIGlmcmFtZSBcbiAgZGVmIGNvbnRlbnRfZG9jdW1lbnRcbiAgICBET00oYCNAbmF0aXZlLmNvbnRlbnREb2N1bWVudCB8fCAjQG5hdGl2ZS5jb250ZW50V2luZG93LmRvY3VtZW50YClcbiAgZW5kXG5cbiAgIyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgaWZyYW1lIGNvbnRlbnQncyB3aW5kb3cuXG4gICNcbiAgIyBAcGFyYW0gbWVzc2FnZSBbU3RyaW5nXSB0aGUgbWVzc2FnZVxuICAjIEBwYXJhbSBvcHRpb25zIFtIYXNoXSBvcHRpb25hbCBgdG86IHRhcmdldGBcbiAgZGVmIHNlbmQobWVzc2FnZSwgb3B0aW9ucz17fSlcbiAgICBjb250ZW50X3dpbmRvdy5zZW5kKG1lc3NhZ2UsIG9wdGlvbnMpXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImFsaWFzX25hdGl2ZSIsImNvbnRlbnRfd2luZG93IiwibmV3IiwiQG5hdGl2ZSIsImNvbnRlbnRfZG9jdW1lbnQiLCJET00iLCJzZW5kIiwibWVzc2FnZSIsIm9wdGlvbnMiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUFZQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRTVCLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFHRSxjQUFBQyxjQUFBQSxDQUFhLEtBQWJBLENBQUE7QUFBQSxjQUNBQSxjQUFBQSxDQUFhLE1BQWJBLENBREE7QUFBQTtBQUtBQyxVQUFBQSxrQ0FBQUEsMkJBQUFBLDBCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFBLElBQUEsdUJBQUEsV0FBQUMsS0FBQUEsQ0FBc0JDLGNBQU8sY0FBN0JEO0FBREZELFVBQUFBLENBQUFBLHNDQUFBQSxDQUxBO0FBQUE7QUFXQUcsVUFBQUEsb0NBQUFBLDZCQUFBQSw0QkFBQUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQ0UsV0FBQUMsS0FBQUEsQ0FBTUYsY0FBTyxvQkFBcUJBLGNBQU8sdUJBQXpDRTtBQURGRCxVQUFBQSxDQUFBQSx3Q0FBQUEsQ0FYQTtBQUFBLFVBbUJBLE9BQUFFLENBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQVMsT0FBRCxFQUFVLE9BQWxCQTtBQUFBQSxZQUFBQTs7QUFBQUE7QUF6QkY7QUF5Qm9CLFlBQUE7QUFBQSxZQUFBLFlBQVEsWUFBQSxFQUFSO0FBQUEsWUFBQSxDQXpCcEI7QUFBQSxZQTBCSSxXQUFBTCxnQkFBQUEsQ0FBQUEsQ0FBQUssTUFBQUEsQ0FBb0JDLFNBQVNDLE9BQTdCRixDQTFCSjtBQXlCRUEsVUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBLGdCQW5CQTtBQUhGUCxRQUFBQSxHQUFBQSxXQUFBQSxFQUFlLHVCQUFmQTtBQUY0QkEsTUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0Isb0JBQWhCQTtBQUFaRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNDkzNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2VsZW1lbnQucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9hdHRyaWJ1dGVzJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9kYXRhJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9wb3NpdGlvbidcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvb2Zmc2V0J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9zY3JvbGwnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L3NpemUnXG5cbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvYnV0dG9uJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9pbWFnZSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvZm9ybSdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvaW5wdXQnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L3NlbGVjdCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2VsZW1lbnQvdGVtcGxhdGUnXG5yZXF1aXJlICdicm93c2VyL2RvbS9lbGVtZW50L3RleHRhcmVhJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudC9pZnJhbWUnXG5cbm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbmNsYXNzIEVsZW1lbnQgPCBOb2RlXG4gIGRlZiBzZWxmLmNyZWF0ZSgqYXJncylcbiAgICAkZG9jdW1lbnQuY3JlYXRlX2VsZW1lbnQoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ldyhub2RlKVxuICAgIGlmIHNlbGYgPT0gRWxlbWVudFxuICAgICAgbmFtZSA9IGBub2RlLm5vZGVOYW1lYC5jYXBpdGFsaXplXG5cbiAgICAgIGlmIEVsZW1lbnQuY29uc3RhbnRzLmluY2x1ZGU/KG5hbWUpXG4gICAgICAgIEVsZW1lbnQuY29uc3RfZ2V0KG5hbWUpLm5ldyhub2RlKVxuICAgICAgZWxzZVxuICAgICAgICBzdXBlclxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgaW5jbHVkZSBFdmVudDo6VGFyZ2V0XG5cbiAgdGFyZ2V0IHt8dmFsdWV8XG4gICAgYmVnaW5cbiAgICAgIERPTSh2YWx1ZSlcbiAgICByZXNjdWUgU3RhbmRhcmRFcnJvciwgSlM6OkVycm9yXG4gICAgICBuaWxcbiAgICBlbmRcbiAgfVxuXG4gIGlmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50Lm1hdGNoZXMnXG4gICAgZGVmID1+KHNlbGVjdG9yKVxuICAgICAgYCNAbmF0aXZlLm1hdGNoZXMoI3tzZWxlY3Rvcn0pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5tYXRjaGVzIChPcGVyYSknXG4gICAgZGVmID1+KHNlbGVjdG9yKVxuICAgICAgYCNAbmF0aXZlLm9NYXRjaGVzU2VsZWN0b3IoI3tzZWxlY3Rvcn0pYFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRWxlbWVudC5tYXRjaGVzIChJbnRlcm5ldCBFeHBsb3JlciknXG4gICAgZGVmID1+KHNlbGVjdG9yKVxuICAgICAgYCNAbmF0aXZlLm1zTWF0Y2hlc1NlbGVjdG9yKCN7c2VsZWN0b3J9KWBcbiAgICBlbmRcbiAgZWxzaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0VsZW1lbnQubWF0Y2hlcyAoRmlyZWZveCknXG4gICAgZGVmID1+KHNlbGVjdG9yKVxuICAgICAgYCNAbmF0aXZlLm1vek1hdGNoZXNTZWxlY3Rvcigje3NlbGVjdG9yfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdFbGVtZW50Lm1hdGNoZXMgKENocm9tZSknXG4gICAgZGVmID1+KHNlbGVjdG9yKVxuICAgICAgYCNAbmF0aXZlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcigje3NlbGVjdG9yfSlgXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIubG9hZGVkPyAnU2l6emxlJ1xuICAgIGRlZiA9fihzZWxlY3RvcilcbiAgICAgIGBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yKCNAbmF0aXZlLCAje3NlbGVjdG9yfSlgXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIENoZWNrIHdoZXRoZXIgdGhlIGVsZW1lbnQgbWF0Y2hlcyB0aGUgZ2l2ZW4gc2VsZWN0b3IuXG4gICAgI1xuICAgICMgQHBhcmFtIHNlbGVjdG9yIFtTdHJpbmddIHRoZSBDU1Mgc2VsZWN0b3JcbiAgICBkZWYgPX4oc2VsZWN0b3IpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnc2VsZWN0b3IgbWF0Y2hpbmcgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgUXVlcnkgZm9yIGNoaWxkcmVuIHdpdGggdGhlIGdpdmVuIFhQcGF0aHMuXG4gICNcbiAgIyBAcGFyYW0gcGF0aHMgW0FycmF5PFN0cmluZz5dIHRoZSBYUGF0aHMgdG8gbG9vayBmb3JcbiAgI1xuICAjIEByZXR1cm4gW05vZGVTZXRdXG4gIGRlZiAvKCpwYXRocylcbiAgICBOb2RlU2V0W3BhdGhzLm1hcCB7IHxwYXRofCB4cGF0aChwYXRoKSB9XVxuICBlbmRcblxuICAjIEdldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICNcbiAgIyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgYXR0cmlidXRlIG5hbWVcbiAgIyBAcGFyYW0gb3B0aW9ucyBbSGFzaF0gb3B0aW9ucyBmb3IgdGhlIGF0dHJpYnV0ZVxuICAjXG4gICMgQG9wdGlvbiBvcHRpb25zIFtTdHJpbmddIDpuYW1lc3BhY2UgdGhlIG5hbWVzcGFjZSBmb3IgdGhlIGF0dHJpYnV0ZVxuICAjXG4gICMgQHJldHVybiBbU3RyaW5nP11cbiAgZGVmIFtdKG5hbWUsIG9wdGlvbnMgPSB7fSlcbiAgICBhdHRyaWJ1dGVzLmdldChuYW1lLCBvcHRpb25zKVxuICBlbmRcblxuICAjIFNldCB0aGUgYXR0cmlidXRlIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlLlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICMgQHBhcmFtIHZhbHVlIFtPYmplY3RdIHRoZSBhdHRyaWJ1dGUgdmFsdWVcbiAgIyBAcGFyYW0gb3B0aW9ucyBbSGFzaF0gdGhlIG9wdGlvbnMgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgI1xuICAjIEBvcHRpb24gb3B0aW9ucyBbU3RyaW5nXSA6bmFtZXNwYWNlIHRoZSBuYW1lc3BhY2UgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KVxuICAgIGF0dHJpYnV0ZXMuc2V0KG5hbWUsIHZhbHVlLCBvcHRpb25zKVxuICBlbmRcblxuICAjIEFkZCBjbGFzcyBuYW1lcyB0byB0aGUgZWxlbWVudC5cbiAgI1xuICAjIEBwYXJhbSBuYW1lcyBbQXJyYXk8U3RyaW5nPl0gY2xhc3MgbmFtZXMgdG8gYWRkXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgYWRkX2NsYXNzKCpuYW1lcylcbiAgICBjbGFzc2VzID0gY2xhc3NfbmFtZXMgKyBuYW1lc1xuXG4gICAgdW5sZXNzIGNsYXNzZXMuZW1wdHk/XG4gICAgICBgI0BuYXRpdmUuY2xhc3NOYW1lID0gI3tjbGFzc2VzLnVuaXEuam9pbiAnICd9YFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEdldCB0aGUgZmlyc3Qgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIENTUyBzZWxlY3RvciBvciBYUGF0aC5cbiAgI1xuICAjIEBwYXJhbSBwYXRoX29yX3NlbGVjdG9yIFtTdHJpbmddIGFuIFhQYXRoIG9yIENTUyBzZWxlY3RvclxuICAjXG4gICMgQHJldHVybiBbTm9kZT9dXG4gIGRlZiBhdChwYXRoX29yX3NlbGVjdG9yKVxuICAgIHhwYXRoKHBhdGhfb3Jfc2VsZWN0b3IpLmZpcnN0IHx8IGNzcyhwYXRoX29yX3NlbGVjdG9yKS5maXJzdCBcbiAgZW5kXG5cbiAgIyBHZXQgdGhlIGZpcnN0IG5vZGUgbWF0Y2hpbmcgdGhlIGdpdmVuIENTUyBzZWxlY3RvcnMuXG4gICNcbiAgIyBAcGFyYW0gcnVsZXMgW0FycmF5PFN0cmluZz5dIHRoZSBDU1Mgc2VsZWN0b3JzIHRvIG1hdGNoIHdpdGhcbiAgI1xuICAjIEByZXR1cm4gW05vZGU/XVxuICBkZWYgYXRfY3NzKCpydWxlcylcbiAgICByZXN1bHQgPSBuaWxcblxuICAgIHJ1bGVzLmVhY2gge3xydWxlfFxuICAgICAgaWYgcmVzdWx0ID0gY3NzKHJ1bGUpLmZpcnN0XG4gICAgICAgIGJyZWFrXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgIyBHZXQgdGhlIGZpcnN0IG5vZGUgbWF0Y2hpbmcgdGhlIGdpdmVuIFhQYXRoLlxuICAjXG4gICMgQHBhcmFtIHBhdGhzIFtBcnJheTxTdHJpbmc+XSB0aGUgWFBhdGggdG8gbWF0Y2ggd2l0aFxuICAjXG4gICMgQHJldHVybiBbTm9kZT9dXG4gIGRlZiBhdF94cGF0aCgqcGF0aHMpXG4gICAgcmVzdWx0ID0gbmlsXG5cbiAgICBwYXRocy5lYWNoIHt8cGF0aHxcbiAgICAgIGlmIHJlc3VsdCA9IHhwYXRoKHBhdGgpLmZpcnN0XG4gICAgICAgIGJyZWFrXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgYWxpYXMgYXR0ciBbXVxuXG4gIGFsaWFzIGF0dHJpYnV0ZSBbXVxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGF0dHJpYnV0ZXNcbiAgIyBAcmV0dXJuIFtBdHRyaWJ1dGVzXSB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIGVsZW1lbnRcbiAgZGVmIGF0dHJpYnV0ZXMob3B0aW9ucyA9IHt9KVxuICAgIEF0dHJpYnV0ZXMubmV3KHNlbGYsIG9wdGlvbnMpXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGF0dHJpYnV0ZV9ub2Rlc1xuICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSBhdHRyaWJ1dGUgbm9kZXMgZm9yIHRoZSBlbGVtZW50XG4gIGRlZiBhdHRyaWJ1dGVfbm9kZXNcbiAgICBOb2RlU2V0W05hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5hdHRyaWJ1dGVzYCwgZ2V0OiA6aXRlbSldXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIGNsYXNzX25hbWVcbiAgIyBAcmV0dXJuIFtTdHJpbmddIGFsbCB0aGUgZWxlbWVudCBjbGFzcyBuYW1lc1xuICBhbGlhc19uYXRpdmUgOmNsYXNzX25hbWUsIDpjbGFzc05hbWVcblxuICAjIEAhYXR0cmlidXRlIFtyXSBjbGFzc19uYW1lc1xuICAjIEByZXR1cm4gW0FycmF5PFN0cmluZz5dIGFsbCB0aGUgZWxlbWVudCBjbGFzcyBuYW1lc1xuICBkZWYgY2xhc3NfbmFtZXNcbiAgICBgI0BuYXRpdmUuY2xhc3NOYW1lYC5zcGxpdCgvXFxzKy8pLnJlamVjdCgmOmVtcHR5PylcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ1F1ZXJ5LmNzcydcbiAgICBkZWYgY3NzKHBhdGgpXG4gICAgICBOb2RlU2V0W05hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5xdWVyeVNlbGVjdG9yQWxsKHBhdGgpYCldXG4gICAgcmVzY3VlIFN0YW5kYXJkRXJyb3IsIEpTOjpFcnJvclxuICAgICAgTm9kZVNldFtdXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIubG9hZGVkPyAnU2l6emxlJ1xuICAgIGRlZiBjc3MocGF0aClcbiAgICAgIE5vZGVTZXRbYFNpenpsZShwYXRoLCAjQG5hdGl2ZSlgXVxuICAgIHJlc2N1ZSBTdGFuZGFyZEVycm9yLCBKUzo6RXJyb3JcbiAgICAgIE5vZGVTZXRbXVxuICAgIGVuZFxuICBlbHNlXG4gICAgIyBRdWVyeSBmb3IgY2hpbGRyZW4gbWF0Y2hpbmcgdGhlIGdpdmVuIENTUyBzZWxlY3Rvci5cbiAgICAjXG4gICAgIyBAcGFyYW0gc2VsZWN0b3IgW1N0cmluZ10gdGhlIENTUyBzZWxlY3RvclxuICAgICNcbiAgICAjIEByZXR1cm4gW05vZGVTZXRdXG4gICAgZGVmIGNzcyhzZWxlY3RvcilcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdxdWVyeSBieSBDU1Mgc2VsZWN0b3IgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQ2xpY2sgdGhlIGVsZW1lbnQuIGl0IGZpcmVzIHRoZSBlbGVtZW50J3MgY2xpY2sgZXZlbnQuXG4gIGRlZiBjbGlja1xuICAgIGAjQG5hdGl2ZS5jbGljaygpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAb3ZlcmxvYWQgZGF0YSgpXG4gICNcbiAgIyAgIFJldHVybiB0aGUgZGF0YSBmb3IgdGhlIGVsZW1lbnQuXG4gICNcbiAgIyAgIEByZXR1cm4gW0RhdGFdXG4gICNcbiAgIyBAb3ZlcmxvYWQgZGF0YShoYXNoKVxuICAjXG4gICMgICBTZXQgZGF0YSBvbiB0aGUgZWxlbWVudC5cbiAgI1xuICAjICAgQHBhcmFtIGhhc2ggW0hhc2hdIHRoZSBkYXRhIHRvIHNldFxuICAjXG4gICMgICBAcmV0dXJuIFtzZWxmXVxuICBkZWYgZGF0YSh2YWx1ZSA9IG5pbClcbiAgICBkYXRhID0gRGF0YS5uZXcoc2VsZilcblxuICAgIHJldHVybiBkYXRhIHVubGVzcyB2YWx1ZVxuXG4gICAgaWYgSGFzaCA9PT0gdmFsdWVcbiAgICAgIGRhdGEuYXNzaWduKHZhbHVlKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd1bmtub3duIGRhdGEgdHlwZSdcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgZ2V0X2F0dHJpYnV0ZSBbXVxuXG4gIGFsaWFzIGdldCBbXVxuXG4gICMgQCFhdHRyaWJ1dGUgaGVpZ2h0XG4gICMgQHJldHVybiBbSW50ZWdlcl0gdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICBkZWYgaGVpZ2h0XG4gICAgc2l6ZS5oZWlnaHRcbiAgZW5kXG5cbiAgZGVmIGhlaWdodD0odmFsdWUpXG4gICAgc2l6ZS5oZWlnaHQgPSB2YWx1ZVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIGlkXG4gICMgQHJldHVybiBbU3RyaW5nP10gdGhlIElEIG9mIHRoZSBlbGVtZW50XG4gIGRlZiBpZFxuICAgICV4e1xuICAgICAgdmFyIGlkID0gI0BuYXRpdmUuaWQ7XG5cbiAgICAgIGlmIChpZCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpZD0odmFsdWUpXG4gICAgYCNAbmF0aXZlLmlkID0gI3t2YWx1ZS50b19zfWBcbiAgZW5kXG5cbiAgIyBTZXQgdGhlIGlubmVyIERPTSBvZiB0aGUgZWxlbWVudCB1c2luZyB0aGUge0J1aWxkZXJ9LlxuICBkZWYgaW5uZXJfZG9tKCZibG9jaylcbiAgICBjbGVhclxuXG4gICAgIyBGSVhNRTogd2hlbiBibG9jayBwYXNzaW5nIGlzIGZpeGVkXG4gICAgZG9jID0gZG9jdW1lbnRcblxuICAgIHNlbGYgPDwgQnVpbGRlci5uZXcoZG9jLCBzZWxmLCAmYmxvY2spLnRvX2FcbiAgZW5kXG5cbiAgIyBTZXQgdGhlIGlubmVyIERPTSB3aXRoIHRoZSBnaXZlbiBub2RlLlxuICAjXG4gICMgKHNlZSAjYXBwZW5kX2NoaWxkKVxuICBkZWYgaW5uZXJfZG9tPShub2RlKVxuICAgIGNsZWFyXG5cbiAgICBzZWxmIDw8IG5vZGVcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpbnNwZWN0ID0gbmFtZS5kb3duY2FzZVxuXG4gICAgaWYgaWRcbiAgICAgIGluc3BlY3QgKz0gJy4nICsgaWQgKyAnISdcbiAgICBlbmRcblxuICAgIHVubGVzcyBjbGFzc19uYW1lcy5lbXB0eT9cbiAgICAgIGluc3BlY3QgKz0gJy4nICsgY2xhc3NfbmFtZXMuam9pbignLicpXG4gICAgZW5kXG5cbiAgICBcIiM8RE9NOjpFbGVtZW50OiAje2luc3BlY3R9PlwiXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgb2Zmc2V0XG4gICMgQHJldHVybiBbT2Zmc2V0XSB0aGUgb2Zmc2V0IG9mIHRoZSBlbGVtZW50XG4gIGRlZiBvZmZzZXQoKnZhbHVlcylcbiAgICBvZmYgPSBPZmZzZXQubmV3KHNlbGYpXG5cbiAgICB1bmxlc3MgdmFsdWVzLmVtcHR5P1xuICAgICAgb2ZmLnNldCgqdmFsdWVzKVxuICAgIGVuZFxuXG4gICAgb2ZmXG4gIGVuZFxuXG4gIGRlZiBvZmZzZXQ9KHZhbHVlKVxuICAgIG9mZnNldC5zZXQoKnZhbHVlKVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSBwb3NpdGlvblxuICAjIEByZXR1cm4gW1Bvc2l0aW9uXSB0aGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgZGVmIHBvc2l0aW9uXG4gICAgQHBvc2l0aW9uIHx8PSBQb3NpdGlvbi5uZXcoc2VsZilcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gc2Nyb2xsXG4gICMgQHJldHVybiBbU2Nyb2xsXSB0aGUgc2Nyb2xsaW5nIGZvciB0aGUgZWxlbWVudFxuICBkZWYgc2Nyb2xsXG4gICAgQHNjcm9sbCB8fD0gU2Nyb2xsLm5ldyhzZWxmKVxuICBlbmRcblxuICAjIFNlYXJjaCBmb3IgYWxsIHRoZSBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gWFBhdGhzIG9yIENTUyBzZWxlY3RvcnMuXG4gICNcbiAgIyBAcGFyYW0gc2VsZWN0b3JzIFtBcnJheTxTdHJpbmc+XSBtaXhlZCBsaXN0IG9mIFhQYXRocyBhbmQgQ1NTIHNlbGVjdG9yc1xuICAjXG4gICMgQHJldHVybiBbTm9kZVNldF1cbiAgZGVmIHNlYXJjaCgqc2VsZWN0b3JzKVxuICAgIE5vZGVTZXQubmV3IHNlbGVjdG9ycy5tYXAge3xzZWxlY3RvcnxcbiAgICAgIHhwYXRoKHNlbGVjdG9yKS50b19hLmNvbmNhdChjc3Moc2VsZWN0b3IpLnRvX2EpXG4gICAgfS5mbGF0dGVuLnVuaXFcbiAgZW5kXG5cbiAgYWxpYXMgc2V0IFtdPVxuXG4gIGFsaWFzIHNldF9hdHRyaWJ1dGUgW109XG5cbiAgIyBAb3ZlcmxvYWQgc3R5bGUoKVxuICAjXG4gICMgICBSZXR1cm4gdGhlIHN0eWxlIGZvciB0aGUgZWxlbWVudC5cbiAgI1xuICAjICAgQHJldHVybiBbQ1NTOjpEZWNsYXJhdGlvbl1cbiAgI1xuICAjIEBvdmVybG9hZCBzdHlsZShkYXRhKVxuICAjXG4gICMgICBTZXQgdGhlIENTUyBzdHlsZSBhcyBzdHJpbmcgb3Igc2V0IG9mIHZhbHVlcy5cbiAgI1xuICAjICAgQHBhcmFtIGRhdGEgW1N0cmluZywgSGFzaF0gdGhlIG5ldyBzdHlsZVxuICAjXG4gICMgICBAcmV0dXJuIFtzZWxmXVxuICAjXG4gICMgQG92ZXJsb2FkIHN0eWxlKCZibG9jaylcbiAgI1xuICAjICAgU2V0IHRoZSBDU1Mgc3R5bGUgZnJvbSBhIENTUyBidWlsZGVyIERTTC5cbiAgI1xuICAjICAgQHJldHVybiBbc2VsZl1cbiAgZGVmIHN0eWxlKGRhdGEgPSBuaWwsICZibG9jaylcbiAgICBzdHlsZSA9IENTUzo6RGVjbGFyYXRpb24ubmV3KGAjQG5hdGl2ZS5zdHlsZWApXG5cbiAgICByZXR1cm4gc3R5bGUgdW5sZXNzIGRhdGEgfHwgYmxvY2tcblxuICAgIGlmIFN0cmluZyA9PT0gZGF0YVxuICAgICAgc3R5bGUucmVwbGFjZShkYXRhKVxuICAgIGVsc2lmIEhhc2ggPT09IGRhdGFcbiAgICAgIHN0eWxlLmFzc2lnbihkYXRhKVxuICAgIGVsc2lmIGJsb2NrXG4gICAgICBzdHlsZS5hcHBseSgmYmxvY2spXG4gICAgZWxzZVxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3Vua25vd24gZGF0YSB0eXBlJ1xuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnQ1NTLmNvbXB1dGVkJ1xuICAgIGRlZiBzdHlsZSFcbiAgICAgIENTUzo6RGVjbGFyYXRpb24ubmV3KGAje3dpbmRvdy50b19ufS5nZXRDb21wdXRlZFN0eWxlKCNAbmF0aXZlLCBudWxsKWApXG4gICAgZW5kXG4gIGVsc2lmIEJyb3dzZXIuc3VwcG9ydHM/ICdDU1MuY3VycmVudCdcbiAgICBkZWYgc3R5bGUhXG4gICAgICBDU1M6OkRlY2xhcmF0aW9uLm5ldyhgI0BuYXRpdmUuY3VycmVudFN0eWxlYClcbiAgICBlbmRcbiAgZWxzZVxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIHN0eWxlIVxuICAgICMgQHJldHVybiBbQ1NTOjpEZWNsYXJhdGlvbl0gZ2V0IHRoZSBjb21wdXRlZCBzdHlsZSBmb3IgdGhlIGVsZW1lbnRcbiAgICBkZWYgc3R5bGUhXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCAnY29tcHV0ZWQgc3R5bGUgdW5zdXBwb3J0ZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBlbGVtZW50LlxuICAjXG4gICMgQHBhcmFtIG5hbWUgW1N0cmluZ10gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gIGRlZiByZW1vdmVfYXR0cmlidXRlKG5hbWUpXG4gICAgYCNAbmF0aXZlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKWBcbiAgZW5kXG5cbiAgIyBSZW1vdmUgY2xhc3MgbmFtZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgI1xuICAjIEBwYXJhbSBuYW1lcyBbQXJyYXk8U3RyaW5nPl0gY2xhc3MgbmFtZXMgdG8gcmVtb3ZlXG4gICNcbiAgIyBAcmV0dXJuIFtzZWxmXVxuICBkZWYgcmVtb3ZlX2NsYXNzKCpuYW1lcylcbiAgICBjbGFzc2VzID0gY2xhc3NfbmFtZXMgLSBuYW1lc1xuXG4gICAgaWYgY2xhc3Nlcy5lbXB0eT9cbiAgICAgIGAjQG5hdGl2ZS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJylgXG4gICAgZWxzZVxuICAgICAgYCNAbmF0aXZlLmNsYXNzTmFtZSA9ICN7Y2xhc3Nlcy5qb2luICcgJ31gXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHNpemVcbiAgIyBAcmV0dXJuIFtTaXplXSB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudFxuICBkZWYgc2l6ZSgqaW5jKVxuICAgIFNpemUubmV3KHNlbGYsICppbmMpXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgd2lkdGhcbiAgIyBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgZGVmIHdpZHRoXG4gICAgc2l6ZS53aWR0aFxuICBlbmRcblxuICBkZWYgd2lkdGg9KHZhbHVlKVxuICAgIHNpemUud2lkdGggPSB2YWx1ZVxuICBlbmRcblxuICAjIEAhYXR0cmlidXRlIFtyXSB3aW5kb3dcbiAgIyBAcmV0dXJuIFtXaW5kb3ddIHRoZSB3aW5kb3cgZm9yIHRoZSBlbGVtZW50XG4gIGRlZiB3aW5kb3dcbiAgICBkb2N1bWVudC53aW5kb3dcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8oJ1F1ZXJ5LnhwYXRoJykgfHwgQnJvd3Nlci5sb2FkZWQ/KCd3aWNrZWQtZ29vZC14cGF0aCcpXG4gICAgaWYgQnJvd3Nlci5sb2FkZWQ/ICd3aWNrZWQtZ29vZC14cGF0aCdcbiAgICAgIGB3Z3hwYXRoLmluc3RhbGwoKWBcbiAgICBlbmRcblxuICAgIGRlZiB4cGF0aChwYXRoKVxuICAgICAgTm9kZVNldFtOYXRpdmU6OkFycmF5Lm5ldyhcbiAgICAgICAgYCgjQG5hdGl2ZS5vd25lckRvY3VtZW50IHx8ICNAbmF0aXZlKS5ldmFsdWF0ZShwYXRoLFxuICAgICAgICAgICAjQG5hdGl2ZSwgbnVsbCwgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsIG51bGwpYCxcbiAgICAgICAgZ2V0OiAgICA6c25hcHNob3RJdGVtLFxuICAgICAgICBsZW5ndGg6IDpzbmFwc2hvdExlbmd0aCldXG4gICAgcmVzY3VlIFN0YW5kYXJkRXJyb3IsIEpTOjpFcnJvclxuICAgICAgTm9kZVNldFtdXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIFF1ZXJ5IGZvciBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gWFBhdGguXG4gICAgI1xuICAgICMgQHBhcmFtIHBhdGggW1N0cmluZ10gdGhlIFhQYXRoXG4gICAgI1xuICAgICMgQHJldHVybiBbTm9kZVNldF1cbiAgICBkZWYgeHBhdGgocGF0aClcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdxdWVyeSBieSBYUGF0aCB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwiY2xhc3MiLCJjcmVhdGUiLCJzZWxmIiwiY3JlYXRlX2VsZW1lbnQiLCIkZG9jdW1lbnQiLCJhcmdzIiwibmV3IiwiPT0iLCJuYW1lIiwiY2FwaXRhbGl6ZSIsImNvbnN0YW50cyIsImluY2x1ZGU/IiwiY29uc3RfZ2V0Iiwibm9kZSIsImluY2x1ZGUiLCJ0YXJnZXQiLCJET00iLCJ2YWx1ZSIsInN1cHBvcnRzPyIsIj1+IiwiQG5hdGl2ZSIsInNlbGVjdG9yIiwibG9hZGVkPyIsInJhaXNlIiwiLyIsIltdIiwibWFwIiwicGF0aHMiLCJ4cGF0aCIsInBhdGgiLCJhdHRyaWJ1dGVzIiwiZ2V0Iiwib3B0aW9ucyIsIltdPSIsInNldCIsImFkZF9jbGFzcyIsImNsYXNzZXMiLCIrIiwiY2xhc3NfbmFtZXMiLCJuYW1lcyIsImVtcHR5PyIsInVuaXEiLCJqb2luIiwiYXQiLCJwYXRoX29yX3NlbGVjdG9yIiwiZmlyc3QiLCJjc3MiLCJhdF9jc3MiLCJyZXN1bHQiLCJlYWNoIiwicnVsZXMiLCJydWxlIiwiYXRfeHBhdGgiLCJhdHRyaWJ1dGVfbm9kZXMiLCJhbGlhc19uYXRpdmUiLCJyZWplY3QiLCJzcGxpdCIsImNsaWNrIiwiZGF0YSIsIj09PSIsImFzc2lnbiIsImhlaWdodCIsInNpemUiLCJoZWlnaHQ9IiwiJHdyaXRlciIsIi0iLCIxIiwiaWQiLCJpZD0iLCJ0b19zIiwiaW5uZXJfZG9tIiwiY2xlYXIiLCJkb2MiLCJkb2N1bWVudCIsIjw8IiwiYmxvY2siLCJ0b19hIiwiaW5uZXJfZG9tPSIsImluc3BlY3QiLCJkb3duY2FzZSIsIm9mZnNldCIsIm9mZiIsInZhbHVlcyIsIm9mZnNldD0iLCJwb3NpdGlvbiIsIkBwb3NpdGlvbiIsInNjcm9sbCIsIkBzY3JvbGwiLCJzZWFyY2giLCJzZWxlY3RvcnMiLCJjb25jYXQiLCJmbGF0dGVuIiwic3R5bGUiLCJyZXBsYWNlIiwiYXBwbHkiLCJzdHlsZSEiLCJ3aW5kb3ciLCJ0b19uIiwicmVtb3ZlX2F0dHJpYnV0ZSIsInJlbW92ZV9jbGFzcyIsImluYyIsIndpZHRoIiwid2lkdGg9Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGdDQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FEQTtBQUFBLE1BRUFBLFNBQUFBLENBQVEsOEJBQVJBLENBRkE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLDRCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSw0QkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEsMEJBQVJBLENBTEE7QUFBQSxNQU9BQSxTQUFBQSxDQUFRLDRCQUFSQSxDQVBBO0FBQUEsTUFRQUEsU0FBQUEsQ0FBUSwyQkFBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsMEJBQVJBLENBVEE7QUFBQSxNQVVBQSxTQUFBQSxDQUFRLDJCQUFSQSxDQVZBO0FBQUEsTUFXQUEsU0FBQUEsQ0FBUSw0QkFBUkEsQ0FYQTtBQUFBLE1BWUFBLFNBQUFBLENBQVEsOEJBQVJBLENBWkE7QUFBQSxNQWFBQSxTQUFBQSxDQUFRLDhCQUFSQSxDQWJBO0FBQUEsTUFjQUEsU0FBQUEsQ0FBUSw0QkFBUkEsQ0FkQTtBQUFBLEVBZ0JBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEJDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxRQUFBQyxVQUFJQyxJQUFKRCxhQUFBQSxvQkFBQUEsa0JBcEJGLEVBb0JFQTtBQUFBQSxVQUFBQTtBQUFBQTs7QUFBQUE7QUFwQkY7QUFBQSxVQUFBLDREQUFBO0FBQUE7QUFvQmtCLFVBQUEsa0JBcEJsQjtBQUFBLFVBcUJJLE9BQUFFLE1BQUFDLGVBQUFELGtCQUFBQSxFQUF5QixVQUFDRSxJ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Im1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJicm93c2VyL2RvbS9kb2N1bWVudC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIERPTVxuXG5jbGFzcyBEb2N1bWVudCA8IEVsZW1lbnRcbiAgIyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgbWF0Y2hpbmcgdGhlIGdpdmVuIElELCBDU1Mgc2VsZWN0b3Igb3IgWFBhdGguXG4gICNcbiAgIyBAcGFyYW0gd2hhdCBbU3RyaW5nXSBJRCwgQ1NTIHNlbGVjdG9yIG9yIFhQYXRoXG4gICNcbiAgIyBAcmV0dXJuIFtFbGVtZW50P10gdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnRcbiAgZGVmIFtdKHdoYXQpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI0BuYXRpdmUuZ2V0RWxlbWVudEJ5SWQod2hhdCk7XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuICN7RE9NKGByZXN1bHRgKX07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3NzKHdoYXQpLmZpcnN0IHx8IHhwYXRoKHdoYXQpLmZpcnN0XG4gIGVuZFxuXG4gIGFsaWFzIGF0IFtdXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gYm9keVxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgYm9keSBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICBkZWYgYm9keVxuICAgIERPTShgI0BuYXRpdmUuYm9keWApXG4gIGVuZFxuXG4gICMgQ3JlYXRlIGEgbmV3IGVsZW1lbnQgZm9yIHRoZSBkb2N1bWVudC5cbiAgI1xuICAjIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBub2RlIG5hbWVcbiAgIyBAcGFyYW0gb3B0aW9ucyBbSGFzaF0gb3B0aW9uYWwgYDpuYW1lc3BhY2VgIG5hbWVcbiAgI1xuICAjIEByZXR1cm4gW0VsZW1lbnRdXG4gIGRlZiBjcmVhdGVfZWxlbWVudChuYW1lLCBvcHRpb25zID0ge30pXG4gICAgaWYgbnMgPSBvcHRpb25zWzpuYW1lc3BhY2VdXG4gICAgICBET00oYCNAbmF0aXZlLmNyZWF0ZUVsZW1lbnROUygje25zfSwgI3tuYW1lfSlgKVxuICAgIGVsc2VcbiAgICAgIERPTShgI0BuYXRpdmUuY3JlYXRlRWxlbWVudChuYW1lKWApXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQ3JlYXRlIGEgbmV3IHRleHQgbm9kZSBmb3IgdGhlIGRvY3VtZW50LlxuICAjXG4gICMgQHBhcmFtIGNvbnRlbnQgW1N0cmluZ10gdGhlIHRleHQgY29udGVudFxuICAjXG4gICMgQHJldHVybiBbVGV4dF1cbiAgZGVmIGNyZWF0ZV90ZXh0KGNvbnRlbnQpXG4gICAgRE9NKGAjQG5hdGl2ZS5jcmVhdGVUZXh0Tm9kZSgje2NvbnRlbnR9KWApXG4gIGVuZFxuXG4gIGRlZiBkb2N1bWVudFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSBbcl0gaGVhZFxuICAjIEByZXR1cm4gW0VsZW1lbnQ/XSB0aGUgaGVhZCBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICBkZWYgaGVhZFxuICAgIERPTShgI0BuYXRpdmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdYClcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RE9NOjpEb2N1bWVudD5cIlxuICBlbmRcblxuICBpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuYWRkTGlzdGVuZXInXG4gICAgZGVmIHJlYWR5KCZibG9jaylcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIHJldHVybiBibG9jay5jYWxsIGlmIHJlYWR5P1xuXG4gICAgICBvbiAnZG9tOmxvYWQnIGRvIHxlfFxuICAgICAgICBlLm9mZlxuXG4gICAgICAgIGJsb2NrLmNhbGxcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRXZlbnQuYXR0YWNoJ1xuICAgIGRlZiByZWFkeSgmYmxvY2spXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgICByZXR1cm4gYmxvY2suY2FsbCBpZiByZWFkeT9cblxuICAgICAgb24gJ3JlYWR5OnN0YXRlOmNoYW5nZScgZG8gfGV8XG4gICAgICAgIGlmIHJlYWR5P1xuICAgICAgICAgIGUub2ZmXG5cbiAgICAgICAgICBibG9jay5jYWxsXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIFdhaXQgZm9yIHRoZSBkb2N1bWVudCB0byBiZSByZWFkeSBhbmQgY2FsbCB0aGUgYmxvY2suXG4gICAgZGVmIHJlYWR5KCZibG9jaylcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdkb2N1bWVudCByZWFkeSB1bnN1cHBvcnRlZCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBDaGVjayBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHkuXG4gIGRlZiByZWFkeT9cbiAgICBgI0BuYXRpdmUucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8ICNAbmF0aXZlLnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcImBcbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSByb290XG4gICMgQHJldHVybiBbRWxlbWVudD9dIHRoZSByb290IGVsZW1lbnQgb2YgdGhlIGRvY3VtZW50XG4gIGRlZiByb290XG4gICAgRE9NKGAjQG5hdGl2ZS5kb2N1bWVudEVsZW1lbnRgKVxuICBlbmRcblxuICBkZWYgcm9vdD0oZWxlbWVudClcbiAgICBgI0BuYXRpdmUuZG9jdW1lbnRFbGVtZW50ID0gI3tOYXRpdmUuY29udmVydChlbGVtZW50KX1gXG4gIGVuZFxuXG4gICMgQCFhdHRyaWJ1dGUgW3JdIHN0eWxlX3NoZWV0c1xuICAjIEByZXR1cm4gW0FycmF5PENTUzo6U3R5bGVTaGVldD5dIHRoZSBzdHlsZSBzaGVldHMgZm9yIHRoZSBkb2N1bWVudFxuICBkZWYgc3R5bGVfc2hlZXRzXG4gICAgTmF0aXZlOjpBcnJheS5uZXcoYCNAbmF0aXZlLnN0eWxlU2hlZXRzYCkge3xlfFxuICAgICAgQ1NTOjpTdHlsZVNoZWV0Lm5ldyhlKVxuICAgIH1cbiAgZW5kXG5cbiAgIyBAIWF0dHJpYnV0ZSB0aXRsZVxuICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIGRvY3VtZW50IHRpdGxlXG4gIGRlZiB0aXRsZVxuICAgIGAjQG5hdGl2ZS50aXRsZWBcbiAgZW5kXG5cbiAgZGVmIHRpdGxlPSh2YWx1ZSlcbiAgICBgI0BuYXRpdmUudGl0bGUgPSB2YWx1ZWBcbiAgZW5kXG5cbiAgaWYgQnJvd3Nlci5zdXBwb3J0cz8gJ0RvY3VtZW50LnZpZXcnXG4gICAgZGVmIHdpbmRvd1xuICAgICAgV2luZG93Lm5ldyhgI0BuYXRpdmUuZGVmYXVsdFZpZXdgKVxuICAgIGVuZFxuICBlbHNpZiBCcm93c2VyLnN1cHBvcnRzPyAnRG9jdW1lbnQud2luZG93J1xuICAgIGRlZiB3aW5kb3dcbiAgICAgIFdpbmRvdy5uZXcoYCNAbmF0aXZlLnBhcmVudFdpbmRvd2ApXG4gICAgZW5kXG4gIGVsc2VcbiAgICAjIEAhYXR0cmlidXRlIFtyXSB3aW5kb3dcbiAgICAjIEByZXR1cm4gW1dpbmRvd10gdGhlIHdpbmRvdyBmb3IgdGhlIGRvY3VtZW50XG4gICAgZGVmIHdpbmRvd1xuICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ3dpbmRvdyBmcm9tIGRvY3VtZW50IHVuc3VwcG9ydGVkJ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiW10iLCJAbmF0aXZlIiwiRE9NIiwiY3NzIiwid2hhdCIsImZpcnN0IiwieHBhdGgiLCJib2R5IiwiY3JlYXRlX2VsZW1lbnQiLCJucyIsIm9wdGlvbnMiLCJuYW1lIiwiY3JlYXRlX3RleHQiLCJjb250ZW50IiwiZG9jdW1lbnQiLCJzZWxmIiwiaGVhZCIsImluc3BlY3QiLCJzdXBwb3J0cz8iLCJyZWFkeSIsImJsb2NrIiwicmFpc2UiLCJyZWFkeT8iLCJjYWxsIiwib24iLCJlIiwib2ZmIiwicm9vdCIsInJvb3Q9IiwiY29udmVydCIsImVsZW1lbnQiLCJzdHlsZV9zaGVldHMiLCJuZXciLCJ0aXRsZSIsInRpdGxlPSIsIndpbmRvdyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBLElBQWdCQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBLE1BRWhCQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBO0FBQUFBO0FBTUU7QUFBQUMsUUFBQUEsc0JBQUFBLGlCQUFBQSxTQUFPLElBQVBBO0FBQUFBLFVBQUFBOztBQUFBQTtBQUNFO0FBQ0osbUJBQW9CQyxjQUFPOztBQUUzQjtBQUNBLG1CQUFpQkMsS0FBQUEsQ0FBSyxNQUFMQSxDQUFjO0FBQy9CO0FBQ0EsSUFOSTtBQUFBLFVBUUEsT0FBQSxrQkFBQUMsS0FBQUEsQ0FBSUMsSUFBSkQsQ0FBQUUsT0FBQUEsQ0FBQUEsQ0FBQSxhQUFtQkMsT0FBQUEsQ0FBTUYsSUFBTkUsQ0FBQUQsT0FBQUEsQ0FBQUEsQ0FBbkIsQ0FSQTtBQURGTCxRQUFBQSxDQUFBQSw0QkFBQUEsQ0FBQTtBQUFBLFFBWUEsaUJBQU0sSUFBTixFQUFTLElBQVQsQ0FaQTtBQUFBO0FBZ0JBTyxRQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxXQUFBTCxLQUFBQSxDQUFNRCxjQUFPLEtBQWJDO0FBREZLLFFBQUFBLENBQUFBLDhCQUFBQSxDQWhCQTtBQUFBO0FBMEJBQyxRQUFBQSxrQ0FBQUEsNkJBQUFBLDBCQUFtQixJQUFELEVBQU8sT0FBekJBO0FBQUFBLFVBQUFBOztBQUFBQTtBQW5DRjtBQW1DMkIsVUFBQTtBQUFBLFVBQUEsWUFBVSxZQUFBLEVBQVY7QUFBQSxVQUFBLENBbkMzQjtBQUFBLFVBb0NJLElBQUEsUUFBR0Ms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QSxDQUFBQSxpQ0FBQUEsQ0FBQUE7QUFQRixRQUFBLENBL0hBO0FBTkZwQyxNQUFBQSxHQUFBQSxXQUFBQSxFQUFpQix1QkFBakJBO0FBRmdCRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNTc2MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2RvY3VtZW50X2ZyYWdtZW50LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbmNsYXNzIERvY3VtZW50RnJhZ21lbnQgPCBFbGVtZW50XG5cbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIl0sIm1hcHBpbmdzIjoiOzs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQkM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQSxNQUFBQSxHQUFBQSxXQUFBQSxFQUF5Qix1QkFBekJBO0FBRmdCRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNTc4NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvZG9tL2J1aWxkZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBUZW1wb3JhcnkgZml4IGZvciBhIGJ1ZyBpbiBTdHJpbmcjc2NhblxubW9kdWxlIFBhZ2dpbzo6VXRpbHNcbiAgZGVmIHNlbGYuaGVyZWRvYyhzdHJpbmcpXG4gICAgc3RyaW5nXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFBhZ2dpbzo6SFRNTDo6RWxlbWVudCA8IEJhc2ljT2JqZWN0XG4gIGRlZiBvbigqYXJncywgJmJsb2NrKVxuICAgIChAb24gfHw9IFtdKSA8PCBbYXJncywgYmxvY2tdXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgRE9NXG5cbmNsYXNzIEJ1aWxkZXJcbiAgZGVmIHNlbGYudG9faFxuICAgIEBidWlsZGVycyB8fD0ge31cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZm9yKGtsYXNzLCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIHRvX2hba2xhc3NdID0gYmxvY2tcbiAgICBlbHNlXG4gICAgICB0b19oW2tsYXNzXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2VsZi5idWlsZChidWlsZGVyLCBpdGVtKVxuICAgIHRvX2guZWFjaCB7fGtsYXNzLCBibG9ja3xcbiAgICAgIGlmIGtsYXNzID09PSBpdGVtXG4gICAgICAgIHJldHVybiBibG9jay5jYWxsKGJ1aWxkZXIsIGl0ZW0pXG4gICAgICBlbmRcbiAgICB9XG5cbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNhbm5vdCBidWlsZCB1bmtub3duIGl0ZW0gI3tpdGVtfVwiXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpkb2N1bWVudCwgOmVsZW1lbnRcblxuICBkZWYgaW5pdGlhbGl6ZShkb2N1bWVudCwgJmJsb2NrKVxuICAgIEBkb2N1bWVudCA9IGRvY3VtZW50XG4gICAgQGJ1aWxkZXIgID0gUGFnZ2lvOjpIVE1MLm5ldygmYmxvY2spXG4gICAgQHJvb3RzICAgID0gQGJ1aWxkZXIuZWFjaC5tYXAgeyB8ZXwgQnVpbGRlci5idWlsZChzZWxmLCBlKSB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgQHJvb3RzXG4gIGVuZFxuZW5kXG5cbkJ1aWxkZXIuZm9yIFN0cmluZyBkbyB8YiwgaXRlbXxcbiAgYi5kb2N1bWVudC5jcmVhdGVfdGV4dChpdGVtKVxuZW5kXG5cbkJ1aWxkZXIuZm9yIFBhZ2dpbzo6SFRNTDo6RWxlbWVudCBkbyB8YiwgaXRlbXxcbiAgZG9tID0gYi5kb2N1bWVudC5jcmVhdGVfZWxlbWVudChgaXRlbS5uYW1lYClcblxuICBpZiBIYXNoID09PSBgaXRlbS5hdHRyaWJ1dGVzYFxuICAgIGRvbS5hdHRyaWJ1dGVzLm1lcmdlIShgaXRlbS5hdHRyaWJ1dGVzYClcbiAgZW5kXG5cbiAgYGl0ZW0uY2xhc3NfbmFtZXNgLmVhY2gge3x2YWx1ZXxcbiAgICBkb20uYWRkX2NsYXNzIHZhbHVlXG4gIH1cblxuICBpZiBvbiA9IGBpdGVtLm9uIHx8IG5pbGBcbiAgICBvbi5lYWNoIHt8YXJncywgYmxvY2t8XG4gICAgICBkb20ub24oKmFyZ3MsICZibG9jaylcbiAgICB9XG4gIGVuZFxuXG4gIGlmIGlubmVyID0gYGl0ZW0uaW5uZXJfaHRtbCB8fCBuaWxgXG4gICAgZG9tLmlubmVyX2h0bWwgPSBpbm5lclxuICBlbHNlXG4gICAgaXRlbS5lYWNoIHt8Y2hpbGR8XG4gICAgICBkb20gPDwgQnVpbGRlci5idWlsZChiLCBjaGlsZClcbiAgICB9XG4gIGVuZFxuXG4gIGRvbVxuZW5kXG5cbkJ1aWxkZXIuZm9yIERPTTo6Tm9kZSBkbyB8YiwgaXRlbXxcbiAgaXRlbVxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiaGVyZWRvYyIsInNlbGYiLCJzdHJpbmciLCJjbGFzcyIsIm9uIiwiQG9uIiwiPDwiLCJhcmdzIiwiYmxvY2siLCJ0b19oIiwiQGJ1aWxkZXJzIiwiZm9yIiwiJHdyaXRlciIsImtsYXNzIiwiW109IiwiLSIsIjEiLCJbXSIsImJ1aWxkIiwiZWFjaCIsIj09PSIsIml0ZW0iLCJjYWxsIiwiYnVpbGRlciIsInJhaXNlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQGRvY3VtZW50IiwiZG9jdW1lbnQiLCJAYnVpbGRlciIsIm5ldyIsIkByb290cyIsIm1hcCIsImUiLCJ0b19hIiwiYiIsImNyZWF0ZV90ZXh0IiwiZG9tIiwiY3JlYXRlX2VsZW1lbnQiLCJhdHRyaWJ1dGVzIiwibWVyZ2UhIiwiYWRkX2NsYXNzIiwidmFsdWUiLCJpbm5l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QW9GNkIsUUFBQTtBQUFBLFFBQUE7QUFBQSxRQUFBLENBcEY3QjtBQUFBLFFBcUZFLE9BQUFVLElBckZGLENBQUEsc0JBQUEscUJBQUEsU0FvRkFWLENBcEVBO0FBRmdCWixJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUEsV0FaQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM1OTk1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20vbXV0YXRpb25fb2JzZXJ2ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlIEJyb3dzZXI7IG1vZHVsZSBET01cblxuIyBBIHtNdXRhdGlvbk9ic2VydmVyfSBpcyBhIHBlcmZvcm1hbnQgd2F5IHRvIG9ic2VydmUgY2hhbmdlcyBpbiB0aGUgRE9NLFxuIyBlaXRoZXIgb24gdGhlIHRyZWUsIHRoZSBhdHRyaWJ1dGVzIG9yIGRhdGEuXG4jXG4jIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXJcbmNsYXNzIE11dGF0aW9uT2JzZXJ2ZXJcbiAgZGVmIHNlbGYuc3VwcG9ydGVkP1xuICAgIEJyb3dzZXIuc3VwcG9ydHM/IDpNdXRhdGlvbk9ic2VydmVyXG4gIGVuZFxuXG4gIGluY2x1ZGUgTmF0aXZlOjpXcmFwcGVyXG5cbiAgIyBFbmNhcHN1bGF0ZXMgYSByZWNvcmRlZCBjaGFuZ2UuXG4gIGNsYXNzIFJlY29yZFxuICAgIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdHlwZVxuICAgICMgQHJldHVybiBbOmF0dHJpYnV0ZXMsIDp0cmVlLCA6Y2RhdGFdIHRoZSB0eXBlIG9mIHRoZSByZWNvcmRlZCBjaGFuZ2VcbiAgICBkZWYgdHlwZVxuICAgICAgY2FzZSBgI0BuYXRpdmUudHlwZWBcbiAgICAgIHdoZW4gOmF0dHJpYnV0ZXMgICAgdGhlbiA6YXR0cmlidXRlXG4gICAgICB3aGVuIDpjaGlsZExpc3QgICAgIHRoZW4gOnRyZWVcbiAgICAgIHdoZW4gOmNoYXJhY3RlckRhdGEgdGhlbiA6Y2RhdGFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYW5nZSBoYXBwZW5lZCBvbiBhdHRyaWJ1dGVzLlxuICAgIGRlZiBhdHRyaWJ1dGU/XG4gICAgICB0eXBlID09IDphdHRyaWJ1dGVcbiAgICBlbmRcblxuICAgICMgUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFuZ2UgaGFwcGVuZWQgb24gdGhlIHRyZWUuXG4gICAgZGVmIHRyZWU/XG4gICAgICB0eXBlID09IDp0cmVlXG4gICAgZW5kXG5cbiAgICAjIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhbmdlIGhhcHBlbmVkIGluIGEgQ0RBVEEgc2VjdGlvbi5cbiAgICBkZWYgY2RhdGE/XG4gICAgICB0eXBlID09IDpjZGF0YVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gYWRkZWRcbiAgICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSBhZGRlZCBub2Rlc1xuICAgIGRlZiBhZGRlZFxuICAgICAgYXJyYXkgPSBpZiBgI0BuYXRpdmUuYWRkZWROb2RlcyAhPSBudWxsYFxuICAgICAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUuYWRkZWROb2Rlc2ApXG4gICAgICBlbHNlXG4gICAgICAgIFtdXG4gICAgICBlbmRcblxuICAgICAgTm9kZVNldFthcnJheV1cbiAgICBlbmRcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIHJlbW92ZWRcbiAgICAjIEByZXR1cm4gW05vZGVTZXRdIHRoZSByZW1vdmVkIG5vZGVzXG4gICAgZGVmIHJlbW92ZWRcbiAgICAgIGFycmF5ID0gaWYgYCNAbmF0aXZlLnJlbW92ZWROb2RlcyAhPSBudWxsYFxuICAgICAgICBOYXRpdmU6OkFycmF5Lm5ldyhgI0BuYXRpdmUucmVtb3ZlZE5vZGVzYClcbiAgICAgIGVsc2VcbiAgICAgICAgW11cbiAgICAgIGVuZFxuXG4gICAgICBOb2RlU2V0W2FycmF5XVxuICAgIGVuZFxuXG4gICAgIyBAIWF0dHJpYnV0ZSBbcl0gdGFyZ2V0XG4gICAgIyBAcmV0dXJuIFtOb2RlXSB0aGUgbm9kZSB0aGUgbXV0YXRpb24gYWZmZWN0ZWRcbiAgICBkZWYgdGFyZ2V0XG4gICAgICBET00oYCNAbmF0aXZlLnRhcmdldGApXG4gICAgZW5kXG5cbiAgICAjIEAhYXR0cmlidXRlIFtyXSBvbGRcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG9sZCB2YWx1ZVxuICAgIGFsaWFzX25hdGl2ZSA6b2xkLCA6b2xkVmFsdWVcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVcbiAgICAjIEByZXR1cm4gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgIGFsaWFzX25hdGl2ZSA6bmFtZSwgOmF0dHJpYnV0ZU5hbWVcblxuICAgICMgQCFhdHRyaWJ1dGUgW3JdIG5hbWVzcGFjZVxuICAgICMgQHJldHVybiBbU3RyaW5nXSB0aGUgbmFtZXNwYWNlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICBhbGlhc19uYXRpdmUgOm5hbWVzcGFjZSwgOmF0dHJpYnV0ZU5hbWVzcGFjZVxuICBlbmRcblxuICAjIENyZWF0ZSBhIG5ldyBNdXRhdGlvbk9ic2VydmVyIHdpdGggdGhlIGdpdmVuIGJsb2NrLlxuICAjXG4gICMgQHlpZWxkcGFyYW0gcmVjb3JkcyBbQXJyYXk8UmVjb3JkPl0gdGhlIHJlY29yZGVkIGNoYW5nZXNcbiAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbihyZWNvcmRzKSB7XG4gICAgICAgIHJldHVybiAje2Jsb2NrLmNhbGwoYHJlY29yZHNgLm1hcCB7IHxyfCBCcm93c2VyOjpET006Ok11dGF0aW9uT2JzZXJ2ZXI6OlJlY29yZC5uZXcocikgfSl9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyKGBuZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIoZnVuYylgKVxuICBlbmRcblxuICAjIE9ic2VydmUgdGhlIGdpdmVuIHRhcmdldCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAjXG4gICMgVGhlIHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgI1xuICAjICsgKipjaGlsZHJlbioqIC0gd2hldGhlciB0byBvYnNlcnZlIGNoYW5nZXMgb24gdGhlIGNoaWxkcmVuXG4gICMgICBvZiB0aGUgdGFyZ2V0IG9yIG5vdFxuICAjICsgKip0cmVlKiogLSB3aGV0aGVyIHRvIG9ic2VydmUgY2hhbmdlcyBvbiB0aGUgd2hvbGUgc3VidHJlZVxuICAjICAgb3Igbm90XG4gICMgKyAqKmF0dHJpYnV0ZXMqKiAtIHdoZXRoZXIgdG8gb2JzZXJ2ZSBjaGFuZ2VzIHRvIGF0dHJpYnV0ZXMgb3Igbm90LFxuICAjICAgaWYgdGhlIHZhbHVlIGlzIGA6b2xkYCB0aGUgb2xkIHZhbHVlIHdpbGwgYmUgc2F2ZWRcbiAgIyArICoqY2RhdGEqKiAtIHdoZXRoZXIgdG8gb2JzZXJ2ZSBjaGFuZ2VzIHRvIENEQVRBIHNlY3Rpb25zIG9yIG5vdCxcbiAgIyAgIGlmIHRoZSB2YWx1ZSBpcyBgOm9sZGAgdGhlIG9sZCB2YWx1ZSB3aWxsIGJlIHNhdmVkXG4gICMgKyAqKmZpbHRlcioqIC0gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIG9ic2VydmVcbiAgI1xuICAjIEBwYXJhbSB0YXJnZXQgW0RPTTo6Tm9kZSwgbmF0aXZlXSB0aGUgbm9kZSB0byBvYnNlcnZlXG4gICMgQHBhcmFtIG9wdGlvbnMgW0hhc2g/XSB0aGUgb3B0aW9uc1xuICBkZWYgb2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMgPSBuaWwpXG4gICAgdW5sZXNzIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGNoaWxkcmVuOiAgIHRydWUsXG4gICAgICAgIHRyZWU6ICAgICAgIHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IDpvbGQsXG4gICAgICAgIGNkYXRhOiAgICAgIDpvbGRcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGAjQG5hdGl2ZS5vYnNlcnZlKCN7TmF0aXZlLmNvbnZlcnQodGFyZ2V0KX0sICN7Y29udmVydChvcHRpb25zKX0pYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICAjIEVtcHR5IHRoZSBvYnNlcnZlciBxdWV1ZSBhbmQgcmV0dXJuIGl0cyBjb250ZW50cy5cbiAgI1xuICAjIEByZXR1cm4gW0FycmF5PFJlY29yZD5dXG4gIGRlZiB0YWtlXG4gICAgYCNAbmF0aXZlLnRha2VSZWNvcmRzKClgLm1hcCB7IHxyfCBSZWNvcmQubmV3KHIpIH1cbiAgZW5kXG5cbiAgIyBEaXNjb25uZWN0IHRoZSBvYnNlcnZlciwgdGh1cyBzdG9wcGluZyBvYnNlcnZpbmcgYW55IGNoYW5nZXMuXG4gIGRlZiBkaXNjb25uZWN0XG4gICAgYCNAbmF0aXZlLmRpc2Nvbm5lY3QoKWBcbiAgZW5kXG5cbnByaXZhdGVcbiAgZGVmIGNvbnZlcnQoaGFzaClcbiAgICBvcHRpb25zID0gTmF0aXZlKGB7fWApXG5cbiAgICBpZiBoYXNoWzpjaGlsZHJlbl1cbiAgICAgIG9wdGlvbnNbOmNoaWxkTGlzdF0gPSB0cnVlXG4gICAgZW5kXG5cbiAgICBpZiBoYXNoWzp0cmVlXVxuICAgICAgb3B0aW9uc1s6c3VidHJlZV0gPSB0cnVlXG4gICAgZW5kXG5cbiAgICBpZiBhdHRycyA9IGhhc2hbOmF0dHJpYnV0ZXNdXG4gICAgICBvcHRpb25zWzphdHRyaWJ1dGVzXSA9IHRydWVcblxuICAgICAgaWYgYXR0cnMgPT0gOm9sZFxuICAgICAgICBvcHRpb25zWzphdHRyaWJ1dGVPbGRWYWx1ZV0gPSB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGlmIGZpbHRlciA9IGhhc2hbOmZpbHRlcl1cbiAgICAgIG9wdGlvbnNbOmF0dHJpYnV0ZUZpbHRlcl0gPSBmaWx0ZXJcbiAgICBlbmRcblxuICAgIGlmIGNkYXRhID0gaGFzaFs6Y2RhdGFdXG4gICAgICBvcHRpb25zWzpjaGFyYWN0ZXJEYXRhXSA9IHRydWVcblxuICAgICAgaWYgY2RhdGEgPT0gOm9sZFxuICAgICAgICBvcHRpb25zWzpjaGFyYWN0ZXJEYXRhT2xkVmFsdWVdID0gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvcHRpb25zLnRvX25cbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsInN1cHBvcnRlZD8iLCJzZWxmIiwic3VwcG9ydHM/IiwiaW5jbHVkZSIsInR5cGUiLCJAbmF0aXZlIiwiYXR0cmlidXRlPyIsIj09IiwidHJlZT8iLCJjZGF0YT8iLCJhZGRlZCIsImFycmF5IiwibmV3IiwiW10iLCJyZW1vdmVkIiwidGFyZ2V0IiwiRE9NIiwiYWxpYXNfbmF0aXZlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiY2FsbCIsIm1hcCIsInIiLCJvYnNlcnZlIiwib3B0aW9ucyIsImNvbnZlcnQiLCJ0YWtlIiwiZGlzY29ubmVjdCIsInByaXZhdGUiLCJOYXRpdmUiLCJoYXNoIiwiJHdyaXRlciIsIltdPSIsIi0iLCIxIiwiYXR0cnMiLCJmaWx0ZXIiLCJjZGF0YSIsInRvX24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQU1oQkM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFVBQUlDLElBQUpELGlCQUFBQSxxQ0FBQUEsU0FBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsT0FBQSx1QkFBQUUsY0FBQUEsQ0FBa0Isa0JBQWxCQTtBQURGRixRQUFBQSxDQUFBQSxnREFBQUEsQ0FBQTtBQUFBLFlBSUFHLFNBQUFBLENBQVEsSUFBQSxzQkFBQSxZQUFSQSxDQUpBO0FBQUEsUUFPQUo7QUFBQUEsUUFBQUE7O0FBQUFBLFVBQUFBOztBQUFBQTtBQUFBQTtB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LFlBQUFELE9BQUEsQ0FBQUUsVUFBQUYsT0FBQSxDQUFBLFFBQUEsQ0FBQUUsRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBdUtNO0FBQUEsWUFFQSxJQUFHSSxLQUFBOUIsT0FBQUEsQ0FBUyxLQUFUQSxDQUFIO0FBQUE7QUF6S04sY0FBQXdCLFVBQUEsQ0EwS2dCLHVCQTFLaEIsRUEwSzBDLElBMUsxQyxDQUFBO0FBQUEsY0EwS1FDLE1BQUFSLE9BQUFRLE9BQUFBLEVBMUtSLFVBQUFELE9BQUEsQ0EwS1FDLENBMUtSO0FBQUEsY0FBQUQsT0FBQSxDQUFBRSxVQUFBRixPQUFBLENBQUEsUUFBQSxDQUFBRSxFQUFBQyxDQUFBRCxDQUFBLENBQUEsQ0F5S00sQ0FGQSxDQURGLENBdEJBO0FBQUEsVUE4QkEsT0FBQVQsT0FBQWMsTUFBQUEsQ0FBQUEsQ0E5QkE7QUFERmIsUUFBQUEsQ0FBQUEsMENBQUFBLENBQUFBLG1CQXZJQTtBQURGMUIsTUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFOZ0JELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2MjAzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9kb20vbm9kZV9zZXQnXG5yZXF1aXJlICdicm93c2VyL2RvbS9ub2RlJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vYXR0cmlidXRlJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vY2hhcmFjdGVyX2RhdGEnXG5yZXF1aXJlICdicm93c2VyL2RvbS90ZXh0J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vY2RhdGEnXG5yZXF1aXJlICdicm93c2VyL2RvbS9jb21tZW50J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZWxlbWVudCdcbnJlcXVpcmUgJ2Jyb3dzZXIvZG9tL2RvY3VtZW50J1xucmVxdWlyZSAnYnJvd3Nlci9kb20vZG9jdW1lbnRfZnJhZ21lbnQnXG5yZXF1aXJlICdicm93c2VyL2RvbS9idWlsZGVyJ1xucmVxdWlyZSAnYnJvd3Nlci9kb20vbXV0YXRpb25fb2JzZXJ2ZXInXG5cbm1vZHVsZSBLZXJuZWxcbiAgIyBQYXJzZSBhbiBYTUwgc3RyaW5nIGludG8gYSBET00gdXNhYmxlIHtCcm93c2VyOjpET006OkRvY3VtZW50fVxuICAjXG4gICMgQHBhcmFtIHdoYXQgW1N0cmluZ10gdGhlIHN0cmluZyB0byBwYXJzZVxuICAjIEByZXR1cm4gW0Jyb3dzZXI6OkRPTTo6RG9jdW1lbnRdIHRoZSBkb2N1bWVudFxuICBkZWYgWE1MKHdoYXQpXG4gICAgJXh7XG4gICAgICB2YXIgZG9jO1xuXG4gICAgICBpZiAod2luZG93LkRPTVBhcnNlcikge1xuICAgICAgICBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdoYXQsICd0ZXh0L3htbCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRvYyAgICAgICA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XG4gICAgICAgIGRvYy5hc3luYyA9ICdmYWxzZSc7XG4gICAgICAgIGRvYy5sb2FkWE1MKHdoYXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIERPTShgZG9jYClcbiAgZW5kXG5cbiAgIyBAb3ZlcmxvYWQgRE9NKGRvY3VtZW50ID0gJGRvY3VtZW50LCAmYmxvY2spXG4gICNcbiAgIyAgIENyZWF0ZSBhIERPTSB0cmVlIHVzaW5nIHRoZSB7UGFnZ2lvOjpIVE1MfSBEU0wuXG4gICNcbiAgIyAgIEBwYXJhbSBkb2N1bWVudCBbQnJvd3Nlcjo6RE9NOjpEb2N1bWVudF0gdGhlIGRvY3VtZW50IGluc3RhbmNlXG4gICMgICAgIHdlIGludGVuZCB0byB1c2VcbiAgI1xuICAjICAgQHJldHVybiBbQnJvd3Nlcjo6RE9NOjpOb2RlLCBCcm93c2VyOjpET006Ok5vZGVTZXRdXG4gICNcbiAgIyBAb3ZlcmxvYWQgRE9NKHN0cmluZywgZG9jdW1lbnQgPSAkZG9jdW1lbnQpXG4gICNcbiAgIyAgIENyZWF0ZSBhIERPTSB0cmVlIGZyb20gYSBIVE1MIHN0cmluZy5cbiAgI1xuICAjICAgQHBhcmFtIHN0cmluZyBbU3RyaW5nXSB0aGUgSFRNTCBzdHJpbmdcbiAgIyAgIEBwYXJhbSBkb2N1bWVudCBbQnJvd3Nlcjo6RE9NOjpEb2N1bWVudF0gdGhlIGRvY3VtZW50IGluc3RhbmNlXG4gICMgICAgIHdlIGludGVuZCB0byB1c2VcbiAgI1xuICAjICAgQHJldHVybiBbQnJvd3Nlcjo6RE9NOjpOb2RlXVxuICAjXG4gICMgQG92ZXJsb2FkIERPTShuYXRpdmUpXG4gICNcbiAgIyAgIFdyYXAgYSBuYXRpdmUgZWxlbWVudCB0byBjcmVhdGUgYSBET00gdHJlZS5cbiAgI1xuICAjICAgQHBhcmFtIG5hdGl2ZSBbTmF0aXZlXSB0aGUgTmF0aXZlIG5vZGVcbiAgI1xuICAjICAgQHJldHVybiBbQnJvd3Nlcjo6RE9NOjpOb2RlXVxuICAjXG4gIGRlZiBET00oKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgZG9jdW1lbnQgPSBhcmdzLnNoaWZ0IHx8ICRkb2N1bWVudFxuICAgICAgcm9vdHMgICAgPSBCcm93c2VyOjpET006OkJ1aWxkZXIubmV3KGRvY3VtZW50LCAmYmxvY2spLnRvX2FcblxuICAgICAgaWYgcm9vdHMubGVuZ3RoID09IDFcbiAgICAgICAgcm9vdHMuZmlyc3RcbiAgICAgIGVsc2VcbiAgICAgICAgQnJvd3Nlcjo6RE9NOjpOb2RlU2V0Lm5ldyhyb290cylcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHdoYXQgICAgID0gYXJncy5zaGlmdFxuICAgICAgZG9jdW1lbnQgPSBhcmdzLnNoaWZ0IHx8ICRkb2N1bWVudFxuXG4gICAgICBpZiBuYXRpdmU/KHdoYXQpXG4gICAgICAgIEJyb3dzZXI6OkRPTTo6Tm9kZS5uZXcod2hhdClcbiAgICAgIGVsc2lmIEJyb3dzZXI6OkRPTTo6Tm9kZSA9PT0gd2hhdFxuICAgICAgICB3aGF0XG4gICAgICBlbHNpZiBTdHJpbmcgPT09IHdoYXRcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIGRvYyA9ICN7TmF0aXZlLnRyeV9jb252ZXJ0KGRvY3VtZW50KX0uY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgZG9jLmlubmVySFRNTCA9IHdoYXQ7XG5cbiAgICAgICAgICByZXR1cm4gI3tET00oYGRvYy5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxID8gZG9jLmNoaWxkTm9kZXNbMF0gOiBkb2NgKX07XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJhcmd1bWVudCBub3QgRE9NIGNvbnZlcnRpYmxlXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQnJvd3NlclxuXG5jbGFzcyBXaW5kb3dcbiAgIyBHZXQgdGhlIHtET006OkRvY3VtZW50fSBmb3IgdGhpcyB3aW5kb3cuXG4gICNcbiAgIyBAcmV0dXJuIFtET006OkRvY3VtZW50XVxuICBkZWYgZG9jdW1lbnRcbiAgICBET00oYCNAbmF0aXZlLmRvY3VtZW50YClcbiAgZW5kXG5lbmRcblxuZW5kXG5cbiRkb2N1bWVudCA9ICR3aW5kb3cuZG9jdW1lbnRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwibW9kdWxlIiwiWE1MIiwiRE9NIiwiYmxvY2siLCJkb2N1bWVudCIsImFyZ3MiLCJzaGlmdCIsIiRkb2N1bWVudCIsInJvb3RzIiwibmV3IiwidG9fYSIsImxlbmd0aCIsIj09IiwiMSIsImZpcnN0Iiwid2hhdCIsIm5hdGl2ZT8iLCI9PT0iLCJ0cnlfY29udmVydCIsInJhaXNlIiwiY2xhc3MiLCJAbmF0aXZlIiwiJHdpbmRvdyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsc0JBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGtCQUFSQSxDQURB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QUFBLElBRUFvQjtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQUFBLE1BSUUsT0FBQWhCLENBQUFBLDRCQUFBQSxxQkFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLFdBQUFGLEtBQUFBLENBQU1tQixjQUFPLFNBQWJuQjtBQURGRSxNQUFBQSxDQUFBQSxnQ0FBQUEsQ0FBQUE7QUFKRmdCLElBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFwQixFQUFBQSxHQUFBQSxXQUFBQSxXQTlGQTtBQUFBLEVBMkdBLE9BQUFPLENBQUFBLGtCQUFZZSxhQUFBbEIsVUFBQUEsQ0FBQUEsQ0FBWkcsQ0EzR0E7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNjMxMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY3NzL2RlY2xhcmF0aW9uLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgQ1NTXG5cbmNsYXNzIERlY2xhcmF0aW9uXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBkZWYgcnVsZVxuICAgIFJ1bGUubmV3KGAjQG5hdGl2ZS5wYXJlbnRSdWxlYCkgaWYgZGVmaW5lZD8oYCNAbmF0aXZlLnBhcmVudFJ1bGVgKVxuICBlbmRcblxuICBkZWYgYXNzaWduKGRhdGEpXG4gICAgZGF0YS5lYWNoIHt8bmFtZSwgdmFsdWV8XG4gICAgICBzZWxmW25hbWVdID0gdmFsdWVcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKHN0cmluZylcbiAgICBgI0BuYXRpdmUuY3NzVGV4dCA9ICN7c3RyaW5nfWBcbiAgZW5kXG5cbiAgZGVmIGFwcGx5KCZibG9jaylcbiAgICBQYWdnaW86OkNTUzo6RGVmaW5pdGlvbi5uZXcoJmJsb2NrKS5lYWNoIHt8c3R5bGV8XG4gICAgICBpZiBzdHlsZS5pbXBvcnRhbnRcbiAgICAgICAgYCNAbmF0aXZlLnNldFByb3BlcnR5KCN7c3R5bGUubmFtZX0sICN7c3R5bGUudmFsdWV9LCBcImltcG9ydGFudFwiKWBcbiAgICAgIGVsc2VcbiAgICAgICAgYCNAbmF0aXZlLnNldFByb3BlcnR5KCN7c3R5bGUubmFtZX0sICN7c3R5bGUudmFsdWV9LCBcIlwiKWBcbiAgICAgIGVuZFxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShuYW1lKVxuICAgIGAjQG5hdGl2ZS5yZW1vdmVQcm9wZXJ0eSgje25hbWV9KWBcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI0BuYXRpdmUuZ2V0UHJvcGVydHlWYWx1ZSgje25hbWV9KTtcblxuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdPShuYW1lLCB2YWx1ZSlcbiAgICBgI0BuYXRpdmUuc2V0UHJvcGVydHkoI3tuYW1lfSwgI3t2YWx1ZS50b19zfSwgXCJcIilgXG4gIGVuZFxuXG4gIGRlZiBpbXBvcnRhbnQ/KG5hbWUpXG4gICAgYCNAbmF0aXZlLmdldFByb3BlcnR5UHJpb3JpdHkoI3tuYW1lfSkgPT0gXCJpbXBvcnRhbnRcImBcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSAjQG5hdGl2ZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSAgPSAjQG5hdGl2ZS5pdGVtKGkpO1xuXG4gICAgICAgICN7eWllbGQgYG5hbWVgLCBzZWxmW2BuYW1lYF19XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhc19uYXRpdmUgOmxlbmd0aFxuICBhbGlhc19uYXRpdmUgOnRvX3MsIDpjc3NUZXh0XG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsIHZhbHVlID0gbmlsKVxuICAgIGlmIG5hbWUuZW5kX3dpdGg/ID89XG4gICAgICBzZWxmW25hbWVbMCAuLiAtMl1dID0gdmFsdWVcbiAgICBlbHNlXG4gICAgICBzZWxmW25hbWVdXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiY2xhc3MiLCJpbmNsdWRlIiwicnVsZSIsIkBuYXRpdmUiLCJuZXciLCJhc3NpZ24iLCJlYWNoIiwiZGF0YSIsIiR3cml0ZXIiLCJuYW1lIiwidmFsdWUiLCJbXT0iLCJzZWxmIiwiLSIsIjEiLCJyZXBsYWNlIiwic3RyaW5nIiwiYXBwbHkiLCJibG9jayIsInN0eWxlIiwiaW1wb3J0YW50IiwiZGVsZXRlIiwiW10iLCJ0b19zIiwiaW1wb3J0YW50PyIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYWxpYXNfbmF0aXZlIiwibWV0aG9kX21pc3NpbmciLCJlbmRfd2l0aD8iLCIwIiwiLTIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQkM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFlBQUFDLFNBQUFBLENBQVEsSUFBQSx1QkFBQSx3QkFBUkEsQ0FBQTtBQUFBLFlBQ0FBLFNBQUFBLENBQVEsMEJBQVJBLENBREE7QUFBQTtBQUdBQyxRQUFBQSx3QkFBQUEsc0JBQUFBLGdCQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxJQUFBLFFBQW1DLFFBQVdDLGNBQU8sV0FBbEIsa0JBQW5DLENBQUE7QUFBQSxZQUFBLE9BQUEsb0JBQUFDLEtBQUFB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QUFBVSxPQUFBQSxDQUFLYixJQUFMYTtBQUhGLFVBQUEsQ0EzRUo7QUEwRUVNLFFBQUFBLENBQUFBLDZDQUFBQSxDQUFBQSwwQkF0RUE7QUFERjVCLE1BQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRmdCRCxJQUFBQSxHQUFBQSxXQUFBQTtBQUFoQkEsRUFBQUEsR0FBQUEsV0FBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozNjQ3NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImJyb3dzZXIvY3NzL3N0eWxlX3NoZWV0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBCcm93c2VyOyBtb2R1bGUgQ1NTXG5cbmNsYXNzIFN0eWxlU2hlZXRcbiAgaW5jbHVkZSBCcm93c2VyOjpOYXRpdmVDYWNoZWRXcmFwcGVyXG5cbiAgZGVmIGluaXRpYWxpemUod2hhdClcbiAgICBpZiB3aGF0LmlzX2E/IERPTTo6RWxlbWVudFxuICAgICAgc3VwZXIoYCN7d2hhdC50b19ufS5zaGVldGApXG4gICAgZWxzZVxuICAgICAgc3VwZXIod2hhdClcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDpkaXNhYmxlZD8sIDpkaXNhYmxlZFxuICBhbGlhc19uYXRpdmUgOmhyZWZcbiAgYWxpYXNfbmF0aXZlIDp0aXRsZVxuICBhbGlhc19uYXRpdmUgOnR5cGVcblxuICBkZWYgbWVkaWFcbiAgICBNZWRpYS5uZXcoYCNAbmF0aXZlLm1lZGlhYCkgaWYgYCNAbmF0aXZlLm1lZGlhICE9IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBvd25lclxuICAgIERPTShgI0BuYXRpdmUub3duZXJOb2RlYClcbiAgZW5kXG5cbiAgZGVmIHBhcmVudFxuICAgIFNoZWV0Lm5ldyhgI0BuYXRpdmUucGFyZW50U3R5bGVTaGVldGApIGlmIGAjQG5hdGl2ZS5wYXJlbnRTdHlsZVNoZWV0ICE9IG51bGxgXG4gIGVuZFxuXG4gIGRlZiBydWxlc1xuICAgIE5hdGl2ZTo6QXJyYXkubmV3KGAjQG5hdGl2ZS5jc3NSdWxlc2ApIHsgfGV8XG4gICAgICBSdWxlLm5ldyhlKVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShpbmRleClcbiAgICBgI0BuYXRpdmUuZGVsZXRlUnVsZShpbmRleClgXG4gIGVuZFxuXG4gIGRlZiBpbnNlcnQoaW5kZXgsIHJ1bGUpXG4gICAgYCNAbmF0aXZlLmluc2VydFJ1bGUoI3tydWxlfSwgI3tpbmRleH0pYFxuICBlbmRcblxuICBkZWYgcnVsZShzZWxlY3RvciwgYm9keSlcbiAgICB1bmxlc3MgU3RyaW5nID09PSBzZWxlY3RvclxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5qb2luICcsICdcbiAgICBlbmRcblxuICAgIHVubGVzcyBTdHJpbmcgPT09IGJvZHlcbiAgICAgIGJvZHkgPSBib2R5Lm1hcCB7fG5hbWUsIHZhbHVlfFxuICAgICAgICBcIiN7bmFtZX06ICN7dmFsdWV9O1wiXG4gICAgICB9LmpvaW4gXCJcXG5cIlxuICAgIGVuZFxuXG4gICAgaW5zZXJ0KGxlbmd0aCwgXCIje3NlbGVjdG9yfSB7ICN7Ym9keX0gfVwiKVxuICBlbmRcblxuICBkZWYgW10oaWQpXG4gICAgcnVsZXMuZmluZCB7IHxyfCBsb2cgcjsgci5pZCA9PSBpZCB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZygqYXJncywgJmJsb2NrKVxuICAgIHJ1bGVzLl9fc2VuZF9fKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGNsYXNzIE1lZGlhIDwgTmF0aXZlOjpBcnJheVxuICAgIGFsaWFzX25hdGl2ZSA6dGV4dCwgOm1lZGlhVGV4dFxuICAgIGFsaWFzX25hdGl2ZSA6dG9fcywgOm1lZGlhVGV4dFxuXG4gICAgZGVmIHB1c2gobWVkaXVtKVxuICAgICAgYCNAbmF0aXZlLmFwcGVuZE1lZGl1bSgje21lZGl1bX0pYFxuXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgZGVsZXRlKG1lZGl1bSlcbiAgICAgIGAjQG5hdGl2ZS5kZWxldGVNZWRpdW0oI3ttZWRpdW19KWBcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImluY2x1ZGUiLCJpbml0aWFsaXplIiwid2hhdCIsImlzX2E/IiwidG9fbiIsImFsaWFzX25hdGl2ZSIsIm1lZGlhIiwiQG5hdGl2ZSIsIm5ldyIsIm93bmVyIiwiRE9NIiwicGFyZW50IiwicnVsZXMiLCJlIiwiZGVsZXRlIiwiaW5zZXJ0IiwicnVsZSIsImluZGV4IiwiPT09Iiwic2VsZWN0b3IiLCJqb2luIiwiYm9keSIsIm1hcCIsIm5hbWUiLCJ2YWx1ZSIsImxlbmd0aCIsIltdIiwiZmluZCIsImxvZyIsInIiLCJpZCIsIj09IiwibWV0aG9kX21pc3NpbmciLCJfX3NlbmRfXyIsImFyZ3MiLCJibG9jayIsInB1c2giLCJtZWRpdW0iLCJzZWxmIl0sIm1hcHBpbmdzIjoiOzs7OztFQUFBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFBZ0JBO0FBQUFBLElBQUFBOztBQUFBQSxNQUFBQTs7QUFBQUEsTUFFaEJDO0FBQUFBLE1BQUFBOztBQUFBQSxRQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxZQUFBQyxTQUFBQSxDQUFRLElBQUEsdUJBQUEsd0JBQVJBLENBQUE7QUFBQTtBQUVBQyxRQUFBQSw4QkFBQUEsMkJBQUFBLHNCQUFlLElBQWZBO0FBQUFBLFVBQUFBOztBQUFBQSxVQUFBQTtBQUFBQSxVQUNFLElBQUEsUUFBR0MsSUFBQUMsVUFBQUEsQ0FBVyxJQUFBLG1CQUFBLFlBQVhBLENBQUgsQ0FBQTtBQUFBLFlBQ0UsT0FBQSxVQUFBLEVBQUEsK0VBQUEsRUFBQSxDQUFTRCxJQUFBRSxNQUFBQSxDQUFBQSxDQUFVLE1BQW5CLENBQUEsTUFBQTtBQURGLFVBQUE7QUFBQSxZQUdFLE9BQUEsVUFBQSxFQUFBLCtFQUFBLEVBQUEsQ0FBTUYsSUFBTixDQUFBLE1BQUE7QUFIRixVQUFBO0FBREZELFFBQUFBLENBQUFBLHND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QkEsQ0FEQTtBQUFBO0FBR0ErQixVQUFBQSx3QkFBQUEsaUJBQUFBLGdCQUFTLE1BQVRBO0FBQUFBLFlBQUFBOztBQUFBQTtBQUNFLFlBQUU3QixjQUFPLGNBQWdCOEIsTUFBTyxDQUFoQztBQUFBLFlBRUEsT0FBQUMsSUFGQTtBQURGRixVQUFBQSxDQUFBQSw0QkFBQUEsQ0FIQTtBQUFBLFVBU0EsT0FBQXRCLENBQUFBLDBCQUFBQSxtQkFBQUEsU0FBVyxNQUFYQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFFUCxjQUFPLGNBQWdCOEIsTUFBTztBQURsQ3ZCLFVBQUFBLENBQUFBLDhCQUFBQSxDQUFBQSxrQkFUQTtBQURGZixRQUFBQSxHQUFBQSxXQUFBQSxFQUFjLElBQUEsc0JBQUEsVUFBZEEsV0EvREE7QUFERkEsTUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGZ0JELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NjQ1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jc3MvcnVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIENTU1xuXG5jbGFzcyBSdWxlXG4gIGluY2x1ZGUgQnJvd3Nlcjo6TmF0aXZlQ2FjaGVkV3JhcHBlclxuXG4gIFNUWUxFX1JVTEUgICAgICAgICAgICAgICA9IDFcbiAgQ0hBUlNFVF9SVUxFICAgICAgICAgICAgID0gMlxuICBJTVBPUlRfUlVMRSAgICAgICAgICAgICAgPSAzXG4gIE1FRElBX1JVTEUgICAgICAgICAgICAgICA9IDRcbiAgRk9OVF9GQUNFX1JVTEUgICAgICAgICAgID0gNVxuICBQQUdFX1JVTEUgICAgICAgICAgICAgICAgPSA2XG4gIEtFWUZSQU1FU19SVUxFICAgICAgICAgICA9IDdcbiAgS0VZRlJBTUVfUlVMRSAgICAgICAgICAgID0gOFxuICBOQU1FU1BBQ0VfUlVMRSAgICAgICAgICAgPSAxMFxuICBDT1VOVEVSX1NUWUxFX1JVTEUgICAgICAgPSAxMVxuICBTVVBQT1JUU19SVUxFICAgICAgICAgICAgPSAxMlxuICBET0NVTUVOVF9SVUxFICAgICAgICAgICAgPSAxM1xuICBGT05UX0ZFQVRVUkVfVkFMVUVTX1JVTEUgPSAxNFxuICBWSUVXUE9SVF9SVUxFICAgICAgICAgICAgPSAxNVxuICBSRUdJT05fU1RZTEVfUlVMRSAgICAgICAgPSAxNlxuXG4gIGRlZiBzZWxmLm5ldyhydWxlKVxuICAgIGlmIHNlbGYgPT0gUnVsZVxuICAgICAgQGNsYXNzZXMgfHw9IFtuaWwsIFN0eWxlXVxuXG4gICAgICBpZiBrbGFzcyA9IEBjbGFzc2VzW2BydWxlLnR5cGVgXVxuICAgICAgICBrbGFzcy5uZXcocnVsZSlcbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2Nhbm5vdCBpbnN0YW50aWF0ZSBhIG5vbiBkZXJpdmVkIFJ1bGUgb2JqZWN0J1xuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3VwZXIocnVsZSlcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXNfbmF0aXZlIDp0ZXh0LCA6Y3NzVGV4dFxuICBhbGlhc19uYXRpdmUgOnRvX3MsIDpjc3NUZXh0XG5cbiAgZGVmIHBhcmVudFxuICAgIFJ1bGUubmV3KGAjQG5hdGl2ZS5wYXJlbnRSdWxlYCkgaWYgYCNAbmF0aXZlLnBhcmVudFJ1bGUgIT0gbnVsbGBcbiAgZW5kXG5cbiAgZGVmIHN0eWxlX3NoZWV0XG4gICAgU3R5bGVTaGVldC5uZXcoYCNAbmF0aXZlLnBhcmVudFN0eWxlU2hlZXRgKSBpZiBgI0BuYXRpdmUucGFyZW50U3R5bGVTaGVldCAhPSBudWxsYFxuICBlbmRcbmVuZFxuXG5lbmQ7IGVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImNsYXNzIiwiaW5jbHVkZSIsIjEiLCIyIiwiMyIsIjQiLCI1IiwiNiIsIjciLCI4IiwiMTAiLCIxMSIsIjEyIiwiMTMiLCIxNCIsIjE1IiwiMTYiLCJuZXciLCJzZWxmIiwiPT0iLCJAY2xhc3NlcyIsImtsYXNzIiwiW10iLCJydWxlIiwicmFpc2UiLCJhbGlhc19uYXRpdmUiLCJwYXJlbnQiLCJAbmF0aXZlIiwic3R5bGVfc2hlZXQiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUVoQkM7QUFBQUEsTUFBQUE7O0FBQUFBLFFBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFlBQUFDLFNBQUFBLENBQVEsSUFBQSx1QkFBQSx3QkFBUkEsQ0FBQTtBQUFBLFFBRUEsMENBQTJCQyxDQUEzQixDQUZBO0FBQUEsUUFHQSw0Q0FBMkJDLENBQTNCLENBSEE7QUFBQSxRQUlBLDJDQUEyQkMsQ0FBM0IsQ0FKQTtBQUFBLFFBS0EsMENBQTJCQyxDQUEzQixDQUxBO0FBQUEsUUFNQSw4Q0FBMkJDLENBQTNCLENBTkE7QUFBQSxRQU9BLHlDQUEyQkMsQ0FBM0IsQ0FQQTtBQUFBLFFBUUEsOENBQTJCQyxDQUEzQixDQVJBO0FBQUEsUUFTQSw2Q0FBMkJDLENBQTNCLENBVEE7QUFBQSxRQVVBLDhDQUEyQkMsRUFBM0IsQ0FWQTtBQUFBLFFBV0Esa0RBQTJCQyxFQUEzQixDQVhBO0FBQUEsUUFZQSw2Q0FBMkJDLEVBQTNCLENBWkE7QUFBQSxRQWFBLDZDQUEyQkMsRUFBM0IsQ0FiQTtBQUFBLFFBY0Esd0RBQTJCQyxFQUEzQixDQWRBO0FBQUEsUUFlQSw2Q0FBMkJDLEVBQTNCLENBZkE7QUFBQSxRQWdCQSxpREFBMkJDLEVBQTNCLENBaEJBO0FBQUEsUUFrQkFDLFVBQUlDLElBQUpELFVBQUFBLGNBQUFBLFNBQWEsSUFBYkE7QUFBQUEsVUFBQUE7QUFBQUE7O0FBQUFBLFVBQUFBO0FBQUFBLFVBQ0UsSUFBR0MsSUFBQUMsT0FBQUEsQ0FBUSxvQkFBUkEsQ0FBSDtBQUFBO0FBQ0UsWUFBQUMsZUF4Qk4sY0F3Qk1BLFlBeEJOLFNBd0JtQixDQUFDLEdBQUQsRUFBTSxxQkFBTixDQXhCbkIsQ0F3Qk07QUFBQSxZQUVBLElBQUEsUUFBR0MsQ0FBQUEsUUFBUUQsWUFBQUUsT0FBQUEsQ0FBVSxTQUFWQSxDQUFSRCxDQUFILENBQUE7QUFBQSxjQUNFLE9BQUFBLEtBQUFKLEtBQUFBLENBQVVNLElBQVZOO0FBREYsWUFBQTtBQUFBLGNBR0UsV0FBQU8sT0FBQUEsQ0FBTSwrQkFBZSw4Q0FBckJBO0FBSEYsWUFBQSxDQUZBO0FBREYsVUFBQTtBQUFBLFlBU0UsT0FBQSxVQUFBLEVBQUEscUZBQUEsRUFBQSxDQUFNRCxJQUFOLENBQUEsTUFBQTtBQVRGLFVBQUE7QUFERk4sUUFBQUEsQ0FBQUEseUJBQUFBLENBbEJBO0FBQUEsWUFnQ0FRLGNBQUFBLENBQWEsUUFBTyxTQUFwQkEsQ0FoQ0E7QUFBQSxZQWlDQUEsY0FBQUEsQ0FBYSxRQUFPLFNBQXBCQSxDQWpDQTtBQUFBO0FBbUNBQyxRQUFBQSwwQkFBQUEsaUJBQUFBLGtCQUFBQTtBQUFBQSxVQUFBQTs7QUFBQUEsVUFDRSxJQUFBLFFBQXFDQyxjQUFPLG1CQUE1QyxDQUFBO0FBQUEsWUFBQSxPQUFBLG9CQUFBVixLQUFBQSxDQUFXVSxjQUFPLFdBQWxCVjtBQUFBLFVBQUE7QUFBQTtBQUFBLFVBQUE7QUFERlMsUUFBQUEsQ0FBQUEsNEJBQUFBLENBbkNBO0FBQUEsUUF1Q0EsT0FBQUUsQ0FBQUEsK0JBQUFBLHNCQUFBQSx1QkFBQUE7QUFBQUEsVUFBQUE7O0FBQUFBLFVBQ0UsSUFBQSxRQUFpREQsY0FBTyx5QkFBeEQsQ0FBQTtBQUFBLFlBQUEsT0FBQSwwQkFBQVYsS0FBQUEsQ0FBaUJVLGNBQU8saUJBQXhCVjtBQUFBLFVBQUE7QUFBQTtBQUFBLFVBQUE7QUFERlcsUUFBQUEsQ0FBQUEsaUNBQUFBLENBQUFBLHVCQXZDQTtBQURGNUIsTUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGZ0JELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NzI2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jc3MvcnVsZS9zdHlsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgQnJvd3NlcjsgbW9kdWxlIENTUzsgY2xhc3MgUnVsZVxuXG5jbGFzcyBTdHlsZSA8IFJ1bGVcbiAgYWxpYXNfbmF0aXZlIDpzZWxlY3RvciwgOnNlbGVjdG9yVGV4dFxuICBhbGlhc19uYXRpdmUgOmlkLCA6c2VsZWN0b3JUZXh0XG5cbiAgZGVmIGRlY2xhcmF0aW9uXG4gICAgRGVjbGFyYXRpb24ubmV3KGAjQG5hdGl2ZS5zdHlsZWApXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZygqYXJncywgJmJsb2NrKVxuICAgIGRlY2xhcmF0aW9uLl9fc2VuZF9fKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuZW5kXG5cbmVuZDsgZW5kOyBlbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJjbGFzcyIsImFsaWFzX25hdGl2ZSIsImRlY2xhcmF0aW9uIiwibmV3IiwiQG5hdGl2ZSIsIm1ldGhvZF9taXNzaW5nIiwiX19zZW5kX18iLCJhcmdzIiwiYmxvY2siXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUFnQkE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQSxNQUFZQztBQUFBQSxNQUFBQTs7QUFBQUEsUUFBQUE7O0FBQUFBLFFBRTVCLE9BQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxVQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxjQUFBQyxjQUFBQSxDQUFhLFlBQVcsY0FBeEJBLENBQUE7QUFBQSxjQUNBQSxjQUFBQSxDQUFhLE1BQUssY0FBbEJBLENBREE7QUFBQTtBQUdBQyxVQUFBQSwrQkFBQUEsdUJBQUFBLHVCQUFBQTtBQUFBQSxZQUFBQTs7QUFBQUEsWUFDRSxPQUFBLDJCQUFBQyxLQUFBQSxDQUFrQkMsY0FBTyxNQUF6QkQ7QUFERkQsVUFBQUEsQ0FBQUEsa0NBQUFBLENBSEE7QUFBQSxVQU9BLE9BQUFHLENBQUFBLGtDQUFBQSwwQkFBQUEsMEJBWEYsRUFXRUE7QUFBQUEsWUFBQUE7O0FBQUFBLFlBQUFBO0FBQUFBO0FBWEY7QUFXNEIsWUFBQSw4Q0FYNUI7QUFBQTtBQUFBLFlBQUEsNERBQUE7QUFBQTtBQVdxQixZQUFBLGtCQVhyQjtBQUFBLFlBWUksT0FBQUMsVUFBQUosYUFBQUEsQ0FBQUEsQ0FBQUksWUFBQUEsRUFBcUIsVUFBQ0MsSUFBRCxDQUFyQkQsRUFBNkJFLGdCQUE3QkYsQ0FaSjtBQVdFRCxVQUFBQSxDQUFBQSxzQ0FBQUEsQ0FBQUEsMEJBUEE7QUFERkwsUUFBQUEsR0FBQUEsV0FBQUEsRUFBYyxvQkFBZEE7QUFGNEJBLE1BQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQVpELElBQUFBLEdBQUFBLFdBQUFBO0FBQWhCQSxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2NzgwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnJvd3Nlci9jc3MucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnYnJvd3Nlci9jc3MvZGVjbGFyYXRpb24nXG5yZXF1aXJlICdicm93c2VyL2Nzcy9zdHlsZV9zaGVldCdcbnJlcXVpcmUgJ2Jyb3dzZXIvY3NzL3J1bGUnXG5yZXF1aXJlICdicm93c2VyL2Nzcy9ydWxlL3N0eWxlJ1xuXG5tb2R1bGUgS2VybmVsXG4gICMgQG92ZXJsb2FkIENTUyhkb2N1bWVudCA9ICRkb2N1bWVudCwgJmJsb2NrKVxuICAjXG4gICMgICBDcmVhdGUgYSBgPHN0eWxlPmAgZWxlbWVudCBmcm9tIGEge1BhZ2dpbzo6Q1NTfSBEU0wuXG4gICNcbiAgIyAgIEBwYXJhbSBkb2N1bWVudCBbQnJvd3Nlcjo6RE9NOjpEb2N1bWVudF0gdGhlIGRvY3VtZW50IGluc3RhbmNlXG4gICMgICAgIHdlIGludGVuZCB0byB1c2VcbiAgI1xuICAjICAgQHJldHVybiBbQnJvd3Nlcjo6RE9NOjpFbGVtZW50XSB0aGUgY3JlYXRlZCBgPHN0eWxlPmAgZWxlbWVudFxuICAjXG4gICMgQG92ZXJsb2FkIENTUyhzdHJpbmcsIGRvY3VtZW50ID0gJGRvY3VtZW50KVxuICAjXG4gICMgICBDcmVhdGUgYSBgPHN0eWxlPmAgZWxlbWVudCBmcm9tIGEgc3RyaW5nLlxuICAjXG4gICMgICBAcGFyYW0gZG9jdW1lbnQgW0Jyb3dzZXI6OkRPTTo6RG9jdW1lbnRdIHRoZSBkb2N1bWVudCBpbnN0YW5jZVxuICAjICAgICB3ZSBpbnRlbmQgdG8gdXNlXG4gICNcbiAgIyAgIEByZXR1cm4gW0Jyb3dzZXI6OkRPTTo6RWxlbWVudF0gdGhlIGNyZWF0ZWQgYDxzdHlsZT5gIGVsZW1lbnRcbiAgZGVmIENTUygqYXJncywgJmJsb2NrKVxuICAgIGRvY3VtZW50ID0gaWYgYXJncy5sZW5ndGggPiAxIHx8IGJsb2NrX2dpdmVuP1xuICAgICAgYXJncy5wb3BcbiAgICBlbmQgfHwgJGRvY3VtZW50XG5cbiAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZV9lbGVtZW50KDpzdHlsZSlcbiAgICBzdHlsZVs6dHlwZV0gPSAndGV4dC9jc3MnXG5cbiAgICBpZiBibG9ja1xuICAgICAgc3R5bGUuaW5uZXJfdGV4dCA9IFBhZ2dpby5jc3MoJmJsb2NrKVxuICAgIGVsc2VcbiAgICAgIHN0eWxlLmlubmVyX3RleHQgPSBhcmdzLmpvaW4oXCJcIilcbiAgICBlbmRcblxuICAgIHN0eWxlXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIm1vZHVsZSIsIkNTUyIsImRvY3VtZW50IiwiPiIsImFyZ3MiLCJsZW5ndGgiLCIxIiwiYmxvY2tfZ2l2ZW4/IiwicG9wIiwiJGRvY3VtZW50Iiwic3R5bGUiLCJjcmVhdGVfZWxlbWVudCIsIiR3cml0ZXIiLCJbXT0iLCItIiwiYmxvY2siLCJjc3MiLCJpbm5lcl90ZXh0PSIsImpvaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEseUJBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLHlCQUFSQSxDQURBO0FBQUEsTUFFQUEsU0FBQUEsQ0FBUSxrQkFBUkEsQ0FGQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsd0JBQVJBLENBSEE7QUFBQSxFQUtBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFrQkVDLElBQUFBLHVCQUFBQSxnQkFBQUEsZUF4QkYsRUF3QkVBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQXhCRjtBQXdCaUIsTUFBQSxvQ0F4QmpCO0FBQUE7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUF3QlUsTUFBQSxrQkF4QlY7QUFBQSxNQXlCSUMsV0FBVyxjQUFBLGFBQUEsSUFBQSxRQUFHLGNBQUFDLE9BQUFDLElBQUFDLFFBQUFBLENBQUFBLENBQUFGLEVBQWNHLENBQWRILENBQUEsU0FBbUJJLGVBQW5CLENBQUgsQ0FBQTtBQUFBLFFBQ1QsT0FBQUgsSUFBQUksS0FBQUEsQ0FBQUE7QUFEUyxNQUFBO0FBQUE7QUFBQSxNQUFBLENBQUEsa0JBQUEsU0FFSkMsZUFGSSxDQXpCZjtBQUFBLE1BNkJJQyxRQUFRUixRQUFBUyxnQkFBQUEsQ0FBd0IsT0FBeEJBLENBN0JaO0FBQUE7QUFBQSxNQUFBQyxVQUFBLENBOEJVLE1BOUJWLEVBOEJtQixVQTlCbkIsQ0FBQTtBQUFBLE1BOEJJQyxNQUFBSCxLQUFBRyxPQUFBQSxFQTlCSixVQUFBRCxPQUFBLENBOEJJQyxDQTlCSjtBQUFBLE1BQUFELE9BQUEsQ0FBQUUsVUFBQUYsT0FBQSxDQUFBLFFBQUEsQ0FBQUUsRUFBQVIsQ0FBQVEsQ0FBQSxDQUFBLENBQUE7QUFBQSxNQWdDSSxJQUFBLFFBQUdDLEtBQUgsQ0FBQTtBQUFBO0FBaENKLFFBQUFILFVBQUEsQ0FpQ3lCSSxNQUFBLHNCQUFBQSxPQUFBQSxFQUFBQSxFQUFBQSxFQUFZRCxnQkFBWkMsQ0FqQ3pCLENBQUE7QUFBQSxRQWlDTUMsTUFBQVAsS0FBQU8sZUFBQUEsRUFqQ04sVUFBQUwsT0FBQSxDQWlDTUssQ0FqQ047QUFBQSxRQUFBTCxPQUFBLENBQUFFLFVBQUFGLE9BQUEsQ0FBQSxRQUFBLENBQUFFLEVBQUFSLENBQUFRLENBQUEsQ0FBQTtBQWdDSSxNQUFBO0FBQUE7QUFoQ0osUUFBQUYsVUFBQSxDQW1DeUJSLElBQUFjLE1BQUFBLENBQVUsRUFBVkEsQ0FuQ3pCLENBQUE7QUFBQSxRQW1DTUQsTUFBQVAsS0FBQU8sZUFBQUEsRUFuQ04sVUFBQUwsT0FBQSxDQW1DTUssQ0FuQ047QUFBQSxRQUFBTCxPQUFBLENBQUFFLFVBQUFGLE9BQUEsQ0FBQSxRQUFBLENBQUFFLEVBQUFSLENBQUFRLENBQUEsQ0FBQTtBQWdDSSxNQUFBLENBaENKO0FBQUEsTUFzQ0ksT0FBQUosS0F0Q0o7QUF3QkVULElBQUFBLENBQUFBLDRCQUFBQTtBQWxCRkQsRUFBQUEsR0FBQUEsV0FBQUEsV0FMQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2ODQwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9icm93c2VyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ25hdGl2ZSdcbnJlcXVpcmUgJ3BhZ2dpbydcblxucmVxdWlyZSAnYnJvd3Nlci92ZXJzaW9uJ1xucmVxdWlyZSAnYnJvd3Nlci91dGlscydcbnJlcXVpcmUgJ2Jyb3dzZXIvZm9ybV9kYXRhJ1xucmVxdWlyZSAnYnJvd3Nlci9zdXBwb3J0J1xuXG5yZXF1aXJlICdicm93c2VyL2V2ZW50J1xucmVxdWlyZSAnYnJvd3Nlci93aW5kb3cnXG5yZXF1aXJlICdicm93c2VyL2RvbSdcbnJlcXVpcmUgJ2Jyb3dzZXIvY3NzJ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsUUFBUkEsQ0FBQTtBQUFBLE1BQ0FBLFNBQUFBLENBQVEsUUFBUkEsQ0FEQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsaUJBQVJBLENBSEE7QUFBQSxNQUlBQSxTQUFBQSxDQUFRLGVBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLG1CQUFSQSxDQUxBO0FBQUEsTUFNQUEsU0FBQUEsQ0FBUSxpQkFBUkEsQ0FOQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsZUFBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsZ0JBQVJBLENBVEE7QUFBQSxNQVVBQSxTQUFBQSxDQUFRLGFBQVJBLENBVkE7QUFBQSxFQVdBLFdBQUFBLFNBQUFBLENBQVEsYUFBUkEsQ0FYQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM2ODU4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiKGV4aXQpIl0sInNvdXJjZXNDb250ZW50IjpbIktlcm5lbC5leGl0XG4iXSwibmFtZXMiOlsiZXhpdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBLHNCQUFBQSxNQUFBQSxDQUFBQTs7In19XX0=
